var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source2, exclude) => {
  var target = {};
  for (var prop in source2)
    if (__hasOwnProp.call(source2, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source2, prop))
        target[prop] = source2[prop];
    }
  return target;
};
function _mergeNamespaces(n2, m2) {
  m2.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n2)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n2, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  });
  return Object.freeze(n2);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var react = { exports: {} };
var react_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject$1(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
  var from2;
  var to2 = toObject$1(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from2 = Object(arguments[s]);
    for (var key in from2) {
      if (hasOwnProperty$1.call(from2, key)) {
        to2[key] = from2[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from2);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from2, symbols[i])) {
          to2[symbols[i]] = from2[symbols[i]];
        }
      }
    }
  }
  return to2;
};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = objectAssign, n = 60103, p = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q = 60109, r$2 = 60110, t = 60112;
react_production_min.Suspense = 60113;
var u = 60115, v$3 = 60116;
if (typeof Symbol === "function" && Symbol.for) {
  var w = Symbol.for;
  n = w("react.element");
  p = w("react.portal");
  react_production_min.Fragment = w("react.fragment");
  react_production_min.StrictMode = w("react.strict_mode");
  react_production_min.Profiler = w("react.profiler");
  q = w("react.provider");
  r$2 = w("react.context");
  t = w("react.forward_ref");
  react_production_min.Suspense = w("react.suspense");
  u = w("react.memo");
  v$3 = w("react.lazy");
}
var x = typeof Symbol === "function" && Symbol.iterator;
function y$1(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = x && a[x] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$2 = {};
function C$1(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$2;
  this.updater = c || A;
}
C$1.prototype.isReactComponent = {};
C$1.prototype.setState = function(a, b) {
  if (typeof a !== "object" && typeof a !== "function" && a != null)
    throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};
C$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function D$1() {
}
D$1.prototype = C$1.prototype;
function E$2(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$2;
  this.updater = c || A;
}
var F$2 = E$2.prototype = new D$1();
F$2.constructor = E$2;
l(F$2, C$1.prototype);
F$2.isPureReactComponent = true;
var G$1 = { current: null }, H$2 = Object.prototype.hasOwnProperty, I$2 = { key: true, ref: true, __self: true, __source: true };
function J$1(a, b, c) {
  var e, d = {}, k = null, h = null;
  if (b != null)
    for (e in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
      H$2.call(b, e) && !I$2.hasOwnProperty(e) && (d[e] = b[e]);
  var g = arguments.length - 2;
  if (g === 1)
    d.children = c;
  else if (1 < g) {
    for (var f = Array(g), m2 = 0; m2 < g; m2++)
      f[m2] = arguments[m2 + 2];
    d.children = f;
  }
  if (a && a.defaultProps)
    for (e in g = a.defaultProps, g)
      d[e] === void 0 && (d[e] = g[e]);
  return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G$1.current };
}
function K(a, b) {
  return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function L(a) {
  return typeof a === "object" && a !== null && a.$$typeof === n;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var M$1 = /\/+/g;
function N$1(a, b) {
  return typeof a === "object" && a !== null && a.key != null ? escape("" + a.key) : b.toString(36);
}
function O$1(a, b, c, e, d) {
  var k = typeof a;
  if (k === "undefined" || k === "boolean")
    a = null;
  var h = false;
  if (a === null)
    h = true;
  else
    switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case n:
          case p:
            h = true;
        }
    }
  if (h)
    return h = a, d = d(h), a = e === "" ? "." + N$1(h, 0) : e, Array.isArray(d) ? (c = "", a != null && (c = a.replace(M$1, "$&/") + "/"), O$1(d, b, c, "", function(a2) {
      return a2;
    })) : d != null && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M$1, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = e === "" ? "." : e + ":";
  if (Array.isArray(a))
    for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = e + N$1(k, g);
      h += O$1(k, b, c, f, d);
    }
  else if (f = y$1(a), typeof f === "function")
    for (a = f.call(a), g = 0; !(k = a.next()).done; )
      k = k.value, f = e + N$1(k, g++), h += O$1(k, b, c, f, d);
  else if (k === "object")
    throw b = "" + a, Error(z(31, b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}
function P$1(a, b, c) {
  if (a == null)
    return a;
  var e = [], d = 0;
  O$1(a, e, "", "", function(a2) {
    return b.call(c, a2, d++);
  });
  return e;
}
function Q(a) {
  if (a._status === -1) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function(b2) {
      a._status === 0 && (b2 = b2.default, a._status = 1, a._result = b2);
    }, function(b2) {
      a._status === 0 && (a._status = 2, a._result = b2);
    });
  }
  if (a._status === 1)
    return a._result;
  throw a._result;
}
var R$2 = { current: null };
function S$1() {
  var a = R$2.current;
  if (a === null)
    throw Error(z(321));
  return a;
}
var T$1 = { ReactCurrentDispatcher: R$2, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l };
react_production_min.Children = { map: P$1, forEach: function(a, b, c) {
  P$1(a, function() {
    b.apply(this, arguments);
  }, c);
}, count: function(a) {
  var b = 0;
  P$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return P$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!L(a))
    throw Error(z(143));
  return a;
} };
react_production_min.Component = C$1;
react_production_min.PureComponent = E$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a, b, c) {
  if (a === null || a === void 0)
    throw Error(z(267, a));
  var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
  if (b != null) {
    b.ref !== void 0 && (k = b.ref, h = G$1.current);
    b.key !== void 0 && (d = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g = a.type.defaultProps;
    for (f in b)
      H$2.call(b, f) && !I$2.hasOwnProperty(f) && (e[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
  }
  var f = arguments.length - 2;
  if (f === 1)
    e.children = c;
  else if (1 < f) {
    g = Array(f);
    for (var m2 = 0; m2 < f; m2++)
      g[m2] = arguments[m2 + 2];
    e.children = g;
  }
  return {
    $$typeof: n,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};
react_production_min.createContext = function(a, b) {
  b === void 0 && (b = null);
  a = { $$typeof: r$2, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
  a.Provider = { $$typeof: q, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = J$1;
react_production_min.createFactory = function(a) {
  var b = J$1.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: t, render: a };
};
react_production_min.isValidElement = L;
react_production_min.lazy = function(a) {
  return { $$typeof: v$3, _payload: { _status: -1, _result: a }, _init: Q };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: u, type: a, compare: b === void 0 ? null : b };
};
react_production_min.useCallback = function(a, b) {
  return S$1().useCallback(a, b);
};
react_production_min.useContext = function(a, b) {
  return S$1().useContext(a, b);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a, b) {
  return S$1().useEffect(a, b);
};
react_production_min.useImperativeHandle = function(a, b, c) {
  return S$1().useImperativeHandle(a, b, c);
};
react_production_min.useLayoutEffect = function(a, b) {
  return S$1().useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return S$1().useMemo(a, b);
};
react_production_min.useReducer = function(a, b, c) {
  return S$1().useReducer(a, b, c);
};
react_production_min.useRef = function(a) {
  return S$1().useRef(a);
};
react_production_min.useState = function(a) {
  return S$1().useState(a);
};
react_production_min.version = "17.0.2";
{
  react.exports = react_production_min;
}
var React = react.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  var f, g, h, k;
  if (typeof performance === "object" && typeof performance.now === "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    var t2 = null, u2 = null, w = function() {
      if (t2 !== null)
        try {
          var a = exports.unstable_now();
          t2(true, a);
          t2 = null;
        } catch (b) {
          throw setTimeout(w, 0), b;
        }
    };
    f = function(a) {
      t2 !== null ? setTimeout(f, 0, a) : (t2 = a, setTimeout(w, 0));
    };
    g = function(a, b) {
      u2 = setTimeout(a, b);
    };
    h = function() {
      clearTimeout(u2);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y2 = window.clearTimeout;
    if (typeof console !== "undefined") {
      var z2 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z2 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E2;
    };
    k = function() {
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (B2 !== null) {
        var a = exports.unstable_now();
        E2 = a + D2;
        try {
          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b) {
          throw G2.postMessage(null), b;
        }
      } else
        A2 = false;
    };
    f = function(a) {
      B2 = a;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g = function(a, b) {
      C2 = x2(function() {
        a(exports.unstable_now());
      }, b);
    };
    h = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; ; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (e !== void 0 && 0 < I2(e, b))
          a[d] = b, a[c] = e, c = d;
        else
          break a;
      }
  }
  function J2(a) {
    a = a[0];
    return a === void 0 ? null : a;
  }
  function K2(a) {
    var b = a[0];
    if (b !== void 0) {
      var c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e = a.length; d < e; ) {
            var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
            if (n2 !== void 0 && 0 > I2(n2, c))
              r2 !== void 0 && 0 > I2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);
            else if (r2 !== void 0 && 0 > I2(r2, c))
              a[d] = r2, a[v2] = c, d = v2;
            else
              break a;
          }
      }
      return b;
    }
    return null;
  }
  function I2(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return c !== 0 ? c : a.id - b.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a) {
    for (var b = J2(M2); b !== null; ) {
      if (b.callback === null)
        K2(M2);
      else if (b.startTime <= a)
        K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);
      else
        break;
      b = J2(M2);
    }
  }
  function U2(a) {
    S2 = false;
    T2(a);
    if (!R2)
      if (J2(L2) !== null)
        R2 = true, f(V2);
      else {
        var b = J2(M2);
        b !== null && g(U2, b.startTime - a);
      }
  }
  function V2(a, b) {
    R2 = false;
    S2 && (S2 = false, h());
    Q2 = true;
    var c = P2;
    try {
      T2(b);
      for (O2 = J2(L2); O2 !== null && (!(O2.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
        var d = O2.callback;
        if (typeof d === "function") {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e = d(O2.expirationTime <= b);
          b = exports.unstable_now();
          typeof e === "function" ? O2.callback = e : O2 === J2(L2) && K2(L2);
          T2(b);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (O2 !== null)
        var m2 = true;
      else {
        var n2 = J2(M2);
        n2 !== null && g(U2, n2.startTime - b);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c, Q2 = false;
    }
  }
  var W2 = k;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports.unstable_next = function(a) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = P2;
    }
    var c = P2;
    P2 = b;
    try {
      return a();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = P2;
    P2 = a;
    try {
      return b();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    typeof c === "object" && c !== null ? (c = c.delay, c = typeof c === "number" && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: N2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, H2(M2, a), J2(L2) === null && a === J2(M2) && (S2 ? h() : S2 = true, g(U2, c - d))) : (a.sortIndex = e, H2(L2, a), R2 || Q2 || (R2 = true, f(V2)));
    return a;
  };
  exports.unstable_wrapCallback = function(a) {
    var b = P2;
    return function() {
      var c = P2;
      P2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        P2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, m = objectAssign, r$1 = scheduler.exports;
function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y(227));
var ba = new Set(), ca = {};
function da(a, b) {
  ea(a, b);
  ea(a + "Capture", b);
}
function ea(a, b) {
  ca[a] = b;
  for (a = 0; a < b.length; a++)
    ba.add(b[a]);
}
var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined"), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a) {
  if (ia.call(ka, a))
    return true;
  if (ia.call(ja, a))
    return false;
  if (ha.test(a))
    return ka[a] = true;
  ja[a] = true;
  return false;
}
function ma(a, b, c, d) {
  if (c !== null && c.type === 0)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (c !== null)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return a !== "data-" && a !== "aria-";
    default:
      return false;
  }
}
function na(a, b, c, d) {
  if (b === null || typeof b === "undefined" || ma(a, b, c, d))
    return true;
  if (d)
    return false;
  if (c !== null)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return b === false;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function B$1(a, b, c, d, e, f, g) {
  this.acceptsBooleans = b === 2 || b === 3 || b === 4;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new B$1(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  D[b] = new B$1(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new B$1(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new B$1(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new B$1(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new B$1(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  D[a] = new B$1(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new B$1(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new B$1(a, 5, false, a.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B$1(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B$1(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B$1(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new B$1(a, 1, false, a.toLowerCase(), null, false, false);
});
D.xlinkHref = new B$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  D[a] = new B$1(a, 1, false, a.toLowerCase(), null, true, true);
});
function qa(a, b, c, d) {
  var e = D.hasOwnProperty(b) ? D[b] : null;
  var f = e !== null ? e.type === 0 : d ? false : !(2 < b.length) || b[0] !== "o" && b[0] !== "O" || b[1] !== "n" && b[1] !== "N" ? false : true;
  f || (na(b, c, e, d) && (c = null), d || e === null ? la(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === true ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if (typeof Symbol === "function" && Symbol.for) {
  var E$1 = Symbol.for;
  sa = E$1("react.element");
  ta = E$1("react.portal");
  ua = E$1("react.fragment");
  wa = E$1("react.strict_mode");
  xa = E$1("react.profiler");
  ya = E$1("react.provider");
  za = E$1("react.context");
  Aa = E$1("react.forward_ref");
  Ba = E$1("react.suspense");
  Ca = E$1("react.suspense_list");
  Da = E$1("react.memo");
  Ea = E$1("react.lazy");
  Fa = E$1("react.block");
  E$1("react.scope");
  Ga = E$1("react.opaque.id");
  Ha = E$1("react.debug_trace_mode");
  Ia = E$1("react.offscreen");
  Ja = E$1("react.legacy_hidden");
}
var Ka = typeof Symbol === "function" && Symbol.iterator;
function La(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
var Ma;
function Na(a) {
  if (Ma === void 0)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      Ma = b && b[1] || "";
    }
  return "\n" + Ma + a;
}
var Oa = false;
function Pa(a, b) {
  if (!a || Oa)
    return "";
  Oa = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect === "object" && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }
      a();
    }
  } catch (k) {
    if (k && d && typeof k.stack === "string") {
      for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
        h--;
      for (; 1 <= g && 0 <= h; g--, h--)
        if (e[g] !== f[h]) {
          if (g !== 1 || h !== 1) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h])
                return "\n" + e[g].replace(" at new ", " at ");
            while (1 <= g && 0 <= h);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, false), a;
    case 11:
      return a = Pa(a.type.render, false), a;
    case 22:
      return a = Pa(a.type._render, false), a;
    case 1:
      return a = Pa(a.type, true), a;
    default:
      return "";
  }
}
function Ra(a) {
  if (a == null)
    return null;
  if (typeof a === "function")
    return a.displayName || a.name || null;
  if (typeof a === "string")
    return a;
  switch (a) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if (typeof a === "object")
    switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";
      case ya:
        return (a._context.displayName || "Context") + ".Provider";
      case Aa:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || (b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef");
      case Da:
        return Ra(a.type);
      case Fa:
        return Ra(a._render);
      case Ea:
        b = a._payload;
        a = a._init;
        try {
          return Ra(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && a.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && typeof c !== "undefined" && typeof c.get === "function" && typeof c.set === "function") {
    var e = c.get, f = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || (typeof document !== "undefined" ? document : void 0);
  if (typeof a === "undefined")
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c != null ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = b.defaultValue == null ? "" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;
  c = Sa(b.value != null ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: b.type === "checkbox" || b.type === "radio" ? b.checked != null : b.value != null };
}
function $a(a, b) {
  b = b.checked;
  b != null && qa(a, "checked", b, false);
}
function ab(a, b) {
  $a(a, b);
  var c = Sa(b.value), d = b.type;
  if (c != null)
    if (d === "number") {
      if (c === 0 && a.value === "" || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if (d === "submit" || d === "reset") {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
  b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);
}
function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!(d !== "submit" && d !== "reset" || b.value !== void 0 && b.value !== null))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  c !== "" && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  c !== "" && (a.name = c);
}
function bb(a, b, c) {
  if (b !== "number" || Xa(a.ownerDocument) !== a)
    c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
function db(a) {
  var b = "";
  aa.Children.forEach(a, function(a2) {
    a2 != null && (b += a2);
  });
  return b;
}
function eb(a, b) {
  a = m({ children: void 0 }, b);
  if (b = db(b.children))
    a.children = b;
  return a;
}
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++)
      b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++)
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      b !== null || a[e].disabled || (b = a[e]);
    }
    b !== null && (b.selected = true);
  }
}
function gb(a, b) {
  if (b.dangerouslySetInnerHTML != null)
    throw Error(y(91));
  return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (c == null) {
    c = b.children;
    b = b.defaultValue;
    if (c != null) {
      if (b != null)
        throw Error(y(92));
      if (Array.isArray(c)) {
        if (!(1 >= c.length))
          throw Error(y(93));
        c = c[0];
      }
      b = c;
    }
    b == null && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  c != null && (c = "" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c));
  d != null && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && b !== "" && b !== null && (a.value = b);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a, b) {
  return a == null || a === "http://www.w3.org/1999/xhtml" ? lb(b) : a === "http://www.w3.org/2000/svg" && b === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
}
var nb, ob = function(a) {
  return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a)
    a.innerHTML = b;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = nb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function pb(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && c.nodeType === 3) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a) {
  rb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b] = qb[a];
  });
});
function sb(a, b, c) {
  return b == null || typeof b === "boolean" || b === "" ? "" : c || typeof b !== "number" || b === 0 || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}
function tb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d = c.indexOf("--") === 0, e = sb(c, b[c], d);
      c === "float" && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
}
var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a, b) {
  if (b) {
    if (ub[a] && (b.children != null || b.dangerouslySetInnerHTML != null))
      throw Error(y(137, a));
    if (b.dangerouslySetInnerHTML != null) {
      if (b.children != null)
        throw Error(y(60));
      if (!(typeof b.dangerouslySetInnerHTML === "object" && "__html" in b.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (b.style != null && typeof b.style !== "object")
      throw Error(y(62));
  }
}
function wb(a, b) {
  if (a.indexOf("-") === -1)
    return typeof b.is === "string";
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return a.nodeType === 3 ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if (typeof yb !== "function")
      throw Error(y(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb(a, b, c, d, e) {
  return a(b, c, d, e);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (zb !== null || Ab !== null)
    Ib(), Fb();
}
function Nb(a, b, c) {
  if (Lb)
    return a(b, c);
  Lb = true;
  try {
    return Jb(a, b, c);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a, b) {
  var c = a.stateNode;
  if (c === null)
    return null;
  var d = Db(c);
  if (d === null)
    return null;
  c = d[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea"));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && typeof c !== "function")
    throw Error(y(231, b, typeof c));
  return c;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = false;
  }
function Rb(a, b, c, d, e, f, g, h, k) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
  Sb = true;
  Tb = a;
} };
function Xb(a, b, c, d, e, f, g, h, k) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a, b, c, d, e, f, g, h, k) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, (b.flags & 1026) !== 0 && (c = b.return), a = b.return;
    while (a);
  }
  return b.tag === 3 ? c : null;
}
function $b(a) {
  if (a.tag === 13) {
    var b = a.memoizedState;
    b === null && (a = a.alternate, a !== null && (b = a.memoizedState));
    if (b !== null)
      return b.dehydrated;
  }
  return null;
}
function ac(a) {
  if (Zb(a) !== a)
    throw Error(y(188));
}
function bc(a) {
  var b = a.alternate;
  if (!b) {
    b = Zb(a);
    if (b === null)
      throw Error(y(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (e === null)
      break;
    var f = e.alternate;
    if (f === null) {
      d = e.return;
      if (d !== null) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f.child) {
      for (f = e.child; f; ) {
        if (f === c)
          return ac(e), a;
        if (f === d)
          return ac(e), b;
        f = f.sibling;
      }
      throw Error(y(188));
    }
    if (c.return !== d.return)
      c = e, d = f;
    else {
      for (var g = false, h = e.child; h; ) {
        if (h === c) {
          g = true;
          c = e;
          d = f;
          break;
        }
        if (h === d) {
          g = true;
          d = e;
          c = f;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f.child; h; ) {
          if (h === c) {
            g = true;
            c = f;
            d = e;
            break;
          }
          if (h === d) {
            g = true;
            d = f;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g)
          throw Error(y(189));
      }
    }
    if (c.alternate !== d)
      throw Error(y(190));
  }
  if (c.tag !== 3)
    throw Error(y(188));
  return c.stateNode.current === c ? a : b;
}
function cc(a) {
  a = bc(a);
  if (!a)
    return null;
  for (var b = a; ; ) {
    if (b.tag === 5 || b.tag === 6)
      return b;
    if (b.child)
      b.child.return = b, b = b.child;
    else {
      if (b === a)
        break;
      for (; !b.sibling; ) {
        if (!b.return || b.return === a)
          return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return null;
}
function dc(a, b) {
  for (var c = a.alternate; b !== null; ) {
    if (b === a || b === c)
      return true;
    b = b.return;
  }
  return false;
}
var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = new Map(), oc = new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b, c, d, e) {
  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
}
function sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b.pointerId);
  }
}
function tc(a, b, c, d, e, f) {
  if (a === null || a.nativeEvent !== f)
    return a = rc(b, c, d, e, f), b !== null && (b = Cb(b), b !== null && fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  e !== null && b.indexOf(e) === -1 && b.push(e);
  return a;
}
function uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return kc = tc(kc, a, b, c, d, e), true;
    case "dragenter":
      return lc = tc(lc, a, b, c, d, e), true;
    case "mouseover":
      return mc = tc(mc, a, b, c, d, e), true;
    case "pointerover":
      var f = e.pointerId;
      nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
  }
  return false;
}
function vc(a) {
  var b = wc(a.target);
  if (b !== null) {
    var c = Zb(b);
    if (c !== null) {
      if (b = c.tag, b === 13) {
        if (b = $b(c), b !== null) {
          a.blockedOn = b;
          hc(a.lanePriority, function() {
            r$1.unstable_runWithPriority(a.priority, function() {
              gc(c);
            });
          });
          return;
        }
      } else if (b === 3 && c.stateNode.hydrate) {
        a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function xc(a) {
  if (a.blockedOn !== null)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (c !== null)
      return b = Cb(c), b !== null && fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function zc(a, b, c) {
  xc(a) && c.delete(b);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a = jc[0];
    if (a.blockedOn !== null) {
      a = Cb(a.blockedOn);
      a !== null && ec(a);
      break;
    }
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (c !== null) {
        a.blockedOn = c;
        break;
      }
      b.shift();
    }
    a.blockedOn === null && jc.shift();
  }
  kc !== null && xc(kc) && (kc = null);
  lc !== null && xc(lc) && (lc = null);
  mc !== null && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r$1.unstable_scheduleCallback(r$1.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b(b2) {
    return Bc(b2, a);
  }
  if (0 < jc.length) {
    Bc(jc[0], a);
    for (var c = 1; c < jc.length; c++) {
      var d = jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  kc !== null && Bc(kc, a);
  lc !== null && Bc(lc, a);
  mc !== null && Bc(mc, a);
  nc.forEach(b);
  oc.forEach(b);
  for (c = 0; c < pc.length; c++)
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < pc.length && (c = pc[0], c.blockedOn === null); )
    vc(c), c.blockedOn === null && pc.shift();
}
function Dc(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a) {
  if (Fc[a])
    return Fc[a];
  if (!Ec[a])
    return a;
  var b = Ec[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Gc)
      return Fc[a] = b[c];
  return a;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = new Map(), Nc = new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c], e = a[c + 1];
    e = "on" + (e[0].toUpperCase() + e.slice(1));
    Nc.set(d, b);
    Mc.set(d, e);
    da(e, [d]);
  }
}
var Qc = r$1.unstable_now;
Qc();
var F$1 = 8;
function Rc(a) {
  if ((1 & a) !== 0)
    return F$1 = 15, 1;
  if ((2 & a) !== 0)
    return F$1 = 14, 2;
  if ((4 & a) !== 0)
    return F$1 = 13, 4;
  var b = 24 & a;
  if (b !== 0)
    return F$1 = 12, b;
  if ((a & 32) !== 0)
    return F$1 = 11, 32;
  b = 192 & a;
  if (b !== 0)
    return F$1 = 10, b;
  if ((a & 256) !== 0)
    return F$1 = 9, 256;
  b = 3584 & a;
  if (b !== 0)
    return F$1 = 8, b;
  if ((a & 4096) !== 0)
    return F$1 = 7, 4096;
  b = 4186112 & a;
  if (b !== 0)
    return F$1 = 6, b;
  b = 62914560 & a;
  if (b !== 0)
    return F$1 = 5, b;
  if (a & 67108864)
    return F$1 = 4, 67108864;
  if ((a & 134217728) !== 0)
    return F$1 = 3, 134217728;
  b = 805306368 & a;
  if (b !== 0)
    return F$1 = 2, b;
  if ((1073741824 & a) !== 0)
    return F$1 = 1, 1073741824;
  F$1 = 8;
  return a;
}
function Sc(a) {
  switch (a) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a));
  }
}
function Uc(a, b) {
  var c = a.pendingLanes;
  if (c === 0)
    return F$1 = 0;
  var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
  if (f !== 0)
    d = f, e = F$1 = 15;
  else if (f = c & 134217727, f !== 0) {
    var k = f & ~g;
    k !== 0 ? (d = Rc(k), e = F$1) : (h &= f, h !== 0 && (d = Rc(h), e = F$1));
  } else
    f = c & ~g, f !== 0 ? (d = Rc(f), e = F$1) : h !== 0 && (d = Rc(h), e = F$1);
  if (d === 0)
    return 0;
  d = 31 - Vc(d);
  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
  if (b !== 0 && b !== d && (b & g) === 0) {
    Rc(b);
    if (e <= F$1)
      return b;
    F$1 = e;
  }
  b = a.entangledLanes;
  if (b !== 0)
    for (a = a.entanglements, b &= d; 0 < b; )
      c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
}
function Xc(a, b) {
  switch (a) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a = Yc(24 & ~b), a === 0 ? Xc(10, b) : a;
    case 10:
      return a = Yc(192 & ~b), a === 0 ? Xc(8, b) : a;
    case 8:
      return a = Yc(3584 & ~b), a === 0 && (a = Yc(4186112 & ~b), a === 0 && (a = 512)), a;
    case 2:
      return b = Yc(805306368 & ~b), b === 0 && (b = 268435456), b;
  }
  throw Error(y(358, a));
}
function Yc(a) {
  return a & -a;
}
function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function $c(a, b, c) {
  a.pendingLanes |= b;
  var d = b - 1;
  a.suspendedLanes &= d;
  a.pingedLanes &= d;
  a = a.eventTimes;
  b = 31 - Vc(b);
  a[b] = c;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a) {
  return a === 0 ? 32 : 31 - (bd(a) / cd | 0) | 0;
}
var dd = r$1.unstable_UserBlockingPriority, ed = r$1.unstable_runWithPriority, fd = true;
function gd(a, b, c, d) {
  Kb || Ib();
  var e = hd, f = Kb;
  Kb = true;
  try {
    Hb(e, a, b, c, d);
  } finally {
    (Kb = f) || Mb();
  }
}
function id(a, b, c, d) {
  ed(dd, hd.bind(null, a, b, c, d));
}
function hd(a, b, c, d) {
  if (fd) {
    var e;
    if ((e = (b & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a))
      a = rc(null, a, b, c, d), jc.push(a);
    else {
      var f = yc(a, b, c, d);
      if (f === null)
        e && sc(a, d);
      else {
        if (e) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f, a, b, c, d);
            jc.push(a);
            return;
          }
          if (uc(f, a, b, c, d))
            return;
          sc(a, d);
        }
        jd(a, b, d, null, c);
      }
    }
  }
}
function yc(a, b, c, d) {
  var e = xb(d);
  e = wc(e);
  if (e !== null) {
    var f = Zb(e);
    if (f === null)
      e = null;
    else {
      var g = f.tag;
      if (g === 13) {
        e = $b(f);
        if (e !== null)
          return e;
        e = null;
      } else if (g === 3) {
        if (f.stateNode.hydrate)
          return f.tag === 3 ? f.stateNode.containerInfo : null;
        e = null;
      } else
        f !== e && (e = null);
    }
  }
  jd(a, b, d, e, c);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++)
    ;
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
    ;
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b;
  a === 10 && (a = 13);
  return 32 <= a || a === 13 ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f, g) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
    this.isDefaultPrevented = (f.defaultPrevented != null ? f.defaultPrevented : f.returnValue === false) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue !== "unknown" && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble !== "unknown" && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = m({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = m({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if (b !== "Unidentified")
      return b;
  }
  return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return a.type === "keypress" ? od(a) : 0;
}, keyCode: function(a) {
  return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
}, which: function(a) {
  return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return $d.indexOf(b.keyCode) !== -1;
    case "keydown":
      return b.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return typeof a === "object" && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (b.which !== 32)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return a === "compositionend" || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && b.locale !== "ko" ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b === "input" ? !!le[a.type] : b === "textarea" ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if (a === "change")
    return b;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = typeof ze.oninput === "function";
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if (a.propertyName === "value" && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    a = re;
    if (Kb)
      a(b);
    else {
      Kb = true;
      try {
        Gb(a, b);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a, b, c) {
  a === "focusin" ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae();
}
function De(a) {
  if (a === "selectionchange" || a === "keyup" || a === "keydown")
    return te(qe);
}
function Ee(a, b) {
  if (a === "click")
    return te(b);
}
function Fe(a, b) {
  if (a === "input" || a === "change")
    return te(b);
}
function Ge(a, b) {
  return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = typeof Object.is === "function" ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a, b) {
  if (He(a, b))
    return true;
  if (typeof a !== "object" || a === null || typeof b !== "object" || b === null)
    return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++)
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
      return false;
  return true;
}
function Ke(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Le(a, b) {
  var c = Ke(a);
  a = 0;
  for (var d; c; ) {
    if (c.nodeType === 3) {
      d = a + c.textContent.length;
      if (a <= b && d >= b)
        return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Ke(c);
  }
}
function Me(a, b) {
  return a && b ? a === b ? true : a && a.nodeType === 3 ? false : b && b.nodeType === 3 ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = typeof b.contentWindow.location.href === "string";
    } catch (d) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && (b === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b === "textarea" || a.contentEditable === "true");
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
  Te || Qe == null || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Yb(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = (b & 4) !== 0;
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f = void 0;
      if (b)
        for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
      else
        for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
    }
  }
  if (Ub)
    throw a = Vb, Ub = false, Vb = null, a;
}
function G(a, b) {
  var c = $e(b), d = a + "__bubble";
  c.has(d) || (af(b, a, 2, false), c.add(d));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a) {
  a[bf] || (a[bf] = true, ba.forEach(function(b) {
    Ye.has(b) || df(b, false, a, null);
    df(b, true, a, null);
  }));
}
function df(a, b, c, d) {
  var e = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f = c;
  a === "selectionchange" && c.nodeType !== 9 && (f = c.ownerDocument);
  if (d !== null && !b && Ye.has(a)) {
    if (a !== "scroll")
      return;
    e |= 2;
    f = d;
  }
  var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
  g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
}
function af(a, b, c, d) {
  var e = Nc.get(b);
  switch (e === void 0 ? 2 : e) {
    case 0:
      e = gd;
      break;
    case 1:
      e = id;
      break;
    default:
      e = hd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Pb || b !== "touchstart" && b !== "touchmove" && b !== "wheel" || (e = true);
  d ? e !== void 0 ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : e !== void 0 ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function jd(a, b, c, d, e) {
  var f = d;
  if ((b & 1) === 0 && (b & 2) === 0 && d !== null)
    a:
      for (; ; ) {
        if (d === null)
          return;
        var g = d.tag;
        if (g === 3 || g === 4) {
          var h = d.stateNode.containerInfo;
          if (h === e || h.nodeType === 8 && h.parentNode === e)
            break;
          if (g === 4)
            for (g = d.return; g !== null; ) {
              var k = g.tag;
              if (k === 3 || k === 4) {
                if (k = g.stateNode.containerInfo, k === e || k.nodeType === 8 && k.parentNode === e)
                  return;
              }
              g = g.return;
            }
          for (; h !== null; ) {
            g = wc(h);
            if (g === null)
              return;
            k = g.tag;
            if (k === 5 || k === 6) {
              d = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
  Nb(function() {
    var d2 = f, e2 = xb(c), g2 = [];
    a: {
      var h3 = Mc.get(a);
      if (h3 !== void 0) {
        var k2 = td, x2 = a;
        switch (a) {
          case "keypress":
            if (od(c) === 0)
              break a;
          case "keydown":
          case "keyup":
            k2 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k2 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k2 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k2 = Fd;
            break;
          case "click":
            if (c.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k2 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k2 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k2 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k2 = Hd;
            break;
          case Lc:
            k2 = Xd;
            break;
          case "scroll":
            k2 = vd;
            break;
          case "wheel":
            k2 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k2 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k2 = Td;
        }
        var w = (b & 4) !== 0, z2 = !w && a === "scroll", u2 = w ? h3 !== null ? h3 + "Capture" : null : h3;
        w = [];
        for (var t2 = d2, q2; t2 !== null; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          q2.tag === 5 && v2 !== null && (q2 = v2, u2 !== null && (v2 = Ob(t2, u2), v2 != null && w.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w.length && (h3 = new k2(h3, x2, null, c, e2), g2.push({ event: h3, listeners: w }));
      }
    }
    if ((b & 7) === 0) {
      a: {
        h3 = a === "mouseover" || a === "pointerover";
        k2 = a === "mouseout" || a === "pointerout";
        if (h3 && (b & 16) === 0 && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k2 || h3) {
          h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k2) {
            if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, x2 !== null && (z2 = Zb(x2), x2 !== z2 || x2.tag !== 5 && x2.tag !== 6))
              x2 = null;
          } else
            k2 = null, x2 = d2;
          if (k2 !== x2) {
            w = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if (a === "pointerout" || a === "pointerover")
              w = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = k2 == null ? h3 : ue(k2);
            q2 = x2 == null ? h3 : ue(x2);
            h3 = new w(v2, t2 + "leave", k2, c, e2);
            h3.target = z2;
            h3.relatedTarget = q2;
            v2 = null;
            wc(e2) === d2 && (w = new w(u2, t2 + "enter", x2, c, e2), w.target = q2, w.relatedTarget = z2, v2 = w);
            z2 = v2;
            if (k2 && x2)
              b: {
                w = k2;
                u2 = x2;
                t2 = 0;
                for (q2 = w; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w = gf(w), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w === u2 || u2 !== null && w === u2.alternate)
                    break b;
                  w = gf(w);
                  u2 = gf(u2);
                }
                w = null;
              }
            else
              w = null;
            k2 !== null && hf(g2, h3, k2, w, false);
            x2 !== null && z2 !== null && hf(g2, z2, x2, w, true);
          }
        }
      }
      a: {
        h3 = d2 ? ue(d2) : window;
        k2 = h3.nodeName && h3.nodeName.toLowerCase();
        if (k2 === "select" || k2 === "input" && h3.type === "file")
          var J2 = ve;
        else if (me(h3))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k2 = h3.nodeName) && k2.toLowerCase() === "input" && (h3.type === "checkbox" || h3.type === "radio") && (J2 = Ee);
        if (J2 && (J2 = J2(a, d2))) {
          ne(g2, J2, c, e2);
          break a;
        }
        K2 && K2(a, h3, d2);
        a === "focusout" && (K2 = h3._wrapperState) && K2.controlled && h3.type === "number" && bb(h3, "number", h3.value);
      }
      K2 = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(K2) || K2.contentEditable === "true")
            Qe = K2, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e2);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e2);
      }
      var Q2;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a, c) && (L2 = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (L2 = "onCompositionStart");
      L2 && (de && c.locale !== "ko" && (ie || L2 !== "onCompositionStart" ? L2 === "onCompositionEnd" && ie && (Q2 = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c, e2), g2.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), Q2 !== null && (L2.data = Q2))));
      if (Q2 = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = Q2);
    }
    se(g2, b);
  });
}
function ef(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; a !== null; ) {
    var e = a, f = e.stateNode;
    e.tag === 5 && f !== null && (e = f, f = Ob(a, c), f != null && d.unshift(ef(a, f, e)), f = Ob(a, b), f != null && d.push(ef(a, f, e)));
    a = a.return;
  }
  return d;
}
function gf(a) {
  if (a === null)
    return null;
  do
    a = a.return;
  while (a && a.tag !== 5);
  return a ? a : null;
}
function hf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; c !== null && c !== d; ) {
    var h = c, k = h.alternate, l2 = h.stateNode;
    if (k !== null && k === d)
      break;
    h.tag === 5 && l2 !== null && (h = l2, e ? (k = Ob(c, f), k != null && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), k != null && g.push(ef(c, k, h))));
    c = c.return;
  }
  g.length !== 0 && a.push({ event: b, listeners: g });
}
function jf() {
}
var kf = null, lf = null;
function mf(a, b) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b.autoFocus;
  }
  return false;
}
function nf(a, b) {
  return a === "textarea" || a === "option" || a === "noscript" || typeof b.children === "string" || typeof b.children === "number" || typeof b.dangerouslySetInnerHTML === "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
}
var of = typeof setTimeout === "function" ? setTimeout : void 0, pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
function qf(a) {
  a.nodeType === 1 ? a.textContent = "" : a.nodeType === 9 && (a = a.body, a != null && (a.textContent = ""));
}
function rf(a) {
  for (; a != null; a = a.nextSibling) {
    var b = a.nodeType;
    if (b === 1 || b === 3)
      break;
  }
  return a;
}
function sf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (a.nodeType === 8) {
      var c = a.data;
      if (c === "$" || c === "$!" || c === "$?") {
        if (b === 0)
          return a;
        b--;
      } else
        c === "/$" && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a) {
  return { $$typeof: Ga, toString: a, valueOf: a };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a) {
  var b = a[wf];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;
      if (b.child !== null || c !== null && c.child !== null)
        for (a = sf(a); a !== null; ) {
          if (c = a[wf])
            return c;
          a = sf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[wf] || a[ff];
  return !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
}
function ue(a) {
  if (a.tag === 5 || a.tag === 6)
    return a.stateNode;
  throw Error(y(33));
}
function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b = a[yf];
  b === void 0 && (b = a[yf] = new Set());
  return b;
}
var zf = [], Af = -1;
function Bf(a) {
  return { current: a };
}
function H$1(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}
function I$1(a, b) {
  Af++;
  zf[Af] = a.current;
  a.current = b;
}
var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
function Ef(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Cf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f;
  for (f in c)
    e[f] = b[f];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Ff(a) {
  a = a.childContextTypes;
  return a !== null && a !== void 0;
}
function Gf() {
  H$1(N);
  H$1(M);
}
function Hf(a, b, c) {
  if (M.current !== Cf)
    throw Error(y(168));
  I$1(M, b);
  I$1(N, c);
}
function If(a, b, c) {
  var d = a.stateNode;
  a = b.childContextTypes;
  if (typeof d.getChildContext !== "function")
    return c;
  d = d.getChildContext();
  for (var e in d)
    if (!(e in a))
      throw Error(y(108, Ra(b) || "Unknown", e));
  return m({}, c, d);
}
function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I$1(M, a);
  I$1(N, N.current);
  return true;
}
function Kf(a, b, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(y(169));
  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H$1(N), H$1(M), I$1(M, a)) : H$1(N);
  I$1(N, c);
}
var Lf = null, Mf = null, Nf = r$1.unstable_runWithPriority, Of = r$1.unstable_scheduleCallback, Pf = r$1.unstable_cancelCallback, Qf = r$1.unstable_shouldYield, Rf = r$1.unstable_requestPaint, Sf = r$1.unstable_now, Tf = r$1.unstable_getCurrentPriorityLevel, Uf = r$1.unstable_ImmediatePriority, Vf = r$1.unstable_UserBlockingPriority, Wf = r$1.unstable_NormalPriority, Xf = r$1.unstable_LowPriority, Yf = r$1.unstable_IdlePriority, Zf = {}, $f = Rf !== void 0 ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a) {
  switch (a) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg(a, b) {
  a = fg(a);
  return Nf(a, b);
}
function hg(a, b, c) {
  a = fg(a);
  return Of(a, b, c);
}
function ig() {
  if (bg !== null) {
    var a = bg;
    bg = null;
    Pf(a);
  }
  jg();
}
function jg() {
  if (!cg && ag !== null) {
    cg = true;
    var a = 0;
    try {
      var b = ag;
      gg(99, function() {
        for (; a < b.length; a++) {
          var c = b[a];
          do
            c = c(true);
          while (c !== null);
        }
      });
      ag = null;
    } catch (c) {
      throw ag !== null && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a, b) {
  if (a && a.defaultProps) {
    b = m({}, b);
    a = a.defaultProps;
    for (var c in a)
      b[c] === void 0 && (b[c] = a[c]);
    return b;
  }
  return b;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b = mg.current;
  H$1(mg);
  a.type._context._currentValue = b;
}
function sg(a, b) {
  for (; a !== null; ) {
    var c = a.alternate;
    if ((a.childLanes & b) === b)
      if (c === null || (c.childLanes & b) === b)
        break;
      else
        c.childLanes |= b;
    else
      a.childLanes |= b, c !== null && (c.childLanes |= b);
    a = a.return;
  }
}
function tg(a, b) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  a !== null && a.firstContext !== null && ((a.lanes & b) !== 0 && (ug = true), a.firstContext = null);
}
function vg(a, b) {
  if (pg !== a && b !== false && b !== 0) {
    if (typeof b !== "number" || b === 1073741823)
      pg = a, b = 1073741823;
    b = { context: a, observedBits: b, next: null };
    if (og === null) {
      if (ng === null)
        throw Error(y(308));
      og = b;
      ng.dependencies = { lanes: 0, firstContext: b, responders: null };
    } else
      og = og.next = b;
  }
  return a._currentValue;
}
var wg = false;
function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function zg(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a, b) {
  a = a.updateQueue;
  if (a !== null) {
    a = a.shared;
    var c = a.pending;
    c === null ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
}
function Bg(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (d !== null && (d = d.updateQueue, c === d)) {
    var e = null, f = null;
    c = c.firstBaseUpdate;
    if (c !== null) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        f === null ? e = f = g : f = f.next = g;
        c = c.next;
      } while (c !== null);
      f === null ? e = f = b : f = f.next = b;
    } else
      e = f = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  a === null ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function Cg(a, b, c, d) {
  var e = a.updateQueue;
  wg = false;
  var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
  if (h !== null) {
    e.shared.pending = null;
    var k = h, l2 = k.next;
    k.next = null;
    g === null ? f = l2 : g.next = l2;
    g = k;
    var n2 = a.alternate;
    if (n2 !== null) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g && (A2 === null ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);
    }
  }
  if (f !== null) {
    A2 = e.baseState;
    g = 0;
    n2 = l2 = k = null;
    do {
      h = f.lane;
      var p2 = f.eventTime;
      if ((d & h) === h) {
        n2 !== null && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f.tag,
          payload: f.payload,
          callback: f.callback,
          next: null
        });
        a: {
          var C2 = a, x2 = f;
          h = b;
          p2 = c;
          switch (x2.tag) {
            case 1:
              C2 = x2.payload;
              if (typeof C2 === "function") {
                A2 = C2.call(p2, A2, h);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x2.payload;
              h = typeof C2 === "function" ? C2.call(p2, A2, h) : C2;
              if (h === null || h === void 0)
                break a;
              A2 = m({}, A2, h);
              break a;
            case 2:
              wg = true;
          }
        }
        f.callback !== null && (a.flags |= 32, h = e.effects, h === null ? e.effects = [f] : h.push(f));
      } else
        p2 = { eventTime: p2, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, n2 === null ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g |= h;
      f = f.next;
      if (f === null)
        if (h = e.shared.pending, h === null)
          break;
        else
          f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
    } while (1);
    n2 === null && (k = A2);
    e.baseState = k;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = n2;
    Dg |= g;
    a.lanes = g;
    a.memoizedState = A2;
  }
}
function Eg(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (a !== null)
    for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (e !== null) {
        d.callback = null;
        d = c;
        if (typeof e !== "function")
          throw Error(y(191, e));
        e.call(d);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = c === null || c === void 0 ? b : m({}, b, c);
  a.memoizedState = c;
  a.lanes === 0 && (a.updateQueue.baseState = c);
}
var Kg = { isMounted: function(a) {
  return (a = a._reactInternals) ? Zb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.payload = b;
  c !== void 0 && c !== null && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.tag = 1;
  f.payload = b;
  c !== void 0 && c !== null && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = Hg(), d = Ig(a), e = zg(c, d);
  e.tag = 2;
  b !== void 0 && b !== null && (e.callback = b);
  Ag(a, e);
  Jg(a, d, c);
} };
function Lg(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return typeof a.shouldComponentUpdate === "function" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
}
function Mg(a, b, c) {
  var d = false, e = Cf;
  var f = b.contextType;
  typeof f === "object" && f !== null ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = d !== null && d !== void 0) ? Ef(a, e) : Cf);
  b = new b(c, f);
  a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null;
  b.updater = Kg;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}
function Ng(a, b, c, d) {
  a = b.state;
  typeof b.componentWillReceiveProps === "function" && b.componentWillReceiveProps(c, d);
  typeof b.UNSAFE_componentWillReceiveProps === "function" && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}
function Og(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = Fg;
  xg(a);
  var f = b.contextType;
  typeof f === "object" && f !== null ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
  Cg(a, c, e, d);
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  typeof f === "function" && (Gg(a, b, f, c), e.state = a.memoizedState);
  typeof b.getDerivedStateFromProps === "function" || typeof e.getSnapshotBeforeUpdate === "function" || typeof e.UNSAFE_componentWillMount !== "function" && typeof e.componentWillMount !== "function" || (b = e.state, typeof e.componentWillMount === "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount === "function" && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
  typeof e.componentDidMount === "function" && (a.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a, b, c) {
  a = c.ref;
  if (a !== null && typeof a !== "function" && typeof a !== "object") {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (c.tag !== 1)
          throw Error(y(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(y(147, a));
      var e = "" + a;
      if (b !== null && b.ref !== null && typeof b.ref === "function" && b.ref._stringRef === e)
        return b.ref;
      b = function(a2) {
        var b2 = d.refs;
        b2 === Fg && (b2 = d.refs = {});
        a2 === null ? delete b2[e] : b2[e] = a2;
      };
      b._stringRef = e;
      return b;
    }
    if (typeof a !== "string")
      throw Error(y(284));
    if (!c._owner)
      throw Error(y(290, a));
  }
  return a;
}
function Rg(a, b) {
  if (a.type !== "textarea")
    throw Error(y(31, Object.prototype.toString.call(b) === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}
function Sg(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.lastEffect;
      d2 !== null ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
      c2.nextEffect = null;
      c2.flags = 8;
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; d2 !== null; )
      b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = new Map(); b2 !== null; )
      b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = Tg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f(b2, c2, d2) {
    b2.index = d2;
    if (!a)
      return c2;
    d2 = b2.alternate;
    if (d2 !== null)
      return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
    b2.flags = 2;
    return c2;
  }
  function g(b2) {
    a && b2.alternate === null && (b2.flags = 2);
    return b2;
  }
  function h(a2, b2, c2, d2) {
    if (b2 === null || b2.tag !== 6)
      return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k(a2, b2, c2, d2) {
    if (b2 !== null && b2.elementType === c2.type)
      return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
    d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Qg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function n2(a2, b2, c2, d2, f2) {
    if (b2 === null || b2.tag !== 7)
      return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function A2(a2, b2, c2) {
    if (typeof b2 === "string" || typeof b2 === "number")
      return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
    if (typeof b2 === "object" && b2 !== null) {
      switch (b2.$$typeof) {
        case sa:
          return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
        case ta:
          return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
      }
      if (Pg(b2) || La(b2))
        return b2 = Xg(b2, a2.mode, c2, null), b2.return = a2, b2;
      Rg(a2, b2);
    }
    return null;
  }
  function p2(a2, b2, c2, d2) {
    var e2 = b2 !== null ? b2.key : null;
    if (typeof c2 === "string" || typeof c2 === "number")
      return e2 !== null ? null : h(a2, b2, "" + c2, d2);
    if (typeof c2 === "object" && c2 !== null) {
      switch (c2.$$typeof) {
        case sa:
          return c2.key === e2 ? c2.type === ua ? n2(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
        case ta:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
      }
      if (Pg(c2) || La(c2))
        return e2 !== null ? null : n2(a2, b2, c2, d2, null);
      Rg(a2, c2);
    }
    return null;
  }
  function C2(a2, b2, c2, d2, e2) {
    if (typeof d2 === "string" || typeof d2 === "number")
      return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
    if (typeof d2 === "object" && d2 !== null) {
      switch (d2.$$typeof) {
        case sa:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
        case ta:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
      }
      if (Pg(d2) || La(d2))
        return a2 = a2.get(c2) || null, n2(b2, a2, d2, e2, null);
      Rg(b2, d2);
    }
    return null;
  }
  function x2(e2, g2, h3, k2) {
    for (var l3 = null, t2 = null, u2 = g2, z2 = g2 = 0, q2 = null; u2 !== null && z2 < h3.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e2, u2, h3[z2], k2);
      if (n3 === null) {
        u2 === null && (u2 = q2);
        break;
      }
      a && u2 && n3.alternate === null && b(e2, u2);
      g2 = f(n3, g2, z2);
      t2 === null ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h3.length)
      return c(e2, u2), l3;
    if (u2 === null) {
      for (; z2 < h3.length; z2++)
        u2 = A2(e2, h3[z2], k2), u2 !== null && (g2 = f(u2, g2, z2), t2 === null ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d(e2, u2); z2 < h3.length; z2++)
      q2 = C2(u2, e2, z2, h3[z2], k2), q2 !== null && (a && q2.alternate !== null && u2.delete(q2.key === null ? z2 : q2.key), g2 = f(q2, g2, z2), t2 === null ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  function w(e2, g2, h3, k2) {
    var l3 = La(h3);
    if (typeof l3 !== "function")
      throw Error(y(150));
    h3 = l3.call(h3);
    if (h3 == null)
      throw Error(y(151));
    for (var t2 = l3 = null, u2 = g2, z2 = g2 = 0, q2 = null, n3 = h3.next(); u2 !== null && !n3.done; z2++, n3 = h3.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w2 = p2(e2, u2, n3.value, k2);
      if (w2 === null) {
        u2 === null && (u2 = q2);
        break;
      }
      a && u2 && w2.alternate === null && b(e2, u2);
      g2 = f(w2, g2, z2);
      t2 === null ? l3 = w2 : t2.sibling = w2;
      t2 = w2;
      u2 = q2;
    }
    if (n3.done)
      return c(e2, u2), l3;
    if (u2 === null) {
      for (; !n3.done; z2++, n3 = h3.next())
        n3 = A2(e2, n3.value, k2), n3 !== null && (g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d(e2, u2); !n3.done; z2++, n3 = h3.next())
      n3 = C2(u2, e2, z2, n3.value, k2), n3 !== null && (a && n3.alternate !== null && u2.delete(n3.key === null ? z2 : n3.key), g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  return function(a2, d2, f2, h3) {
    var k2 = typeof f2 === "object" && f2 !== null && f2.type === ua && f2.key === null;
    k2 && (f2 = f2.props.children);
    var l3 = typeof f2 === "object" && f2 !== null;
    if (l3)
      switch (f2.$$typeof) {
        case sa:
          a: {
            l3 = f2.key;
            for (k2 = d2; k2 !== null; ) {
              if (k2.key === l3) {
                switch (k2.tag) {
                  case 7:
                    if (f2.type === ua) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    break;
                  default:
                    if (k2.elementType === f2.type) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props);
                      d2.ref = Qg(a2, k2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                }
                c(a2, k2);
                break;
              } else
                b(a2, k2);
              k2 = k2.sibling;
            }
            f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h3, f2.key), d2.return = a2, a2 = d2) : (h3 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h3), h3.ref = Qg(a2, d2, f2), h3.return = a2, a2 = h3);
          }
          return g(a2);
        case ta:
          a: {
            for (k2 = f2.key; d2 !== null; ) {
              if (d2.key === k2)
                if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Wg(f2, a2.mode, h3);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
      }
    if (typeof f2 === "string" || typeof f2 === "number")
      return f2 = "" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h3), d2.return = a2, a2 = d2), g(a2);
    if (Pg(f2))
      return x2(a2, d2, f2, h3);
    if (La(f2))
      return w(a2, d2, f2, h3);
    l3 && Rg(a2, f2);
    if (typeof f2 === "undefined" && !k2)
      switch (a2.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a2.type) || "Component"));
      }
    return c(a2, d2);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
function dh(a) {
  if (a === $g)
    throw Error(y(174));
  return a;
}
function eh(a, b) {
  I$1(ch, b);
  I$1(bh, a);
  I$1(ah, $g);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
      break;
    default:
      a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
  }
  H$1(ah);
  I$1(ah, b);
}
function fh() {
  H$1(ah);
  H$1(bh);
  H$1(ch);
}
function gh(a) {
  dh(ch.current);
  var b = dh(ah.current);
  var c = mb(b, a.type);
  b !== c && (I$1(bh, a), I$1(ah, c));
}
function hh(a) {
  bh.current === a && (H$1(ah), H$1(bh));
}
var P = Bf(0);
function ih(a) {
  for (var b = a; b !== null; ) {
    if (b.tag === 13) {
      var c = b.memoizedState;
      if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
        return b;
    } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
      if ((b.flags & 64) !== 0)
        return b;
    } else if (b.child !== null) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; b.sibling === null; ) {
      if (b.return === null || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a, b) {
  var c = nh(5, null, null, 0);
  c.elementType = "DELETED";
  c.type = "DELETED";
  c.stateNode = b;
  c.return = a;
  c.flags = 8;
  a.lastEffect !== null ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}
function oh(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return b !== null ? (a.stateNode = b, true) : false;
    case 6:
      return b = a.pendingProps === "" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a) {
  if (lh) {
    var b = kh;
    if (b) {
      var c = b;
      if (!oh(a, b)) {
        b = rf(c.nextSibling);
        if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;
          lh = false;
          jh = a;
          return;
        }
        mh(jh, c);
      }
      jh = a;
      kh = rf(b.firstChild);
    } else
      a.flags = a.flags & -1025 | 2, lh = false, jh = a;
  }
}
function qh(a) {
  for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
    a = a.return;
  jh = a;
}
function rh(a) {
  if (a !== jh)
    return false;
  if (!lh)
    return qh(a), lh = true, false;
  var b = a.type;
  if (a.tag !== 5 || b !== "head" && b !== "body" && !nf(b, a.memoizedProps))
    for (b = kh; b; )
      mh(a, b), b = rf(b.nextSibling);
  qh(a);
  if (a.tag === 13) {
    a = a.memoizedState;
    a = a !== null ? a.dehydrated : null;
    if (!a)
      throw Error(y(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (a.nodeType === 8) {
          var c = a.data;
          if (c === "/$") {
            if (b === 0) {
              kh = rf(a.nextSibling);
              break a;
            }
            b--;
          } else
            c !== "$" && c !== "$!" && c !== "$?" || b++;
        }
        a = a.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a = 0; a < th.length; a++)
    th[a]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R$1 = null, S = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a, b) {
  if (b === null)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Ch(a, b, c, d, e, f) {
  xh = f;
  R$1 = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  vh.current = a === null || a.memoizedState === null ? Dh : Eh;
  a = c(d, e);
  if (zh) {
    f = 0;
    do {
      zh = false;
      if (!(25 > f))
        throw Error(y(301));
      f += 1;
      T = S = null;
      b.updateQueue = null;
      vh.current = Fh;
      a = c(d, e);
    } while (zh);
  }
  vh.current = Gh;
  b = S !== null && S.next !== null;
  xh = 0;
  T = S = R$1 = null;
  yh = false;
  if (b)
    throw Error(y(300));
  return a;
}
function Hh() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  T === null ? R$1.memoizedState = T = a : T = T.next = a;
  return T;
}
function Ih() {
  if (S === null) {
    var a = R$1.alternate;
    a = a !== null ? a.memoizedState : null;
  } else
    a = S.next;
  var b = T === null ? R$1.memoizedState : T.next;
  if (b !== null)
    T = b, S = a;
  else {
    if (a === null)
      throw Error(y(310));
    S = a;
    a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
    T === null ? R$1.memoizedState = T = a : T = T.next = a;
  }
  return T;
}
function Jh(a, b) {
  return typeof b === "function" ? b(a) : b;
}
function Kh(a) {
  var b = Ih(), c = b.queue;
  if (c === null)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = S, e = d.baseQueue, f = c.pending;
  if (f !== null) {
    if (e !== null) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }
    d.baseQueue = e = f;
    c.pending = null;
  }
  if (e !== null) {
    e = e.next;
    d = d.baseState;
    var h = g = f = null, k = e;
    do {
      var l2 = k.lane;
      if ((xh & l2) === l2)
        h !== null && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
      else {
        var n2 = {
          lane: l2,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        };
        h === null ? (g = h = n2, f = d) : h = h.next = n2;
        R$1.lanes |= l2;
        Dg |= l2;
      }
      k = k.next;
    } while (k !== null && k !== e);
    h === null ? f = d : h.next = g;
    He(d, b.memoizedState) || (ug = true);
    b.memoizedState = d;
    b.baseState = f;
    b.baseQueue = h;
    c.lastRenderedState = d;
  }
  return [b.memoizedState, c.dispatch];
}
function Lh(a) {
  var b = Ih(), c = b.queue;
  if (c === null)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f = b.memoizedState;
  if (e !== null) {
    c.pending = null;
    var g = e = e.next;
    do
      f = a(f, g.action), g = g.next;
    while (g !== e);
    He(f, b.memoizedState) || (ug = true);
    b.memoizedState = f;
    b.baseQueue === null && (b.baseState = f);
    c.lastRenderedState = f;
  }
  return [f, d];
}
function Mh(a, b, c) {
  var d = b._getVersion;
  d = d(b._source);
  var e = b._workInProgressVersionPrimary;
  if (e !== null)
    a = e === d;
  else if (a = a.mutableReadLanes, a = (xh & a) === a)
    b._workInProgressVersionPrimary = d, th.push(b);
  if (a)
    return c(b._source);
  th.push(b);
  throw Error(y(350));
}
function Nh(a, b, c, d) {
  var e = U;
  if (e === null)
    throw Error(y(349));
  var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
    return Mh(e, b, c);
  }), l2 = k[1], n2 = k[0];
  k = T;
  var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w = R$1;
  a.memoizedState = { refs: p2, source: b, subscribe: d };
  h.useEffect(function() {
    p2.getSnapshot = c;
    p2.setSnapshot = l2;
    var a2 = f(b._source);
    if (!He(g, a2)) {
      a2 = c(b._source);
      He(n2, a2) || (l2(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
      a2 = e.mutableReadLanes;
      e.entangledLanes |= a2;
      for (var d2 = e.entanglements, h3 = a2; 0 < h3; ) {
        var k2 = 31 - Vc(h3), v2 = 1 << k2;
        d2[k2] |= a2;
        h3 &= ~v2;
      }
    }
  }, [c, b, d]);
  h.useEffect(function() {
    return d(b._source, function() {
      var a2 = p2.getSnapshot, c2 = p2.setSnapshot;
      try {
        c2(a2(b._source));
        var d2 = Ig(w);
        e.mutableReadLanes |= d2 & e.pendingLanes;
      } catch (q2) {
        c2(function() {
          throw q2;
        });
      }
    });
  }, [b, d]);
  He(C2, c) && He(x2, b) && He(A2, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R$1, a), k.queue = a, k.baseQueue = null, n2 = Mh(e, b, c), k.memoizedState = k.baseState = n2);
  return n2;
}
function Ph(a, b, c) {
  var d = Ih();
  return Nh(d, a, b, c);
}
function Qh(a) {
  var b = Hh();
  typeof a === "function" && (a = a());
  b.memoizedState = b.baseState = a;
  a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
  a = a.dispatch = Oh.bind(null, R$1, a);
  return [b.memoizedState, a];
}
function Rh(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = R$1.updateQueue;
  b === null ? (b = { lastEffect: null }, R$1.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function Sh(a) {
  var b = Hh();
  a = { current: a };
  return b.memoizedState = a;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a, b, c, d) {
  var e = Hh();
  R$1.flags |= a;
  e.memoizedState = Rh(1 | b, c, void 0, d === void 0 ? null : d);
}
function Vh(a, b, c, d) {
  var e = Ih();
  d = d === void 0 ? null : d;
  var f = void 0;
  if (S !== null) {
    var g = S.memoizedState;
    f = g.destroy;
    if (d !== null && Bh(d, g.deps)) {
      Rh(b, c, f, d);
      return;
    }
  }
  R$1.flags |= a;
  e.memoizedState = Rh(1 | b, c, f, d);
}
function Wh(a, b) {
  return Uh(516, 4, a, b);
}
function Xh(a, b) {
  return Vh(516, 4, a, b);
}
function Yh(a, b) {
  return Vh(4, 2, a, b);
}
function Zh(a, b) {
  if (typeof b === "function")
    return a = a(), b(a), function() {
      b(null);
    };
  if (b !== null && b !== void 0)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function $h(a, b, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b, a), c);
}
function ai() {
}
function bi(a, b) {
  var c = Ih();
  b = b === void 0 ? null : b;
  var d = c.memoizedState;
  if (d !== null && b !== null && Bh(b, d[1]))
    return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ci(a, b) {
  var c = Ih();
  b = b === void 0 ? null : b;
  var d = c.memoizedState;
  if (d !== null && b !== null && Bh(b, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function di(a, b) {
  var c = eg();
  gg(98 > c ? 98 : c, function() {
    a(true);
  });
  gg(97 < c ? 97 : c, function() {
    var c2 = wh.transition;
    wh.transition = 1;
    try {
      a(false), b();
    } finally {
      wh.transition = c2;
    }
  });
}
function Oh(a, b, c) {
  var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;
  g === null ? f.next = f : (f.next = g.next, g.next = f);
  b.pending = f;
  g = a.alternate;
  if (a === R$1 || g !== null && g === R$1)
    zh = yh = true;
  else {
    if (a.lanes === 0 && (g === null || g.lanes === 0) && (g = b.lastRenderedReducer, g !== null))
      try {
        var h = b.lastRenderedState, k = g(h, c);
        f.eagerReducer = g;
        f.eagerState = k;
        if (He(k, h))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a, e, d);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {
  Hh().memoizedState = [a, b === void 0 ? null : b];
  return a;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return Uh(4, 2, Zh.bind(null, b, a), c);
}, useLayoutEffect: function(a, b) {
  return Uh(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Hh();
  b = b === void 0 ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Hh();
  b = c !== void 0 ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  a = a.dispatch = Oh.bind(null, R$1, a);
  return [d.memoizedState, a];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Qh(a), c = b[0], d = b[1];
  Wh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Qh(false), b = a[0];
  a = di.bind(null, a[1]);
  Sh(a);
  return [a, b];
}, useMutableSource: function(a, b, c) {
  var d = Hh();
  d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
  return Nh(d, a, b, c);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a = false, b = uf(function() {
      a || (a = true, c("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c = Qh(b)[1];
    (R$1.mode & 2) === 0 && (R$1.flags |= 516, Rh(5, function() {
      c("r:" + (tf++).toString(36));
    }, void 0, null));
    return b;
  }
  b = "r:" + (tf++).toString(36);
  Qh(b);
  return b;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Kh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Kh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Lh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Lh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a, b, c, d) {
  b.child = a === null ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}
function gi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  tg(b, e);
  d = Ch(a, b, c, d, f, e);
  if (a !== null && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, d, e);
  return b.child;
}
function ii(a, b, c, d, e, f) {
  if (a === null) {
    var g = c.type;
    if (typeof g === "function" && !ji(g) && g.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0)
      return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
    a = Vg(c.type, null, d, b, b.mode, f);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  g = a.child;
  if ((e & f) === 0 && (e = g.memoizedProps, c = c.compare, c = c !== null ? c : Je, c(e, d) && a.ref === b.ref))
    return hi(a, b, f);
  b.flags |= 1;
  a = Tg(g, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function ki(a, b, c, d, e, f) {
  if (a !== null && Je(a.memoizedProps, d) && a.ref === b.ref)
    if (ug = false, (f & e) !== 0)
      (a.flags & 16384) !== 0 && (ug = true);
    else
      return b.lanes = a.lanes, hi(a, b, f);
  return li(a, b, c, d, f);
}
function mi(a, b, c) {
  var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;
  if (d.mode === "hidden" || d.mode === "unstable-defer-without-hiding")
    if ((b.mode & 4) === 0)
      b.memoizedState = { baseLanes: 0 }, ni(b, c);
    else if ((c & 1073741824) !== 0)
      b.memoizedState = { baseLanes: 0 }, ni(b, f !== null ? f.baseLanes : c);
    else
      return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
  else
    f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
  fi(a, b, e, c);
  return b.child;
}
function oi(a, b) {
  var c = b.ref;
  if (a === null && c !== null || a !== null && a.ref !== c)
    b.flags |= 128;
}
function li(a, b, c, d, e) {
  var f = Ff(c) ? Df : M.current;
  f = Ef(b, f);
  tg(b, e);
  c = Ch(a, b, c, d, f, e);
  if (a !== null && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, c, e);
  return b.child;
}
function pi(a, b, c, d, e) {
  if (Ff(c)) {
    var f = true;
    Jf(b);
  } else
    f = false;
  tg(b, e);
  if (b.stateNode === null)
    a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
  else if (a === null) {
    var g = b.stateNode, h = b.memoizedProps;
    g.props = h;
    var k = g.context, l2 = c.contextType;
    typeof l2 === "object" && l2 !== null ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));
    var n2 = c.getDerivedStateFromProps, A2 = typeof n2 === "function" || typeof g.getSnapshotBeforeUpdate === "function";
    A2 || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== d || k !== l2) && Ng(b, g, d, l2);
    wg = false;
    var p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    k = b.memoizedState;
    h !== d || p2 !== k || N.current || wg ? (typeof n2 === "function" && (Gg(b, c, n2, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p2, k, l2)) ? (A2 || typeof g.UNSAFE_componentWillMount !== "function" && typeof g.componentWillMount !== "function" || (typeof g.componentWillMount === "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount === "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount === "function" && (b.flags |= 4)) : (typeof g.componentDidMount === "function" && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l2, d = h) : (typeof g.componentDidMount === "function" && (b.flags |= 4), d = false);
  } else {
    g = b.stateNode;
    yg(a, b);
    h = b.memoizedProps;
    l2 = b.type === b.elementType ? h : lg(b.type, h);
    g.props = l2;
    A2 = b.pendingProps;
    p2 = g.context;
    k = c.contextType;
    typeof k === "object" && k !== null ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
    var C2 = c.getDerivedStateFromProps;
    (n2 = typeof C2 === "function" || typeof g.getSnapshotBeforeUpdate === "function") || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== A2 || p2 !== k) && Ng(b, g, d, k);
    wg = false;
    p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    var x2 = b.memoizedState;
    h !== A2 || p2 !== x2 || N.current || wg ? (typeof C2 === "function" && (Gg(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || typeof g.UNSAFE_componentWillUpdate !== "function" && typeof g.componentWillUpdate !== "function" || (typeof g.componentWillUpdate === "function" && g.componentWillUpdate(d, x2, k), typeof g.UNSAFE_componentWillUpdate === "function" && g.UNSAFE_componentWillUpdate(d, x2, k)), typeof g.componentDidUpdate === "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate === "function" && (b.flags |= 256)) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g.props = d, g.state = x2, g.context = k, d = l2) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), d = false);
  }
  return qi(a, b, c, d, f, e);
}
function qi(a, b, c, d, e, f) {
  oi(a, b);
  var g = (b.flags & 64) !== 0;
  if (!d && !g)
    return e && Kf(b, c, false), hi(a, b, f);
  d = b.stateNode;
  ei.current = b;
  var h = g && typeof c.getDerivedStateFromError !== "function" ? null : d.render();
  b.flags |= 1;
  a !== null && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
  b.memoizedState = d.state;
  e && Kf(b, c, true);
  return b.child;
}
function ri(a) {
  var b = a.stateNode;
  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
  eh(a, b.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a, b, c) {
  var d = b.pendingProps, e = P.current, f = false, g;
  (g = (b.flags & 64) !== 0) || (g = a !== null && a.memoizedState === null ? false : (e & 2) !== 0);
  g ? (f = true, b.flags &= -65) : a !== null && a.memoizedState === null || d.fallback === void 0 || d.unstable_avoidThisFallback === true || (e |= 1);
  I$1(P, e & 1);
  if (a === null) {
    d.fallback !== void 0 && ph(b);
    a = d.children;
    e = d.fallback;
    if (f)
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
    if (typeof d.unstable_expectedLoadTime === "number")
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
    c = vi({ mode: "visible", children: a }, b.mode, c, null);
    c.return = b;
    return b.child = c;
  }
  if (a.memoizedState !== null) {
    if (f)
      return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }
  if (f)
    return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
  c = xi(a, b, d.children, c);
  b.memoizedState = null;
  return c;
}
function ui(a, b, c, d) {
  var e = a.mode, f = a.child;
  b = { mode: "hidden", children: b };
  (e & 2) === 0 && f !== null ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
  c = Xg(c, e, d, null);
  f.return = a;
  c.return = a;
  f.sibling = c;
  a.child = f;
  return c;
}
function xi(a, b, c, d) {
  var e = a.child;
  a = e.sibling;
  c = Tg(e, { mode: "visible", children: c });
  (b.mode & 2) === 0 && (c.lanes = d);
  c.return = b;
  c.sibling = null;
  a !== null && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
  return b.child = c;
}
function wi(a, b, c, d, e) {
  var f = b.mode, g = a.child;
  a = g.sibling;
  var h = { mode: "hidden", children: c };
  (f & 2) === 0 && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, g !== null ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
  a !== null ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
  d.return = b;
  c.return = b;
  c.sibling = d;
  b.child = c;
  return d;
}
function yi(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  c !== null && (c.lanes |= b);
  sg(a.return, b);
}
function zi(a, b, c, d, e, f) {
  var g = a.memoizedState;
  g === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
}
function Ai(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f = d.tail;
  fi(a, b, d.children, c);
  d = P.current;
  if ((d & 2) !== 0)
    d = d & 1 | 2, b.flags |= 64;
  else {
    if (a !== null && (a.flags & 64) !== 0)
      a:
        for (a = b.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && yi(a, c);
          else if (a.tag === 19)
            yi(a, c);
          else if (a.child !== null) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  I$1(P, d);
  if ((b.mode & 2) === 0)
    b.memoizedState = null;
  else
    switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; c !== null; )
          a = c.alternate, a !== null && ih(a) === null && (e = c), c = c.sibling;
        c = e;
        c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        zi(b, false, e, c, f, b.lastEffect);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; e !== null; ) {
          a = e.alternate;
          if (a !== null && ih(a) === null) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        zi(b, true, c, null, f, b.lastEffect);
        break;
      case "together":
        zi(b, false, null, null, void 0, b.lastEffect);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function hi(a, b, c) {
  a !== null && (b.dependencies = a.dependencies);
  Dg |= b.lanes;
  if ((c & b.childLanes) !== 0) {
    if (a !== null && b.child !== a.child)
      throw Error(y(153));
    if (b.child !== null) {
      a = b.child;
      c = Tg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; a.sibling !== null; )
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a, b) {
  for (var c = b.child; c !== null; ) {
    if (c.tag === 5 || c.tag === 6)
      a.appendChild(c.stateNode);
    else if (c.tag !== 4 && c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Ci = function() {
};
Di = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    dh(ah.current);
    var f = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;
      case "option":
        e = eb(a, e);
        d = eb(a, d);
        f = [];
        break;
      case "select":
        e = m({}, e, { value: void 0 });
        d = m({}, d, { value: void 0 });
        f = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;
      default:
        typeof e.onClick !== "function" && typeof d.onClick === "function" && (a.onclick = jf);
    }
    vb(c, d);
    var g;
    c = null;
    for (l2 in e)
      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && e[l2] != null)
        if (l2 === "style") {
          var h = e[l2];
          for (g in h)
            h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ca.hasOwnProperty(l2) ? f || (f = []) : (f = f || []).push(l2, null));
    for (l2 in d) {
      var k = d[l2];
      h = e != null ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k !== h && (k != null || h != null))
        if (l2 === "style")
          if (h) {
            for (g in h)
              !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k)
              k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else
            c || (f || (f = []), f.push(l2, c)), c = k;
        else
          l2 === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, k != null && h !== k && (f = f || []).push(l2, k)) : l2 === "children" ? typeof k !== "string" && typeof k !== "number" || (f = f || []).push(l2, "" + k) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ca.hasOwnProperty(l2) ? (k != null && l2 === "onScroll" && G("scroll", a), f || h === k || (f = [])) : typeof k === "object" && k !== null && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l2, k));
    }
    c && (f = f || []).push("style", c);
    var l2 = f;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Ei = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Fi(a, b) {
  if (!lh)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; b !== null; )
          b.alternate !== null && (c = b), b = b.sibling;
        c === null ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; c !== null; )
          c.alternate !== null && (d = c), c = c.sibling;
        d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function Gi(a, b, c) {
  var d = b.pendingProps;
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b.type) && Gf(), null;
    case 3:
      fh();
      H$1(N);
      H$1(M);
      uh();
      d = b.stateNode;
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (a === null || a.child === null)
        rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
      Ci(b);
      return null;
    case 5:
      hh(b);
      var e = dh(ch.current);
      c = b.type;
      if (a !== null && b.stateNode != null)
        Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
      else {
        if (!d) {
          if (b.stateNode === null)
            throw Error(y(166));
          return null;
        }
        a = dh(ah.current);
        if (rh(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[wf] = b;
          d[xf] = f;
          switch (c) {
            case "dialog":
              G("cancel", d);
              G("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++)
                G(Xe[a], d);
              break;
            case "source":
              G("error", d);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d);
              G("load", d);
              break;
            case "details":
              G("toggle", d);
              break;
            case "input":
              Za(d, f);
              G("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f.multiple };
              G("invalid", d);
              break;
            case "textarea":
              hb(d, f), G("invalid", d);
          }
          vb(c, f);
          a = null;
          for (var g in f)
            f.hasOwnProperty(g) && (e = f[g], g === "children" ? typeof e === "string" ? d.textContent !== e && (a = ["children", e]) : typeof e === "number" && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && e != null && g === "onScroll" && G("scroll", d));
          switch (c) {
            case "input":
              Va(d);
              cb(d, f, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f.onClick === "function" && (d.onclick = jf);
          }
          d = a;
          b.updateQueue = d;
          d !== null && (b.flags |= 4);
        } else {
          g = e.nodeType === 9 ? e : e.ownerDocument;
          a === kb.html && (a = lb(c));
          a === kb.html ? c === "script" ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof d.is === "string" ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), c === "select" && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[wf] = b;
          a[xf] = d;
          Bi(a, b, false, false);
          b.stateNode = a;
          g = wb(c, d);
          switch (c) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e = d;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e = d;
              break;
            case "video":
            case "audio":
              for (e = 0; e < Xe.length; e++)
                G(Xe[e], a);
              e = d;
              break;
            case "source":
              G("error", a);
              e = d;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e = d;
              break;
            case "details":
              G("toggle", a);
              e = d;
              break;
            case "input":
              Za(a, d);
              e = Ya(a, d);
              G("invalid", a);
              break;
            case "option":
              e = eb(a, d);
              break;
            case "select":
              a._wrapperState = { wasMultiple: !!d.multiple };
              e = m({}, d, { value: void 0 });
              G("invalid", a);
              break;
            case "textarea":
              hb(a, d);
              e = gb(a, d);
              G("invalid", a);
              break;
            default:
              e = d;
          }
          vb(c, e);
          var h = e;
          for (f in h)
            if (h.hasOwnProperty(f)) {
              var k = h[f];
              f === "style" ? tb(a, k) : f === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, k != null && ob(a, k)) : f === "children" ? typeof k === "string" ? (c !== "textarea" || k !== "") && pb(a, k) : typeof k === "number" && pb(a, "" + k) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (ca.hasOwnProperty(f) ? k != null && f === "onScroll" && G("scroll", a) : k != null && qa(a, f, k, g));
            }
          switch (c) {
            case "input":
              Va(a);
              cb(a, d, false);
              break;
            case "textarea":
              Va(a);
              jb(a);
              break;
            case "option":
              d.value != null && a.setAttribute("value", "" + Sa(d.value));
              break;
            case "select":
              a.multiple = !!d.multiple;
              f = d.value;
              f != null ? fb(a, !!d.multiple, f, false) : d.defaultValue != null && fb(a, !!d.multiple, d.defaultValue, true);
              break;
            default:
              typeof e.onClick === "function" && (a.onclick = jf);
          }
          mf(c, d) && (b.flags |= 4);
        }
        b.ref !== null && (b.flags |= 128);
      }
      return null;
    case 6:
      if (a && b.stateNode != null)
        Ei(a, b, a.memoizedProps, d);
      else {
        if (typeof d !== "string" && b.stateNode === null)
          throw Error(y(166));
        c = dh(ch.current);
        dh(ah.current);
        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }
      return null;
    case 13:
      H$1(P);
      d = b.memoizedState;
      if ((b.flags & 64) !== 0)
        return b.lanes = c, b;
      d = d !== null;
      c = false;
      a === null ? b.memoizedProps.fallback !== void 0 && rh(b) : c = a.memoizedState !== null;
      if (d && !c && (b.mode & 2) !== 0)
        if (a === null && b.memoizedProps.unstable_avoidThisFallback !== true || (P.current & 1) !== 0)
          V === 0 && (V = 3);
        else {
          if (V === 0 || V === 3)
            V = 4;
          U === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U, W);
        }
      if (d || c)
        b.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b), a === null && cf(b.stateNode.containerInfo), null;
    case 10:
      return rg(b), null;
    case 17:
      return Ff(b.type) && Gf(), null;
    case 19:
      H$1(P);
      d = b.memoizedState;
      if (d === null)
        return null;
      f = (b.flags & 64) !== 0;
      g = d.rendering;
      if (g === null)
        if (f)
          Fi(d, false);
        else {
          if (V !== 0 || a !== null && (a.flags & 64) !== 0)
            for (a = b.child; a !== null; ) {
              g = ih(a);
              if (g !== null) {
                b.flags |= 64;
                Fi(d, false);
                f = g.updateQueue;
                f !== null && (b.updateQueue = f, b.flags |= 4);
                d.lastEffect === null && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                d = c;
                for (c = b.child; c !== null; )
                  f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, g === null ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                I$1(P, P.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          d.tail !== null && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        }
      else {
        if (!f)
          if (a = ih(g), a !== null) {
            if (b.flags |= 64, f = true, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Fi(d, true), d.tail === null && d.tailMode === "hidden" && !g.alternate && !lh)
              return b = b.lastEffect = d.lastEffect, b !== null && (b.nextEffect = null), null;
          } else
            2 * O() - d.renderingStartTime > Ji && c !== 1073741824 && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, c !== null ? c.sibling = g : b.child = g, d.last = g);
      }
      return d.tail !== null ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I$1(P, f ? b & 1 | 2 : b & 1), c) : null;
    case 23:
    case 24:
      return Ki(), a !== null && a.memoizedState !== null !== (b.memoizedState !== null) && d.mode !== "unstable-defer-without-hiding" && (b.flags |= 4), null;
  }
  throw Error(y(156, b.tag));
}
function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b = a.flags;
      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 3:
      fh();
      H$1(N);
      H$1(M);
      uh();
      b = a.flags;
      if ((b & 64) !== 0)
        throw Error(y(285));
      a.flags = b & -4097 | 64;
      return a;
    case 5:
      return hh(a), null;
    case 13:
      return H$1(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 19:
      return H$1(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a, b) {
  try {
    var c = "", d = b;
    do
      c += Qa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }
  return { value: a, source: b, stack: e };
}
function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Oi = typeof WeakMap === "function" ? WeakMap : Map;
function Pi(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Qi || (Qi = true, Ri = d);
    Ni(a, b);
  };
  return c;
}
function Si(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if (typeof d === "function") {
    var e = b.value;
    c.payload = function() {
      Ni(a, b);
      return d(e);
    };
  }
  var f = a.stateNode;
  f !== null && typeof f.componentDidCatch === "function" && (c.callback = function() {
    typeof d !== "function" && (Ti === null ? Ti = new Set([this]) : Ti.add(this), Ni(a, b));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : "" });
  });
  return c;
}
var Ui = typeof WeakSet === "function" ? WeakSet : Set;
function Vi(a) {
  var b = a.ref;
  if (b !== null)
    if (typeof b === "function")
      try {
        b(null);
      } catch (c) {
        Wi(a, c);
      }
    else
      b.current = null;
}
function Xi(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b.flags & 256 && a !== null) {
        var c = a.memoizedProps, d = a.memoizedState;
        a = b.stateNode;
        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
        a.__reactInternalSnapshotBeforeUpdate = b;
      }
      return;
    case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a, b, c) {
  switch (c.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b = c.updateQueue;
      b = b !== null ? b.lastEffect : null;
      if (b !== null) {
        a = b = b.next;
        do {
          if ((a.tag & 3) === 3) {
            var d = a.create;
            a.destroy = d();
          }
          a = a.next;
        } while (a !== b);
      }
      b = c.updateQueue;
      b = b !== null ? b.lastEffect : null;
      if (b !== null) {
        a = b = b.next;
        do {
          var e = a;
          d = e.next;
          e = e.tag;
          (e & 4) !== 0 && (e & 1) !== 0 && (Zi(c, a), $i(c, a));
          a = d;
        } while (a !== b);
      }
      return;
    case 1:
      a = c.stateNode;
      c.flags & 4 && (b === null ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
      b = c.updateQueue;
      b !== null && Eg(c, b, a);
      return;
    case 3:
      b = c.updateQueue;
      if (b !== null) {
        a = null;
        if (c.child !== null)
          switch (c.child.tag) {
            case 5:
              a = c.child.stateNode;
              break;
            case 1:
              a = c.child.stateNode;
          }
        Eg(c, b, a);
      }
      return;
    case 5:
      a = c.stateNode;
      b === null && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      c.memoizedState === null && (c = c.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null && Cc(c))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a, b) {
  for (var c = a; ; ) {
    if (c.tag === 5) {
      var d = c.stateNode;
      if (b)
        d = d.style, typeof d.setProperty === "function" ? d.setProperty("display", "none", "important") : d.display = "none";
      else {
        d = c.stateNode;
        var e = c.memoizedProps.style;
        e = e !== void 0 && e !== null && e.hasOwnProperty("display") ? e.display : null;
        d.style.display = sb("display", e);
      }
    } else if (c.tag === 6)
      c.stateNode.nodeValue = b ? "" : c.memoizedProps;
    else if ((c.tag !== 23 && c.tag !== 24 || c.memoizedState === null || c === a) && c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === a)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === a)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function bj(a, b) {
  if (Mf && typeof Mf.onCommitFiberUnmount === "function")
    try {
      Mf.onCommitFiberUnmount(Lf, b);
    } catch (f) {
    }
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b.updateQueue;
      if (a !== null && (a = a.lastEffect, a !== null)) {
        var c = a = a.next;
        do {
          var d = c, e = d.destroy;
          d = d.tag;
          if (e !== void 0)
            if ((d & 4) !== 0)
              Zi(b, c);
            else {
              d = b;
              try {
                e();
              } catch (f) {
                Wi(d, f);
              }
            }
          c = c.next;
        } while (c !== a);
      }
      break;
    case 1:
      Vi(b);
      a = b.stateNode;
      if (typeof a.componentWillUnmount === "function")
        try {
          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
        } catch (f) {
          Wi(b, f);
        }
      break;
    case 5:
      Vi(b);
      break;
    case 4:
      cj(a, b);
  }
}
function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.return = null;
  a.updateQueue = null;
}
function ej(a) {
  return a.tag === 5 || a.tag === 3 || a.tag === 4;
}
function fj(a) {
  a: {
    for (var b = a.return; b !== null; ) {
      if (ej(b))
        break a;
      b = b.return;
    }
    throw Error(y(160));
  }
  var c = b;
  b = c.stateNode;
  switch (c.tag) {
    case 5:
      var d = false;
      break;
    case 3:
      b = b.containerInfo;
      d = true;
      break;
    case 4:
      b = b.containerInfo;
      d = true;
      break;
    default:
      throw Error(y(161));
  }
  c.flags & 16 && (pb(b, ""), c.flags &= -17);
  a:
    b:
      for (c = a; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || ej(c.return)) {
            c = null;
            break a;
          }
          c = c.return;
        }
        c.sibling.return = c.return;
        for (c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2)
            continue b;
          if (c.child === null || c.tag === 4)
            continue b;
          else
            c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) {
          c = c.stateNode;
          break a;
        }
      }
  d ? gj(a, c, b) : hj(a, c, b);
}
function gj(a, b, c) {
  var d = a.tag, e = d === 5 || d === 6;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c !== null && c !== void 0 || b.onclick !== null || (b.onclick = jf));
  else if (d !== 4 && (a = a.child, a !== null))
    for (gj(a, b, c), a = a.sibling; a !== null; )
      gj(a, b, c), a = a.sibling;
}
function hj(a, b, c) {
  var d = a.tag, e = d === 5 || d === 6;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (d !== 4 && (a = a.child, a !== null))
    for (hj(a, b, c), a = a.sibling; a !== null; )
      hj(a, b, c), a = a.sibling;
}
function cj(a, b) {
  for (var c = b, d = false, e, f; ; ) {
    if (!d) {
      d = c.return;
      a:
        for (; ; ) {
          if (d === null)
            throw Error(y(160));
          e = d.stateNode;
          switch (d.tag) {
            case 5:
              f = false;
              break a;
            case 3:
              e = e.containerInfo;
              f = true;
              break a;
            case 4:
              e = e.containerInfo;
              f = true;
              break a;
          }
          d = d.return;
        }
      d = true;
    }
    if (c.tag === 5 || c.tag === 6) {
      a:
        for (var g = a, h = c, k = h; ; )
          if (bj(g, k), k.child !== null && k.tag !== 4)
            k.child.return = k, k = k.child;
          else {
            if (k === h)
              break a;
            for (; k.sibling === null; ) {
              if (k.return === null || k.return === h)
                break a;
              k = k.return;
            }
            k.sibling.return = k.return;
            k = k.sibling;
          }
      f ? (g = e, h = c.stateNode, g.nodeType === 8 ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
    } else if (c.tag === 4) {
      if (c.child !== null) {
        e = c.stateNode.containerInfo;
        f = true;
        c.child.return = c;
        c = c.child;
        continue;
      }
    } else if (bj(a, c), c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === b)
        return;
      c = c.return;
      c.tag === 4 && (d = false);
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function ij(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c = b.updateQueue;
      c = c !== null ? c.lastEffect : null;
      if (c !== null) {
        var d = c = c.next;
        do
          (d.tag & 3) === 3 && (a = d.destroy, d.destroy = void 0, a !== void 0 && a()), d = d.next;
        while (d !== c);
      }
      return;
    case 1:
      return;
    case 5:
      c = b.stateNode;
      if (c != null) {
        d = b.memoizedProps;
        var e = a !== null ? a.memoizedProps : d;
        a = b.type;
        var f = b.updateQueue;
        b.updateQueue = null;
        if (f !== null) {
          c[xf] = d;
          a === "input" && d.type === "radio" && d.name != null && $a(c, d);
          wb(a, e);
          b = wb(a, d);
          for (e = 0; e < f.length; e += 2) {
            var g = f[e], h = f[e + 1];
            g === "style" ? tb(c, h) : g === "dangerouslySetInnerHTML" ? ob(c, h) : g === "children" ? pb(c, h) : qa(c, g, h, b);
          }
          switch (a) {
            case "input":
              ab(c, d);
              break;
            case "textarea":
              ib(c, d);
              break;
            case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, f != null ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (d.defaultValue != null ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (b.stateNode === null)
        throw Error(y(162));
      b.stateNode.nodeValue = b.memoizedProps;
      return;
    case 3:
      c = b.stateNode;
      c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
      return;
    case 12:
      return;
    case 13:
      b.memoizedState !== null && (jj = O(), aj(b.child, true));
      kj(b);
      return;
    case 19:
      kj(b);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b, b.memoizedState !== null);
      return;
  }
  throw Error(y(163));
}
function kj(a) {
  var b = a.updateQueue;
  if (b !== null) {
    a.updateQueue = null;
    var c = a.stateNode;
    c === null && (c = a.stateNode = new Ui());
    b.forEach(function(b2) {
      var d = lj.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function mj(a, b) {
  return a !== null && (a = a.memoizedState, a === null || a.dehydrated !== null) ? (b = b.memoizedState, b !== null && b.dehydrated === null) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return (X & 48) !== 0 ? O() : Fj !== -1 ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;
  if ((a & 2) === 0)
    return 1;
  if ((a & 4) === 0)
    return eg() === 99 ? 1 : 2;
  Gj === 0 && (Gj = tj);
  if (kg.transition !== 0) {
    Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
    a = Gj;
    var b = 4186112 & ~Hj;
    b &= -b;
    b === 0 && (a = 4186112 & ~a, b = a & -a, b === 0 && (b = 8192));
    return b;
  }
  a = eg();
  (X & 4) !== 0 && a === 98 ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
  return a;
}
function Jg(a, b, c) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b);
  if (a === null)
    return null;
  $c(a, b, c);
  a === U && (Hi |= b, V === 4 && Ii(a, W));
  var d = eg();
  b === 1 ? (X & 8) !== 0 && (X & 48) === 0 ? Lj(a) : (Mj(a, c), X === 0 && (wj(), ig())) : ((X & 4) === 0 || d !== 98 && d !== 99 || (Cj === null ? Cj = new Set([a]) : Cj.add(a)), Mj(a, c));
  vj = a;
}
function Kj(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  c !== null && (c.lanes |= b);
  c = a;
  for (a = a.return; a !== null; )
    a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
  return c.tag === 3 ? c.stateNode : null;
}
function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
    var h = 31 - Vc(g), k = 1 << h, l2 = f[h];
    if (l2 === -1) {
      if ((k & d) === 0 || (k & e) !== 0) {
        l2 = b;
        Rc(k);
        var n2 = F$1;
        f[h] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b && (a.expiredLanes |= k);
    g &= ~k;
  }
  d = Uc(a, a === U ? W : 0);
  b = F$1;
  if (d === 0)
    c !== null && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
  else {
    if (c !== null) {
      if (a.callbackPriority === b)
        return;
      c !== Zf && Pf(c);
    }
    b === 15 ? (c = Lj.bind(null, a), ag === null ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : b === 14 ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if ((X & 48) !== 0)
    throw Error(y(327));
  var b = a.callbackNode;
  if (Oj() && a.callbackNode !== b)
    return null;
  var c = Uc(a, a === U ? W : 0);
  if (c === 0)
    return null;
  var d = c;
  var e = X;
  X |= 16;
  var f = Pj();
  if (U !== a || W !== d)
    wj(), Qj(a, d);
  do
    try {
      Rj();
      break;
    } catch (h) {
      Sj(a, h);
    }
  while (1);
  qg();
  oj.current = f;
  X = e;
  Y !== null ? d = 0 : (U = null, W = 0, d = V);
  if ((tj & Hi) !== 0)
    Qj(a, 0);
  else if (d !== 0) {
    d === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), c !== 0 && (d = Tj(a, c)));
    if (d === 1)
      throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c;
    switch (d) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a);
        break;
      case 3:
        Ii(a, c);
        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (Uc(a, 0) !== 0)
            break;
          e = a.suspendedLanes;
          if ((e & c) !== c) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e;
            break;
          }
          a.timeoutHandle = of(Uj.bind(null, a), d);
          break;
        }
        Uj(a);
        break;
      case 4:
        Ii(a, c);
        if ((c & 4186112) === c)
          break;
        d = a.eventTimes;
        for (e = -1; 0 < c; ) {
          var g = 31 - Vc(c);
          f = 1 << g;
          g = d[g];
          g > e && (e = g);
          c &= ~f;
        }
        c = e;
        c = O() - c;
        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
        if (10 < c) {
          a.timeoutHandle = of(Uj.bind(null, a), c);
          break;
        }
        Uj(a);
        break;
      case 5:
        Uj(a);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b ? Nj.bind(null, a) : null;
}
function Ii(a, b) {
  b &= ~uj;
  b &= ~Hi;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - Vc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Lj(a) {
  if ((X & 48) !== 0)
    throw Error(y(327));
  Oj();
  if (a === U && (a.expiredLanes & W) !== 0) {
    var b = W;
    var c = Tj(a, b);
    (tj & Hi) !== 0 && (b = Uc(a, b), c = Tj(a, b));
  } else
    b = Uc(a, 0), c = Tj(a, b);
  a.tag !== 0 && c === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), b !== 0 && (c = Tj(a, b)));
  if (c === 1)
    throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Uj(a);
  Mj(a, O());
  return null;
}
function Vj() {
  if (Cj !== null) {
    var a = Cj;
    Cj = null;
    a.forEach(function(a2) {
      a2.expiredLanes |= 24 & a2.pendingLanes;
      Mj(a2, O());
    });
  }
  ig();
}
function Wj(a, b) {
  var c = X;
  X |= 1;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
}
function Xj(a, b) {
  var c = X;
  X &= -2;
  X |= 8;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
}
function ni(a, b) {
  I$1(rj, qj);
  qj |= b;
  tj |= b;
}
function Ki() {
  qj = rj.current;
  H$1(rj);
}
function Qj(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  c !== -1 && (a.timeoutHandle = -1, pf(c));
  if (Y !== null)
    for (c = Y.return; c !== null; ) {
      var d = c;
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          d !== null && d !== void 0 && Gf();
          break;
        case 3:
          fh();
          H$1(N);
          H$1(M);
          uh();
          break;
        case 5:
          hh(d);
          break;
        case 4:
          fh();
          break;
        case 13:
          H$1(P);
          break;
        case 19:
          H$1(P);
          break;
        case 10:
          rg(d);
          break;
        case 23:
        case 24:
          Ki();
      }
      c = c.return;
    }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a, b) {
  do {
    var c = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d = R$1.memoizedState; d !== null; ) {
          var e = d.queue;
          e !== null && (e.pending = null);
          d = d.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R$1 = null;
      zh = false;
      pj.current = null;
      if (c === null || c.return === null) {
        V = 1;
        sj = b;
        Y = null;
        break;
      }
      a: {
        var f = a, g = c.return, h = c, k = b;
        b = W;
        h.flags |= 2048;
        h.firstEffect = h.lastEffect = null;
        if (k !== null && typeof k === "object" && typeof k.then === "function") {
          var l2 = k;
          if ((h.mode & 2) === 0) {
            var n2 = h.alternate;
            n2 ? (h.updateQueue = n2.updateQueue, h.memoizedState = n2.memoizedState, h.lanes = n2.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var A2 = (P.current & 1) !== 0, p2 = g;
          do {
            var C2;
            if (C2 = p2.tag === 13) {
              var x2 = p2.memoizedState;
              if (x2 !== null)
                C2 = x2.dehydrated !== null ? true : false;
              else {
                var w = p2.memoizedProps;
                C2 = w.fallback === void 0 ? false : w.unstable_avoidThisFallback !== true ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (z2 === null) {
                var u2 = new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if ((p2.mode & 2) === 0) {
                p2.flags |= 64;
                h.flags |= 16384;
                h.flags &= -2981;
                if (h.tag === 1)
                  if (h.alternate === null)
                    h.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h, t2);
                  }
                h.lanes |= 1;
                break a;
              }
              k = void 0;
              h = b;
              var q2 = f.pingCache;
              q2 === null ? (q2 = f.pingCache = new Oi(), k = new Set(), q2.set(l2, k)) : (k = q2.get(l2), k === void 0 && (k = new Set(), q2.set(l2, k)));
              if (!k.has(h)) {
                k.add(h);
                var v2 = Yj.bind(null, f, l2, h);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b;
              break a;
            }
            p2 = p2.return;
          } while (p2 !== null);
          k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        V !== 5 && (V = 2);
        k = Mi(k, h);
        p2 = g;
        do {
          switch (p2.tag) {
            case 3:
              f = k;
              p2.flags |= 4096;
              b &= -b;
              p2.lanes |= b;
              var J2 = Pi(p2, f, b);
              Bg(p2, J2);
              break a;
            case 1:
              f = k;
              var K2 = p2.type, Q2 = p2.stateNode;
              if ((p2.flags & 64) === 0 && (typeof K2.getDerivedStateFromError === "function" || Q2 !== null && typeof Q2.componentDidCatch === "function" && (Ti === null || !Ti.has(Q2)))) {
                p2.flags |= 4096;
                b &= -b;
                p2.lanes |= b;
                var L2 = Si(p2, f, b);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (p2 !== null);
      }
      Zj(c);
    } catch (va) {
      b = va;
      Y === c && c !== null && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return a === null ? Gh : a;
}
function Tj(a, b) {
  var c = X;
  X |= 16;
  var d = Pj();
  U === a && W === b || Qj(a, b);
  do
    try {
      ak();
      break;
    } catch (e) {
      Sj(a, e);
    }
  while (1);
  qg();
  X = c;
  oj.current = d;
  if (Y !== null)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; Y !== null; )
    bk(Y);
}
function Rj() {
  for (; Y !== null && !Qf(); )
    bk(Y);
}
function bk(a) {
  var b = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  b === null ? Zj(a) : Y = b;
  pj.current = null;
}
function Zj(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if ((b.flags & 2048) === 0) {
      c = Gi(c, b, qj);
      if (c !== null) {
        Y = c;
        return;
      }
      c = b;
      if (c.tag !== 24 && c.tag !== 23 || c.memoizedState === null || (qj & 1073741824) !== 0 || (c.mode & 4) === 0) {
        for (var d = 0, e = c.child; e !== null; )
          d |= e.lanes | e.childLanes, e = e.sibling;
        c.childLanes = d;
      }
      a !== null && (a.flags & 2048) === 0 && (a.firstEffect === null && (a.firstEffect = b.firstEffect), b.lastEffect !== null && (a.lastEffect !== null && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (a.lastEffect !== null ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);
      if (c !== null) {
        c.flags &= 2047;
        Y = c;
        return;
      }
      a !== null && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }
    b = b.sibling;
    if (b !== null) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (b !== null);
  V === 0 && (V = 5);
}
function Uj(a) {
  var b = eg();
  gg(99, dk.bind(null, a, b));
  return null;
}
function dk(a, b) {
  do
    Oj();
  while (yj !== null);
  if ((X & 48) !== 0)
    throw Error(y(327));
  var c = a.finishedWork;
  if (c === null)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(y(177));
  a.callbackNode = null;
  var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
  a.pendingLanes = e;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e;
  a.mutableReadLanes &= e;
  a.entangledLanes &= e;
  e = a.entanglements;
  for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
    var k = 31 - Vc(f), l2 = 1 << k;
    e[k] = 0;
    g[k] = -1;
    h[k] = -1;
    f &= ~l2;
  }
  Cj !== null && (d & 24) === 0 && Cj.has(a) && Cj.delete(a);
  a === U && (Y = U = null, W = 0);
  1 < c.flags ? c.lastEffect !== null ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
  if (d !== null) {
    e = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g = Ne();
    if (Oe(g)) {
      if ("selectionStart" in g)
        h = { start: g.selectionStart, end: g.selectionEnd };
      else
        a:
          if (h = (h = g.ownerDocument) && h.defaultView || window, (l2 = h.getSelection && h.getSelection()) && l2.rangeCount !== 0) {
            h = l2.anchorNode;
            f = l2.anchorOffset;
            k = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h.nodeType, k.nodeType;
            } catch (va) {
              h = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w = g, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w !== h || f !== 0 && w.nodeType !== 3 || (A2 = n2 + f);
                  w !== k || l2 !== 0 && w.nodeType !== 3 || (p2 = n2 + l2);
                  w.nodeType === 3 && (n2 += w.nodeValue.length);
                  if ((u2 = w.firstChild) === null)
                    break;
                  z2 = w;
                  w = u2;
                }
                for (; ; ) {
                  if (w === g)
                    break b;
                  z2 === h && ++C2 === f && (A2 = n2);
                  z2 === k && ++x2 === l2 && (p2 = n2);
                  if ((u2 = w.nextSibling) !== null)
                    break;
                  w = z2;
                  z2 = w.parentNode;
                }
                w = u2;
              }
            h = A2 === -1 || p2 === -1 ? null : { start: A2, end: p2 };
          } else
            h = null;
      h = h || { start: 0, end: 0 };
    } else
      h = null;
    lf = { focusedElem: g, selectionRange: h };
    fd = false;
    Ij = null;
    Jj = false;
    Z = d;
    do
      try {
        ek();
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Ij = null;
    Z = d;
    do
      try {
        for (g = a; Z !== null; ) {
          var t2 = Z.flags;
          t2 & 16 && pb(Z.stateNode, "");
          if (t2 & 128) {
            var q2 = Z.alternate;
            if (q2 !== null) {
              var v2 = q2.ref;
              v2 !== null && (typeof v2 === "function" ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h = Z;
              cj(g, h);
              var J2 = h.alternate;
              dj(h);
              J2 !== null && dj(J2);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      g !== null && Oe(t2) && (q2 = g.start, v2 = g.end, v2 === void 0 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h = t2.textContent.length, J2 = Math.min(g.start, h), g = g.end === void 0 ? J2 : Math.min(g.end, h), !v2.extend && J2 > g && (h = g, g = J2, J2 = h), h = Le(t2, J2), f = Le(t2, g), h && f && (v2.rangeCount !== 1 || v2.anchorNode !== h.node || v2.anchorOffset !== h.offset || v2.focusNode !== f.node || v2.focusOffset !== f.offset) && (q2 = q2.createRange(), q2.setStart(h.node, h.offset), v2.removeAllRanges(), J2 > g ? (v2.addRange(q2), v2.extend(f.node, f.offset)) : (q2.setEnd(f.node, f.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        v2.nodeType === 1 && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      typeof t2.focus === "function" && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a.current = c;
    Z = d;
    do
      try {
        for (t2 = a; Z !== null; ) {
          var K2 = Z.flags;
          K2 & 36 && Yi(t2, Z.alternate, Z);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z.ref;
            if (Q2 !== null) {
              var L2 = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              typeof Q2 === "function" ? Q2(q2) : Q2.current = q2;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Z = null;
    $f();
    X = e;
  } else
    a.current = c;
  if (xj)
    xj = false, yj = a, zj = b;
  else
    for (Z = d; Z !== null; )
      b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;
  d = a.pendingLanes;
  d === 0 && (Ti = null);
  d === 1 ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c = c.stateNode;
  if (Mf && typeof Mf.onCommitFiberRoot === "function")
    try {
      Mf.onCommitFiberRoot(Lf, c, void 0, (c.current.flags & 64) === 64);
    } catch (va) {
    }
  Mj(a, O());
  if (Qi)
    throw Qi = false, a = Ri, Ri = null, a;
  if ((X & 8) !== 0)
    return null;
  ig();
  return null;
}
function ek() {
  for (; Z !== null; ) {
    var a = Z.alternate;
    Jj || Ij === null || ((Z.flags & 8) !== 0 ? dc(Z, Ij) && (Jj = true) : Z.tag === 13 && mj(a, Z) && dc(Z, Ij) && (Jj = true));
    var b = Z.flags;
    (b & 256) !== 0 && Xi(a, Z);
    (b & 512) === 0 || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (zj !== 90) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a, fk);
  }
  return false;
}
function $i(a, b) {
  Aj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a, b) {
  Bj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (yj === null)
    return false;
  var a = yj;
  yj = null;
  if ((X & 48) !== 0)
    throw Error(y(331));
  var b = X;
  X |= 32;
  var c = Bj;
  Bj = [];
  for (var d = 0; d < c.length; d += 2) {
    var e = c[d], f = c[d + 1], g = e.destroy;
    e.destroy = void 0;
    if (typeof g === "function")
      try {
        g();
      } catch (k) {
        if (f === null)
          throw Error(y(330));
        Wi(f, k);
      }
  }
  c = Aj;
  Aj = [];
  for (d = 0; d < c.length; d += 2) {
    e = c[d];
    f = c[d + 1];
    try {
      var h = e.create;
      e.destroy = h();
    } catch (k) {
      if (f === null)
        throw Error(y(330));
      Wi(f, k);
    }
  }
  for (h = a.current.firstEffect; h !== null; )
    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
  X = b;
  ig();
  return true;
}
function gk(a, b, c) {
  b = Mi(c, b);
  b = Pi(a, b, 1);
  Ag(a, b);
  b = Hg();
  a = Kj(a, 1);
  a !== null && ($c(a, 1, b), Mj(a, b));
}
function Wi(a, b) {
  if (a.tag === 3)
    gk(a, a, b);
  else
    for (var c = a.return; c !== null; ) {
      if (c.tag === 3) {
        gk(c, a, b);
        break;
      } else if (c.tag === 1) {
        var d = c.stateNode;
        if (typeof c.type.getDerivedStateFromError === "function" || typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d))) {
          a = Mi(b, a);
          var e = Si(c, a, 1);
          Ag(c, e);
          e = Hg();
          c = Kj(c, 1);
          if (c !== null)
            $c(c, 1, e), Mj(c, e);
          else if (typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d)))
            try {
              d.componentDidCatch(b, a);
            } catch (f) {
            }
          break;
        }
      }
      c = c.return;
    }
}
function Yj(a, b, c) {
  var d = a.pingCache;
  d !== null && d.delete(b);
  b = Hg();
  a.pingedLanes |= a.suspendedLanes & c;
  U === a && (W & c) === c && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
  Mj(a, b);
}
function lj(a, b) {
  var c = a.stateNode;
  c !== null && c.delete(b);
  b = 0;
  b === 0 && (b = a.mode, (b & 2) === 0 ? b = 1 : (b & 4) === 0 ? b = eg() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b = Yc(62914560 & ~Gj), b === 0 && (b = 4194304)));
  c = Hg();
  a = Kj(a, b);
  a !== null && ($c(a, b, c), Mj(a, c));
}
var ck;
ck = function(a, b, c) {
  var d = b.lanes;
  if (a !== null)
    if (a.memoizedProps !== b.pendingProps || N.current)
      ug = true;
    else if ((c & d) !== 0)
      ug = (a.flags & 16384) !== 0 ? true : false;
    else {
      ug = false;
      switch (b.tag) {
        case 3:
          ri(b);
          sh();
          break;
        case 5:
          gh(b);
          break;
        case 1:
          Ff(b.type) && Jf(b);
          break;
        case 4:
          eh(b, b.stateNode.containerInfo);
          break;
        case 10:
          d = b.memoizedProps.value;
          var e = b.type._context;
          I$1(mg, e._currentValue);
          e._currentValue = d;
          break;
        case 13:
          if (b.memoizedState !== null) {
            if ((c & b.child.childLanes) !== 0)
              return ti(a, b, c);
            I$1(P, P.current & 1);
            b = hi(a, b, c);
            return b !== null ? b.sibling : null;
          }
          I$1(P, P.current & 1);
          break;
        case 19:
          d = (c & b.childLanes) !== 0;
          if ((a.flags & 64) !== 0) {
            if (d)
              return Ai(a, b, c);
            b.flags |= 64;
          }
          e = b.memoizedState;
          e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null);
          I$1(P, P.current);
          if (d)
            break;
          else
            return null;
        case 23:
        case 24:
          return b.lanes = 0, mi(a, b, c);
      }
      return hi(a, b, c);
    }
  else
    ug = false;
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      d = b.type;
      a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
      a = b.pendingProps;
      e = Ef(b, M.current);
      tg(b, c);
      e = Ch(null, b, d, a, e, c);
      b.flags |= 1;
      if (typeof e === "object" && e !== null && typeof e.render === "function" && e.$$typeof === void 0) {
        b.tag = 1;
        b.memoizedState = null;
        b.updateQueue = null;
        if (Ff(d)) {
          var f = true;
          Jf(b);
        } else
          f = false;
        b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null;
        xg(b);
        var g = d.getDerivedStateFromProps;
        typeof g === "function" && Gg(b, d, g, a);
        e.updater = Kg;
        b.stateNode = e;
        e._reactInternals = b;
        Og(b, d, a, c);
        b = qi(null, b, d, true, f, c);
      } else
        b.tag = 0, fi(null, b, e, c), b = b.child;
      return b;
    case 16:
      e = b.elementType;
      a: {
        a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        f = e._init;
        e = f(e._payload);
        b.type = e;
        f = b.tag = hk(e);
        a = lg(e, a);
        switch (f) {
          case 0:
            b = li(null, b, e, a, c);
            break a;
          case 1:
            b = pi(null, b, e, a, c);
            break a;
          case 11:
            b = gi(null, b, e, a, c);
            break a;
          case 14:
            b = ii(null, b, e, lg(e.type, a), d, c);
            break a;
        }
        throw Error(y(306, e, ""));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
    case 3:
      ri(b);
      d = b.updateQueue;
      if (a === null || d === null)
        throw Error(y(282));
      d = b.pendingProps;
      e = b.memoizedState;
      e = e !== null ? e.element : null;
      yg(a, b);
      Cg(b, d, null, c);
      d = b.memoizedState.element;
      if (d === e)
        sh(), b = hi(a, b, c);
      else {
        e = b.stateNode;
        if (f = e.hydrate)
          kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
        if (f) {
          a = e.mutableSourceEagerHydrationData;
          if (a != null)
            for (e = 0; e < a.length; e += 2)
              f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
          c = Zg(b, null, d, c);
          for (b.child = c; c; )
            c.flags = c.flags & -3 | 1024, c = c.sibling;
        } else
          fi(a, b, d, c), sh();
        b = b.child;
      }
      return b;
    case 5:
      return gh(b), a === null && ph(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : f !== null && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
    case 6:
      return a === null && ph(b), null;
    case 13:
      return ti(a, b, c);
    case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
    case 7:
      return fi(a, b, b.pendingProps, c), b.child;
    case 8:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        g = b.memoizedProps;
        f = e.value;
        var h = b.type._context;
        I$1(mg, h._currentValue);
        h._currentValue = f;
        if (g !== null)
          if (h = g.value, f = He(h, f) ? 0 : (typeof d._calculateChangedBits === "function" ? d._calculateChangedBits(h, f) : 1073741823) | 0, f === 0) {
            if (g.children === e.children && !N.current) {
              b = hi(a, b, c);
              break a;
            }
          } else
            for (h = b.child, h !== null && (h.return = b); h !== null; ) {
              var k = h.dependencies;
              if (k !== null) {
                g = h.child;
                for (var l2 = k.firstContext; l2 !== null; ) {
                  if (l2.context === d && (l2.observedBits & f) !== 0) {
                    h.tag === 1 && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h, l2));
                    h.lanes |= c;
                    l2 = h.alternate;
                    l2 !== null && (l2.lanes |= c);
                    sg(h.return, c);
                    k.lanes |= c;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g = h.tag === 10 ? h.type === b.type ? null : h.child : h.child;
              if (g !== null)
                g.return = h;
              else
                for (g = h; g !== null; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  h = g.sibling;
                  if (h !== null) {
                    h.return = g.return;
                    g = h;
                    break;
                  }
                  g = g.return;
                }
              h = g;
            }
        fi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
    case 14:
      return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);
    case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
    case 19:
      return Ai(a, b, c);
    case 23:
      return mi(a, b, c);
    case 24:
      return mi(a, b, c);
  }
  throw Error(y(156, b.tag));
};
function ik(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}
function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function hk(a) {
  if (typeof a === "function")
    return ji(a) ? 1 : 0;
  if (a !== void 0 && a !== null) {
    a = a.$$typeof;
    if (a === Aa)
      return 11;
    if (a === Da)
      return 14;
  }
  return 2;
}
function Tg(a, b) {
  var c = a.alternate;
  c === null ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Vg(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if (typeof a === "function")
    ji(a) && (g = 1);
  else if (typeof a === "string")
    g = 5;
  else
    a:
      switch (a) {
        case ua:
          return Xg(c.children, e, f, b);
        case Ha:
          g = 8;
          e |= 16;
          break;
        case wa:
          g = 8;
          e |= 1;
          break;
        case xa:
          return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
        case Ba:
          return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
        case Ca:
          return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
        case Ia:
          return vi(c, e, f, b);
        case Ja:
          return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
        default:
          if (typeof a === "object" && a !== null)
            switch (a.$$typeof) {
              case ya:
                g = 10;
                break a;
              case za:
                g = 9;
                break a;
              case Aa:
                g = 11;
                break a;
              case Da:
                g = 14;
                break a;
              case Ea:
                g = 16;
                d = null;
                break a;
              case Fa:
                g = 22;
                break a;
            }
          throw Error(y(130, a == null ? a : typeof a, ""));
      }
  b = nh(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}
function Xg(a, b, c, d) {
  a = nh(7, a, d, b);
  a.lanes = c;
  return a;
}
function vi(a, b, c, d) {
  a = nh(23, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  return a;
}
function Ug(a, b, c) {
  a = nh(6, a, null, b);
  a.lanes = c;
  return a;
}
function Wg(a, b, c) {
  b = nh(4, a.children !== null ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function jk(a, b, c) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a, b, c) {
  var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: ta, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function lk(a, b, c, d) {
  var e = b.current, f = Hg(), g = Ig(e);
  a:
    if (c) {
      c = c._reactInternals;
      b: {
        if (Zb(c) !== c || c.tag !== 1)
          throw Error(y(170));
        var h = c;
        do {
          switch (h.tag) {
            case 3:
              h = h.stateNode.context;
              break b;
            case 1:
              if (Ff(h.type)) {
                h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h = h.return;
        } while (h !== null);
        throw Error(y(171));
      }
      if (c.tag === 1) {
        var k = c.type;
        if (Ff(k)) {
          c = If(c, k, h);
          break a;
        }
      }
      c = h;
    } else
      c = Cf;
  b.context === null ? b.context = c : b.pendingContext = c;
  b = zg(f, g);
  b.payload = { element: a };
  d = d === void 0 ? null : d;
  d !== null && (b.callback = d);
  Ag(e, b);
  Jg(e, g, f);
  return g;
}
function mk(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function nk(a, b) {
  a = a.memoizedState;
  if (a !== null && a.dehydrated !== null) {
    var c = a.retryLane;
    a.retryLane = c !== 0 && c < b ? c : b;
  }
}
function ok(a, b) {
  nk(a, b);
  (a = a.alternate) && nk(a, b);
}
function pk() {
  return null;
}
function qk(a, b, c) {
  var d = c != null && c.hydrationOptions != null && c.hydrationOptions.mutableSources || null;
  c = new jk(a, b, c != null && c.hydrate === true);
  b = nh(3, null, null, b === 2 ? 7 : b === 1 ? 3 : 0);
  c.current = b;
  b.stateNode = c;
  xg(b);
  a[ff] = c.current;
  cf(a.nodeType === 8 ? a.parentNode : a);
  if (d)
    for (a = 0; a < d.length; a++) {
      b = d[a];
      var e = b._getVersion;
      e = e(b._source);
      c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
    }
  this._internalRoot = c;
}
qk.prototype.render = function(a) {
  lk(a, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a = this._internalRoot, b = a.containerInfo;
  lk(null, a, null, function() {
    b[ff] = null;
  });
};
function rk(a) {
  return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
}
function sk(a, b) {
  b || (b = a ? a.nodeType === 9 ? a.documentElement : a.firstChild : null, b = !(!b || b.nodeType !== 1 || !b.hasAttribute("data-reactroot")));
  if (!b)
    for (var c; c = a.lastChild; )
      a.removeChild(c);
  return new qk(a, 0, b ? { hydrate: true } : void 0);
}
function tk(a, b, c, d, e) {
  var f = c._reactRootContainer;
  if (f) {
    var g = f._internalRoot;
    if (typeof e === "function") {
      var h = e;
      e = function() {
        var a2 = mk(g);
        h.call(a2);
      };
    }
    lk(b, g, a, e);
  } else {
    f = c._reactRootContainer = sk(c, d);
    g = f._internalRoot;
    if (typeof e === "function") {
      var k = e;
      e = function() {
        var a2 = mk(g);
        k.call(a2);
      };
    }
    Xj(function() {
      lk(b, g, a, e);
    });
  }
  return mk(g);
}
ec = function(a) {
  if (a.tag === 13) {
    var b = Hg();
    Jg(a, 4, b);
    ok(a, 4);
  }
};
fc = function(a) {
  if (a.tag === 13) {
    var b = Hg();
    Jg(a, 67108864, b);
    ok(a, 67108864);
  }
};
gc = function(a) {
  if (a.tag === 13) {
    var b = Hg(), c = Ig(a);
    Jg(a, c, b);
    ok(a, c);
  }
};
hc = function(a, b) {
  return b();
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      ab(a, c);
      b = c.name;
      if (c.type === "radio" && b != null) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e)
              throw Error(y(90));
            Wa(d);
            ab(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, b != null && fb(a, !!c.multiple, b, false);
  }
};
Gb = Wj;
Hb = function(a, b, c, d, e) {
  var f = X;
  X |= 4;
  try {
    return gg(98, a.bind(null, b, c, d, e));
  } finally {
    X = f, X === 0 && (wj(), ig());
  }
};
Ib = function() {
  (X & 49) === 0 && (Vj(), Oj());
};
Jb = function(a, b) {
  var c = X;
  X |= 2;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
};
function uk(a, b) {
  var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!rk(b))
    throw Error(y(200));
  return kk(a, b, null, c);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = cc(a);
  return a === null ? null : a.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a) {
  if (a == null)
    return null;
  if (a.nodeType === 1)
    return a;
  var b = a._reactInternals;
  if (b === void 0) {
    if (typeof a.render === "function")
      throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }
  a = cc(b);
  a = a === null ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a, b) {
  var c = X;
  if ((c & 48) !== 0)
    return a(b);
  X |= 1;
  try {
    if (a)
      return gg(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, true, c);
};
reactDom_production_min.render = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!rk(a))
    throw Error(y(40));
  return a._reactRootContainer ? (Xj(function() {
    tk(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a, b) {
  return uk(a, b, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!rk(c))
    throw Error(y(200));
  if (a == null || a._reactInternals === void 0)
    throw Error(y(38));
  return tk(a, b, c, false, d);
};
reactDom_production_min.version = "17.0.2";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var ReactDOM = reactDom.exports;
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var r, B = r || (r = {});
B.Pop = "POP";
B.Push = "PUSH";
B.Replace = "REPLACE";
var C = function(b) {
  return b;
};
function E(b) {
  b.preventDefault();
  b.returnValue = "";
}
function F() {
  var b = [];
  return { get length() {
    return b.length;
  }, push: function(h) {
    b.push(h);
    return function() {
      b = b.filter(function(e) {
        return e !== h;
      });
    };
  }, call: function(h) {
    b.forEach(function(e) {
      return e && e(h);
    });
  } };
}
function H() {
  return Math.random().toString(36).substr(2, 8);
}
function I(b) {
  var h = b.pathname;
  h = h === void 0 ? "/" : h;
  var e = b.search;
  e = e === void 0 ? "" : e;
  b = b.hash;
  b = b === void 0 ? "" : b;
  e && e !== "?" && (h += e.charAt(0) === "?" ? e : "?" + e);
  b && b !== "#" && (h += b.charAt(0) === "#" ? b : "#" + b);
  return h;
}
function J(b) {
  var h = {};
  if (b) {
    var e = b.indexOf("#");
    0 <= e && (h.hash = b.substr(e), b = b.substr(0, e));
    e = b.indexOf("?");
    0 <= e && (h.search = b.substr(e), b = b.substr(0, e));
    b && (h.pathname = b);
  }
  return h;
}
function createHashHistory(b) {
  function h() {
    var a = J(m2.location.hash.substr(1)), f = a.pathname, l2 = a.search;
    a = a.hash;
    var k = u2.state || {};
    return [k.idx, C({ pathname: f === void 0 ? "/" : f, search: l2 === void 0 ? "" : l2, hash: a === void 0 ? "" : a, state: k.usr || null, key: k.key || "default" })];
  }
  function e() {
    if (t2)
      c.call(t2), t2 = null;
    else {
      var a = r.Pop, f = h(), l2 = f[0];
      f = f[1];
      if (c.length)
        if (l2 != null) {
          var k = q2 - l2;
          k && (t2 = { action: a, location: f, retry: function() {
            p2(-1 * k);
          } }, p2(k));
        } else
          ;
      else
        A2(a);
    }
  }
  function x2(a) {
    var f = document.querySelector("base"), l2 = "";
    f && f.getAttribute("href") && (f = m2.location.href, l2 = f.indexOf("#"), l2 = l2 === -1 ? f : f.slice(0, l2));
    return l2 + "#" + (typeof a === "string" ? a : I(a));
  }
  function z2(a, f) {
    f === void 0 && (f = null);
    return C(_extends$1({ pathname: d.pathname, hash: "", search: "" }, typeof a === "string" ? J(a) : a, { state: f, key: H() }));
  }
  function A2(a) {
    v2 = a;
    a = h();
    q2 = a[0];
    d = a[1];
    g.call({ action: v2, location: d });
  }
  function y2(a, f) {
    function l2() {
      y2(a, f);
    }
    var k = r.Push, n2 = z2(a, f);
    if (!c.length || (c.call({ action: k, location: n2, retry: l2 }), false)) {
      var G2 = [{ usr: n2.state, key: n2.key, idx: q2 + 1 }, x2(n2)];
      n2 = G2[0];
      G2 = G2[1];
      try {
        u2.pushState(n2, "", G2);
      } catch (K2) {
        m2.location.assign(G2);
      }
      A2(k);
    }
  }
  function w(a, f) {
    function l2() {
      w(a, f);
    }
    var k = r.Replace, n2 = z2(a, f);
    c.length && (c.call({ action: k, location: n2, retry: l2 }), 1) || (n2 = [{ usr: n2.state, key: n2.key, idx: q2 }, x2(n2)], u2.replaceState(n2[0], "", n2[1]), A2(k));
  }
  function p2(a) {
    u2.go(a);
  }
  b === void 0 && (b = {});
  b = b.window;
  var m2 = b === void 0 ? document.defaultView : b, u2 = m2.history, t2 = null;
  m2.addEventListener("popstate", e);
  m2.addEventListener("hashchange", function() {
    var a = h()[1];
    I(a) !== I(d) && e();
  });
  var v2 = r.Pop;
  b = h();
  var q2 = b[0], d = b[1], g = F(), c = F();
  q2 == null && (q2 = 0, u2.replaceState(_extends$1({}, u2.state, { idx: q2 }), ""));
  return {
    get action() {
      return v2;
    },
    get location() {
      return d;
    },
    createHref: x2,
    push: y2,
    replace: w,
    go: p2,
    back: function() {
      p2(-1);
    },
    forward: function() {
      p2(1);
    },
    listen: function(a) {
      return g.push(a);
    },
    block: function(a) {
      var f = c.push(a);
      c.length === 1 && m2.addEventListener("beforeunload", E);
      return function() {
        f();
        c.length || m2.removeEventListener("beforeunload", E);
      };
    }
  };
}
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
const NavigationContext = /* @__PURE__ */ react.exports.createContext(null);
const LocationContext = /* @__PURE__ */ react.exports.createContext(null);
const RouteContext = /* @__PURE__ */ react.exports.createContext({
  outlet: null,
  matches: []
});
function Navigate(_ref2) {
  let {
    to: to2,
    replace,
    state
  } = _ref2;
  !useInRouterContext() ? invariant(false) : void 0;
  let navigate = useNavigate();
  react.exports.useEffect(() => {
    navigate(to2, {
      replace,
      state
    });
  });
  return null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(false);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = r.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = react.exports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = J(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location2 = react.exports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  if (location2 == null) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ react.exports.createElement(LocationContext.Provider, {
    children,
    value: {
      location: location2,
      navigationType
    }
  }));
}
function Routes(_ref4) {
  let {
    children,
    location: location2
  } = _ref4;
  return useRoutes(createRoutesFromChildren(children), location2);
}
function useHref(to2) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to2);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to2);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return react.exports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return react.exports.useContext(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.exports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to2 === "number") {
      navigator2.go(to2);
      return;
    }
    let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /* @__PURE__ */ react.exports.createContext(null);
function useOutlet(context) {
  let outlet = react.exports.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ react.exports.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useParams() {
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to2) {
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return react.exports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname), [to2, routePathnamesJson, locationPathname]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    matches: parentMatches
  } = react.exports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? J(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function createRoutesFromChildren(children) {
  let routes = [];
  react.exports.Children.forEach(children, (element) => {
    if (!/* @__PURE__ */ react.exports.isValidElement(element)) {
      return;
    }
    if (element.type === react.exports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    let route2 = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };
    if (element.props.children) {
      route2.children = createRoutesFromChildren(element.props.children);
    }
    routes.push(route2);
  });
  return routes;
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location2 = typeof locationArg === "string" ? J(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route2, index) => {
    let meta = {
      relativePath: route2.path || "",
      caseSensitive: route2.caseSensitive === true,
      childrenIndex: index,
      route: route2
    };
    if (meta.relativePath.startsWith("/")) {
      !meta.relativePath.startsWith(parentPath) ? invariant(false) : void 0;
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route2.children && route2.children.length > 0) {
      !(route2.index !== true) ? invariant(false) : void 0;
      flattenRoutes(route2.children, branches, routesMeta, path);
    }
    if (route2.path == null && !route2.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route2.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n2, i) => n2 === b[i]);
  return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route2 = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route: route2
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index) => {
    return /* @__PURE__ */ react.exports.createElement(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : /* @__PURE__ */ react.exports.createElement(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "");
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value2, paramName) {
  try {
    return decodeURIComponent(value2);
  } catch (error) {
    return value2;
  }
}
function resolvePath(to2, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to2 === "string" ? J(to2) : to2;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to2 = typeof toArg === "string" ? J(toArg) : toArg;
  let toPathname = toArg === "" || to2.pathname === "" ? "/" : to2.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to2.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to2, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to2) {
  return to2 === "" || to2.pathname === "" ? "/" : typeof to2 === "string" ? J(to2).pathname : to2.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$2(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
const _excluded$1 = ["onClick", "reloadDocument", "replace", "state", "target", "to"], _excluded2$1 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function HashRouter(_ref2) {
  let {
    basename,
    children,
    window: window2
  } = _ref2;
  let historyRef = react.exports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2
    });
  }
  let history = historyRef.current;
  let [state, setState] = react.exports.useState({
    action: history.action,
    location: history.location
  });
  react.exports.useLayoutEffect(() => history.listen(setState), [history]);
  return /* @__PURE__ */ react.exports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
const Link = /* @__PURE__ */ react.exports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to: to2
  } = _ref4, rest = _objectWithoutPropertiesLoose$2(_ref4, _excluded$1);
  let href = useHref(to2);
  let internalOnClick = useLinkClickHandler(to2, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("a", _extends({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
const NavLink = /* @__PURE__ */ react.exports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to: to2,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose$2(_ref5, _excluded2$1);
  let location2 = useLocation();
  let path = useResolvedPath(to2);
  let locationPathname = location2.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ react.exports.createElement(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to: to2
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
function useLinkClickHandler(to2, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to2);
  return react.exports.useCallback((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || I(location2) === I(path);
      navigate(to2, {
        replace,
        state
      });
    }
  }, [location2, navigate, path, replaceProp, state, target, to2]);
}
var jsxDevRuntime = { exports: {} };
var reactJsxDevRuntime_production_min = {};
/** @license React v17.0.2
 * react-jsx-dev-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
reactJsxDevRuntime_production_min.Fragment = 60107;
if (typeof Symbol === "function" && Symbol.for) {
  var a = Symbol.for;
  reactJsxDevRuntime_production_min.Fragment = a("react.fragment");
}
reactJsxDevRuntime_production_min.jsxDEV = void 0;
{
  jsxDevRuntime.exports = reactJsxDevRuntime_production_min;
}
/*!
 * Chart.js v3.7.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
const requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce$3(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function noop$2() {
}
const uid = function() {
  let id2 = 0;
  return function() {
    return id2++;
  };
}();
function isNullOrUndef(value2) {
  return value2 === null || typeof value2 === "undefined";
}
function isArray$2(value2) {
  if (Array.isArray && Array.isArray(value2)) {
    return true;
  }
  const type = Object.prototype.toString.call(value2);
  if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject$5(value2) {
  return value2 !== null && Object.prototype.toString.call(value2) === "[object Object]";
}
const isNumberFinite = (value2) => (typeof value2 === "number" || value2 instanceof Number) && isFinite(+value2);
function finiteOrDefault(value2, defaultValue) {
  return isNumberFinite(value2) ? value2 : defaultValue;
}
function valueOrDefault(value2, defaultValue) {
  return typeof value2 === "undefined" ? defaultValue : value2;
}
const toPercentage = (value2, dimension) => typeof value2 === "string" && value2.endsWith("%") ? parseFloat(value2) / 100 : value2 / dimension;
const toDimension = (value2, dimension) => typeof value2 === "string" && value2.endsWith("%") ? parseFloat(value2) / 100 * dimension : +value2;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys2;
  if (isArray$2(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject$5(loopable)) {
    keys2 = Object.keys(loopable);
    len = keys2.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys2[i]], keys2[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1$1(source2) {
  if (isArray$2(source2)) {
    return source2.map(clone$1$1);
  }
  if (isObject$5(source2)) {
    const target = Object.create(null);
    const keys2 = Object.keys(source2);
    const klen = keys2.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys2[k]] = clone$1$1(source2[keys2[k]]);
    }
    return target;
  }
  return source2;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source2, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source2[key];
  if (isObject$5(tval) && isObject$5(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1$1(sval);
  }
}
function merge(target, source2, options) {
  const sources = isArray$2(source2) ? source2 : [source2];
  const ilen = sources.length;
  if (!isObject$5(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source2 = sources[i];
    if (!isObject$5(source2)) {
      continue;
    }
    const keys2 = Object.keys(source2);
    for (let k = 0, klen = keys2.length; k < klen; ++k) {
      merger(keys2[k], target, source2, options);
    }
  }
  return target;
}
function mergeIf(target, source2) {
  return merge(target, source2, { merger: _mergerIf });
}
function _mergerIf(key, target, source2) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source2[key];
  if (isObject$5(tval) && isObject$5(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1$1(sval);
  }
}
const emptyString = "";
const dot = ".";
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.substr(pos, idx - pos)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value2) => typeof value2 !== "undefined";
const isFunction$3 = (value2) => typeof value2 === "function";
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign$1 = Math.sign;
function niceNum(range2) {
  const roundedRange = Math.round(range2);
  range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
  const niceRange = Math.pow(10, Math.floor(log10(range2)));
  const fraction = range2 / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value2) {
  const result = [];
  const sqrt = Math.sqrt(value2);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value2 % i === 0) {
      result.push(i);
      result.push(value2 / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber$1(n2) {
  return !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostEquals(x2, y2, epsilon) {
  return Math.abs(x2 - y2) < epsilon;
}
function almostWhole(x2, epsilon) {
  const rounded = Math.round(x2);
  return rounded - epsilon <= x2 && rounded + epsilon >= x2;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value2;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value2 = array[i][property];
    if (!isNaN(value2)) {
      target.min = Math.min(target.min, value2);
      target.max = Math.max(target.max, value2);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x2) {
  if (!isNumberFinite(x2)) {
    return;
  }
  let e = 1;
  let p2 = 0;
  while (Math.round(x2 * e) / e !== x2) {
    e *= 10;
    p2++;
  }
  return p2;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value2, min2, max2) {
  return Math.max(min2, Math.min(max2, value2));
}
function _int16Range(value2) {
  return _limitValue(value2, -32768, 32767);
}
function _isBetween(value2, start, end, epsilon = 1e-6) {
  return value2 >= Math.min(start, end) - epsilon && value2 <= Math.max(start, end) + epsilon;
}
const atEdge = (t2) => t2 === 0 || t2 === 1;
const elasticIn = (t2, s, p2) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * TAU / p2));
const elasticOut = (t2, s, p2) => Math.pow(2, -10 * t2) * Math.sin((t2 - s) * TAU / p2) + 1;
const effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s = 0.1125;
    const p2 = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s, p2) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s, p2);
  },
  easeInBack(t2) {
    const s = 1.70158;
    return t2 * t2 * ((s + 1) * t2 - s);
  },
  easeOutBack(t2) {
    const s = 1.70158;
    return (t2 -= 1) * t2 * ((s + 1) * t2 + s) + 1;
  },
  easeInOutBack(t2) {
    let s = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m2 = 7.5625;
    const d = 2.75;
    if (t2 < 1 / d) {
      return m2 * t2 * t2;
    }
    if (t2 < 2 / d) {
      return m2 * (t2 -= 1.5 / d) * t2 + 0.75;
    }
    if (t2 < 2.5 / d) {
      return m2 * (t2 -= 2.25 / d) * t2 + 0.9375;
    }
    return m2 * (t2 -= 2.625 / d) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
const hex = "0123456789ABCDEF";
const h1 = (b) => hex[b & 15];
const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
const eq = (b) => (b & 240) >> 4 === (b & 15);
function isShort(v2) {
  return eq(v2.r) && eq(v2.g) && eq(v2.b) && eq(v2.a);
}
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
function hexString(v2) {
  var f = isShort(v2) ? h1 : h2;
  return v2 ? "#" + f(v2.r) + f(v2.g) + f(v2.b) + (v2.a < 255 ? f(v2.a) : "") : v2;
}
function round$1(v2) {
  return v2 + 0.5 | 0;
}
const lim = (v2, l2, h) => Math.max(Math.min(v2, h), l2);
function p2b(v2) {
  return lim(round$1(v2 * 2.55), 0, 255);
}
function n2b(v2) {
  return lim(round$1(v2 * 255), 0, 255);
}
function b2n(v2) {
  return lim(round$1(v2 / 2.55) / 100, 0, 1);
}
function n2p(v2) {
  return lim(round$1(v2 * 100), 0, 100);
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m2 = RGB_RE.exec(str);
  let a = 255;
  let r2, g, b;
  if (!m2) {
    return;
  }
  if (m2[7] !== r2) {
    const v2 = +m2[7];
    a = 255 & (m2[8] ? p2b(v2) : v2 * 255);
  }
  r2 = +m2[1];
  g = +m2[3];
  b = +m2[5];
  r2 = 255 & (m2[2] ? p2b(r2) : r2);
  g = 255 & (m2[4] ? p2b(g) : g);
  b = 255 & (m2[6] ? p2b(b) : b);
  return {
    r: r2,
    g,
    b,
    a
  };
}
function rgbString(v2) {
  return v2 && (v2.a < 255 ? `rgba(${v2.r}, ${v2.g}, ${v2.b}, ${b2n(v2.a)})` : `rgb(${v2.r}, ${v2.g}, ${v2.b})`);
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l2) {
  const a = s * Math.min(l2, 1 - l2);
  const f = (n2, k = (n2 + h / 30) % 12) => l2 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v2) {
  const f = (n2, k = (n2 + h / 60) % 6) => v2 - v2 * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function rgb2hsl(v2) {
  const range2 = 255;
  const r2 = v2.r / range2;
  const g = v2.g / range2;
  const b = v2.b / range2;
  const max2 = Math.max(r2, g, b);
  const min2 = Math.min(r2, g, b);
  const l2 = (max2 + min2) / 2;
  let h, s, d;
  if (max2 !== min2) {
    d = max2 - min2;
    s = l2 > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    h = max2 === r2 ? (g - b) / d + (g < b ? 6 : 0) : max2 === g ? (b - r2) / d + 2 : (r2 - g) / d + 4;
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l2];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l2) {
  return calln(hsl2rgbn, h, s, l2);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v2) {
  return calln(hsv2rgbn, h, s, v2);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m2 = HUE_RE.exec(str);
  let a = 255;
  let v2;
  if (!m2) {
    return;
  }
  if (m2[5] !== v2) {
    a = m2[6] ? p2b(+m2[5]) : n2b(+m2[5]);
  }
  const h = hue(+m2[2]);
  const p1 = +m2[3] / 100;
  const p2 = +m2[4] / 100;
  if (m2[1] === "hwb") {
    v2 = hwb2rgb(h, p1, p2);
  } else if (m2[1] === "hsv") {
    v2 = hsv2rgb(h, p1, p2);
  } else {
    v2 = hsl2rgb(h, p1, p2);
  }
  return {
    r: v2[0],
    g: v2[1],
    b: v2[2],
    a
  };
}
function rotate(v2, deg) {
  var h = rgb2hsl(v2);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v2.r = h[0];
  v2.g = h[1];
  v2.b = h[2];
}
function hslString(v2) {
  if (!v2) {
    return;
  }
  const a = rgb2hsl(v2);
  const h = a[0];
  const s = n2p(a[1]);
  const l2 = n2p(a[2]);
  return v2.a < 255 ? `hsla(${h}, ${s}%, ${l2}%, ${b2n(v2.a)})` : `hsl(${h}, ${s}%, ${l2}%)`;
}
const map$1$1 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
const names = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys2 = Object.keys(names);
  const tkeys = Object.keys(map$1$1);
  let i, j, k, ok2, nk2;
  for (i = 0; i < keys2.length; i++) {
    ok2 = nk2 = keys2[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk2 = nk2.replace(k, map$1$1[k]);
    }
    k = parseInt(names[ok2], 16);
    unpacked[nk2] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
let names$1;
function nameParse(str) {
  if (!names$1) {
    names$1 = unpack();
    names$1.transparent = [0, 0, 0, 0];
  }
  const a = names$1[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
function modHSL(v2, i, ratio) {
  if (v2) {
    let tmp = rgb2hsl(v2);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v2.r = tmp[0];
    v2.g = tmp[1];
    v2.b = tmp[2];
  }
}
function clone$2(v2, proto2) {
  return v2 ? Object.assign(proto2 || {}, v2) : v2;
}
function fromObject(input) {
  var v2 = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v2 = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v2.a = n2b(input[3]);
      }
    }
  } else {
    v2 = clone$2(input, { r: 0, g: 0, b: 0, a: 1 });
    v2.a = n2b(v2.a);
  }
  return v2;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v2;
    if (type === "object") {
      v2 = fromObject(input);
    } else if (type === "string") {
      v2 = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v2;
    this._valid = !!v2;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v2 = clone$2(this._rgb);
    if (v2) {
      v2.a = b2n(v2.a);
    }
    return v2;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : this._rgb;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : this._rgb;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : this._rgb;
  }
  mix(color2, weight) {
    const me2 = this;
    if (color2) {
      const c1 = me2.rgb;
      const c2 = color2.rgb;
      let w2;
      const p2 = weight === w2 ? 0.5 : weight;
      const w = 2 * p2 - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p2 * c1.a + (1 - p2) * c2.a;
      me2.rgb = c1;
    }
    return me2;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round$1(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v2 = this._rgb;
    v2.r = 255 - v2.r;
    v2.g = 255 - v2.g;
    v2.b = 255 - v2.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}
function index_esm(input) {
  return new Color(input);
}
const isPatternOrGradient = (value2) => value2 instanceof CanvasGradient || value2 instanceof CanvasPattern;
function color(value2) {
  return isPatternOrGradient(value2) ? value2 : index_esm(value2);
}
function getHoverColor(value2) {
  return isPatternOrGradient(value2) ? value2 : index_esm(value2).saturate(0.5).darken(0.1).hexString();
}
const overrides = Object.create(null);
const descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys2 = key.split(".");
  for (let i = 0, n2 = keys2.length; i < n2; ++i) {
    const k = keys2[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set$2(root2, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root2, scope), values);
  }
  return merge(getScope$1(root2, ""), scope);
}
class Defaults {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values) {
    return set$2(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set$2(descriptors, scope, values);
  }
  override(scope, values) {
    return set$2(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject$5(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value2) {
          this[privateName] = value2;
        }
      }
    });
  }
}
var defaults$5 = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc2, longest, string2) {
  let textWidth = data[string2];
  if (!textWidth) {
    textWidth = data[string2] = ctx.measureText(string2).width;
    gc2.push(string2);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc2 = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc2 = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray$2(thing) !== true) {
      longest = _measureText(ctx, data, gc2, longest, thing);
    } else if (isArray$2(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray$2(nestedThing)) {
          longest = _measureText(ctx, data, gc2, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc2.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc2[i]];
    }
    gc2.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x2, y2) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x2, y2);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      ctx.arc(x2, y2, radius, 0, TAU);
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x2 - xOffset, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x2 + yOffset, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x2 + xOffset, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x2 - yOffset, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        ctx.rect(x2 - size, y2 - size, 2 * size, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + yOffset, y2 - xOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      ctx.lineTo(x2 - yOffset, y2 + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      ctx.moveTo(x2 + yOffset, y2 - xOffset);
      ctx.lineTo(x2 - yOffset, y2 + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      ctx.moveTo(x2 + yOffset, y2 - xOffset);
      ctx.lineTo(x2 - yOffset, y2 + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      ctx.moveTo(x2 + yOffset, y2 - xOffset);
      ctx.lineTo(x2 - yOffset, y2 + xOffset);
      break;
    case "line":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      break;
    case "dash":
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 + Math.cos(rad) * radius, y2 + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text, x2, y2, font, opts = {}) {
  const lines = isArray$2(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x2, y2, opts.maxWidth);
    }
    ctx.fillText(line, x2, y2, opts.maxWidth);
    decorateText(ctx, x2, y2, line, opts);
    y2 += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x2, y2, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x2 - metrics.actualBoundingBoxLeft;
    const right = x2 + metrics.actualBoundingBoxRight;
    const top = y2 - metrics.actualBoundingBoxAscent;
    const bottom = y2 + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x: x2, y: y2, w, h, radius } = rect;
  ctx.arc(x2 + radius.topLeft, y2 + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x2, y2 + h - radius.bottomLeft);
  ctx.arc(x2 + radius.bottomLeft, y2 + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x2 + w - radius.bottomRight, y2 + h);
  ctx.arc(x2 + w - radius.bottomRight, y2 + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x2 + w, y2 + radius.topRight);
  ctx.arc(x2 + w - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x2 + radius.topLeft, y2);
}
const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value2, size) {
  const matches = ("" + value2).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value2 = +matches[2];
  switch (matches[3]) {
    case "px":
      return value2;
    case "%":
      value2 /= 100;
      break;
  }
  return size * value2;
}
const numberOrZero = (v2) => +v2 || 0;
function _readValueToProps(value2, props) {
  const ret = {};
  const objProps = isObject$5(props);
  const keys2 = objProps ? Object.keys(props) : props;
  const read = isObject$5(value2) ? objProps ? (prop) => valueOrDefault(value2[prop], value2[props[prop]]) : (prop) => value2[prop] : () => value2;
  for (const prop of keys2) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value2) {
  return _readValueToProps(value2, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value2) {
  return _readValueToProps(value2, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value2) {
  const obj = toTRBL(value2);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults$5.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value2;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value2 = inputs[i];
    if (value2 === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value2 === "function") {
      value2 = value2(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray$2(value2)) {
      value2 = value2[index % value2.length];
      cacheable = false;
    }
    if (value2 !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value2;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min: min2, max: max2 } = minmax;
  const change = toDimension(grace, (max2 - min2) / 2);
  const keepZero = (value2, add2) => beginAtZero && value2 === 0 ? 0 : value2 + add2;
  return {
    min: keepZero(min2, -Math.abs(change)),
    max: keepZero(max2, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _lookup(table, value2, cmp) {
  cmp = cmp || ((index) => table[index] < value2);
  let hi2 = table.length - 1;
  let lo = 0;
  let mid;
  while (hi2 - lo > 1) {
    mid = lo + hi2 >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi2 = mid;
    }
  }
  return { lo, hi: hi2 };
}
const _lookupByKey = (table, key, value2) => _lookup(table, value2, (index) => table[index][key] < value2);
const _rlookupByKey = (table, key, value2) => _lookup(table, value2, (index) => table[index][key] >= value2);
function _filterBetween(values, min2, max2) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min2) {
    start++;
  }
  while (end > start && values[end - 1] > max2) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners2 = stub.listeners;
  const index = listeners2.indexOf(listener);
  if (index !== -1) {
    listeners2.splice(index, 1);
  }
  if (listeners2.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget2 = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget2,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value2) {
      const storage = target._storage || (target._storage = getTarget2());
      target[prop] = storage[prop] = value2;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value2) {
      proxy[prop] = value2;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction$3(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction$3(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value2) => isObject$5(value2) && prop !== "adapters" && (Object.getPrototypeOf(value2) === null || value2.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value2 = resolve2();
  target[prop] = value2;
  return value2;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value2 = _proxy[prop];
  if (isFunction$3(value2) && descriptors2.isScriptable(prop)) {
    value2 = _resolveScriptable(prop, value2, target, receiver);
  }
  if (isArray$2(value2) && value2.length) {
    value2 = _resolveArray(prop, value2, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value2)) {
    value2 = _attachContext(value2, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value2;
}
function _resolveScriptable(prop, value2, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value2 = value2(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value2)) {
    value2 = createSubResolver(_proxy._scopes, _proxy, prop, value2);
  }
  return value2;
}
function _resolveArray(prop, value2, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value2 = value2[_context.index % value2.length];
  } else if (isObject$5(value2[0])) {
    const arr = value2;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value2 = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value2.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value2;
}
function resolveFallback(fallback, prop, value2) {
  return isFunction$3(fallback) ? fallback(prop, value2) : fallback;
}
const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value2) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value2);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value2) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value2);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = new Set();
  set2.add(value2);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value2);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value2);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value2));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value2) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray$2(target) && isObject$5(value2)) {
    return value2;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value2;
  for (const prefix of prefixes) {
    value2 = _resolve(readKey(prefix, prop), scopes);
    if (defined(value2)) {
      return needsSubResolver(prop, value2) ? createSubResolver(scopes, proxy, prop, value2) : value2;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value2 = scope[key];
    if (defined(value2)) {
      return value2;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys2 = target._keys;
  if (!keys2) {
    keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys2;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa2 = t2 * s01;
  const fb2 = t2 * s12;
  return {
    previous: {
      x: current.x - fa2 * (next.x - previous.x),
      y: current.y - fa2 * (next.y - previous.y)
    },
    next: {
      x: current.x + fb2 * (next.x - previous.x),
      y: current.y + fb2 * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign$1(deltaK[i - 1]) !== sign$1(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min2, max2) {
  return Math.max(Math.min(pt, max2), min2);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
const positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles2, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles2[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x2, y2, target) => (x2 > 0 || y2 > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(evt, canvas) {
  const e = evt.native || evt;
  const touches = e.touches;
  const source2 = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source2;
  let box = false;
  let x2, y2;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x2 = offsetX;
    y2 = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x2 = source2.clientX - rect.left;
    y2 = source2.clientY - rect.top;
    box = true;
  }
  return { x: x2, y: y2, box };
}
function getRelativePosition$1(evt, chart) {
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x: x2, y: y2, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x2 - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y2 - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = (v2) => Math.round(v2 * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value2 = getStyle(element, property);
  const matches = value2 && value2.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: p1.y + t2 * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t2, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t2);
  const b = _pointInLine(cp1, cp2, t2);
  const c = _pointInLine(cp2, p2, t2);
  const d = _pointInLine(a, b, t2);
  const e = _pointInLine(b, c, t2);
  return _pointInLine(d, e, t2);
}
const intlCache = new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
const getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x2) {
      return rectX + rectX + width - x2;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x2, value2) {
      return x2 - value2;
    },
    leftForLtr(x2, itemWidth) {
      return x2 - itemWidth;
    }
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x2) {
      return x2;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x2, value2) {
      return x2 + value2;
    },
    leftForLtr(x2, _itemWidth) {
      return x2;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x2) => x2
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value2, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value2) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value2) === 0 || between(endBound, prevValue, value2);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value2 = normalize(point[property]);
    if (value2 === prevValue) {
      continue;
    }
    inside = between(value2, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value2, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
      subStart = null;
    }
    prev = i;
    prevValue = value2;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max2, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max2; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max2 = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max2, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l2, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({ start: s % count, end: e % count, loop: l2, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}
/*!
 * Chart.js v3.7.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
class Animator {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date2, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date2 - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date2 = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date2);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date2, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date2, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date2;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb2) {
    this._getAnims(chart).listeners[event].push(cb2);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = new Animator();
const transparent = "transparent";
const interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
    const from2 = resolve([cfg.from, currentValue, to2]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date2) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date2 - this._start;
      const remain = this._duration - elapsed;
      this._start = date2;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to2]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date2) {
    const elapsed = date2 - this._start;
    const duration2 = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration2);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration2 % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}
const numbers = ["x", "y", "borderWidth", "radius", "tension"];
const colors$1 = ["color", "borderColor", "backgroundColor"];
defaults$5.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
const animationOptions = Object.keys(defaults$5.animation);
defaults$5.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults$5.set("animations", {
  colors: {
    type: "color",
    properties: colors$1
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults$5.describe("animations", {
  _fallback: "animation"
});
defaults$5.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v2) => v2 | 0
      }
    }
  }
});
class Animations {
  constructor(chart, config2) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config2);
  }
  configure(config2) {
    if (!isObject$5(config2)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config2).forEach((key) => {
      const cfg = config2[key];
      if (!isObject$5(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray$2(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date2 = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value2 = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value2, date2);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value2;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value2);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys2 = Object.keys(properties);
  for (let i = 0; i < keys2.length; i++) {
    const anim = animations[keys2[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min2 = opts.min === void 0 ? allowedOverflow : 0;
  const max2 = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max2 : min2,
    end: reverse ? min2 : max2
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x2 = scaleClip(xScale, allowedOverflow);
  const y2 = scaleClip(yScale, allowedOverflow);
  return {
    top: y2.end,
    right: x2.end,
    bottom: y2.start,
    left: x2.start
  };
}
function toClip(value2) {
  let t2, r2, b, l2;
  if (isObject$5(value2)) {
    t2 = value2.top;
    r2 = value2.right;
    b = value2.bottom;
    l2 = value2.left;
  } else {
    t2 = r2 = b = l2 = value2;
  }
  return {
    top: t2,
    right: r2,
    bottom: b,
    left: l2,
    disabled: value2 === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys2 = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys2.push(metasets[i].index);
  }
  return keys2;
}
function applyStack(stack, value2, dsIndex, options = {}) {
  const keys2 = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value2 === null) {
    return;
  }
  for (i = 0, ilen = keys2.length; i < ilen; ++i) {
    datasetIndex = +keys2[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value2 === 0 || sign$1(value2) === sign$1(otherValue)))) {
      value2 += otherValue;
    }
  }
  return value2;
}
function convertObjectDataToArray(data) {
  const keys2 = Object.keys(data);
  const adata = new Array(keys2.length);
  let i, ilen, key;
  for (i = 0, ilen = keys2.length; i < ilen; ++i) {
    key = keys2[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min: min2, max: max2, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max2 : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value2 = stack[meta.index];
    if (positive && value2 > 0 || !positive && value2 < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index, [vAxis]: value2 } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value2;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x2, y2, r2) => axis === "x" ? x2 : axis === "r" ? r2 : y2;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject$5(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config2 = this.chart.config;
    const scopeKeys = config2.datasetScopeKeys(this._type);
    const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config2.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray$2(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject$5(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value2 = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value2, meta.index, { mode });
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value2 = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value2 = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range2.min = Math.min(range2.min, value2);
    range2.max = Math.max(range2.max, value2);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range2, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        break;
      }
    }
    return range2;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value2;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value2 = parsed[i][scale.axis];
      if (isNumberFinite(value2)) {
        values.push(value2);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config2 = this.chart.config;
    const scopeKeys = config2.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults$5.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config2.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config2 = this.chart.config;
      const scopeKeys = config2.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys);
      options = config2.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
}
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min2 = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min2 = Math.min(min2, Math.abs(curr - prev) || min2);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min2;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min2 = Math.min(startValue, endValue);
  const max2 = Math.max(startValue, endValue);
  let barStart = min2;
  let barEnd = max2;
  if (Math.abs(min2) > Math.abs(max2)) {
    barStart = max2;
    barEnd = min2;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min: min2,
    max: max2
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray$2(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign$1(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v2, start, end) {
  return v2 === "start" ? start : v2 === "end" ? end : v2;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    super.updateRangeFromParsed(range2, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range2.min = Math.min(range2.min, custom.min);
      range2.max = Math.max(range2.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value2 = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value: value2
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const metasets = iScale.getMatchingVisibleMetas(this._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== "undefined") {
        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(void 0, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name !== void 0 ? stacks.indexOf(name) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min2 = barThickness || computeMinSampleSize(meta);
    return {
      min: min2,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value2 = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value2;
    let head, size;
    if (length !== value2) {
      start = length - value2;
      length = value2;
    }
    if (floating) {
      value2 = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value2 !== 0 && sign$1(value2) !== sign$1(custom.barEnd)) {
        start = 0;
      }
      start += value2;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value2 === actualBase) {
        base -= size / 2;
      }
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign$1(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
      center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
      size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max2 = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max2 = Math.max(max2, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max2 > 0 && max2;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index);
    const x2 = xScale.getLabelForValue(parsed.x);
    const y2 = yScale.getLabelForValue(parsed.y);
    const r2 = parsed._custom;
    return {
      label: meta.label,
      value: "(" + x2 + ", " + y2 + (r2 ? ", " + r2 : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, { $shared: false });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject$5(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min2 = TAU;
    let max2 = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min2 = Math.min(min2, rotation);
        max2 = Math.max(max2, rotation + circumference);
      }
    }
    return {
      rotation: min2,
      circumference: max2 - min2
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value2 = meta._parsed[i];
      if (value2 !== null && !isNaN(value2) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value2);
      }
    }
    return total;
  }
  calculateCircumference(value2) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value2)) {
      return TAU * (Math.abs(value2) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value2 = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value: value2
    };
  }
  getMaxBorderWidth(arcs) {
    let max2 = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max2;
  }
  getMaxOffset(arcs) {
    let max2 = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
    }
    return max2;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value2 = ": " + tooltipItem.formattedValue;
          if (isArray$2(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value2;
          } else {
            dataLabel += value2;
          }
          return dataLabel;
        }
      }
    }
  }
};
class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber$1(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min2).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max2).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2)).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value2 = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || "",
      value: value2
    };
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const dataset = this.getDataset();
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const dataset = this.getDataset();
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
  }
}
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
class PieController extends DoughnutController {
}
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
class RadarController extends DatasetController {
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const dataset = this.getDataset();
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
      const x2 = reset ? scale.xCenter : pointPosition.x;
      const y2 = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x: x2,
        y: y2,
        angle: pointPosition.angle,
        skip: isNaN(x2) || isNaN(y2),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
class ScatterController extends LineController {
}
ScatterController.id = "scatter";
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class DateAdapter {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value2, format2) {
    return abstract();
  }
  format(timestamp, format2) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
}
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function getRelativePosition(e, chart) {
  if ("native" in e) {
    return {
      x: e.x,
      y: e.y
    };
  }
  return getRelativePosition$1(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  let index, data, element;
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    ({ index, data } = metasets[i]);
    for (let j = 0, jlen = data.length; j < jlen; ++j) {
      element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function binarySearch(metaset, axis, value2, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value2);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range2 = typeof el.getRange === "function" && el.getRange(axis);
      if (range2) {
        const start = lookupMethod(data, axis, value2 - range2);
        const end = lookupMethod(data, axis, value2 + range2);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value2 = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index, data } = metasets[i];
    const { lo, hi: hi2 } = binarySearch(metasets[i], axis, value2, intersect);
    for (let j = lo; j <= hi2; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
  const items = [];
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element, datasetIndex, index });
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element, datasetIndex, index }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
}
function getAxisItems(chart, e, options, useFinalPosition) {
  const position = getRelativePosition(e, chart);
  const items = [];
  const axis = options.axis;
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element, datasetIndex, index });
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      intersectsItem = true;
    }
  });
  if (options.intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({ element, datasetIndex: meta.index, index });
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({ element: data[i], datasetIndex, index: i });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      return getIntersectItems(chart, position, axis, useFinalPosition);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
    },
    x(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "x", intersect: options.intersect }, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "y", intersect: options.intersect }, useFinalPosition);
    }
  }
};
const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
  return array.filter((v2) => v2.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v2) => STATIC_POSITIONS.indexOf(v2.pos) === -1 && v2.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject$5(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x: x2, y: y2 } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y2, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
      }
      stack.start = y2;
      stack.placed += width;
      y2 = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x2, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x2, chartArea.top + stack.placed, width, height);
      }
      stack.start = x2;
      stack.placed += height;
      x2 = box.right;
    }
  }
  chartArea.x = x2;
  chartArea.y = y2;
}
defaults$5.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
class BasePlatform {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config2) {
  }
}
class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config2) {
    config2.options.animation = false;
  }
}
const EXPANDO_KEY = "$chartjs";
const EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
const isNullOrEmpty = (value2) => value2 === null || value2 === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x: x2, y: y2 } = getRelativePosition$1(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x2 !== void 0 ? x2 : null,
    y: y2 !== void 0 ? y2 : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ["height", "width"].forEach((prop) => {
      const value2 = initial[prop];
      if (isNullOrUndef(value2)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value2);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
}
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
class Element {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x: x2, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
    return { x: x2, y: y2 };
  }
  hasValue() {
    return isNumber$1(this.x) && isNumber$1(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
Element.defaults = {};
Element.defaultRoutes = void 0;
const formatters = {
  values(value2) {
    return isArray$2(value2) ? value2 : "" + value2;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults$5.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults$5.route("scale.ticks", "color", "", "color");
defaults$5.route("scale.grid", "color", "", "borderColor");
defaults$5.route("scale.grid", "borderColor", "", "borderColor");
defaults$5.route("scale.title", "color", "", "color");
defaults$5.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults$5.describe("scales", {
  _fallback: "scale"
});
defaults$5.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset2 = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff2;
  if (len < 2) {
    return false;
  }
  for (diff2 = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff2) {
      return false;
    }
  }
  return diff2;
}
const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
const offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset2;
  if (offsetGridLines) {
    if (length === 1) {
      offset2 = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset2 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index ? offset2 : -offset2;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc2 = cache.gc;
    const gcLen = gc2.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc2[i]];
      }
      gc2.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray$2(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset2, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject$5(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value2 = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value2) + height - offset2;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
    } else {
      titleY = offsetFromEdge(scale, position, offset2);
    }
    maxWidth = right - left;
  } else {
    if (isObject$5(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value2 = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value2) - width + offset2;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
    } else {
      titleX = offsetFromEdge(scale, position, offset2);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
    let range2;
    if (minDefined && maxDefined) {
      return { min: min2, max: max2 };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range2 = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min2 = Math.min(min2, range2.min);
      }
      if (!maxDefined) {
        max2 = Math.max(max2, range2.max);
      }
    }
    min2 = maxDefined && min2 > max2 ? max2 : min2;
    max2 = minDefined && min2 > max2 ? min2 : max2;
    return {
      min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
      max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray$2(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray$2(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray$2(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value2) {
    return value2;
  }
  getPixelForValue(value2, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: min2, max: max2 } = this;
    return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset2 = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset2 ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject$5(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value2 = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value2));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject$5(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value2 = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value2));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset2);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x2, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y2 = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y2 = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject$5(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value2 = position[positionAxisID];
        y2 = this.chart.scales[positionAxisID].getPixelForValue(value2) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject$5(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value2 = position[positionAxisID];
        x2 = this.chart.scales[positionAxisID].getPixelForValue(value2);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray$2(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      if (isHorizontal) {
        x2 = pixel;
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y2 = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y2 + textOffset - labelPadding.top;
        let left = x2 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign,
        textBaseline,
        translation: [x2, y2],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x2;
    if (position === "left") {
      if (mirror) {
        x2 = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 += widest;
        }
      } else {
        x2 = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x2 = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 -= widest;
        }
      } else {
        x2 = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x: x2 };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value2) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t2) => t2.value === value2);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
        }
        if (grid.drawTicks) {
          drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y2 = item.textOffset;
      renderText(ctx, label, 0, y2, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset2 = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject$5(position)) {
      offset2 += padding.bottom;
      if (isArray$2(title.text)) {
        offset2 += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset2 += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}
class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto2 = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto2)) {
      parentScope = this.register(proto2);
    }
    const items = this.items;
    const id2 = item.id;
    const scope = this.scope + "." + id2;
    if (!id2) {
      throw new Error("class does not have id: " + item);
    }
    if (id2 in items) {
      return scope;
    }
    items[id2] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults$5.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id2) {
    return this.items[id2];
  }
  unregister(item) {
    const items = this.items;
    const id2 = item.id;
    const scope = this.scope;
    if (id2 in items) {
      delete items[id2];
    }
    if (scope && id2 in defaults$5[scope]) {
      delete defaults$5[scope][id2];
      if (this.override) {
        delete overrides[id2];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults$5.get(parentScope) : {},
    defaults$5.get(scope),
    item.defaults
  ]);
  defaults$5.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults$5.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults$5.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto2) {
  return "id" in proto2 && "defaults" in proto2;
}
class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id2) {
    return this._get(id2, this.controllers, "controller");
  }
  getElement(id2) {
    return this._get(id2, this.elements, "element");
  }
  getPlugin(id2) {
    return this._get(id2, this.plugins, "plugin");
  }
  getScale(id2) {
    return this._get(id2, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id2, typedRegistry, type) {
    const item = typedRegistry.get(id2);
    if (item === void 0) {
      throw new Error('"' + id2 + '" is not a registered ' + type + ".");
    }
    return item;
  }
}
var registry = new Registry();
class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config2 = chart && chart.config;
    const options = valueOrDefault(config2.options && config2.options.plugins, {});
    const plugins = allPlugins(config2);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff2 = (a, b) => a.filter((x2) => !b.some((y2) => x2.plugin.id === y2.plugin.id));
    this._notify(diff2(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff2(descriptors2, previousDescriptors), chart, "start");
  }
}
function allPlugins(config2) {
  const plugins = [];
  const keys2 = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys2.length; i++) {
    plugins.push(registry.getPlugin(keys2[i]));
  }
  const local = config2.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
    }
  }
  return plugins;
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins, options, all) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];
    const id2 = plugin.id;
    const opts = getOpts(options[id2], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config2, plugin, opts, context) {
  const keys2 = config2.pluginScopeKeys(plugin);
  const scopes = config2.getOptionScopes(opts, keys2);
  return config2.createResolver(scopes, context, [""], { scriptable: false, indexable: false, allKeys: true });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults$5.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id2, indexAxis) {
  let axis = id2;
  if (id2 === "_index_") {
    axis = indexAxis;
  } else if (id2 === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id2, scaleOptions) {
  if (id2 === "x" || id2 === "y") {
    return id2;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id2.charAt(0).toLowerCase();
}
function mergeScaleConfig(config2, options) {
  const chartDefaults = overrides[config2.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config2.type, options);
  const firstIDs = Object.create(null);
  const scales = Object.create(null);
  Object.keys(configScales).forEach((id2) => {
    const scaleConf = configScales[id2];
    if (!isObject$5(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id2}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id2}`);
    }
    const axis = determineAxis(id2, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id2;
    scales[id2] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config2.data.datasets.forEach((dataset) => {
    const type = dataset.type || config2.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id2 = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales[id2] = scales[id2] || Object.create(null);
      mergeIf(scales[id2], [{ axis }, configScales[id2], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [defaults$5.scales[scale.type], defaults$5.scale]);
  });
  return scales;
}
function initOptions(config2) {
  const options = config2.options || (config2.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config2, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config2) {
  config2 = config2 || {};
  config2.data = initData(config2.data);
  initOptions(config2);
  return config2;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys2 = keyCache.get(cacheKey);
  if (!keys2) {
    keys2 = generate();
    keyCache.set(cacheKey, keys2);
    keysCached.add(keys2);
  }
  return keys2;
}
const addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
class Config {
  constructor(config2) {
    this._config = initConfig(config2);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config2 = this._config;
    this.clearCache();
    initOptions(config2);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[
      `datasets.${datasetType}`,
      ""
    ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[
      `datasets.${datasetType}.elements.${elementType}`,
      `datasets.${datasetType}`,
      `elements.${elementType}`,
      ""
    ]]);
  }
  pluginScopeKeys(plugin) {
    const id2 = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id2}`, () => [[
      `plugins.${id2}`,
      ...plugin.additionalOptionScopes || []
    ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach((keys2) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys2.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys2.forEach((key) => addIfFound(scopes, options, key));
      keys2.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys2.forEach((key) => addIfFound(scopes, defaults$5, key));
      keys2.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults$5.datasets[type] || {},
      { type },
      defaults$5,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction$3(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject$5(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p2) => !p2.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = (value2) => isObject$5(value2) && Object.getOwnPropertyNames(value2).reduce((acc, key) => acc || isFunction$3(value2[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value2 = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction$3(value2) || hasFunction(value2)) || indexable && isArray$2(value2)) {
      return true;
    }
  }
  return false;
}
var version = "3.7.0";
const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys2 = Object.keys(obj);
  for (const key of keys2) {
    const intKey = +key;
    if (intKey >= start) {
      const value2 = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value2;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
class Chart {
  constructor(item, userConfig) {
    const config2 = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
    }
    const options = config2.createResolver(config2.chartOptionScopes(), this.getContext());
    this.platform = new (config2.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config2);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce$3((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id2) => {
      obj[id2] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id2) => {
        const scaleOptions = scaleOpts[id2];
        const axis = determineAxis(id2, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id2 = scaleOptions.id;
      const axis = determineAxis(id2, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id2] = true;
      let scale = null;
      if (id2 in scales && scales[id2].type === scaleType) {
        scale = scales[id2];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id: id2,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id2) => {
      if (!hasUpdated) {
        delete scales[id2];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults$5.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config2 = this.config;
    config2.update();
    const options = this._options = config2.createResolver(config2.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction$3(mode) ? mode({ datasetIndex: i }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = { meta, index, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners2 = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners2[type] = listener2;
    };
    const listener = (e, x2, y2) => {
      e.offsetX = x2;
      e.offsetY = y2;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners2 = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners2[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners2[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners2[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff2 = (a, b) => a.filter((x2) => !b.some((y2) => x2.datasetIndex === y2.datasetIndex && x2.index === y2.index));
    const deactivated = diff2(lastActive, active);
    const activated = replay ? active : diff2(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
const enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults$5
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x: x2, y: y2, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x2, y2, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x2, y2, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x2, y2, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value2) {
  return _readValueToProps(value2, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r2, theta, x2, y2) {
  return {
    x: x2 + r2 * Math.cos(theta),
    y: y2 + r2 * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset2, spacing, end) {
  const { x: x2, y: y2, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha * outerRadius - offset2 / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x2, y2, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y2);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y2);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y2);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x2, y2, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y2);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y2);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y2);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset2, spacing) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset2, spacing, startAngle + TAU);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset2, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const { x: x2, y: y2, startAngle, pixelMargin, fullCircles } = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x2, y2, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x2, y2, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset2, spacing, endAngle) {
  const { options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset2, spacing, endAngle);
  ctx.stroke();
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset: offset2, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
    return {
      x: x2 + Math.cos(halfAngle) * halfRadius,
      y: y2 + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset2 = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset2) {
      radiusOffset = offset2 / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset2;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
}
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x2 = point.x;
    const y2 = point.y;
    const truncX = x2 | 0;
    if (truncX === prevX) {
      if (y2 < minY) {
        minY = y2;
      } else if (y2 > maxY) {
        maxY = y2;
      }
      avgX = (countX * avgX + x2) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x2, y2);
      prevX = truncX;
      countX = 0;
      minY = maxY = y2;
    }
    lastY = y2;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value2 = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value2, end: value2 });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t2 = Math.abs((value2 - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t2, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
}
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value2 } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value2) < options.radius + options.hitRadius;
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x: x2, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y2, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
    return { x: x2, y: y2 };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x: x2, y: y2, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x2, base);
    right = Math.max(x2, base);
    top = y2 - half;
    bottom = y2 + half;
  } else {
    half = width / 2;
    left = x2 - half;
    right = x2 + half;
    top = Math.min(y2, base);
    bottom = Math.max(y2, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value2, min2, max2) {
  return skip2 ? 0 : _limitValue(value2, min2, max2);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value2 = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value2);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value2 = bar.options.borderRadius;
  const o = toTRBLCorners(value2);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject$5(value2);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x2, y2, useFinalPosition) {
  const skipX = x2 === null;
  const skipY = y2 === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y2, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x2 = rect.x !== refRect.x ? -amount : 0;
  const y2 = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y2;
  return {
    x: rect.x + x2,
    y: rect.y + y2,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x2 + base) / 2 : x2,
      y: horizontal ? y2 : (y2 + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
}
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill === void 0) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return "origin";
  }
  return fill;
}
function decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if (isObject$5(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    if (fill[0] === "-" || fill[0] === "+") {
      target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  return ["origin", "start", "end", "stack", "shape"].indexOf(fill) >= 0 && fill;
}
function computeLinearBoundary(source2) {
  const { scale = {}, fill } = source2;
  let target = null;
  let horizontal;
  if (fill === "start") {
    target = scale.bottom;
  } else if (fill === "end") {
    target = scale.top;
  } else if (isObject$5(fill)) {
    target = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    target = scale.getBasePixel();
  }
  if (isNumberFinite(target)) {
    horizontal = scale.isHorizontal();
    return {
      x: horizontal ? target : null,
      y: horizontal ? null : target
    };
  }
  return null;
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x: x2, y: y2, radius } = this;
    bounds = bounds || { start: 0, end: TAU };
    ctx.arc(x2, y2, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x: x2, y: y2, radius } = this;
    const angle = point.angle;
    return {
      x: x2 + Math.cos(angle) * radius,
      y: y2 + Math.sin(angle) * radius,
      angle
    };
  }
}
function computeCircularBoundary(source2) {
  const { scale, fill } = source2;
  const options = scale.options;
  const length = scale.getLabels().length;
  const target = [];
  const start = options.reverse ? scale.max : scale.min;
  const end = options.reverse ? scale.min : scale.max;
  let i, center, value2;
  if (fill === "start") {
    value2 = start;
  } else if (fill === "end") {
    value2 = end;
  } else if (isObject$5(fill)) {
    value2 = fill.value;
  } else {
    value2 = scale.getBaseValue();
  }
  if (options.grid.circular) {
    center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value2)
    });
  }
  for (i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value2));
  }
  return target;
}
function computeBoundary(source2) {
  const scale = source2.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source2);
  }
  return computeLinearBoundary(source2);
}
function findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function pointsFromSegments(boundary, line) {
  const { x: x2 = null, y: y2 = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y2 !== null) {
      points.push({ x: first.x, y: y2 });
      points.push({ x: last.x, y: y2 });
    } else if (x2 !== null) {
      points.push({ x: x2, y: first.y });
      points.push({ x: x2, y: last.y });
    }
  });
  return points;
}
function buildStackLine(source2) {
  const { scale, index, line } = source2;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(createBoundaryLine({ x: null, y: scale.bottom }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({ points, options: {} });
}
function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return { first, last, point };
}
function getTarget(source2) {
  const { chart, fill, line } = source2;
  if (isNumberFinite(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === "stack") {
    return buildStackLine(source2);
  }
  if (fill === "shape") {
    return true;
  }
  const boundary = computeBoundary(source2);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return createBoundaryLine(boundary, line);
}
function createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray$2(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: { tension: 0 },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function resolveTarget(sources, index, propagate) {
  const source2 = sources[index];
  let fill = source2.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isNumberFinite(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _clip(ctx, target, clipY) {
  ctx.beginPath();
  target.path(ctx);
  ctx.lineTo(target.last().x, clipY);
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return { property, start, end };
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = findSegmentEnd(start, end, points);
    const bounds = getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
function _fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    _clip(ctx, target, area.top);
    _fill(ctx, { line, target, color: above, scale, property });
    ctx.restore();
    ctx.save();
    _clip(ctx, target, area.bottom);
  }
  _fill(ctx, { line, target, color: below, scale, property });
  ctx.restore();
}
function drawfill(ctx, source2, area) {
  const target = getTarget(source2);
  const { line, scale, axis } = source2;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, { line, target, above, below, area, scale, axis });
    unclipArea(ctx);
  }
}
var plugin_filler = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source2;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source2 = null;
      if (line && line.options && line instanceof LineElement) {
        source2 = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source2;
      sources.push(source2);
    }
    for (i = 0; i < count; ++i) {
      source2 = sources[i];
      if (!source2 || source2.fill === false) {
        continue;
      }
      source2.fill = resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source2 = metasets[i].$filler;
      if (!source2) {
        continue;
      }
      source2.line.updateControlPoints(area, source2.axis);
      if (draw2) {
        drawfill(chart.ctx, source2, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source2 = metasets[i].$filler;
      if (source2) {
        drawfill(chart.ctx, source2, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source2 = args.meta.$filler;
    if (!source2 || source2.fill === false || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    drawfill(chart.ctx, source2, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
const getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config2) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config2.chart;
    this.options = config2.options;
    this.ctx = config2.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults$5.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x2, y2, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
        const centerY = y2 + halfFontSize;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x2, y2, legendItem) {
      renderText(ctx, legendItem.text, x2, y2 + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x2 = cursor.x;
      let y2 = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x2 + width + padding > this.right) {
          y2 = cursor.y += lineHeight;
          cursor.line++;
          x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y2 + lineHeight > this.bottom) {
        x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y2 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x2);
      drawLegendBox(realX, y2, legendItem);
      x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x2), y2, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y2;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y2 = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y2 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x2 = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x2, y2, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x2, y2) {
    let i, hitBox, lh2;
    if (_isBetween(x2, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
      lh2 = this.legendHitBoxes;
      for (i = 0; i < lh2.length; ++i) {
        hitBox = lh2[i];
        if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
}
function isListened(type, opts) {
  if (type === "mousemove" && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci2 = legend.chart;
      if (ci2.isDatasetVisible(index)) {
        ci2.hide(index);
        legendItem.hidden = true;
      } else {
        ci2.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x2 = 0;
    let y2 = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x2 += pos.x;
        y2 += pos.y;
        ++count;
      }
    }
    return {
      x: x2 / count,
      y: y2 / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x2 = eventPosition.x;
    let y2 = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x2 = tp.x;
      y2 = tp.y;
    }
    return {
      x: x2,
      y: y2
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray$2(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value: value2 } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value2,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart, size) {
  const { y: y2, height } = size;
  if (y2 < height / 2) {
    return "top";
  } else if (y2 > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x: x2, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x2 + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x2 - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x: x2, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x2 <= (left + right) / 2 ? "left" : "right";
  } else if (x2 <= width / 2) {
    xAlign = "left";
  } else if (x2 >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x: x2, width } = size;
  if (xAlign === "right") {
    x2 -= width;
  } else if (xAlign === "center") {
    x2 -= width / 2;
  }
  return x2;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y: y2, height } = size;
  if (yAlign === "top") {
    y2 += paddingAndSize;
  } else if (yAlign === "bottom") {
    y2 -= height + paddingAndSize;
  } else {
    y2 -= height / 2;
  }
  return y2;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x2 = alignX(size, xAlign);
  const y2 = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x2 += paddingAndSize;
    } else if (xAlign === "right") {
      x2 -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x2 -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x2 += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x2, 0, chart.width - size.width),
    y: _limitValue(y2, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
class Tooltip extends Element {
  constructor(config2) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config2.chart || config2._chart;
    this._chart = this.chart;
    this.options = config2.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x: x2, y: y2 } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x2 + topLeft, y2);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width - topRight, y2);
    ctx.quadraticCurveTo(x2 + width, y2, x2 + width, y2 + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width, y2 + height - bottomRight);
    ctx.quadraticCurveTo(x2 + width, y2 + height, x2 + width - bottomRight, y2 + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + bottomLeft, y2 + height);
    ctx.quadraticCurveTo(x2, y2 + height, x2, y2 + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2, y2 + topLeft);
    ctx.quadraticCurveTo(x2, y2, x2 + topLeft, y2);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({ chart, options });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    const args = {
      tooltip
    };
    if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
      return;
    }
    if (tooltip) {
      tooltip.draw(chart.ctx);
    }
    chart.notifyPlugins("afterTooltipDraw", args);
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop$2,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop$2,
      beforeBody: noop$2,
      beforeLabel: noop$2,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value2 = tooltipItem.formattedValue;
        if (!isNullOrUndef(value2)) {
          label += value2;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop$2,
      afterBody: noop$2,
      beforeFooter: noop$2,
      footer: noop$2,
      afterFooter: noop$2
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
const addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === "string") {
    index = labels.push(raw) - 1;
    addedLabels.unshift({ index, label: raw });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
const validIndex = (index, max2) => index === null ? null : _limitValue(Math.round(index), 0, max2);
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index, label } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min2, max: max2 } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min2 = 0;
      }
      if (!maxDefined) {
        max2 = this.getLabels().length - 1;
      }
    }
    this.min = min2;
    this.max = max2;
  }
  buildTicks() {
    const min2 = this.min;
    const max2 = this.max;
    const offset2 = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min2 === 0 && max2 === labels.length - 1 ? labels : labels.slice(min2, max2 + 1);
    this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
    this._startValue = this.min - (offset2 ? 0.5 : 0);
    for (let value2 = min2; value2 <= max2; value2++) {
      ticks.push({ value: value2 });
    }
    return ticks;
  }
  getLabelForValue(value2) {
    const labels = this.getLabels();
    if (value2 >= 0 && value2 < labels.length) {
      return labels[value2];
    }
    return value2;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value2) {
    if (typeof value2 !== "number") {
      value2 = this.parse(value2);
    }
    return value2 === null ? NaN : this.getPixelForDecimal((value2 - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min: min2, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min2);
  const maxDefined = !isNullOrUndef(max2);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
    spacing = (max2 - min2) / numSpaces;
    niceMin = min2;
    niceMax = max2;
  } else if (countDefined) {
    niceMin = minDefined ? min2 : niceMin;
    niceMax = maxDefined ? max2 : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min2) {
      ticks.push({ value: min2 });
      if (niceMin < min2) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min2) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max2) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max2;
    } else {
      ticks.push({ value: max2 });
    }
  } else if (!maxDefined || niceMax === max2) {
    ticks.push({ value: niceMax });
  }
  return ticks;
}
function relativeLabelSize(value2, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value2).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min2, max: max2 } = this;
    const setMin = (v2) => min2 = minDefined ? min2 : v2;
    const setMax = (v2) => max2 = maxDefined ? max2 : v2;
    if (beginAtZero) {
      const minSign = sign$1(min2);
      const maxSign = sign$1(max2);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min2 === max2) {
      let offset2 = 1;
      if (max2 >= Number.MAX_SAFE_INTEGER || min2 <= Number.MIN_SAFE_INTEGER) {
        offset2 = Math.abs(max2 * 0.05);
      }
      setMax(max2 + offset2);
      if (!beginAtZero) {
        setMin(min2 - offset2);
      }
    }
    this.min = min2;
    this.max = max2;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset2;
      end += offset2;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value2) {
    return formatNumber(value2, this.chart.options.locale, this.options.ticks.format);
  }
}
class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const { min: min2, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min2) ? min2 : 0;
    this.max = isNumberFinite(max2) ? max2 : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value2) {
    return value2 === null ? NaN : this.getPixelForDecimal((value2 - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value2 = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value2 === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value2) && value2 > 0 ? value2 : null;
  }
  determineDataLimits() {
    const { min: min2, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min2) ? Math.max(0, min2) : null;
    this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min2 = this.min;
    let max2 = this.max;
    const setMin = (v2) => min2 = minDefined ? min2 : v2;
    const setMax = (v2) => max2 = maxDefined ? max2 : v2;
    const exp = (v2, m2) => Math.pow(10, Math.floor(log10(v2)) + m2);
    if (min2 === max2) {
      if (min2 <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min2, -1));
        setMax(exp(max2, 1));
      }
    }
    if (min2 <= 0) {
      setMin(exp(max2, -1));
    }
    if (max2 <= 0) {
      setMax(exp(min2, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min2 === exp(this.min, 0)) {
      setMin(exp(min2, -1));
    }
    this.min = min2;
    this.max = max2;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value2) {
    return value2 === void 0 ? "0" : formatNumber(value2, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value2) {
    if (value2 === void 0 || value2 === 0) {
      value2 = this.min;
    }
    if (value2 === null || isNaN(value2)) {
      return NaN;
    }
    return this.getPixelForDecimal(value2 === this.min ? 0 : (log10(value2) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults$5.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray$2(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min2, max2) {
  if (angle === min2 || angle === max2) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min2 || angle > max2) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x2 = 0;
  let y2 = 0;
  if (hLimits.start < orig.l) {
    x2 = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x2);
  } else if (hLimits.end > orig.r) {
    x2 = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x2);
  }
  if (vLimits.start < orig.t) {
    y2 = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y2);
  } else if (vLimits.end > orig.b) {
    y2 = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y2);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y2 = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y: y2,
      textAlign,
      left,
      top: y2,
      right: left + size.w,
      bottom: y2 + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x2, w, align) {
  if (align === "right") {
    x2 -= w;
  } else if (align === "center") {
    x2 -= w / 2;
  }
  return x2;
}
function yForAngle(y2, h, angle) {
  if (angle === 90 || angle === 270) {
    y2 -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y2 -= h;
  }
  return y2;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x: x2, y: y2, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
    }
    renderText(ctx, scale._pointLabels[i], x2, y2 + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min: min2, max: max2 } = this.getMinMax(false);
    this.min = isNumberFinite(min2) && !isNaN(min2) ? min2 : 0;
    this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value2, index) => {
      const label = callback(this.options.pointLabels.callback, [value2, index], this);
      return label || label === 0 ? label : "";
    }).filter((v2, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value2) {
    if (isNullOrUndef(value2)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value2) * scalingFactor;
    }
    return (value2 - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value2) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value2));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset2, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset2 = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index - 1));
          drawRadiusLine(this, optsAtIndex, offset2, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset2);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset2, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset2 = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset2, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
}
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
const INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
const UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value2 = input;
  if (typeof parser === "function") {
    value2 = parser(value2);
  }
  if (!isNumberFinite(value2)) {
    value2 = typeof parser === "string" ? adapter.parse(value2, parser) : adapter.parse(value2);
  }
  if (value2 === null) {
    return null;
  }
  if (round2) {
    value2 = round2 === "week" && (isNumber$1(isoWeekday) || isoWeekday === true) ? adapter.startOf(value2, "isoWeek", isoWeekday) : adapter.startOf(value2, round2);
  }
  return +value2;
}
function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min2, max2) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max2, min2, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi: hi2 } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi2];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map2, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map2[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map2 = {};
  const ilen = values.length;
  let i, value2;
  for (i = 0; i < ilen; ++i) {
    value2 = values[i];
    map2[value2] = i;
    ticks.push({
      value: value2,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min2 = Math.min(min2, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max2 = Math.max(max2, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
    max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min2, max2 - 1);
    this.max = Math.max(min2 + 1, max2);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min2 = Number.POSITIVE_INFINITY;
    let max2 = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min2 = arr[0];
      max2 = arr[arr.length - 1];
    }
    return { min: min2, max: max2 };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min2 = this.min;
    const max2 = this.max;
    const ticks = _filterBetween(timestamps, min2, max2);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min2 = this.min;
    const max2 = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber$1(weekday) || weekday === true;
    const ticks = {};
    let first = min2;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
      throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max2 || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x2) => +x2);
  }
  getLabelForValue(value2) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value2, timeOpts.tooltipFormat);
    }
    return adapter.format(value2, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format2) {
    const options = this.options;
    const formats2 = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats2[unit];
    const majorFormat = majorUnit && formats2[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value2) {
    return value2 === null ? NaN : (value2 - this.min) / (this.max - this.min);
  }
  getPixelForValue(value2) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value2);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format2);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi2 = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi2].pos) {
      ({ lo, hi: hi2 } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi2]);
  } else {
    if (val >= table[lo].time && val <= table[hi2].time) {
      ({ lo, hi: hi2 } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi2]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min: min2, max: max2 } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min2 && curr <= max2) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min2, pos: 0 },
        { time: max2, pos: 1 }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value2) {
    return (interpolate(this._table, value2) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;
var resolveConfig$4 = {};
var resolveConfig$3 = {};
var negateValue = {};
Object.defineProperty(negateValue, "__esModule", {
  value: true
});
negateValue.default = _default$6;
function _default$6(value2) {
  value2 = `${value2}`;
  if (value2 === "0") {
    return "0";
  }
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value2)) {
    return value2.replace(/^[+-]?/, (sign2) => sign2 === "-" ? "" : "-");
  }
  if (value2.includes("var(") || value2.includes("calc(")) {
    return `calc(${value2} * -1)`;
  }
}
var corePluginList = {};
Object.defineProperty(corePluginList, "__esModule", {
  value: true
});
corePluginList.default = void 0;
var _default$5 = [
  "preflight",
  "container",
  "accessibility",
  "pointerEvents",
  "visibility",
  "position",
  "inset",
  "isolation",
  "zIndex",
  "order",
  "gridColumn",
  "gridColumnStart",
  "gridColumnEnd",
  "gridRow",
  "gridRowStart",
  "gridRowEnd",
  "float",
  "clear",
  "margin",
  "boxSizing",
  "display",
  "aspectRatio",
  "height",
  "maxHeight",
  "minHeight",
  "width",
  "minWidth",
  "maxWidth",
  "flex",
  "flexShrink",
  "flexGrow",
  "flexBasis",
  "tableLayout",
  "borderCollapse",
  "transformOrigin",
  "translate",
  "rotate",
  "skew",
  "scale",
  "transform",
  "animation",
  "cursor",
  "touchAction",
  "userSelect",
  "resize",
  "scrollSnapType",
  "scrollSnapAlign",
  "scrollSnapStop",
  "scrollMargin",
  "scrollPadding",
  "listStylePosition",
  "listStyleType",
  "appearance",
  "columns",
  "breakBefore",
  "breakInside",
  "breakAfter",
  "gridAutoColumns",
  "gridAutoFlow",
  "gridAutoRows",
  "gridTemplateColumns",
  "gridTemplateRows",
  "flexDirection",
  "flexWrap",
  "placeContent",
  "placeItems",
  "alignContent",
  "alignItems",
  "justifyContent",
  "justifyItems",
  "gap",
  "space",
  "divideWidth",
  "divideStyle",
  "divideColor",
  "divideOpacity",
  "placeSelf",
  "alignSelf",
  "justifySelf",
  "overflow",
  "overscrollBehavior",
  "scrollBehavior",
  "textOverflow",
  "whitespace",
  "wordBreak",
  "borderRadius",
  "borderWidth",
  "borderStyle",
  "borderColor",
  "borderOpacity",
  "backgroundColor",
  "backgroundOpacity",
  "backgroundImage",
  "gradientColorStops",
  "boxDecorationBreak",
  "backgroundSize",
  "backgroundAttachment",
  "backgroundClip",
  "backgroundPosition",
  "backgroundRepeat",
  "backgroundOrigin",
  "fill",
  "stroke",
  "strokeWidth",
  "objectFit",
  "objectPosition",
  "padding",
  "textAlign",
  "textIndent",
  "verticalAlign",
  "fontFamily",
  "fontSize",
  "fontWeight",
  "textTransform",
  "fontStyle",
  "fontVariantNumeric",
  "lineHeight",
  "letterSpacing",
  "textColor",
  "textOpacity",
  "textDecoration",
  "textDecorationColor",
  "textDecorationStyle",
  "textDecorationThickness",
  "textUnderlineOffset",
  "fontSmoothing",
  "placeholderColor",
  "placeholderOpacity",
  "caretColor",
  "accentColor",
  "opacity",
  "backgroundBlendMode",
  "mixBlendMode",
  "boxShadow",
  "boxShadowColor",
  "outlineStyle",
  "outlineWidth",
  "outlineOffset",
  "outlineColor",
  "ringWidth",
  "ringColor",
  "ringOpacity",
  "ringOffsetWidth",
  "ringOffsetColor",
  "blur",
  "brightness",
  "contrast",
  "dropShadow",
  "grayscale",
  "hueRotate",
  "invert",
  "saturate",
  "sepia",
  "filter",
  "backdropBlur",
  "backdropBrightness",
  "backdropContrast",
  "backdropGrayscale",
  "backdropHueRotate",
  "backdropInvert",
  "backdropOpacity",
  "backdropSaturate",
  "backdropSepia",
  "backdropFilter",
  "transitionProperty",
  "transitionDelay",
  "transitionDuration",
  "transitionTimingFunction",
  "willChange",
  "content"
];
corePluginList.default = _default$5;
var configurePlugins = {};
Object.defineProperty(configurePlugins, "__esModule", {
  value: true
});
configurePlugins.default = _default$4;
function _default$4(pluginConfig, plugins) {
  if (pluginConfig === void 0) {
    return plugins;
  }
  const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
    ...new Set(plugins.filter((pluginName) => {
      return pluginConfig !== false && pluginConfig[pluginName] !== false;
    }).concat(Object.keys(pluginConfig).filter((pluginName) => {
      return pluginConfig[pluginName] !== false;
    })))
  ];
  return pluginNames;
}
var defaultConfig_stub = {
  content: [],
  presets: [],
  darkMode: "media",
  theme: {
    screens: {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px",
      "2xl": "1536px"
    },
    colors: ({ colors: colors2 }) => ({
      inherit: colors2.inherit,
      current: colors2.current,
      transparent: colors2.transparent,
      black: colors2.black,
      white: colors2.white,
      slate: colors2.slate,
      gray: colors2.gray,
      zinc: colors2.zinc,
      neutral: colors2.neutral,
      stone: colors2.stone,
      red: colors2.red,
      orange: colors2.orange,
      amber: colors2.amber,
      yellow: colors2.yellow,
      lime: colors2.lime,
      green: colors2.green,
      emerald: colors2.emerald,
      teal: colors2.teal,
      cyan: colors2.cyan,
      sky: colors2.sky,
      blue: colors2.blue,
      indigo: colors2.indigo,
      violet: colors2.violet,
      purple: colors2.purple,
      fuchsia: colors2.fuchsia,
      pink: colors2.pink,
      rose: colors2.rose
    }),
    columns: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      "3xs": "16rem",
      "2xs": "18rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem"
    },
    spacing: {
      px: "1px",
      0: "0px",
      0.5: "0.125rem",
      1: "0.25rem",
      1.5: "0.375rem",
      2: "0.5rem",
      2.5: "0.625rem",
      3: "0.75rem",
      3.5: "0.875rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem",
      11: "2.75rem",
      12: "3rem",
      14: "3.5rem",
      16: "4rem",
      20: "5rem",
      24: "6rem",
      28: "7rem",
      32: "8rem",
      36: "9rem",
      40: "10rem",
      44: "11rem",
      48: "12rem",
      52: "13rem",
      56: "14rem",
      60: "15rem",
      64: "16rem",
      72: "18rem",
      80: "20rem",
      96: "24rem"
    },
    animation: {
      none: "none",
      spin: "spin 1s linear infinite",
      ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
      pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      bounce: "bounce 1s infinite"
    },
    aspectRatio: {
      auto: "auto",
      square: "1 / 1",
      video: "16 / 9"
    },
    backdropBlur: ({ theme }) => theme("blur"),
    backdropBrightness: ({ theme }) => theme("brightness"),
    backdropContrast: ({ theme }) => theme("contrast"),
    backdropGrayscale: ({ theme }) => theme("grayscale"),
    backdropHueRotate: ({ theme }) => theme("hueRotate"),
    backdropInvert: ({ theme }) => theme("invert"),
    backdropOpacity: ({ theme }) => theme("opacity"),
    backdropSaturate: ({ theme }) => theme("saturate"),
    backdropSepia: ({ theme }) => theme("sepia"),
    backgroundColor: ({ theme }) => theme("colors"),
    backgroundImage: {
      none: "none",
      "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
      "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
      "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
      "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
      "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
      "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
      "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
      "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme }) => theme("opacity"),
    backgroundPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    backgroundSize: {
      auto: "auto",
      cover: "cover",
      contain: "contain"
    },
    blur: {
      0: "0",
      none: "0",
      sm: "4px",
      DEFAULT: "8px",
      md: "12px",
      lg: "16px",
      xl: "24px",
      "2xl": "40px",
      "3xl": "64px"
    },
    brightness: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    borderColor: ({ theme }) => __spreadProps(__spreadValues({}, theme("colors")), {
      DEFAULT: theme("colors.gray.200", "currentColor")
    }),
    borderOpacity: ({ theme }) => theme("opacity"),
    borderRadius: {
      none: "0px",
      sm: "0.125rem",
      DEFAULT: "0.25rem",
      md: "0.375rem",
      lg: "0.5rem",
      xl: "0.75rem",
      "2xl": "1rem",
      "3xl": "1.5rem",
      full: "9999px"
    },
    borderWidth: {
      DEFAULT: "1px",
      0: "0px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    boxShadow: {
      sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
      DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
      md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
      lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
      xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
      "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
      inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
      none: "none"
    },
    boxShadowColor: ({ theme }) => theme("colors"),
    caretColor: ({ theme }) => theme("colors"),
    accentColor: ({ theme }) => __spreadProps(__spreadValues({}, theme("colors")), {
      auto: "auto"
    }),
    contrast: {
      0: "0",
      50: ".5",
      75: ".75",
      100: "1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    container: {},
    content: {
      none: "none"
    },
    cursor: {
      auto: "auto",
      default: "default",
      pointer: "pointer",
      wait: "wait",
      text: "text",
      move: "move",
      help: "help",
      "not-allowed": "not-allowed",
      none: "none",
      "context-menu": "context-menu",
      progress: "progress",
      cell: "cell",
      crosshair: "crosshair",
      "vertical-text": "vertical-text",
      alias: "alias",
      copy: "copy",
      "no-drop": "no-drop",
      grab: "grab",
      grabbing: "grabbing",
      "all-scroll": "all-scroll",
      "col-resize": "col-resize",
      "row-resize": "row-resize",
      "n-resize": "n-resize",
      "e-resize": "e-resize",
      "s-resize": "s-resize",
      "w-resize": "w-resize",
      "ne-resize": "ne-resize",
      "nw-resize": "nw-resize",
      "se-resize": "se-resize",
      "sw-resize": "sw-resize",
      "ew-resize": "ew-resize",
      "ns-resize": "ns-resize",
      "nesw-resize": "nesw-resize",
      "nwse-resize": "nwse-resize",
      "zoom-in": "zoom-in",
      "zoom-out": "zoom-out"
    },
    divideColor: ({ theme }) => theme("borderColor"),
    divideOpacity: ({ theme }) => theme("borderOpacity"),
    divideWidth: ({ theme }) => theme("borderWidth"),
    dropShadow: {
      sm: "0 1px 1px rgb(0 0 0 / 0.05)",
      DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
      md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
      lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
      xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
      "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
      none: "0 0 #0000"
    },
    fill: ({ theme }) => theme("colors"),
    grayscale: {
      0: "0",
      DEFAULT: "100%"
    },
    hueRotate: {
      0: "0deg",
      15: "15deg",
      30: "30deg",
      60: "60deg",
      90: "90deg",
      180: "180deg"
    },
    invert: {
      0: "0",
      DEFAULT: "100%"
    },
    flex: {
      1: "1 1 0%",
      auto: "1 1 auto",
      initial: "0 1 auto",
      none: "none"
    },
    flexBasis: ({ theme }) => __spreadProps(__spreadValues({
      auto: "auto"
    }, theme("spacing")), {
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%"
    }),
    flexGrow: {
      0: "0",
      DEFAULT: "1"
    },
    flexShrink: {
      0: "0",
      DEFAULT: "1"
    },
    fontFamily: {
      sans: [
        "ui-sans-serif",
        "system-ui",
        "-apple-system",
        "BlinkMacSystemFont",
        '"Segoe UI"',
        "Roboto",
        '"Helvetica Neue"',
        "Arial",
        '"Noto Sans"',
        "sans-serif",
        '"Apple Color Emoji"',
        '"Segoe UI Emoji"',
        '"Segoe UI Symbol"',
        '"Noto Color Emoji"'
      ],
      serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
      mono: [
        "ui-monospace",
        "SFMono-Regular",
        "Menlo",
        "Monaco",
        "Consolas",
        '"Liberation Mono"',
        '"Courier New"',
        "monospace"
      ]
    },
    fontSize: {
      xs: ["0.75rem", { lineHeight: "1rem" }],
      sm: ["0.875rem", { lineHeight: "1.25rem" }],
      base: ["1rem", { lineHeight: "1.5rem" }],
      lg: ["1.125rem", { lineHeight: "1.75rem" }],
      xl: ["1.25rem", { lineHeight: "1.75rem" }],
      "2xl": ["1.5rem", { lineHeight: "2rem" }],
      "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
      "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
      "5xl": ["3rem", { lineHeight: "1" }],
      "6xl": ["3.75rem", { lineHeight: "1" }],
      "7xl": ["4.5rem", { lineHeight: "1" }],
      "8xl": ["6rem", { lineHeight: "1" }],
      "9xl": ["8rem", { lineHeight: "1" }]
    },
    fontWeight: {
      thin: "100",
      extralight: "200",
      light: "300",
      normal: "400",
      medium: "500",
      semibold: "600",
      bold: "700",
      extrabold: "800",
      black: "900"
    },
    gap: ({ theme }) => theme("spacing"),
    gradientColorStops: ({ theme }) => theme("colors"),
    gridAutoColumns: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridColumn: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-7": "span 7 / span 7",
      "span-8": "span 8 / span 8",
      "span-9": "span 9 / span 9",
      "span-10": "span 10 / span 10",
      "span-11": "span 11 / span 11",
      "span-12": "span 12 / span 12",
      "span-full": "1 / -1"
    },
    gridColumnEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridColumnStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridRow: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-full": "1 / -1"
    },
    gridRowStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7"
    },
    gridRowEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7"
    },
    gridTemplateColumns: {
      none: "none",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))",
      7: "repeat(7, minmax(0, 1fr))",
      8: "repeat(8, minmax(0, 1fr))",
      9: "repeat(9, minmax(0, 1fr))",
      10: "repeat(10, minmax(0, 1fr))",
      11: "repeat(11, minmax(0, 1fr))",
      12: "repeat(12, minmax(0, 1fr))"
    },
    gridTemplateRows: {
      none: "none",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))"
    },
    height: ({ theme }) => __spreadProps(__spreadValues({
      auto: "auto"
    }, theme("spacing")), {
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    inset: ({ theme }) => __spreadProps(__spreadValues({
      auto: "auto"
    }, theme("spacing")), {
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    keyframes: {
      spin: {
        to: {
          transform: "rotate(360deg)"
        }
      },
      ping: {
        "75%, 100%": {
          transform: "scale(2)",
          opacity: "0"
        }
      },
      pulse: {
        "50%": {
          opacity: ".5"
        }
      },
      bounce: {
        "0%, 100%": {
          transform: "translateY(-25%)",
          animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
        },
        "50%": {
          transform: "none",
          animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
        }
      }
    },
    letterSpacing: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0em",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeight: {
      none: "1",
      tight: "1.25",
      snug: "1.375",
      normal: "1.5",
      relaxed: "1.625",
      loose: "2",
      3: ".75rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem"
    },
    listStyleType: {
      none: "none",
      disc: "disc",
      decimal: "decimal"
    },
    margin: ({ theme }) => __spreadValues({
      auto: "auto"
    }, theme("spacing")),
    maxHeight: ({ theme }) => __spreadProps(__spreadValues({}, theme("spacing")), {
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    maxWidth: ({ theme, breakpoints }) => __spreadValues({
      none: "none",
      0: "0rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content",
      prose: "65ch"
    }, breakpoints(theme("screens"))),
    minHeight: {
      0: "0px",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    },
    minWidth: {
      0: "0px",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    },
    objectPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    opacity: {
      0: "0",
      5: "0.05",
      10: "0.1",
      20: "0.2",
      25: "0.25",
      30: "0.3",
      40: "0.4",
      50: "0.5",
      60: "0.6",
      70: "0.7",
      75: "0.75",
      80: "0.8",
      90: "0.9",
      95: "0.95",
      100: "1"
    },
    order: {
      first: "-9999",
      last: "9999",
      none: "0",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12"
    },
    padding: ({ theme }) => theme("spacing"),
    placeholderColor: ({ theme }) => theme("colors"),
    placeholderOpacity: ({ theme }) => theme("opacity"),
    outlineColor: ({ theme }) => theme("colors"),
    outlineOffset: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    outlineWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    ringColor: ({ theme }) => __spreadValues({
      DEFAULT: theme("colors.blue.500", "#3b82f6")
    }, theme("colors")),
    ringOffsetColor: ({ theme }) => theme("colors"),
    ringOffsetWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    ringOpacity: ({ theme }) => __spreadValues({
      DEFAULT: "0.5"
    }, theme("opacity")),
    ringWidth: {
      DEFAULT: "3px",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    rotate: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg",
      45: "45deg",
      90: "90deg",
      180: "180deg"
    },
    saturate: {
      0: "0",
      50: ".5",
      100: "1",
      150: "1.5",
      200: "2"
    },
    scale: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5"
    },
    scrollMargin: ({ theme }) => __spreadValues({}, theme("spacing")),
    scrollPadding: ({ theme }) => theme("spacing"),
    sepia: {
      0: "0",
      DEFAULT: "100%"
    },
    skew: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg"
    },
    space: ({ theme }) => __spreadValues({}, theme("spacing")),
    stroke: ({ theme }) => theme("colors"),
    strokeWidth: {
      0: "0",
      1: "1",
      2: "2"
    },
    textColor: ({ theme }) => theme("colors"),
    textDecorationColor: ({ theme }) => theme("colors"),
    textDecorationThickness: {
      auto: "auto",
      "from-font": "from-font",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    textUnderlineOffset: {
      auto: "auto",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    textIndent: ({ theme }) => __spreadValues({}, theme("spacing")),
    textOpacity: ({ theme }) => theme("opacity"),
    transformOrigin: {
      center: "center",
      top: "top",
      "top-right": "top right",
      right: "right",
      "bottom-right": "bottom right",
      bottom: "bottom",
      "bottom-left": "bottom left",
      left: "left",
      "top-left": "top left"
    },
    transitionDelay: {
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionDuration: {
      DEFAULT: "150ms",
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionProperty: {
      none: "none",
      all: "all",
      DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
      colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
      opacity: "opacity",
      shadow: "box-shadow",
      transform: "transform"
    },
    transitionTimingFunction: {
      DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
      linear: "linear",
      in: "cubic-bezier(0.4, 0, 1, 1)",
      out: "cubic-bezier(0, 0, 0.2, 1)",
      "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme }) => __spreadProps(__spreadValues({}, theme("spacing")), {
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    width: ({ theme }) => __spreadProps(__spreadValues({
      auto: "auto"
    }, theme("spacing")), {
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%",
      screen: "100vw",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    willChange: {
      auto: "auto",
      scroll: "scroll-position",
      contents: "contents",
      transform: "transform"
    },
    zIndex: {
      auto: "auto",
      0: "0",
      10: "10",
      20: "20",
      30: "30",
      40: "40",
      50: "50"
    }
  },
  variantOrder: [
    "first",
    "last",
    "odd",
    "even",
    "visited",
    "checked",
    "empty",
    "read-only",
    "group-hover",
    "group-focus",
    "focus-within",
    "hover",
    "focus",
    "focus-visible",
    "active",
    "disabled"
  ],
  plugins: []
};
var colors = {};
var log$1 = {};
var ansiStyles$1 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
const cssKeywords = colorName;
const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
  reverseKeywords[cssKeywords[key]] = key;
}
const convert$1 = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
var conversions$2 = convert$1;
for (const model of Object.keys(convert$1)) {
  if (!("channels" in convert$1[model])) {
    throw new Error("missing channels property: " + model);
  }
  if (!("labels" in convert$1[model])) {
    throw new Error("missing channel labels property: " + model);
  }
  if (convert$1[model].labels.length !== convert$1[model].channels) {
    throw new Error("channel and label counts mismatch: " + model);
  }
  const { channels, labels } = convert$1[model];
  delete convert$1[model].channels;
  delete convert$1[model].labels;
  Object.defineProperty(convert$1[model], "channels", { value: channels });
  Object.defineProperty(convert$1[model], "labels", { value: labels });
}
convert$1.rgb.hsl = function(rgb) {
  const r2 = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const min2 = Math.min(r2, g, b);
  const max2 = Math.max(r2, g, b);
  const delta = max2 - min2;
  let h;
  let s;
  if (max2 === min2) {
    h = 0;
  } else if (r2 === max2) {
    h = (g - b) / delta;
  } else if (g === max2) {
    h = 2 + (b - r2) / delta;
  } else if (b === max2) {
    h = 4 + (r2 - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  const l2 = (min2 + max2) / 2;
  if (max2 === min2) {
    s = 0;
  } else if (l2 <= 0.5) {
    s = delta / (max2 + min2);
  } else {
    s = delta / (2 - max2 - min2);
  }
  return [h, s * 100, l2 * 100];
};
convert$1.rgb.hsv = function(rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h;
  let s;
  const r2 = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const v2 = Math.max(r2, g, b);
  const diff2 = v2 - Math.min(r2, g, b);
  const diffc = function(c) {
    return (v2 - c) / 6 / diff2 + 1 / 2;
  };
  if (diff2 === 0) {
    h = 0;
    s = 0;
  } else {
    s = diff2 / v2;
    rdif = diffc(r2);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r2 === v2) {
      h = bdif - gdif;
    } else if (g === v2) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v2) {
      h = 2 / 3 + gdif - rdif;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return [
    h * 360,
    s * 100,
    v2 * 100
  ];
};
convert$1.rgb.hwb = function(rgb) {
  const r2 = rgb[0];
  const g = rgb[1];
  let b = rgb[2];
  const h = convert$1.rgb.hsl(rgb)[0];
  const w = 1 / 255 * Math.min(r2, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r2, Math.max(g, b));
  return [h, w * 100, b * 100];
};
convert$1.rgb.cmyk = function(rgb) {
  const r2 = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const k = Math.min(1 - r2, 1 - g, 1 - b);
  const c = (1 - r2 - k) / (1 - k) || 0;
  const m2 = (1 - g - k) / (1 - k) || 0;
  const y2 = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m2 * 100, y2 * 100, k * 100];
};
function comparativeDistance(x2, y2) {
  return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
}
convert$1.rgb.keyword = function(rgb) {
  const reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  let currentClosestDistance = Infinity;
  let currentClosestKeyword;
  for (const keyword of Object.keys(cssKeywords)) {
    const value2 = cssKeywords[keyword];
    const distance = comparativeDistance(rgb, value2);
    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }
  return currentClosestKeyword;
};
convert$1.keyword.rgb = function(keyword) {
  return cssKeywords[keyword];
};
convert$1.rgb.xyz = function(rgb) {
  let r2 = rgb[0] / 255;
  let g = rgb[1] / 255;
  let b = rgb[2] / 255;
  r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
  g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
  b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
  const x2 = r2 * 0.4124 + g * 0.3576 + b * 0.1805;
  const y2 = r2 * 0.2126 + g * 0.7152 + b * 0.0722;
  const z2 = r2 * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x2 * 100, y2 * 100, z2 * 100];
};
convert$1.rgb.lab = function(rgb) {
  const xyz = convert$1.rgb.xyz(rgb);
  let x2 = xyz[0];
  let y2 = xyz[1];
  let z2 = xyz[2];
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
  const l2 = 116 * y2 - 16;
  const a = 500 * (x2 - y2);
  const b = 200 * (y2 - z2);
  return [l2, a, b];
};
convert$1.hsl.rgb = function(hsl) {
  const h = hsl[0] / 360;
  const s = hsl[1] / 100;
  const l2 = hsl[2] / 100;
  let t2;
  let t3;
  let val;
  if (s === 0) {
    val = l2 * 255;
    return [val, val, val];
  }
  if (l2 < 0.5) {
    t2 = l2 * (1 + s);
  } else {
    t2 = l2 + s - l2 * s;
  }
  const t1 = 2 * l2 - t2;
  const rgb = [0, 0, 0];
  for (let i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i] = val * 255;
  }
  return rgb;
};
convert$1.hsl.hsv = function(hsl) {
  const h = hsl[0];
  let s = hsl[1] / 100;
  let l2 = hsl[2] / 100;
  let smin = s;
  const lmin = Math.max(l2, 0.01);
  l2 *= 2;
  s *= l2 <= 1 ? l2 : 2 - l2;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v2 = (l2 + s) / 2;
  const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l2 + s);
  return [h, sv * 100, v2 * 100];
};
convert$1.hsv.rgb = function(hsv) {
  const h = hsv[0] / 60;
  const s = hsv[1] / 100;
  let v2 = hsv[2] / 100;
  const hi2 = Math.floor(h) % 6;
  const f = h - Math.floor(h);
  const p2 = 255 * v2 * (1 - s);
  const q2 = 255 * v2 * (1 - s * f);
  const t2 = 255 * v2 * (1 - s * (1 - f));
  v2 *= 255;
  switch (hi2) {
    case 0:
      return [v2, t2, p2];
    case 1:
      return [q2, v2, p2];
    case 2:
      return [p2, v2, t2];
    case 3:
      return [p2, q2, v2];
    case 4:
      return [t2, p2, v2];
    case 5:
      return [v2, p2, q2];
  }
};
convert$1.hsv.hsl = function(hsv) {
  const h = hsv[0];
  const s = hsv[1] / 100;
  const v2 = hsv[2] / 100;
  const vmin = Math.max(v2, 0.01);
  let sl;
  let l2;
  l2 = (2 - s) * v2;
  const lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l2 /= 2;
  return [h, sl * 100, l2 * 100];
};
convert$1.hwb.rgb = function(hwb) {
  const h = hwb[0] / 360;
  let wh2 = hwb[1] / 100;
  let bl = hwb[2] / 100;
  const ratio = wh2 + bl;
  let f;
  if (ratio > 1) {
    wh2 /= ratio;
    bl /= ratio;
  }
  const i = Math.floor(6 * h);
  const v2 = 1 - bl;
  f = 6 * h - i;
  if ((i & 1) !== 0) {
    f = 1 - f;
  }
  const n2 = wh2 + f * (v2 - wh2);
  let r2;
  let g;
  let b;
  switch (i) {
    default:
    case 6:
    case 0:
      r2 = v2;
      g = n2;
      b = wh2;
      break;
    case 1:
      r2 = n2;
      g = v2;
      b = wh2;
      break;
    case 2:
      r2 = wh2;
      g = v2;
      b = n2;
      break;
    case 3:
      r2 = wh2;
      g = n2;
      b = v2;
      break;
    case 4:
      r2 = n2;
      g = wh2;
      b = v2;
      break;
    case 5:
      r2 = v2;
      g = wh2;
      b = n2;
      break;
  }
  return [r2 * 255, g * 255, b * 255];
};
convert$1.cmyk.rgb = function(cmyk) {
  const c = cmyk[0] / 100;
  const m2 = cmyk[1] / 100;
  const y2 = cmyk[2] / 100;
  const k = cmyk[3] / 100;
  const r2 = 1 - Math.min(1, c * (1 - k) + k);
  const g = 1 - Math.min(1, m2 * (1 - k) + k);
  const b = 1 - Math.min(1, y2 * (1 - k) + k);
  return [r2 * 255, g * 255, b * 255];
};
convert$1.xyz.rgb = function(xyz) {
  const x2 = xyz[0] / 100;
  const y2 = xyz[1] / 100;
  const z2 = xyz[2] / 100;
  let r2;
  let g;
  let b;
  r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
  g = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
  b = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
  r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
  g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
  b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
  r2 = Math.min(Math.max(0, r2), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r2 * 255, g * 255, b * 255];
};
convert$1.xyz.lab = function(xyz) {
  let x2 = xyz[0];
  let y2 = xyz[1];
  let z2 = xyz[2];
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
  const l2 = 116 * y2 - 16;
  const a = 500 * (x2 - y2);
  const b = 200 * (y2 - z2);
  return [l2, a, b];
};
convert$1.lab.xyz = function(lab) {
  const l2 = lab[0];
  const a = lab[1];
  const b = lab[2];
  let x2;
  let y2;
  let z2;
  y2 = (l2 + 16) / 116;
  x2 = a / 500 + y2;
  z2 = y2 - b / 200;
  const y22 = y2 ** 3;
  const x22 = x2 ** 3;
  const z22 = z2 ** 3;
  y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
  x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
  z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
  x2 *= 95.047;
  y2 *= 100;
  z2 *= 108.883;
  return [x2, y2, z2];
};
convert$1.lab.lch = function(lab) {
  const l2 = lab[0];
  const a = lab[1];
  const b = lab[2];
  let h;
  const hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  const c = Math.sqrt(a * a + b * b);
  return [l2, c, h];
};
convert$1.lch.lab = function(lch) {
  const l2 = lch[0];
  const c = lch[1];
  const h = lch[2];
  const hr = h / 360 * 2 * Math.PI;
  const a = c * Math.cos(hr);
  const b = c * Math.sin(hr);
  return [l2, a, b];
};
convert$1.rgb.ansi16 = function(args, saturation = null) {
  const [r2, g, b] = args;
  let value2 = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
  value2 = Math.round(value2 / 50);
  if (value2 === 0) {
    return 30;
  }
  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r2 / 255));
  if (value2 === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$1.hsv.ansi16 = function(args) {
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};
convert$1.rgb.ansi256 = function(args) {
  const r2 = args[0];
  const g = args[1];
  const b = args[2];
  if (r2 === g && g === b) {
    if (r2 < 8) {
      return 16;
    }
    if (r2 > 248) {
      return 231;
    }
    return Math.round((r2 - 8) / 247 * 24) + 232;
  }
  const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert$1.ansi16.rgb = function(args) {
  let color2 = args % 10;
  if (color2 === 0 || color2 === 7) {
    if (args > 50) {
      color2 += 3.5;
    }
    color2 = color2 / 10.5 * 255;
    return [color2, color2, color2];
  }
  const mult = (~~(args > 50) + 1) * 0.5;
  const r2 = (color2 & 1) * mult * 255;
  const g = (color2 >> 1 & 1) * mult * 255;
  const b = (color2 >> 2 & 1) * mult * 255;
  return [r2, g, b];
};
convert$1.ansi256.rgb = function(args) {
  if (args >= 232) {
    const c = (args - 232) * 10 + 8;
    return [c, c, c];
  }
  args -= 16;
  let rem;
  const r2 = Math.floor(args / 36) / 5 * 255;
  const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b = rem % 6 / 5 * 255;
  return [r2, g, b];
};
convert$1.rgb.hex = function(args) {
  const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
  const string2 = integer.toString(16).toUpperCase();
  return "000000".substring(string2.length) + string2;
};
convert$1.hex.rgb = function(args) {
  const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  let colorString = match[0];
  if (match[0].length === 3) {
    colorString = colorString.split("").map((char) => {
      return char + char;
    }).join("");
  }
  const integer = parseInt(colorString, 16);
  const r2 = integer >> 16 & 255;
  const g = integer >> 8 & 255;
  const b = integer & 255;
  return [r2, g, b];
};
convert$1.rgb.hcg = function(rgb) {
  const r2 = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max2 = Math.max(Math.max(r2, g), b);
  const min2 = Math.min(Math.min(r2, g), b);
  const chroma = max2 - min2;
  let grayscale;
  let hue2;
  if (chroma < 1) {
    grayscale = min2 / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue2 = 0;
  } else if (max2 === r2) {
    hue2 = (g - b) / chroma % 6;
  } else if (max2 === g) {
    hue2 = 2 + (b - r2) / chroma;
  } else {
    hue2 = 4 + (r2 - g) / chroma;
  }
  hue2 /= 6;
  hue2 %= 1;
  return [hue2 * 360, chroma * 100, grayscale * 100];
};
convert$1.hsl.hcg = function(hsl) {
  const s = hsl[1] / 100;
  const l2 = hsl[2] / 100;
  const c = l2 < 0.5 ? 2 * s * l2 : 2 * s * (1 - l2);
  let f = 0;
  if (c < 1) {
    f = (l2 - 0.5 * c) / (1 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert$1.hsv.hcg = function(hsv) {
  const s = hsv[1] / 100;
  const v2 = hsv[2] / 100;
  const c = s * v2;
  let f = 0;
  if (c < 1) {
    f = (v2 - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert$1.hcg.rgb = function(hcg) {
  const h = hcg[0] / 360;
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  if (c === 0) {
    return [g * 255, g * 255, g * 255];
  }
  const pure = [0, 0, 0];
  const hi2 = h % 1 * 6;
  const v2 = hi2 % 1;
  const w = 1 - v2;
  let mg2 = 0;
  switch (Math.floor(hi2)) {
    case 0:
      pure[0] = 1;
      pure[1] = v2;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v2;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v2;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  mg2 = (1 - c) * g;
  return [
    (c * pure[0] + mg2) * 255,
    (c * pure[1] + mg2) * 255,
    (c * pure[2] + mg2) * 255
  ];
};
convert$1.hcg.hsv = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v2 = c + g * (1 - c);
  let f = 0;
  if (v2 > 0) {
    f = c / v2;
  }
  return [hcg[0], f * 100, v2 * 100];
};
convert$1.hcg.hsl = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const l2 = g * (1 - c) + 0.5 * c;
  let s = 0;
  if (l2 > 0 && l2 < 0.5) {
    s = c / (2 * l2);
  } else if (l2 >= 0.5 && l2 < 1) {
    s = c / (2 * (1 - l2));
  }
  return [hcg[0], s * 100, l2 * 100];
};
convert$1.hcg.hwb = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v2 = c + g * (1 - c);
  return [hcg[0], (v2 - c) * 100, (1 - v2) * 100];
};
convert$1.hwb.hcg = function(hwb) {
  const w = hwb[1] / 100;
  const b = hwb[2] / 100;
  const v2 = 1 - b;
  const c = v2 - w;
  let g = 0;
  if (c < 1) {
    g = (v2 - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert$1.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert$1.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert$1.gray.rgb = function(args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert$1.gray.hsl = function(args) {
  return [0, 0, args[0]];
};
convert$1.gray.hsv = convert$1.gray.hsl;
convert$1.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert$1.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert$1.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert$1.gray.hex = function(gray) {
  const val = Math.round(gray[0] / 100 * 255) & 255;
  const integer = (val << 16) + (val << 8) + val;
  const string2 = integer.toString(16).toUpperCase();
  return "000000".substring(string2.length) + string2;
};
convert$1.rgb.gray = function(rgb) {
  const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
const conversions$1 = conversions$2;
function buildGraph() {
  const graph = {};
  const models2 = Object.keys(conversions$1);
  for (let len = models2.length, i = 0; i < len; i++) {
    graph[models2[i]] = {
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  const graph = buildGraph();
  const queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions$1[current]);
    for (let len = adjacents.length, i = 0; i < len; i++) {
      const adjacent = adjacents[i];
      const node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from2, to2) {
  return function(args) {
    return to2(from2(args));
  };
}
function wrapConversion(toModel, graph) {
  const path = [graph[toModel].parent, toModel];
  let fn = conversions$1[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions$1[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path;
  return fn;
}
var route$1 = function(fromModel) {
  const graph = deriveBFS(fromModel);
  const conversion = {};
  const models2 = Object.keys(graph);
  for (let len = models2.length, i = 0; i < len; i++) {
    const toModel = models2[i];
    const node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
const conversions = conversions$2;
const route = route$1;
const convert = {};
const models = Object.keys(conversions);
function wrapRaw(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    return fn(args);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    const result = fn(args);
    if (typeof result === "object") {
      for (let len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach((fromModel) => {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
  Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
  const routes = route(fromModel);
  const routeModels = Object.keys(routes);
  routeModels.forEach((toModel) => {
    const fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;
(function(module2) {
  const wrapAnsi16 = (fn, offset2) => (...args) => {
    const code = fn(...args);
    return `[${code + offset2}m`;
  };
  const wrapAnsi256 = (fn, offset2) => (...args) => {
    const code = fn(...args);
    return `[${38 + offset2};5;${code}m`;
  };
  const wrapAnsi16m = (fn, offset2) => (...args) => {
    const rgb = fn(...args);
    return `[${38 + offset2};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  const ansi2ansi = (n2) => n2;
  const rgb2rgb = (r2, g, b) => [r2, g, b];
  const setLazyProperty = (object, property, get2) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value2 = get2();
        Object.defineProperty(object, property, {
          value: value2,
          enumerable: true,
          configurable: true
        });
        return value2;
      },
      enumerable: true,
      configurable: true
    });
  };
  let colorConvert$1;
  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert$1 === void 0) {
      colorConvert$1 = colorConvert;
    }
    const offset2 = isBackground ? 10 : 0;
    const styles2 = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles2[name] = wrap(identity, offset2);
      } else if (typeof suite === "object") {
        styles2[name] = wrap(suite[targetSpace], offset2);
      }
    }
    return styles2;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles2 = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles2.color.gray = styles2.color.blackBright;
    styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
    styles2.color.grey = styles2.color.blackBright;
    styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles2)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles2[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles2[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles2, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles2, "codes", {
      value: codes,
      enumerable: false
    });
    styles2.color.close = "[39m";
    styles2.bgColor.close = "[49m";
    setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles2;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles$1);
var browser$1 = {
  stdout: false,
  stderr: false
};
const stringReplaceAll$1 = (string2, substring, replacer) => {
  let index = string2.indexOf(substring);
  if (index === -1) {
    return string2;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string2.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string2.substr(endIndex);
  return returnValue;
};
const stringEncaseCRLFWithFirstIndex$1 = (string2, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string2[index - 1] === "\r";
    returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string2.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string2.substr(endIndex);
  return returnValue;
};
var util = {
  stringReplaceAll: stringReplaceAll$1,
  stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
};
const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
const ESCAPES = new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", ""],
  ["a", "\x07"]
]);
function unescape(c) {
  const u2 = c[0] === "u";
  const bracket = c[1] === "{";
  if (u2 && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }
  if (u2 && bracket) {
    return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
  }
  return ESCAPES.get(c) || c;
}
function parseArguments(name, arguments_) {
  const results = [];
  const chunks = arguments_.trim().split(/\s*,\s*/g);
  let matches;
  for (const chunk of chunks) {
    const number2 = Number(chunk);
    if (!Number.isNaN(number2)) {
      results.push(number2);
    } else if (matches = chunk.match(STRING_REGEX)) {
      results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape2, character) => escape2 ? unescape(escape2) : character));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
  }
  return results;
}
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;
  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name = matches[1];
    if (matches[2]) {
      const args = parseArguments(name, matches[2]);
      results.push([name].concat(args));
    } else {
      results.push([name]);
    }
  }
  return results;
}
function buildStyle(chalk2, styles2) {
  const enabled = {};
  for (const layer of styles2) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }
  let current = chalk2;
  for (const [styleName, styles3] of Object.entries(enabled)) {
    if (!Array.isArray(styles3)) {
      continue;
    }
    if (!(styleName in current)) {
      throw new Error(`Unknown Chalk style: ${styleName}`);
    }
    current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
  }
  return current;
}
var templates = (chalk2, temporary) => {
  const styles2 = [];
  const chunks = [];
  let chunk = [];
  temporary.replace(TEMPLATE_REGEX, (m2, escapeCharacter, inverse, style, close, character) => {
    if (escapeCharacter) {
      chunk.push(unescape(escapeCharacter));
    } else if (style) {
      const string2 = chunk.join("");
      chunk = [];
      chunks.push(styles2.length === 0 ? string2 : buildStyle(chalk2, styles2)(string2));
      styles2.push({ inverse, styles: parseStyle(style) });
    } else if (close) {
      if (styles2.length === 0) {
        throw new Error("Found extraneous } in Chalk template literal");
      }
      chunks.push(buildStyle(chalk2, styles2)(chunk.join("")));
      chunk = [];
      styles2.pop();
    } else {
      chunk.push(character);
    }
  });
  chunks.push(chunk.join(""));
  if (styles2.length > 0) {
    const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(errMessage);
  }
  return chunks.join("");
};
const ansiStyles = ansiStyles$1.exports;
const { stdout: stdoutColor, stderr: stderrColor } = browser$1;
const {
  stringReplaceAll,
  stringEncaseCRLFWithFirstIndex
} = util;
const { isArray: isArray$1 } = Array;
const levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
class ChalkClass {
  constructor(options) {
    return chalkFactory(options);
  }
}
const chalkFactory = (options) => {
  const chalk2 = {};
  applyOptions(chalk2, options);
  chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
  Object.setPrototypeOf(chalk2, Chalk.prototype);
  Object.setPrototypeOf(chalk2.template, chalk2);
  chalk2.template.constructor = () => {
    throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
  };
  chalk2.template.Instance = ChalkClass;
  return chalk2.template;
};
function Chalk(options) {
  return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
for (const model of usedModels) {
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
const proto$3 = Object.defineProperties(() => {
}, __spreadProps(__spreadValues({}, styles), {
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    }
  }
}));
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    if (isArray$1(arguments_[0]) && isArray$1(arguments_[0].raw)) {
      return applyStyle(builder, chalkTag(builder, ...arguments_));
    }
    return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  };
  Object.setPrototypeOf(builder, proto$3);
  builder._generator = self2;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const applyStyle = (self2, string2) => {
  if (self2.level <= 0 || !string2) {
    return self2._isEmpty ? "" : string2;
  }
  let styler = self2._styler;
  if (styler === void 0) {
    return string2;
  }
  const { openAll, closeAll } = styler;
  if (string2.indexOf("") !== -1) {
    while (styler !== void 0) {
      string2 = stringReplaceAll(string2, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string2.indexOf("\n");
  if (lfIndex !== -1) {
    string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
  }
  return openAll + string2 + closeAll;
};
let template;
const chalkTag = (chalk2, ...strings) => {
  const [firstString] = strings;
  if (!isArray$1(firstString) || !isArray$1(firstString.raw)) {
    return strings.join(" ");
  }
  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];
  for (let i = 1; i < firstString.length; i++) {
    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
  }
  if (template === void 0) {
    template = templates;
  }
  return template(chalk2, parts.join(""));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk();
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
chalk.stderr.supportsColor = stderrColor;
var source = chalk;
Object.defineProperty(log$1, "__esModule", {
  value: true
});
log$1.dim = dim;
log$1.default = void 0;
var _chalk$1 = _interopRequireDefault$5(source);
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
let alreadyShown = new Set();
function log(chalk2, messages, key) {
  if (key && alreadyShown.has(key))
    return;
  if (key)
    alreadyShown.add(key);
  console.warn("");
  messages.forEach((message) => console.warn(chalk2, "-", message));
}
function dim(input) {
  return _chalk$1.default.dim(input);
}
var _default$3 = {
  info(key, messages) {
    log(_chalk$1.default.bold.cyan("info"), ...Array.isArray(key) ? [
      key
    ] : [
      messages,
      key
    ]);
  },
  warn(key, messages) {
    log(_chalk$1.default.bold.yellow("warn"), ...Array.isArray(key) ? [
      key
    ] : [
      messages,
      key
    ]);
  },
  risk(key, messages) {
    log(_chalk$1.default.bold.magenta("risk"), ...Array.isArray(key) ? [
      key
    ] : [
      messages,
      key
    ]);
  }
};
log$1.default = _default$3;
Object.defineProperty(colors, "__esModule", {
  value: true
});
colors.default = void 0;
var _log$2 = _interopRequireDefault$4(log$1);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function warn$1({ version: version2, from: from2, to: to2 }) {
  _log$2.default.warn(`${from2}-color-renamed`, [
    `As of Tailwind CSS ${version2}, \`${from2}\` has been renamed to \`${to2}\`.`,
    "Update your configuration file to silence this warning."
  ]);
}
var _default$2 = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337"
  },
  get lightBlue() {
    warn$1({
      version: "v2.2",
      from: "lightBlue",
      to: "sky"
    });
    return this.sky;
  },
  get warmGray() {
    warn$1({
      version: "v3.0",
      from: "warmGray",
      to: "stone"
    });
    return this.stone;
  },
  get trueGray() {
    warn$1({
      version: "v3.0",
      from: "trueGray",
      to: "neutral"
    });
    return this.neutral;
  },
  get coolGray() {
    warn$1({
      version: "v3.0",
      from: "coolGray",
      to: "gray"
    });
    return this.gray;
  },
  get blueGray() {
    warn$1({
      version: "v3.0",
      from: "blueGray",
      to: "slate"
    });
    return this.slate;
  }
};
colors.default = _default$2;
var defaults$4 = {};
Object.defineProperty(defaults$4, "__esModule", {
  value: true
});
defaults$4.defaults = defaults$3;
function defaults$3(target, ...sources) {
  for (let source2 of sources) {
    for (let k in source2) {
      var ref;
      if (!(target === null || target === void 0 ? void 0 : (ref = target.hasOwnProperty) === null || ref === void 0 ? void 0 : ref.call(target, k))) {
        target[k] = source2[k];
      }
    }
    for (let k1 of Object.getOwnPropertySymbols(source2)) {
      var ref1;
      if (!(target === null || target === void 0 ? void 0 : (ref1 = target.hasOwnProperty) === null || ref1 === void 0 ? void 0 : ref1.call(target, k1))) {
        target[k1] = source2[k1];
      }
    }
  }
  return target;
}
var toPath$1 = {};
Object.defineProperty(toPath$1, "__esModule", {
  value: true
});
toPath$1.toPath = toPath;
function toPath(path) {
  if (Array.isArray(path))
    return path;
  let openBrackets = path.split("[").length - 1;
  let closedBrackets = path.split("]").length - 1;
  if (openBrackets !== closedBrackets) {
    throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
  }
  return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var normalizeConfig$1 = {};
Object.defineProperty(normalizeConfig$1, "__esModule", {
  value: true
});
normalizeConfig$1.normalizeConfig = normalizeConfig;
var _log$1 = _interopRequireWildcard(log$1);
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function normalizeConfig(config2) {
  let valid = (() => {
    if (config2.purge) {
      return false;
    }
    if (!config2.content) {
      return false;
    }
    if (!Array.isArray(config2.content) && !(typeof config2.content === "object" && config2.content !== null)) {
      return false;
    }
    if (Array.isArray(config2.content)) {
      return config2.content.every((path) => {
        if (typeof path === "string")
          return true;
        if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string")
          return false;
        if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
          return false;
        }
        return true;
      });
    }
    if (typeof config2.content === "object" && config2.content !== null) {
      if (Object.keys(config2.content).some((key) => ![
        "files",
        "extract",
        "transform"
      ].includes(key))) {
        return false;
      }
      if (Array.isArray(config2.content.files)) {
        if (!config2.content.files.every((path) => {
          if (typeof path === "string")
            return true;
          if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string")
            return false;
          if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
            return false;
          }
          return true;
        })) {
          return false;
        }
        if (typeof config2.content.extract === "object") {
          for (let value2 of Object.values(config2.content.extract)) {
            if (typeof value2 !== "function") {
              return false;
            }
          }
        } else if (!(config2.content.extract === void 0 || typeof config2.content.extract === "function")) {
          return false;
        }
        if (typeof config2.content.transform === "object") {
          for (let value2 of Object.values(config2.content.transform)) {
            if (typeof value2 !== "function") {
              return false;
            }
          }
        } else if (!(config2.content.transform === void 0 || typeof config2.content.transform === "function")) {
          return false;
        }
      }
      return true;
    }
    return false;
  })();
  if (!valid) {
    _log$1.default.warn("purge-deprecation", [
      "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
      "Update your configuration file to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
    ]);
  }
  config2.safelist = (() => {
    var ref;
    let { content, purge, safelist } = config2;
    if (Array.isArray(safelist))
      return safelist;
    if (Array.isArray(content === null || content === void 0 ? void 0 : content.safelist))
      return content.safelist;
    if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.safelist))
      return purge.safelist;
    if (Array.isArray(purge === null || purge === void 0 ? void 0 : (ref = purge.options) === null || ref === void 0 ? void 0 : ref.safelist))
      return purge.options.safelist;
    return [];
  })();
  if (typeof config2.prefix === "function") {
    _log$1.default.warn("prefix-function", [
      "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
      "Update `prefix` in your configuration to be a string to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
    ]);
    config2.prefix = "";
  } else {
    var _prefix;
    config2.prefix = (_prefix = config2.prefix) !== null && _prefix !== void 0 ? _prefix : "";
  }
  config2.content = {
    files: (() => {
      let { content, purge } = config2;
      if (Array.isArray(purge))
        return purge;
      if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.content))
        return purge.content;
      if (Array.isArray(content))
        return content;
      if (Array.isArray(content === null || content === void 0 ? void 0 : content.content))
        return content.content;
      if (Array.isArray(content === null || content === void 0 ? void 0 : content.files))
        return content.files;
      return [];
    })(),
    extract: (() => {
      let extract = (() => {
        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
        if ((ref = config2.purge) === null || ref === void 0 ? void 0 : ref.extract)
          return config2.purge.extract;
        if ((ref1 = config2.content) === null || ref1 === void 0 ? void 0 : ref1.extract)
          return config2.content.extract;
        if ((ref2 = config2.purge) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.extract) === null || ref3 === void 0 ? void 0 : ref3.DEFAULT)
          return config2.purge.extract.DEFAULT;
        if ((ref4 = config2.content) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.extract) === null || ref5 === void 0 ? void 0 : ref5.DEFAULT)
          return config2.content.extract.DEFAULT;
        if ((ref6 = config2.purge) === null || ref6 === void 0 ? void 0 : (ref7 = ref6.options) === null || ref7 === void 0 ? void 0 : ref7.extractors)
          return config2.purge.options.extractors;
        if ((ref8 = config2.content) === null || ref8 === void 0 ? void 0 : (ref9 = ref8.options) === null || ref9 === void 0 ? void 0 : ref9.extractors)
          return config2.content.options.extractors;
        return {};
      })();
      let extractors = {};
      let defaultExtractor = (() => {
        var ref, ref10, ref11, ref12;
        if ((ref = config2.purge) === null || ref === void 0 ? void 0 : (ref10 = ref.options) === null || ref10 === void 0 ? void 0 : ref10.defaultExtractor) {
          return config2.purge.options.defaultExtractor;
        }
        if ((ref11 = config2.content) === null || ref11 === void 0 ? void 0 : (ref12 = ref11.options) === null || ref12 === void 0 ? void 0 : ref12.defaultExtractor) {
          return config2.content.options.defaultExtractor;
        }
        return void 0;
      })();
      if (defaultExtractor !== void 0) {
        extractors.DEFAULT = defaultExtractor;
      }
      if (typeof extract === "function") {
        extractors.DEFAULT = extract;
      } else if (Array.isArray(extract)) {
        for (let { extensions, extractor } of extract !== null && extract !== void 0 ? extract : []) {
          for (let extension of extensions) {
            extractors[extension] = extractor;
          }
        }
      } else if (typeof extract === "object" && extract !== null) {
        Object.assign(extractors, extract);
      }
      return extractors;
    })(),
    transform: (() => {
      let transform = (() => {
        var ref, ref13, ref14, ref15, ref16, ref17;
        if ((ref = config2.purge) === null || ref === void 0 ? void 0 : ref.transform)
          return config2.purge.transform;
        if ((ref13 = config2.content) === null || ref13 === void 0 ? void 0 : ref13.transform)
          return config2.content.transform;
        if ((ref14 = config2.purge) === null || ref14 === void 0 ? void 0 : (ref15 = ref14.transform) === null || ref15 === void 0 ? void 0 : ref15.DEFAULT)
          return config2.purge.transform.DEFAULT;
        if ((ref16 = config2.content) === null || ref16 === void 0 ? void 0 : (ref17 = ref16.transform) === null || ref17 === void 0 ? void 0 : ref17.DEFAULT)
          return config2.content.transform.DEFAULT;
        return {};
      })();
      let transformers = {};
      if (typeof transform === "function") {
        transformers.DEFAULT = transform;
      }
      if (typeof transform === "object" && transform !== null) {
        Object.assign(transformers, transform);
      }
      return transformers;
    })()
  };
  for (let file2 of config2.content.files) {
    if (typeof file2 === "string" && /{([^,]*?)}/g.test(file2)) {
      _log$1.default.warn("invalid-glob-braces", [
        `The glob pattern ${_log$1.dim(file2)} in your Tailwind CSS configuration is invalid.`,
        `Update it to ${_log$1.dim(file2.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
      ]);
      break;
    }
  }
  if (config2.content.files.length === 0) {
    _log$1.default.warn("content-problems", [
      "The `content` option in your Tailwind CSS configuration is missing or empty.",
      "Configure your content sources or your generated CSS will be missing styles.",
      "https://tailwindcss.com/docs/content-configuration"
    ]);
  }
  return config2;
}
var isPlainObject$2 = {};
Object.defineProperty(isPlainObject$2, "__esModule", {
  value: true
});
isPlainObject$2.default = isPlainObject$1;
function isPlainObject$1(value2) {
  if (Object.prototype.toString.call(value2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return prototype === null || prototype === Object.prototype;
}
var cloneDeep$1 = {};
Object.defineProperty(cloneDeep$1, "__esModule", {
  value: true
});
cloneDeep$1.cloneDeep = cloneDeep;
function cloneDeep(value2) {
  if (Array.isArray(value2)) {
    return value2.map((child) => cloneDeep(child));
  }
  if (typeof value2 === "object" && value2 !== null) {
    return Object.fromEntries(Object.entries(value2).map(([k, v2]) => [
      k,
      cloneDeep(v2)
    ]));
  }
  return value2;
}
Object.defineProperty(resolveConfig$3, "__esModule", {
  value: true
});
resolveConfig$3.default = resolveConfig$2;
var _negateValue = _interopRequireDefault$3(negateValue);
var _corePluginList = _interopRequireDefault$3(corePluginList);
var _configurePlugins = _interopRequireDefault$3(configurePlugins);
var _defaultConfigStub = _interopRequireDefault$3(defaultConfig_stub);
var _colors = _interopRequireDefault$3(colors);
var _defaults = defaults$4;
var _toPath = toPath$1;
var _normalizeConfig = normalizeConfig$1;
var _isPlainObject = _interopRequireDefault$3(isPlainObject$2);
var _cloneDeep = cloneDeep$1;
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function isFunction$2(input) {
  return typeof input === "function";
}
function isObject$4(input) {
  return typeof input === "object" && input !== null;
}
function mergeWith(target, ...sources) {
  let customizer = sources.pop();
  for (let source2 of sources) {
    for (let k in source2) {
      let merged = customizer(target[k], source2[k]);
      if (merged === void 0) {
        if (isObject$4(target[k]) && isObject$4(source2[k])) {
          target[k] = mergeWith(target[k], source2[k], customizer);
        } else {
          target[k] = source2[k];
        }
      } else {
        target[k] = merged;
      }
    }
  }
  return target;
}
const configUtils = {
  colors: _colors.default,
  negative(scale) {
    return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
      let negativeValue = _negateValue.default(scale[key]);
      if (negativeValue !== void 0) {
        negativeScale[`-${key}`] = negativeValue;
      }
      return negativeScale;
    }, {});
  },
  breakpoints(screens) {
    return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce((breakpoints, key) => __spreadProps(__spreadValues({}, breakpoints), {
      [`screen-${key}`]: screens[key]
    }), {});
  }
};
function value(valueToResolve, ...args) {
  return isFunction$2(valueToResolve) ? valueToResolve(...args) : valueToResolve;
}
function collectExtends(items) {
  return items.reduce((merged, { extend: extend2 }) => {
    return mergeWith(merged, extend2, (mergedValue, extendValue) => {
      if (mergedValue === void 0) {
        return [
          extendValue
        ];
      }
      if (Array.isArray(mergedValue)) {
        return [
          extendValue,
          ...mergedValue
        ];
      }
      return [
        extendValue,
        mergedValue
      ];
    });
  }, {});
}
function mergeThemes(themes) {
  return __spreadProps(__spreadValues({}, themes.reduce((merged, theme) => _defaults.defaults(merged, theme), {})), {
    extend: collectExtends(themes)
  });
}
function mergeExtensionCustomizer(merged, value1) {
  if (Array.isArray(merged) && isObject$4(merged[0])) {
    return merged.concat(value1);
  }
  if (Array.isArray(value1) && isObject$4(value1[0]) && isObject$4(merged)) {
    return [
      merged,
      ...value1
    ];
  }
  if (Array.isArray(value1)) {
    return value1;
  }
  return void 0;
}
function mergeExtensions(_a) {
  var _b = _a, { extend: extend2 } = _b, theme = __objRest(_b, ["extend"]);
  return mergeWith(theme, extend2, (themeValue, extensions) => {
    if (!isFunction$2(themeValue) && !extensions.some(isFunction$2)) {
      return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
    }
    return (resolveThemePath, utils2) => mergeWith({}, ...[
      themeValue,
      ...extensions
    ].map((e) => value(e, resolveThemePath, utils2)), mergeExtensionCustomizer);
  });
}
function resolveFunctionKeys(object) {
  const resolvePath2 = (key, defaultValue) => {
    const path = _toPath.toPath(key);
    let index = 0;
    let val = object;
    while (val !== void 0 && val !== null && index < path.length) {
      val = val[path[index++]];
      val = isFunction$2(val) ? val(resolvePath2, configUtils) : val;
    }
    if (val === void 0) {
      return defaultValue;
    }
    if (_isPlainObject.default(val)) {
      return _cloneDeep.cloneDeep(val);
    }
    return val;
  };
  resolvePath2.theme = resolvePath2;
  for (let key1 in configUtils) {
    resolvePath2[key1] = configUtils[key1];
  }
  return Object.keys(object).reduce((resolved, key) => {
    return __spreadProps(__spreadValues({}, resolved), {
      [key]: isFunction$2(object[key]) ? object[key](resolvePath2, configUtils) : object[key]
    });
  }, {});
}
function extractPluginConfigs(configs) {
  let allConfigs = [];
  configs.forEach((config2) => {
    allConfigs = [
      ...allConfigs,
      config2
    ];
    var ref1;
    const plugins = (ref1 = config2 === null || config2 === void 0 ? void 0 : config2.plugins) !== null && ref1 !== void 0 ? ref1 : [];
    if (plugins.length === 0) {
      return;
    }
    plugins.forEach((plugin) => {
      if (plugin.__isOptionsFunction) {
        plugin = plugin();
      }
      var ref;
      allConfigs = [
        ...allConfigs,
        ...extractPluginConfigs([
          (ref = plugin === null || plugin === void 0 ? void 0 : plugin.config) !== null && ref !== void 0 ? ref : {}
        ])
      ];
    });
  });
  return allConfigs;
}
function resolveCorePlugins(corePluginConfigs) {
  const result = [
    ...corePluginConfigs
  ].reduceRight((resolved, corePluginConfig) => {
    if (isFunction$2(corePluginConfig)) {
      return corePluginConfig({
        corePlugins: resolved
      });
    }
    return _configurePlugins.default(corePluginConfig, resolved);
  }, _corePluginList.default);
  return result;
}
function resolvePluginLists(pluginLists) {
  const result = [
    ...pluginLists
  ].reduceRight((resolved, pluginList) => {
    return [
      ...resolved,
      ...pluginList
    ];
  }, []);
  return result;
}
function resolveConfig$2(configs) {
  let allConfigs = [
    ...extractPluginConfigs(configs),
    {
      prefix: "",
      important: false,
      separator: ":",
      variantOrder: _defaultConfigStub.default.variantOrder
    }
  ];
  var ref, ref2;
  return _normalizeConfig.normalizeConfig(_defaults.defaults({
    theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map((t2) => {
      return (ref = t2 === null || t2 === void 0 ? void 0 : t2.theme) !== null && ref !== void 0 ? ref : {};
    })))),
    corePlugins: resolveCorePlugins(allConfigs.map((c) => c.corePlugins)),
    plugins: resolvePluginLists(configs.map((c) => {
      return (ref2 = c === null || c === void 0 ? void 0 : c.plugins) !== null && ref2 !== void 0 ? ref2 : [];
    }))
  }, ...allConfigs));
}
var getAllConfigs$1 = {};
var featureFlags$1 = {};
Object.defineProperty(featureFlags$1, "__esModule", {
  value: true
});
featureFlags$1.flagEnabled = flagEnabled;
featureFlags$1.issueFlagNotices = issueFlagNotices;
featureFlags$1.default = void 0;
var _chalk = _interopRequireDefault$2(source);
var _log = _interopRequireDefault$2(log$1);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
let defaults$2 = {
  optimizeUniversalDefaults: false
};
let featureFlags = {
  future: [],
  experimental: [
    "optimizeUniversalDefaults"
  ]
};
function flagEnabled(config2, flag) {
  if (featureFlags.future.includes(flag)) {
    var ref;
    var ref1, ref2;
    return config2.future === "all" || ((ref2 = (ref1 = config2 === null || config2 === void 0 ? void 0 : (ref = config2.future) === null || ref === void 0 ? void 0 : ref[flag]) !== null && ref1 !== void 0 ? ref1 : defaults$2[flag]) !== null && ref2 !== void 0 ? ref2 : false);
  }
  if (featureFlags.experimental.includes(flag)) {
    var ref3;
    var ref4, ref5;
    return config2.experimental === "all" || ((ref5 = (ref4 = config2 === null || config2 === void 0 ? void 0 : (ref3 = config2.experimental) === null || ref3 === void 0 ? void 0 : ref3[flag]) !== null && ref4 !== void 0 ? ref4 : defaults$2[flag]) !== null && ref5 !== void 0 ? ref5 : false);
  }
  return false;
}
function experimentalFlagsEnabled(config2) {
  if (config2.experimental === "all") {
    return featureFlags.experimental;
  }
  var ref;
  return Object.keys((ref = config2 === null || config2 === void 0 ? void 0 : config2.experimental) !== null && ref !== void 0 ? ref : {}).filter((flag) => featureFlags.experimental.includes(flag) && config2.experimental[flag]);
}
function issueFlagNotices(config2) {
  if (experimentalFlagsEnabled(config2).length > 0) {
    let changes = experimentalFlagsEnabled(config2).map((s) => _chalk.default.yellow(s)).join(", ");
    _log.default.warn("experimental-flags-enabled", [
      `You have enabled experimental features: ${changes}`,
      "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
    ]);
  }
}
var _default$1 = featureFlags;
featureFlags$1.default = _default$1;
Object.defineProperty(getAllConfigs$1, "__esModule", {
  value: true
});
getAllConfigs$1.default = getAllConfigs;
var _defaultConfigStubJs = _interopRequireDefault$1(defaultConfig_stub);
var _featureFlags = featureFlags$1;
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function getAllConfigs(config2) {
  var ref;
  const configs = ((ref = config2 === null || config2 === void 0 ? void 0 : config2.presets) !== null && ref !== void 0 ? ref : [
    _defaultConfigStubJs.default
  ]).slice().reverse().flatMap((preset) => getAllConfigs(preset instanceof Function ? preset() : preset));
  const features = {};
  const experimentals = Object.keys(features).filter((feature) => _featureFlags.flagEnabled(config2, feature)).map((feature) => features[feature]);
  return [
    config2,
    ...experimentals,
    ...configs
  ];
}
Object.defineProperty(resolveConfig$4, "__esModule", {
  value: true
});
resolveConfig$4.default = resolveConfig$1;
var _resolveConfig = _interopRequireDefault(resolveConfig$3);
var _getAllConfigs = _interopRequireDefault(getAllConfigs$1);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function resolveConfig$1(...configs) {
  let [, ...defaultConfigs] = _getAllConfigs.default(configs[0]);
  return _resolveConfig.default([
    ...configs,
    ...defaultConfigs
  ]);
}
let resolveConfig = resolveConfig$4;
var resolveConfig_1 = (resolveConfig.__esModule ? resolveConfig : { default: resolveConfig }).default;
function _objectWithoutPropertiesLoose$1(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var PropTypes = propTypes.exports;
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
var config = {
  disabled: false
};
var TransitionGroupContext = React.createContext(null);
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback2) {
    callback2 = this.setNextCallback(callback2);
    this.setState(nextState, callback2);
  };
  _proto.setNextCallback = function setNextCallback(callback2) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback2(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: null
    }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps));
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass$1(node, c);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      node && node.scrollTop;
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose$1(_this$props, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends$1({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
var ReactCSSTransition = CSSTransition;
//! moment.js
//! version : 2.29.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback2) {
  hookCallback = callback2;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject$3(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined$1(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i;
  for (i = 0; i < arr.length; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend$3(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i;
    for (i = 0; i < len; i++) {
      if (i in t2 && fun.call(this, t2[i], i, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m2) {
  if (m2._isValid == null) {
    var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m2)) {
      m2._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m2._isValid;
}
function createInvalid(flags) {
  var m2 = createUTC(NaN);
  if (flags != null) {
    extend$3(getParsingFlags(m2), flags);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i, prop, val;
  if (!isUndefined$1(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined$1(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined$1(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined$1(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined$1(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined$1(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined$1(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined$1(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined$1(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined$1(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentProperties.length > 0) {
    for (i = 0; i < momentProperties.length; i++) {
      prop = momentProperties[i];
      val = from2[prop];
      if (!isUndefined$1(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend$3(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key;
      for (i = 0; i < arguments.length; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction$1(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set$1(config2) {
  var prop, i;
  for (i in config2) {
    if (hasOwnProp(config2, i)) {
      prop = config2[i];
      if (isFunction$1(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend$3({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject$3(parentConfig[prop]) && isObject$3(childConfig[prop])) {
        res[prop] = {};
        extend$3(res[prop], parentConfig[prop]);
        extend$3(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$3(parentConfig[prop])) {
      res[prop] = extend$3({}, res[prop]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction$1(output) ? output.call(mom, now2) : output;
}
function zeroFill(number2, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback2) {
  var func2 = callback2;
  if (typeof callback2 === "string") {
    func2 = function() {
      return this[callback2]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func2;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func2.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(func2.apply(this, arguments), token2);
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction$1(array[i2]) ? array[i2].call(mom, format2) : array[i2];
    }
    return output;
  };
}
function formatMoment(m2, format2) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m2.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m2);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number2) {
  return this._ordinal.replace("%d", number2);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number2, withoutSuffix, string2, isFuture) {
  var output = this._relativeTime[string2];
  return isFunction$1(output) ? output(number2, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number2);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction$1(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u2;
  for (u2 in unitsObj) {
    if (hasOwnProp(unitsObj, u2)) {
      units.push({ unit: u2, priority: priorities[u2] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number2) {
  if (number2 < 0) {
    return Math.ceil(number2) || 0;
  } else {
    return Math.floor(number2);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value2 = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value2 = absFloor(coercedNumber);
  }
  return value2;
}
function makeGetSet(unit, keepTime) {
  return function(value2) {
    if (value2 != null) {
      set$1$1(this, unit, value2);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get$1(this, unit);
    }
  };
}
function get$1(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1$1(mom, unit, value2) {
  if (mom.isValid() && !isNaN(value2)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value2 = toInt(value2);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value2, mom.month(), daysInMonth(value2, mom.month()));
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value2);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction$1(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value2) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i;
    for (i = 0; i < prioritized.length; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction$1(this[units])) {
      return this[units](value2);
    }
  }
  return this;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction$1(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config2) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config2._strict, config2._locale);
}
function unescapeFormat(s) {
  return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
    return p1 || p2 || p3 || p4;
  }));
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback2) {
  var i, func2 = callback2;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback2)) {
    func2 = function(input, array) {
      array[callback2] = toInt(input);
    };
  }
  for (i = 0; i < token2.length; i++) {
    tokens[token2[i]] = func2;
  }
}
function addWeekParseToken(token2, callback2) {
  addParseToken(token2, function(input, array, config2, token3) {
    config2._w = config2._w || {};
    callback2(input, config2._w, config2, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config2) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config2._a, config2, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n2, x2) {
  return (n2 % x2 + x2) % x2;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config2, token2) {
  var month = config2._locale.monthsParse(input, token2, config2._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m2, format2) {
  if (!m2) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format2) {
  if (!m2) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii2, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format2 === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value2) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value2 === "string") {
    if (/^\d+$/.test(value2)) {
      value2 = toInt(value2);
    } else {
      value2 = mom.localeData().monthsParse(value2);
      if (!isNumber(value2)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value2));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value2, dayOfMonth);
  return mom;
}
function getSetMonth(value2) {
  if (value2 != null) {
    setMonth(this, value2);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get$1(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 12; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
  }
  for (i = 0; i < 24; i++) {
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
}
addFormatToken("Y", 0, 0, function() {
  var y2 = this.year();
  return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y2, m2, d, h, M2, s, ms) {
  var date2;
  if (y2 < 100 && y2 >= 0) {
    date2 = new Date(y2 + 400, m2, d, h, M2, s, ms);
    if (isFinite(date2.getFullYear())) {
      date2.setFullYear(y2);
    }
  } else {
    date2 = new Date(y2, m2, d, h, M2, s, ms);
  }
  return date2;
}
function createUTCDate(y2) {
  var date2, args;
  if (y2 < 100 && y2 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y2 + 400;
    date2 = new Date(Date.UTC.apply(null, args));
    if (isFinite(date2.getUTCFullYear())) {
      date2.setUTCFullYear(y2);
    }
  } else {
    date2 = new Date(Date.UTC.apply(null, arguments));
  }
  return date2;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config2, token2) {
  week[token2.substr(0, 1)] = toInt(input);
});
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  doy: 6
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
  var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format2) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii2, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format2 === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format2 === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format2 === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config2) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config2) {
  config2._isPm = config2._locale.isPM(input);
  config2._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config2) {
  array[HOUR] = toInt(input);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input, array, config2) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input, array, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input, array, config2) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names2) {
  var i = 0, j, next, locale2, split;
  while (i < names2.length) {
    split = normalizeLocale(names2[i]).split("-");
    j = split.length;
    next = normalizeLocale(names2[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined$1(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("Locale " + key + " not found. Did you forget to load it?");
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config2) {
  if (config2 !== null) {
    var locale2, parentConfig = baseConfig;
    config2.abbr = name;
    if (locales[name] != null) {
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
      parentConfig = locales[name]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale2 = loadLocale(config2.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x2) {
        defineLocale(x2.name, x2.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config2) {
  if (config2 != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config2));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name;
      }
      locale2 = new Locale(config2);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m2) {
  var overflow, a = m2._a;
  if (a && getParsingFlags(m2).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i, l2, string2 = config2._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat;
  if (match) {
    getParsingFlags(config2).iso = true;
    for (i = 0, l2 = isoDates.length; i < l2; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l2 = isoTimes.length; i < l2; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m2 = hm % 100, h = (hm - m2) / 100;
    return h * 60 + m2;
  }
}
function configFromRFC2822(config2) {
  var match = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
    if (!checkWeekday(match[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match[8], match[9], match[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config2) {
  config2._d = new Date(config2._i + (config2._useUTC ? " UTC" : ""));
});
function defaults$1(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i, date2, input = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults$1(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date2 = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date2.getUTCMonth();
    config2._a[DATE] = date2.getUTCDate();
  }
  for (i = 0; i < 3 && config2._a[i] == null; ++i) {
    config2._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config2._a[i] = input[i] = config2._a[i] == null ? i === 2 ? 1 : 0 : config2._a[i];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(null, input);
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config2._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults$1(w.GG, config2._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults$1(w.W, 1);
    weekday = defaults$1(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults$1(w.gg, config2._a[YEAR], curWeek.year);
    week = defaults$1(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string2 = "" + config2._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  for (i = 0; i < tokens2.length; i++) {
    token2 = tokens2[i];
    parsedInput = (string2.match(getParseRegexForToken(token2, config2)) || [])[0];
    if (parsedInput) {
      skipped = string2.substr(0, string2.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string2 = string2.slice(string2.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string2.length > 0) {
    getParsingFlags(config2).unusedInput.push(string2);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(config2._locale, config2._a[HOUR], config2._meridiem);
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
  if (config2._f.length === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = new Date(NaN);
    return;
  }
  for (i = 0; i < config2._f.length; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend$3(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i = normalizeObjectUnits(config2._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config2._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
    return obj && parseInt(obj, 10);
  });
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input = config2._i, format2 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config2._i = input = config2._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config2._d = input;
  } else if (isArray(format2)) {
    configFromStringAndArray(config2);
  } else if (format2) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input = config2._i;
  if (isUndefined$1(input)) {
    config2._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config2._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config2);
  } else if (isArray(input)) {
    config2._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject$3(input)) {
    configFromObject(config2);
  } else if (isNumber(input)) {
    config2._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$3(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other < this ? this : other;
  } else {
    return createInvalid();
  }
}), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other > this ? this : other;
  } else {
    return createInvalid();
  }
});
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now$1 = function() {
  return Date.now ? Date.now() : +new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i = 0; i < ordering.length; ++i) {
    if (m2[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i]]) !== toInt(m2[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration2) {
  var normalizedInput = normalizeObjectUnits(duration2), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number2) {
  if (number2 < 0) {
    return Math.round(-1 * number2) * -1;
  } else {
    return Math.round(number2);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string2) {
  var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined$1(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration2 = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration2 = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration2 = {};
    if (key) {
      duration2[key] = +input;
    } else {
      duration2.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration2 = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration2 = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration2 == null) {
    duration2 = {};
  } else if (typeof duration2 === "object" && ("from" in duration2 || "to" in duration2)) {
    diffRes = momentsDifference(createLocal(duration2.from), createLocal(duration2.to));
    duration2 = {};
    duration2.ms = diffRes.milliseconds;
    duration2.M = diffRes.months;
  }
  ret = new Duration(duration2);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration2, isAdding, updateOffset) {
  var milliseconds2 = duration2._milliseconds, days2 = absRound(duration2._days), months2 = absRound(duration2._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get$1(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1$1(mom, "Date", get$1(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString$1(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString$1(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject$3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property;
  for (i = 0; i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString$1(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject$3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0; i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats2) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats2 = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats2 = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats2 = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats2 && (isFunction$1(formats2[format2]) ? formats2[format2].call(this, now2) : formats2[format2]);
  return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween$1(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$1() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(m2, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  if (isFunction$1(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(m2, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func2 = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func2 = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func2 + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
  if (key === void 0) {
    return this.localeData();
  } else {
    return this.locale(key);
  }
});
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y2, m2, d) {
  if (y2 < 100 && y2 >= 0) {
    return new Date(y2 + 400, m2, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y2, m2, d).valueOf();
  }
}
function utcStartOfDate(y2, m2, d) {
  if (y2 < 100 && y2 >= 0) {
    return Date.UTC(y2 + 400, m2, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y2, m2, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend$3({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config2, token2) {
  var era = config2._locale.erasParse(input, token2, config2._strict);
  if (era) {
    getParsingFlags(config2).era = era;
  } else {
    getParsingFlags(config2).invalidEra = input;
  }
});
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config2, token2) {
  var match;
  if (config2._locale._eraYearOrdinalRegex) {
    match = input.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array[YEAR] = config2._locale.eraYearOrdinalParse(input, match);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m2, format2) {
  var i, l2, date2, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date2 = hooks(eras[i].since).startOf("day");
        eras[i].since = date2.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date2 = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date2.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l2, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l2, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l2, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l2, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l2, dir, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l2, eras = this.eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    namePieces.push(regexEscape(eras[i].name));
    abbrPieces.push(regexEscape(eras[i].abbr));
    narrowPieces.push(regexEscape(eras[i].narrow));
    mixedPieces.push(regexEscape(eras[i].name));
    mixedPieces.push(regexEscape(eras[i].abbr));
    mixedPieces.push(regexEscape(eras[i].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config2, token2) {
  week[token2.substr(0, 2)] = toInt(input);
});
addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date2.getUTCFullYear());
  this.month(date2.getUTCMonth());
  this.date(date2.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config2) {
  config2._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween$1;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString$1;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string2) {
  return string2;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set$1;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber(format2)) {
    index = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1$1(format2, index, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index != null) {
    return get$1$1(format2, (index + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number2) {
    var b = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number2 + output;
  }
});
hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration2, input, value2, direction) {
  var other = createDuration(input, value2);
  duration2._milliseconds += direction * other._milliseconds;
  duration2._days += direction * other._days;
  duration2._months += direction * other._months;
  return duration2._bubble();
}
function add$1(input, value2) {
  return addSubtract$1(this, input, value2, 1);
}
function subtract$1(input, value2) {
  return addSubtract$1(this, input, value2, -1);
}
function absCeil(number2) {
  if (number2 < 0) {
    return Math.floor(number2);
  } else {
    return Math.ceil(number2);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  s: 45,
  m: 45,
  h: 22,
  d: 26,
  w: null,
  M: 11
};
function substituteTimeAgo(string2, number2, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number2 || 1, !!withoutSuffix, string2, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration2 = createDuration(posNegDuration).abs(), seconds2 = round(duration2.as("s")), minutes2 = round(duration2.as("m")), hours2 = round(duration2.as("h")), days2 = round(duration2.as("d")), months2 = round(duration2.as("M")), weeks2 = round(duration2.as("w")), years2 = round(duration2.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th2 = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th2 = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th2.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th2, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config2) {
  config2._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config2) {
  config2._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.29.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now$1;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm",
  TIME_SECONDS: "HH:mm:ss",
  TIME_MS: "HH:mm:ss.SSS",
  WEEK: "GGGG-[W]WW",
  MONTH: "YYYY-MM"
};
/*!
  * chartjs-adapter-moment v1.0.0
  * https://www.chartjs.org
  * (c) 2021 chartjs-adapter-moment Contributors
  * Released under the MIT license
  */
const FORMATS = {
  datetime: "MMM D, YYYY, h:mm:ss a",
  millisecond: "h:mm:ss.SSS a",
  second: "h:mm:ss a",
  minute: "h:mm a",
  hour: "hA",
  day: "MMM D",
  week: "ll",
  month: "MMM YYYY",
  quarter: "[Q]Q - YYYY",
  year: "YYYY"
};
adapters._date.override(typeof hooks === "function" ? {
  _id: "moment",
  formats: function() {
    return FORMATS;
  },
  parse: function(value2, format2) {
    if (typeof value2 === "string" && typeof format2 === "string") {
      value2 = hooks(value2, format2);
    } else if (!(value2 instanceof hooks)) {
      value2 = hooks(value2);
    }
    return value2.isValid() ? value2.valueOf() : null;
  },
  format: function(time, format2) {
    return hooks(time).format(format2);
  },
  add: function(time, amount, unit) {
    return hooks(time).add(amount, unit).valueOf();
  },
  diff: function(max2, min2, unit) {
    return hooks(max2).diff(hooks(min2), unit);
  },
  startOf: function(time, unit, weekday) {
    time = hooks(time);
    if (unit === "isoWeek") {
      weekday = Math.trunc(Math.min(Math.max(0, weekday), 6));
      return time.isoWeekday(weekday).startOf("day").valueOf();
    }
    return time.startOf(unit).valueOf();
  },
  endOf: function(time, unit) {
    return hooks(time).endOf(unit).valueOf();
  }
} : {});
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value2) => value2 instanceof Date;
var isNullOrUndefined = (value2) => value2 == null;
const isObjectType = (value2) => typeof value2 === "object";
var isObject$2 = (value2) => !isNullOrUndefined(value2) && !Array.isArray(value2) && isObjectType(value2) && !isDateObject(value2);
var getEventValue = (event) => isObject$2(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names2, name) => names2.has(getNodeParentName(name));
var compact = (value2) => Array.isArray(value2) ? value2.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (obj, path, defaultValue) => {
  if (!path || !isObject$2(obj)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], obj);
  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;
};
const EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
const HookFormContext = React.createContext(null);
const useFormContext = () => React.useContext(HookFormContext);
var getProxyFormState = (formState, _proxyFormState, localProxyFormState, isRoot = true) => {
  const result = {};
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (_proxyFormState[_key] !== VALIDATION_MODE.all) {
          _proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value2) => isObject$2(value2) && !Object.keys(value2).length;
var shouldRenderFormState = (formStateData, _proxyFormState, isRoot) => {
  const _a = formStateData, { name } = _a, formState = __objRest(_a, ["name"]);
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value2) => Array.isArray(value2) ? value2 : [value2];
var shouldSubscribeByName = (name, signalName, exact) => exact && signalName ? name === signalName : !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = React.useRef(props);
  _props.current = props;
  React.useEffect(() => {
    const tearDown = (subscription2) => {
      if (subscription2) {
        subscription2.unsubscribe();
      }
    };
    const subscription = !props.disabled && _props.current.subject.subscribe({
      next: _props.current.callback
    });
    return () => tearDown(subscription);
  }, [props.disabled]);
}
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = React.useRef(name);
  const _mounted = React.useRef(true);
  _name.current = name;
  const callback2 = React.useCallback((value2) => _mounted.current && shouldSubscribeByName(_name.current, value2.name, exact) && shouldRenderFormState(value2, _localProxyFormState.current) && updateFormState(__spreadValues(__spreadValues({}, control._formState), value2)), [control, exact]);
  useSubscribe({
    disabled,
    callback: callback2,
    subject: control._subjects.state
  });
  React.useEffect(() => {
    _mounted.current = true;
    return () => {
      _mounted.current = false;
    };
  }, []);
  return getProxyFormState(formState, control._proxyFormState, _localProxyFormState.current, false);
}
var isString = (value2) => typeof value2 === "string";
var generateWatchOutput = (names2, _names, formValues, isGlobal) => {
  const isArray2 = Array.isArray(names2);
  if (isString(names2)) {
    isGlobal && _names.watch.add(names2);
    return get(formValues, names2);
  }
  if (isArray2) {
    return names2.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
var isFunction = (value2) => typeof value2 === "function";
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact } = props || {};
  const _name = React.useRef(name);
  _name.current = name;
  const callback2 = React.useCallback((formState) => {
    if (shouldSubscribeByName(_name.current, formState.name, exact)) {
      const fieldValues = generateWatchOutput(_name.current, control._names, formState.values || control._formValues);
      updateValue(isUndefined(_name.current) || isObject$2(fieldValues) && !objectHasFunction(fieldValues) ? __spreadValues({}, fieldValues) : Array.isArray(fieldValues) ? [...fieldValues] : isUndefined(fieldValues) ? defaultValue : fieldValues);
    }
  }, [control, exact, defaultValue]);
  useSubscribe({
    disabled,
    subject: control._subjects.watch,
    callback: callback2
  });
  const [value2, updateValue] = React.useState(isUndefined(defaultValue) ? control._getWatch(name) : defaultValue);
  React.useEffect(() => {
    control._removeUnmounted();
  });
  return value2;
}
function useController(props) {
  const methods = useFormContext();
  const { name, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value2 = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name
  });
  const _registerProps = React.useRef(control.register(name, __spreadProps(__spreadValues({}, props.rules), {
    value: value2
  })));
  React.useEffect(() => {
    const updateMounted = (name2, value3) => {
      const field = get(control._fields, name2);
      if (field) {
        field._f.mount = value3;
      }
    };
    updateMounted(name, true);
    return () => {
      const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
      (isArrayField ? _shouldUnregisterField && !control._stateFlags.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  return {
    field: {
      name,
      value: value2,
      onChange: React.useCallback((event) => {
        _registerProps.current.onChange({
          target: {
            value: getEventValue(event),
            name
          },
          type: EVENTS.CHANGE
        });
      }, [name]),
      onBlur: React.useCallback(() => {
        _registerProps.current.onBlur({
          target: {
            value: get(control._formValues, name),
            name
          },
          type: EVENTS.BLUR
        });
      }, [name, control]),
      ref: React.useCallback((elm) => {
        const field = get(control._fields, name);
        if (elm && field && elm.focus) {
          field._f.ref = {
            focus: () => elm.focus(),
            select: () => elm.select(),
            setCustomValidity: (message) => elm.setCustomValidity(message),
            reportValidity: () => elm.reportValidity()
          };
        }
      }, [name, control._fields])
    },
    formState,
    fieldState: Object.defineProperties({}, {
      invalid: {
        get: () => !!get(formState.errors, name)
      },
      isDirty: {
        get: () => !!get(formState.dirtyFields, name)
      },
      isTouched: {
        get: () => !!get(formState.touchedFields, name)
      },
      error: {
        get: () => get(formState.errors, name)
      }
    })
  };
}
const Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? __spreadProps(__spreadValues({}, errors[name]), {
  types: __spreadProps(__spreadValues({}, errors[name] && errors[name].types ? errors[name].types : {}), {
    [type]: message || true
  })
}) : {};
var isKey = (value2) => /^\w*$/.test(value2);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
function set(object, path, value2) {
  let index = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index < length) {
    const key = tempPath[index];
    let newValue = value2;
    if (index !== lastIndex) {
      const objValue = object[key];
      newValue = isObject$2(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
}
const focusFieldBy = (fields, callback2, fieldsNames) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const _a = field, { _f } = _a, currentField = __objRest(_a, ["_f"]);
      if (_f && callback2(_f.name)) {
        if (_f.ref.focus && isUndefined(_f.ref.focus())) {
          break;
        } else if (_f.refs) {
          _f.refs[0].focus();
          break;
        }
      } else if (isObject$2(currentField)) {
        focusFieldBy(currentField, callback2);
      }
    }
  }
};
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = compact(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isBoolean = (value2) => typeof value2 === "boolean";
var isFileInput = (element) => element.type === "file";
var isMessage = (value2) => isString(value2) || React.isValidElement(value2);
var isRadioInput = (element) => element.type === "radio";
var isRegex = (value2) => value2 instanceof RegExp;
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult : defaultResult;
  }
  return defaultResult;
};
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject$2(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, inputValue, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required: required2, maxLength, minLength, min: min2, max: max2, pattern, validate: validate2, name, valueAsNumber, mount, disabled } = field._f;
  if (!mount || disabled) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || " ");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && !ref.value || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = __spreadValues({
      type: exceedMax ? maxType : minType,
      message,
      ref
    }, appendErrorsCurry(exceedMax ? maxType : minType, message));
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required2 && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value: value2, message } = isMessage(required2) ? { value: !!required2, message: required2 } : getValueAndMessage(required2);
    if (value2) {
      error[name] = __spreadValues({
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef
      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || +inputValue;
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      if (isString(maxOutput.value)) {
        exceedMax = valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value)) {
        exceedMin = valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = __spreadValues({
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref
      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate2) {
    if (isFunction(validate2)) {
      const result = await validate2(inputValue);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = __spreadValues(__spreadValues({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject$2(validate2)) {
      let validationResult = {};
      for (const key in validate2) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate2[key](inputValue), inputRef, key);
        if (validateError) {
          validationResult = __spreadValues(__spreadValues({}, validateError), appendErrorsCurry(key, validateError.message));
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = __spreadValues({
          ref: inputRef
        }, validationResult);
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy;
  const isArray2 = Array.isArray(data);
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray2 || isObject$2(data))) {
    copy = isArray2 ? [] : {};
    for (const key in data) {
      if (isFunction(data[key])) {
        copy = data;
        break;
      }
      copy[key] = cloneObject(data[key]);
    }
  } else {
    return data;
  }
  return copy;
}
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index = 0;
  while (index < length) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (!isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const updatePath = isKey(path) ? [path] : stringToPath(path);
  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);
  const key = updatePath[updatePath.length - 1];
  let previousObjRef;
  if (childObject) {
    delete childObject[key];
  }
  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {
    let index = -1;
    let objectRef;
    const currentPaths = updatePath.slice(0, -(k + 1));
    const currentPathsLength = currentPaths.length - 1;
    if (k > 0) {
      previousObjRef = object;
    }
    while (++index < currentPaths.length) {
      const item = currentPaths[index];
      objectRef = objectRef ? objectRef[item] : object[item];
      if (currentPathsLength === index && (isObject$2(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && isEmptyArray(objectRef))) {
        previousObjRef ? delete previousObjRef[item] : delete object[item];
      }
      previousObjRef = objectRef;
    }
  }
  return object;
}
function createSubject() {
  let _observers = [];
  const next = (value2) => {
    for (const observer of _observers) {
      observer.next(value2);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o) => o !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
}
var isPrimitive = (value2) => isNullOrUndefined(value2) || !isObjectType(value2);
function deepEqual$1(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject$2(val1) && isObject$2(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual$1(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isHTMLElement = (value2) => {
  const owner = value2 ? value2.ownerDocument : 0;
  const ElementClass = owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement;
  return value2 instanceof ElementClass;
};
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject$2(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject$2(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject$2(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject$2(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : __spreadValues({}, markFieldsDirty(data[key]));
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual$1(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value2, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value2) ? value2 : valueAsNumber ? value2 === "" || isNullOrUndefined(value2) ? NaN : +value2 : valueAsDate && isString(value2) ? new Date(value2) : setValueAs ? setValueAs(value2) : value2;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (_f.refs ? _f.refs.every((ref2) => ref2.disabled) : ref.disabled) {
    return;
  }
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value: value2 }) => value2);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? void 0 : isRegex(rule) ? rule.source : isObject$2(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names2 = name.split(".");
  while (names2.length) {
    const fieldName = names2.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names2.pop();
  }
  return {
    name
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
const defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = __spreadValues(__spreadValues({}, defaultOptions), props);
  let _formState = {
    isDirty: false,
    isValidating: false,
    dirtyFields: {},
    isSubmitted: false,
    submitCount: 0,
    touchedFields: {},
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    errors: {}
  };
  let _fields = {};
  let _defaultValues = cloneObject(_options.defaultValues) || {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _stateFlags = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: new Set(),
    unMount: new Set(),
    array: new Set(),
    watch: new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  let validateFields = {};
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    watch: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce2 = (callback2) => (wait) => {
    clearTimeout(timer);
    timer = window.setTimeout(callback2, wait);
  };
  const _updateValid = async (shouldSkipRender) => {
    let isValid2 = false;
    if (_proxyFormState.isValid) {
      isValid2 = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (!shouldSkipRender && isValid2 !== _formState.isValid) {
        _formState.isValid = isValid2;
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
    return isValid2;
  };
  const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method) {
      _stateFlags.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (_proxyFormState.errors && shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value2, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value2) ? get(_defaultValues, name) : value2);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _stateFlags.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let isFieldDirty = false;
    const output = {
      name
    };
    const isPreviousFieldTouched = get(_formState.touchedFields, name);
    if (_proxyFormState.isDirty) {
      const isPreviousFormDirty = _formState.isDirty;
      _formState.isDirty = output.isDirty = _getDirty();
      isFieldDirty = isPreviousFormDirty !== output.isDirty;
    }
    if (_proxyFormState.dirtyFields && (!isBlurEvent || shouldDirty)) {
      const isPreviousFieldDirty = get(_formState.dirtyFields, name);
      const isCurrentFieldPristine = deepEqual$1(get(_defaultValues, name), fieldValue);
      isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
      output.dirtyFields = _formState.dirtyFields;
      isFieldDirty = isFieldDirty || isPreviousFieldDirty !== get(_formState.dirtyFields, name);
    }
    if (isBlurEvent && !isPreviousFieldTouched) {
      set(_formState.touchedFields, name, isBlurEvent);
      output.touchedFields = _formState.touchedFields;
      isFieldDirty = isFieldDirty || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
    }
    isFieldDirty && shouldRender && _subjects.state.next(output);
    return isFieldDirty ? output : {};
  };
  const shouldRenderByError = async (name, isValid2, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && _formState.isValid !== isValid2;
    if (props.delayError && error) {
      delayErrorCallback = debounce2(() => updateErrors(name, error));
      delayErrorCallback(props.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual$1(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = __spreadProps(__spreadValues(__spreadValues({}, fieldState), shouldUpdateValid ? { isValid: isValid2 } : {}), {
        errors: _formState.errors,
        name
      });
      _formState = __spreadValues(__spreadValues({}, _formState), updatedFormState);
      _subjects.state.next(updatedFormState);
    }
    validateFields[name]--;
    if (_proxyFormState.isValidating && !Object.values(validateFields).some((v2) => v2)) {
      _subjects.state.next({
        isValidating: false
      });
      validateFields = {};
    }
  };
  const _executeSchema = async (name) => _options.resolver ? await _options.resolver(__spreadValues({}, _formValues), _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation)) : {};
  const executeSchemaAndUpdateState = async (names2) => {
    const { errors } = await _executeSchema();
    if (names2) {
      for (const name of names2) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const _a = field, { _f } = _a, fieldValue = __objRest(_a, ["_f"]);
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const fieldError = await validateField(field, get(_formValues, _f.name), shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation, isFieldArrayRoot);
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        fieldValue && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = new Set();
  };
  const _getDirty = (name, data) => (name && data && set(_formValues, name, data), !deepEqual$1(getValues(), _defaultValues));
  const _getWatch = (names2, defaultValue, isGlobal) => {
    const fieldValues = __spreadValues({}, _stateFlags.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names2) ? { [names2]: defaultValue } : defaultValue);
    return generateWatchOutput(names2, _names, fieldValues, isGlobal);
  };
  const _getFieldArray = (name) => compact(get(_stateFlags.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value2, options = {}) => {
    const field = get(_fields, name);
    let fieldValue = value2;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value2, fieldReference));
        fieldValue = isWeb && isHTMLElement(fieldReference.ref) && isNullOrUndefined(value2) ? "" : value2;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((selectRef) => selectRef.selected = fieldValue.includes(selectRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => !checkboxRef.disabled && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.watch.next({
              name
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value2, options) => {
    for (const fieldKey in value2) {
      const fieldValue = value2[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value2, options = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value2);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: _formValues
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
        _subjects.state.next({
          name,
          dirtyFields: _formState.dirtyFields,
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({});
    _subjects.watch.next({
      name
    });
  };
  const onChange = async (event) => {
    const target = event.target;
    let name = target.name;
    const field = get(_fields, name);
    if (field) {
      let error;
      let isValid2;
      const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.watch.next({
        name,
        type: event.type
      });
      if (shouldSkipValidation) {
        return shouldRender && _subjects.state.next(__spreadValues({ name }, watched ? {} : fieldState));
      }
      !isBlurEvent && watched && _subjects.state.next({});
      validateFields[name] = validateFields[name] ? 1 : 1;
      _subjects.state.next({
        isValidating: true
      });
      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);
        const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
        const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
        error = errorLookupResult.error;
        name = errorLookupResult.name;
        isValid2 = isEmptyObject(errors);
      } else {
        error = (await validateField(field, get(_formValues, name), shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        isValid2 = await _updateValid(true);
      }
      field._f.deps && trigger(field._f.deps);
      shouldRenderByError(name, isValid2, error, fieldState);
    }
  };
  const trigger = async (name, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    _subjects.state.next({
      isValidating: true
    });
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid2;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next(__spreadProps(__spreadValues(__spreadValues({}, !isString(name) || _proxyFormState.isValid && isValid2 !== _formState.isValid ? {} : { name }), _options.resolver ? { isValid: isValid2 } : {}), {
      errors: _formState.errors,
      isValidating: false
    }));
    options.shouldFocus && !validationResult && focusFieldBy(_fields, (key) => get(_formState.errors, key), name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = __spreadValues(__spreadValues({}, _defaultValues), _stateFlags.mount ? _formValues : {});
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name),
    error: get((formState || _formState).errors, name)
  });
  const clearErrors = (name) => {
    name ? convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName)) : _formState.errors = {};
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const setError = (name, error, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    set(_formState.errors, name, __spreadProps(__spreadValues({}, error), {
      ref
    }));
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.watch.subscribe({
    next: (info) => name(_getWatch(void 0, defaultValue), info)
  }) : _getWatch(name, defaultValue, true);
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (get(_fields, fieldName)) {
        if (!options.keepValue) {
          unset(_fields, fieldName);
          unset(_formValues, fieldName);
        }
        !options.keepError && unset(_formState.errors, fieldName);
        !options.keepDirty && unset(_formState.dirtyFields, fieldName);
        !options.keepTouched && unset(_formState.touchedFields, fieldName);
        !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
      }
    }
    _subjects.watch.next({});
    _subjects.state.next(__spreadValues(__spreadValues({}, _formState), !options.keepDirty ? {} : { isDirty: _getDirty() }));
    !options.keepIsValid && _updateValid();
  };
  const register = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled);
    set(_fields, name, {
      _f: __spreadValues(__spreadProps(__spreadValues({}, field && field._f ? field._f : { ref: { name } }), {
        name,
        mount: true
      }), options)
    });
    _names.mount.add(name);
    field ? disabledIsDefined && set(_formValues, name, options.disabled ? void 0 : get(_formValues, name, getFieldValue(field._f))) : updateValidAndValue(name, true, options.value);
    return __spreadProps(__spreadValues(__spreadValues({}, disabledIsDefined ? { disabled: options.disabled } : {}), _options.shouldUseNativeValidation ? {
      required: !!options.required,
      min: getRuleValue(options.min),
      max: getRuleValue(options.max),
      minLength: getRuleValue(options.minLength),
      maxLength: getRuleValue(options.maxLength),
      pattern: getRuleValue(options.pattern)
    } : {}), {
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: __spreadValues(__spreadValues({}, field._f), radioOrCheckbox ? {
              refs: [
                ...refs.filter(live),
                fieldRef,
                ...!!Array.isArray(get(_defaultValues, name)) ? [{}] : []
              ],
              ref: { type: fieldRef.type, name }
            } : { ref: fieldRef })
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _stateFlags.action) && _names.unMount.add(name);
        }
      }
    });
  };
  const handleSubmit = (onValid, onInvalid) => async (e) => {
    if (e) {
      e.preventDefault && e.preventDefault();
      e.persist && e.persist();
    }
    let hasNoPromiseError = true;
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    try {
      if (_options.resolver) {
        const { errors, values } = await _executeSchema();
        _formState.errors = errors;
        fieldValues = values;
      } else {
        await executeBuiltInValidation(_fields);
      }
      if (isEmptyObject(_formState.errors)) {
        _subjects.state.next({
          errors: {},
          isSubmitting: true
        });
        await onValid(fieldValues, e);
      } else {
        if (onInvalid) {
          await onInvalid(__spreadValues({}, _formState.errors), e);
        }
        _options.shouldFocusError && focusFieldBy(_fields, (key) => get(_formState.errors, key), _names.mount);
      }
    } catch (err) {
      hasNoPromiseError = false;
      throw err;
    } finally {
      _formState.isSubmitted = true;
      _subjects.state.next({
        isSubmitted: true,
        isSubmitting: false,
        isSubmitSuccessful: isEmptyObject(_formState.errors) && hasNoPromiseError,
        submitCount: _formState.submitCount + 1,
        errors: _formState.errors
      });
    }
  };
  const resetField = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, get(_defaultValues, name));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, options.defaultValue);
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, get(_defaultValues, name)) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next(__spreadValues({}, _formState));
    }
  };
  const reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues || _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const values = formValues && !isEmptyObject(formValues) ? cloneUpdatedValues : _defaultValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        for (const fieldName of _names.mount) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              try {
                if (isHTMLElement(fieldReference)) {
                  fieldReference.closest("form").reset();
                  break;
                }
              } catch (_a) {
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneUpdatedValues;
      _subjects.array.next({
        values
      });
      _subjects.watch.next({
        values
      });
    }
    _names = {
      mount: new Set(),
      unMount: new Set(),
      array: new Set(),
      watch: new Set(),
      watchAll: false,
      focus: ""
    };
    _stateFlags.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid;
    _stateFlags.watch = !!props.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: keepStateOptions.keepDirty || keepStateOptions.keepDirtyValues ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual$1(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: keepStateOptions.keepDirty || keepStateOptions.keepDirtyValues ? _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitting: false,
      isSubmitSuccessful: false
    });
  };
  const setFocus = (name, options = {}) => {
    const field = get(_fields, name)._f;
    const fieldRef = field.refs ? field.refs[0] : field.ref;
    fieldRef.focus();
    options.shouldSelect && fieldRef.select();
  };
  return {
    control: {
      register,
      unregister,
      getFieldState,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _getFieldArray,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _stateFlags() {
        return _stateFlags;
      },
      set _stateFlags(value2) {
        _stateFlags = value2;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value2) {
        _names = value2;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value2) {
        _formState = value2;
      },
      get _options() {
        return _options;
      },
      set _options(value2) {
        _options = __spreadValues(__spreadValues({}, _options), value2);
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = React.useRef();
  const [formState, updateFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    dirtyFields: {},
    isSubmitted: false,
    submitCount: 0,
    touchedFields: {},
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    errors: {}
  });
  if (_formControl.current) {
    _formControl.current.control._options = props;
  } else {
    _formControl.current = __spreadProps(__spreadValues({}, createFormControl(props)), {
      formState
    });
  }
  const control = _formControl.current.control;
  const callback2 = React.useCallback((value2) => {
    if (shouldRenderFormState(value2, control._proxyFormState, true)) {
      control._formState = __spreadValues(__spreadValues({}, control._formState), value2);
      updateFormState(__spreadValues({}, control._formState));
    }
  }, [control]);
  useSubscribe({
    subject: control._subjects.state,
    callback: callback2
  });
  React.useEffect(() => {
    if (!control._stateFlags.mount) {
      control._proxyFormState.isValid && control._updateValid();
      control._stateFlags.mount = true;
    }
    if (control._stateFlags.watch) {
      control._stateFlags.watch = false;
      control._subjects.state.next({});
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control._proxyFormState);
  return _formControl.current;
}
var lib$2 = function(e) {
  var t2 = {};
  function r2(n2) {
    if (t2[n2])
      return t2[n2].exports;
    var a = t2[n2] = { i: n2, l: false, exports: {} };
    return e[n2].call(a.exports, a, a.exports, r2), a.l = true, a.exports;
  }
  return r2.m = e, r2.c = t2, r2.d = function(e2, t3, n2) {
    r2.o(e2, t3) || Object.defineProperty(e2, t3, { enumerable: true, get: n2 });
  }, r2.r = function(e2) {
    typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
  }, r2.t = function(e2, t3) {
    if (1 & t3 && (e2 = r2(e2)), 8 & t3)
      return e2;
    if (4 & t3 && typeof e2 == "object" && e2 && e2.__esModule)
      return e2;
    var n2 = Object.create(null);
    if (r2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e2 }), 2 & t3 && typeof e2 != "string")
      for (var a in e2)
        r2.d(n2, a, function(t4) {
          return e2[t4];
        }.bind(null, a));
    return n2;
  }, r2.n = function(e2) {
    var t3 = e2 && e2.__esModule ? function() {
      return e2.default;
    } : function() {
      return e2;
    };
    return r2.d(t3, "a", t3), t3;
  }, r2.o = function(e2, t3) {
    return Object.prototype.hasOwnProperty.call(e2, t3);
  }, r2.p = "", r2(r2.s = 9);
}([function(e, t2) {
  e.exports = react.exports;
}, function(e, t2, r2) {
  var n2;
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  !function() {
    var r3 = {}.hasOwnProperty;
    function a() {
      for (var e2 = [], t3 = 0; t3 < arguments.length; t3++) {
        var n3 = arguments[t3];
        if (n3) {
          var o = typeof n3;
          if (o === "string" || o === "number")
            e2.push(n3);
          else if (Array.isArray(n3) && n3.length) {
            var i = a.apply(null, n3);
            i && e2.push(i);
          } else if (o === "object")
            for (var u2 in n3)
              r3.call(n3, u2) && n3[u2] && e2.push(u2);
        }
      }
      return e2.join(" ");
    }
    e.exports ? (a.default = a, e.exports = a) : (n2 = function() {
      return a;
    }.apply(t2, [])) === void 0 || (e.exports = n2);
  }();
}, function(e, t2, r2) {
  (function(t3) {
    var r3 = /^\s+|\s+$/g, n2 = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, o = /^0o[0-7]+$/i, i = parseInt, u2 = typeof t3 == "object" && t3 && t3.Object === Object && t3, c = typeof self == "object" && self && self.Object === Object && self, s = u2 || c || Function("return this")(), l2 = Object.prototype.toString, f = s.Symbol, d = f ? f.prototype : void 0, p2 = d ? d.toString : void 0;
    function h(e2) {
      if (typeof e2 == "string")
        return e2;
      if (y2(e2))
        return p2 ? p2.call(e2) : "";
      var t4 = e2 + "";
      return t4 == "0" && 1 / e2 == -1 / 0 ? "-0" : t4;
    }
    function m2(e2) {
      var t4 = typeof e2;
      return !!e2 && (t4 == "object" || t4 == "function");
    }
    function y2(e2) {
      return typeof e2 == "symbol" || function(e3) {
        return !!e3 && typeof e3 == "object";
      }(e2) && l2.call(e2) == "[object Symbol]";
    }
    function b(e2) {
      return e2 ? (e2 = function(e3) {
        if (typeof e3 == "number")
          return e3;
        if (y2(e3))
          return NaN;
        if (m2(e3)) {
          var t4 = typeof e3.valueOf == "function" ? e3.valueOf() : e3;
          e3 = m2(t4) ? t4 + "" : t4;
        }
        if (typeof e3 != "string")
          return e3 === 0 ? e3 : +e3;
        e3 = e3.replace(r3, "");
        var u3 = a.test(e3);
        return u3 || o.test(e3) ? i(e3.slice(2), u3 ? 2 : 8) : n2.test(e3) ? NaN : +e3;
      }(e2)) === 1 / 0 || e2 === -1 / 0 ? 17976931348623157e292 * (e2 < 0 ? -1 : 1) : e2 == e2 ? e2 : 0 : e2 === 0 ? e2 : 0;
    }
    e.exports = function(e2, t4, r4) {
      var n3, a2, o2, i2;
      return e2 = (n3 = e2) == null ? "" : h(n3), a2 = function(e3) {
        var t5 = b(e3), r5 = t5 % 1;
        return t5 == t5 ? r5 ? t5 - r5 : t5 : 0;
      }(r4), o2 = 0, i2 = e2.length, a2 == a2 && (i2 !== void 0 && (a2 = a2 <= i2 ? a2 : i2), o2 !== void 0 && (a2 = a2 >= o2 ? a2 : o2)), r4 = a2, t4 = h(t4), e2.slice(r4, r4 + t4.length) == t4;
    };
  }).call(this, r2(3));
}, function(e, t2) {
  var r2;
  r2 = function() {
    return this;
  }();
  try {
    r2 = r2 || new Function("return this")();
  } catch (e2) {
    typeof window == "object" && (r2 = window);
  }
  e.exports = r2;
}, function(e, t2, r2) {
  (function(t3) {
    var r3 = /^\[object .+?Constructor\]$/, n2 = typeof t3 == "object" && t3 && t3.Object === Object && t3, a = typeof self == "object" && self && self.Object === Object && self, o = n2 || a || Function("return this")();
    var i, u2 = Array.prototype, c = Function.prototype, s = Object.prototype, l2 = o["__core-js_shared__"], f = (i = /[^.]+$/.exec(l2 && l2.keys && l2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + i : "", d = c.toString, p2 = s.hasOwnProperty, h = s.toString, m2 = RegExp("^" + d.call(p2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), y2 = u2.splice, b = x2(o, "Map"), g = x2(Object, "create");
    function v2(e2) {
      var t4 = -1, r4 = e2 ? e2.length : 0;
      for (this.clear(); ++t4 < r4; ) {
        var n3 = e2[t4];
        this.set(n3[0], n3[1]);
      }
    }
    function C2(e2) {
      var t4 = -1, r4 = e2 ? e2.length : 0;
      for (this.clear(); ++t4 < r4; ) {
        var n3 = e2[t4];
        this.set(n3[0], n3[1]);
      }
    }
    function _(e2) {
      var t4 = -1, r4 = e2 ? e2.length : 0;
      for (this.clear(); ++t4 < r4; ) {
        var n3 = e2[t4];
        this.set(n3[0], n3[1]);
      }
    }
    function w(e2, t4) {
      for (var r4, n3, a2 = e2.length; a2--; )
        if ((r4 = e2[a2][0]) === (n3 = t4) || r4 != r4 && n3 != n3)
          return a2;
      return -1;
    }
    function S2(e2) {
      return !(!O2(e2) || (t4 = e2, f && f in t4)) && (function(e3) {
        var t5 = O2(e3) ? h.call(e3) : "";
        return t5 == "[object Function]" || t5 == "[object GeneratorFunction]";
      }(e2) || function(e3) {
        var t5 = false;
        if (e3 != null && typeof e3.toString != "function")
          try {
            t5 = !!(e3 + "");
          } catch (e4) {
          }
        return t5;
      }(e2) ? m2 : r3).test(function(e3) {
        if (e3 != null) {
          try {
            return d.call(e3);
          } catch (e4) {
          }
          try {
            return e3 + "";
          } catch (e4) {
          }
        }
        return "";
      }(e2));
      var t4;
    }
    function j(e2, t4) {
      var r4, n3, a2 = e2.__data__;
      return ((n3 = typeof (r4 = t4)) == "string" || n3 == "number" || n3 == "symbol" || n3 == "boolean" ? r4 !== "__proto__" : r4 === null) ? a2[typeof t4 == "string" ? "string" : "hash"] : a2.map;
    }
    function x2(e2, t4) {
      var r4 = function(e3, t5) {
        return e3 == null ? void 0 : e3[t5];
      }(e2, t4);
      return S2(r4) ? r4 : void 0;
    }
    function N2(e2, t4) {
      if (typeof e2 != "function" || t4 && typeof t4 != "function")
        throw new TypeError("Expected a function");
      var r4 = function() {
        var n3 = arguments, a2 = t4 ? t4.apply(this, n3) : n3[0], o2 = r4.cache;
        if (o2.has(a2))
          return o2.get(a2);
        var i2 = e2.apply(this, n3);
        return r4.cache = o2.set(a2, i2), i2;
      };
      return r4.cache = new (N2.Cache || _)(), r4;
    }
    function O2(e2) {
      var t4 = typeof e2;
      return !!e2 && (t4 == "object" || t4 == "function");
    }
    v2.prototype.clear = function() {
      this.__data__ = g ? g(null) : {};
    }, v2.prototype.delete = function(e2) {
      return this.has(e2) && delete this.__data__[e2];
    }, v2.prototype.get = function(e2) {
      var t4 = this.__data__;
      if (g) {
        var r4 = t4[e2];
        return r4 === "__lodash_hash_undefined__" ? void 0 : r4;
      }
      return p2.call(t4, e2) ? t4[e2] : void 0;
    }, v2.prototype.has = function(e2) {
      var t4 = this.__data__;
      return g ? t4[e2] !== void 0 : p2.call(t4, e2);
    }, v2.prototype.set = function(e2, t4) {
      return this.__data__[e2] = g && t4 === void 0 ? "__lodash_hash_undefined__" : t4, this;
    }, C2.prototype.clear = function() {
      this.__data__ = [];
    }, C2.prototype.delete = function(e2) {
      var t4 = this.__data__, r4 = w(t4, e2);
      return !(r4 < 0) && (r4 == t4.length - 1 ? t4.pop() : y2.call(t4, r4, 1), true);
    }, C2.prototype.get = function(e2) {
      var t4 = this.__data__, r4 = w(t4, e2);
      return r4 < 0 ? void 0 : t4[r4][1];
    }, C2.prototype.has = function(e2) {
      return w(this.__data__, e2) > -1;
    }, C2.prototype.set = function(e2, t4) {
      var r4 = this.__data__, n3 = w(r4, e2);
      return n3 < 0 ? r4.push([e2, t4]) : r4[n3][1] = t4, this;
    }, _.prototype.clear = function() {
      this.__data__ = { hash: new v2(), map: new (b || C2)(), string: new v2() };
    }, _.prototype.delete = function(e2) {
      return j(this, e2).delete(e2);
    }, _.prototype.get = function(e2) {
      return j(this, e2).get(e2);
    }, _.prototype.has = function(e2) {
      return j(this, e2).has(e2);
    }, _.prototype.set = function(e2, t4) {
      return j(this, e2).set(e2, t4), this;
    }, N2.Cache = _, e.exports = N2;
  }).call(this, r2(3));
}, function(e, t2, r2) {
  (function(t3) {
    var r3 = /^\s+|\s+$/g, n2 = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, o = /^0o[0-7]+$/i, i = parseInt, u2 = typeof t3 == "object" && t3 && t3.Object === Object && t3, c = typeof self == "object" && self && self.Object === Object && self, s = u2 || c || Function("return this")(), l2 = Object.prototype.toString, f = Math.max, d = Math.min, p2 = function() {
      return s.Date.now();
    };
    function h(e2) {
      var t4 = typeof e2;
      return !!e2 && (t4 == "object" || t4 == "function");
    }
    function m2(e2) {
      if (typeof e2 == "number")
        return e2;
      if (function(e3) {
        return typeof e3 == "symbol" || function(e4) {
          return !!e4 && typeof e4 == "object";
        }(e3) && l2.call(e3) == "[object Symbol]";
      }(e2))
        return NaN;
      if (h(e2)) {
        var t4 = typeof e2.valueOf == "function" ? e2.valueOf() : e2;
        e2 = h(t4) ? t4 + "" : t4;
      }
      if (typeof e2 != "string")
        return e2 === 0 ? e2 : +e2;
      e2 = e2.replace(r3, "");
      var u3 = a.test(e2);
      return u3 || o.test(e2) ? i(e2.slice(2), u3 ? 2 : 8) : n2.test(e2) ? NaN : +e2;
    }
    e.exports = function(e2, t4, r4) {
      var n3, a2, o2, i2, u3, c2, s2 = 0, l3 = false, y2 = false, b = true;
      if (typeof e2 != "function")
        throw new TypeError("Expected a function");
      function g(t5) {
        var r5 = n3, o3 = a2;
        return n3 = a2 = void 0, s2 = t5, i2 = e2.apply(o3, r5);
      }
      function v2(e3) {
        return s2 = e3, u3 = setTimeout(_, t4), l3 ? g(e3) : i2;
      }
      function C2(e3) {
        var r5 = e3 - c2;
        return c2 === void 0 || r5 >= t4 || r5 < 0 || y2 && e3 - s2 >= o2;
      }
      function _() {
        var e3 = p2();
        if (C2(e3))
          return w(e3);
        u3 = setTimeout(_, function(e4) {
          var r5 = t4 - (e4 - c2);
          return y2 ? d(r5, o2 - (e4 - s2)) : r5;
        }(e3));
      }
      function w(e3) {
        return u3 = void 0, b && n3 ? g(e3) : (n3 = a2 = void 0, i2);
      }
      function S2() {
        var e3 = p2(), r5 = C2(e3);
        if (n3 = arguments, a2 = this, c2 = e3, r5) {
          if (u3 === void 0)
            return v2(c2);
          if (y2)
            return u3 = setTimeout(_, t4), g(c2);
        }
        return u3 === void 0 && (u3 = setTimeout(_, t4)), i2;
      }
      return t4 = m2(t4) || 0, h(r4) && (l3 = !!r4.leading, o2 = (y2 = "maxWait" in r4) ? f(m2(r4.maxWait) || 0, t4) : o2, b = "trailing" in r4 ? !!r4.trailing : b), S2.cancel = function() {
        u3 !== void 0 && clearTimeout(u3), s2 = 0, n3 = c2 = a2 = u3 = void 0;
      }, S2.flush = function() {
        return u3 === void 0 ? i2 : w(p2());
      }, S2;
    };
  }).call(this, r2(3));
}, function(e, t2, r2) {
  (function(e2, r3) {
    var n2 = "[object Arguments]", a = "[object Map]", o = "[object Object]", i = "[object Set]", u2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, c = /^\w*$/, s = /^\./, l2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, f = /\\(\\)?/g, d = /^\[object .+?Constructor\]$/, p2 = /^(?:0|[1-9]\d*)$/, h = {};
    h["[object Float32Array]"] = h["[object Float64Array]"] = h["[object Int8Array]"] = h["[object Int16Array]"] = h["[object Int32Array]"] = h["[object Uint8Array]"] = h["[object Uint8ClampedArray]"] = h["[object Uint16Array]"] = h["[object Uint32Array]"] = true, h[n2] = h["[object Array]"] = h["[object ArrayBuffer]"] = h["[object Boolean]"] = h["[object DataView]"] = h["[object Date]"] = h["[object Error]"] = h["[object Function]"] = h[a] = h["[object Number]"] = h[o] = h["[object RegExp]"] = h[i] = h["[object String]"] = h["[object WeakMap]"] = false;
    var m2 = typeof e2 == "object" && e2 && e2.Object === Object && e2, y2 = typeof self == "object" && self && self.Object === Object && self, b = m2 || y2 || Function("return this")(), g = t2 && !t2.nodeType && t2, v2 = g && typeof r3 == "object" && r3 && !r3.nodeType && r3, C2 = v2 && v2.exports === g && m2.process, _ = function() {
      try {
        return C2 && C2.binding("util");
      } catch (e3) {
      }
    }(), w = _ && _.isTypedArray;
    function S2(e3, t3, r4, n3) {
      var a2 = -1, o2 = e3 ? e3.length : 0;
      for (n3 && o2 && (r4 = e3[++a2]); ++a2 < o2; )
        r4 = t3(r4, e3[a2], a2, e3);
      return r4;
    }
    function j(e3, t3) {
      for (var r4 = -1, n3 = e3 ? e3.length : 0; ++r4 < n3; )
        if (t3(e3[r4], r4, e3))
          return true;
      return false;
    }
    function x2(e3, t3, r4, n3, a2) {
      return a2(e3, function(e4, a3, o2) {
        r4 = n3 ? (n3 = false, e4) : t3(r4, e4, a3, o2);
      }), r4;
    }
    function N2(e3) {
      var t3 = false;
      if (e3 != null && typeof e3.toString != "function")
        try {
          t3 = !!(e3 + "");
        } catch (e4) {
        }
      return t3;
    }
    function O2(e3) {
      var t3 = -1, r4 = Array(e3.size);
      return e3.forEach(function(e4, n3) {
        r4[++t3] = [n3, e4];
      }), r4;
    }
    function k(e3) {
      var t3 = -1, r4 = Array(e3.size);
      return e3.forEach(function(e4) {
        r4[++t3] = e4;
      }), r4;
    }
    var E2, T2, I2, A2 = Array.prototype, D2 = Function.prototype, P2 = Object.prototype, F2 = b["__core-js_shared__"], M2 = (E2 = /[^.]+$/.exec(F2 && F2.keys && F2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + E2 : "", R2 = D2.toString, L2 = P2.hasOwnProperty, z2 = P2.toString, B2 = RegExp("^" + R2.call(L2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), G2 = b.Symbol, $ = b.Uint8Array, V2 = P2.propertyIsEnumerable, K2 = A2.splice, U2 = (T2 = Object.keys, I2 = Object, function(e3) {
      return T2(I2(e3));
    }), q2 = Ne2(b, "DataView"), H2 = Ne2(b, "Map"), W2 = Ne2(b, "Promise"), J2 = Ne2(b, "Set"), Z2 = Ne2(b, "WeakMap"), Q2 = Ne2(Object, "create"), Y2 = Pe2(q2), X2 = Pe2(H2), ee2 = Pe2(W2), te2 = Pe2(J2), re2 = Pe2(Z2), ne2 = G2 ? G2.prototype : void 0, ae2 = ne2 ? ne2.valueOf : void 0, oe2 = ne2 ? ne2.toString : void 0;
    function ie2(e3) {
      var t3 = -1, r4 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r4; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function ue2(e3) {
      var t3 = -1, r4 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r4; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function ce2(e3) {
      var t3 = -1, r4 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r4; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function se2(e3) {
      var t3 = -1, r4 = e3 ? e3.length : 0;
      for (this.__data__ = new ce2(); ++t3 < r4; )
        this.add(e3[t3]);
    }
    function le2(e3) {
      this.__data__ = new ue2(e3);
    }
    function fe2(e3, t3) {
      var r4 = Le2(e3) || Re2(e3) ? function(e4, t4) {
        for (var r5 = -1, n4 = Array(e4); ++r5 < e4; )
          n4[r5] = t4(r5);
        return n4;
      }(e3.length, String) : [], n3 = r4.length, a2 = !!n3;
      for (var o2 in e3)
        !t3 && !L2.call(e3, o2) || a2 && (o2 == "length" || ke2(o2, n3)) || r4.push(o2);
      return r4;
    }
    function de2(e3, t3) {
      for (var r4 = e3.length; r4--; )
        if (Me2(e3[r4][0], t3))
          return r4;
      return -1;
    }
    ie2.prototype.clear = function() {
      this.__data__ = Q2 ? Q2(null) : {};
    }, ie2.prototype.delete = function(e3) {
      return this.has(e3) && delete this.__data__[e3];
    }, ie2.prototype.get = function(e3) {
      var t3 = this.__data__;
      if (Q2) {
        var r4 = t3[e3];
        return r4 === "__lodash_hash_undefined__" ? void 0 : r4;
      }
      return L2.call(t3, e3) ? t3[e3] : void 0;
    }, ie2.prototype.has = function(e3) {
      var t3 = this.__data__;
      return Q2 ? t3[e3] !== void 0 : L2.call(t3, e3);
    }, ie2.prototype.set = function(e3, t3) {
      return this.__data__[e3] = Q2 && t3 === void 0 ? "__lodash_hash_undefined__" : t3, this;
    }, ue2.prototype.clear = function() {
      this.__data__ = [];
    }, ue2.prototype.delete = function(e3) {
      var t3 = this.__data__, r4 = de2(t3, e3);
      return !(r4 < 0) && (r4 == t3.length - 1 ? t3.pop() : K2.call(t3, r4, 1), true);
    }, ue2.prototype.get = function(e3) {
      var t3 = this.__data__, r4 = de2(t3, e3);
      return r4 < 0 ? void 0 : t3[r4][1];
    }, ue2.prototype.has = function(e3) {
      return de2(this.__data__, e3) > -1;
    }, ue2.prototype.set = function(e3, t3) {
      var r4 = this.__data__, n3 = de2(r4, e3);
      return n3 < 0 ? r4.push([e3, t3]) : r4[n3][1] = t3, this;
    }, ce2.prototype.clear = function() {
      this.__data__ = { hash: new ie2(), map: new (H2 || ue2)(), string: new ie2() };
    }, ce2.prototype.delete = function(e3) {
      return xe(this, e3).delete(e3);
    }, ce2.prototype.get = function(e3) {
      return xe(this, e3).get(e3);
    }, ce2.prototype.has = function(e3) {
      return xe(this, e3).has(e3);
    }, ce2.prototype.set = function(e3, t3) {
      return xe(this, e3).set(e3, t3), this;
    }, se2.prototype.add = se2.prototype.push = function(e3) {
      return this.__data__.set(e3, "__lodash_hash_undefined__"), this;
    }, se2.prototype.has = function(e3) {
      return this.__data__.has(e3);
    }, le2.prototype.clear = function() {
      this.__data__ = new ue2();
    }, le2.prototype.delete = function(e3) {
      return this.__data__.delete(e3);
    }, le2.prototype.get = function(e3) {
      return this.__data__.get(e3);
    }, le2.prototype.has = function(e3) {
      return this.__data__.has(e3);
    }, le2.prototype.set = function(e3, t3) {
      var r4 = this.__data__;
      if (r4 instanceof ue2) {
        var n3 = r4.__data__;
        if (!H2 || n3.length < 199)
          return n3.push([e3, t3]), this;
        r4 = this.__data__ = new ce2(n3);
      }
      return r4.set(e3, t3), this;
    };
    var pe2, me2 = (pe2 = function(e3, t3) {
      return e3 && ye(e3, t3, qe2);
    }, function(e3, t3) {
      if (e3 == null)
        return e3;
      if (!ze(e3))
        return pe2(e3, t3);
      for (var r4 = e3.length, n3 = -1, a2 = Object(e3); ++n3 < r4 && t3(a2[n3], n3, a2) !== false; )
        ;
      return e3;
    }), ye = function(e3) {
      return function(t3, r4, n3) {
        for (var a2 = -1, o2 = Object(t3), i2 = n3(t3), u3 = i2.length; u3--; ) {
          var c2 = i2[e3 ? u3 : ++a2];
          if (r4(o2[c2], c2, o2) === false)
            break;
        }
        return t3;
      };
    }();
    function be2(e3, t3) {
      for (var r4 = 0, n3 = (t3 = Ee2(t3, e3) ? [t3] : Se2(t3)).length; e3 != null && r4 < n3; )
        e3 = e3[De2(t3[r4++])];
      return r4 && r4 == n3 ? e3 : void 0;
    }
    function ge2(e3, t3) {
      return e3 != null && t3 in Object(e3);
    }
    function ve2(e3, t3, r4, u3, c2) {
      return e3 === t3 || (e3 == null || t3 == null || !$e2(e3) && !Ve(t3) ? e3 != e3 && t3 != t3 : function(e4, t4, r5, u4, c3, s2) {
        var l3 = Le2(e4), f2 = Le2(t4), d2 = "[object Array]", p3 = "[object Array]";
        l3 || (d2 = (d2 = Oe2(e4)) == n2 ? o : d2);
        f2 || (p3 = (p3 = Oe2(t4)) == n2 ? o : p3);
        var h3 = d2 == o && !N2(e4), m3 = p3 == o && !N2(t4), y3 = d2 == p3;
        if (y3 && !h3)
          return s2 || (s2 = new le2()), l3 || Ue2(e4) ? je2(e4, t4, r5, u4, c3, s2) : function(e5, t5, r6, n3, o2, u5, c4) {
            switch (r6) {
              case "[object DataView]":
                if (e5.byteLength != t5.byteLength || e5.byteOffset != t5.byteOffset)
                  return false;
                e5 = e5.buffer, t5 = t5.buffer;
              case "[object ArrayBuffer]":
                return !(e5.byteLength != t5.byteLength || !n3(new $(e5), new $(t5)));
              case "[object Boolean]":
              case "[object Date]":
              case "[object Number]":
                return Me2(+e5, +t5);
              case "[object Error]":
                return e5.name == t5.name && e5.message == t5.message;
              case "[object RegExp]":
              case "[object String]":
                return e5 == t5 + "";
              case a:
                var s3 = O2;
              case i:
                var l4 = 2 & u5;
                if (s3 || (s3 = k), e5.size != t5.size && !l4)
                  return false;
                var f3 = c4.get(e5);
                if (f3)
                  return f3 == t5;
                u5 |= 1, c4.set(e5, t5);
                var d3 = je2(s3(e5), s3(t5), n3, o2, u5, c4);
                return c4.delete(e5), d3;
              case "[object Symbol]":
                if (ae2)
                  return ae2.call(e5) == ae2.call(t5);
            }
            return false;
          }(e4, t4, d2, r5, u4, c3, s2);
        if (!(2 & c3)) {
          var b2 = h3 && L2.call(e4, "__wrapped__"), g2 = m3 && L2.call(t4, "__wrapped__");
          if (b2 || g2) {
            var v3 = b2 ? e4.value() : e4, C3 = g2 ? t4.value() : t4;
            return s2 || (s2 = new le2()), r5(v3, C3, u4, c3, s2);
          }
        }
        if (!y3)
          return false;
        return s2 || (s2 = new le2()), function(e5, t5, r6, n3, a2, o2) {
          var i2 = 2 & a2, u5 = qe2(e5), c4 = u5.length, s3 = qe2(t5).length;
          if (c4 != s3 && !i2)
            return false;
          var l4 = c4;
          for (; l4--; ) {
            var f3 = u5[l4];
            if (!(i2 ? f3 in t5 : L2.call(t5, f3)))
              return false;
          }
          var d3 = o2.get(e5);
          if (d3 && o2.get(t5))
            return d3 == t5;
          var p4 = true;
          o2.set(e5, t5), o2.set(t5, e5);
          var h4 = i2;
          for (; ++l4 < c4; ) {
            f3 = u5[l4];
            var m4 = e5[f3], y4 = t5[f3];
            if (n3)
              var b3 = i2 ? n3(y4, m4, f3, t5, e5, o2) : n3(m4, y4, f3, e5, t5, o2);
            if (!(b3 === void 0 ? m4 === y4 || r6(m4, y4, n3, a2, o2) : b3)) {
              p4 = false;
              break;
            }
            h4 || (h4 = f3 == "constructor");
          }
          if (p4 && !h4) {
            var g3 = e5.constructor, v4 = t5.constructor;
            g3 == v4 || !("constructor" in e5) || !("constructor" in t5) || typeof g3 == "function" && g3 instanceof g3 && typeof v4 == "function" && v4 instanceof v4 || (p4 = false);
          }
          return o2.delete(e5), o2.delete(t5), p4;
        }(e4, t4, r5, u4, c3, s2);
      }(e3, t3, ve2, r4, u3, c2));
    }
    function Ce2(e3) {
      return !(!$e2(e3) || function(e4) {
        return !!M2 && M2 in e4;
      }(e3)) && (Be2(e3) || N2(e3) ? B2 : d).test(Pe2(e3));
    }
    function _e(e3) {
      return typeof e3 == "function" ? e3 : e3 == null ? He2 : typeof e3 == "object" ? Le2(e3) ? function(e4, t4) {
        if (Ee2(e4) && Te2(t4))
          return Ie2(De2(e4), t4);
        return function(r5) {
          var n3 = function(e5, t5, r6) {
            var n4 = e5 == null ? void 0 : be2(e5, t5);
            return n4 === void 0 ? r6 : n4;
          }(r5, e4);
          return n3 === void 0 && n3 === t4 ? function(e5, t5) {
            return e5 != null && function(e6, t6, r6) {
              t6 = Ee2(t6, e6) ? [t6] : Se2(t6);
              var n4, a2 = -1, o2 = t6.length;
              for (; ++a2 < o2; ) {
                var i2 = De2(t6[a2]);
                if (!(n4 = e6 != null && r6(e6, i2)))
                  break;
                e6 = e6[i2];
              }
              if (n4)
                return n4;
              return !!(o2 = e6 ? e6.length : 0) && Ge2(o2) && ke2(i2, o2) && (Le2(e6) || Re2(e6));
            }(e5, t5, ge2);
          }(r5, e4) : ve2(t4, n3, void 0, 3);
        };
      }(e3[0], e3[1]) : function(e4) {
        var t4 = function(e5) {
          var t5 = qe2(e5), r5 = t5.length;
          for (; r5--; ) {
            var n3 = t5[r5], a2 = e5[n3];
            t5[r5] = [n3, a2, Te2(a2)];
          }
          return t5;
        }(e4);
        if (t4.length == 1 && t4[0][2])
          return Ie2(t4[0][0], t4[0][1]);
        return function(r5) {
          return r5 === e4 || function(e5, t5, r6, n3) {
            var a2 = r6.length, o2 = a2, i2 = !n3;
            if (e5 == null)
              return !o2;
            for (e5 = Object(e5); a2--; ) {
              var u3 = r6[a2];
              if (i2 && u3[2] ? u3[1] !== e5[u3[0]] : !(u3[0] in e5))
                return false;
            }
            for (; ++a2 < o2; ) {
              var c2 = (u3 = r6[a2])[0], s2 = e5[c2], l3 = u3[1];
              if (i2 && u3[2]) {
                if (s2 === void 0 && !(c2 in e5))
                  return false;
              } else {
                var f2 = new le2();
                if (n3)
                  var d2 = n3(s2, l3, c2, e5, t5, f2);
                if (!(d2 === void 0 ? ve2(l3, s2, n3, 3, f2) : d2))
                  return false;
              }
            }
            return true;
          }(r5, e4, t4);
        };
      }(e3) : Ee2(t3 = e3) ? (r4 = De2(t3), function(e4) {
        return e4 == null ? void 0 : e4[r4];
      }) : function(e4) {
        return function(t4) {
          return be2(t4, e4);
        };
      }(t3);
      var t3, r4;
    }
    function we2(e3) {
      if (r4 = (t3 = e3) && t3.constructor, n3 = typeof r4 == "function" && r4.prototype || P2, t3 !== n3)
        return U2(e3);
      var t3, r4, n3, a2 = [];
      for (var o2 in Object(e3))
        L2.call(e3, o2) && o2 != "constructor" && a2.push(o2);
      return a2;
    }
    function Se2(e3) {
      return Le2(e3) ? e3 : Ae2(e3);
    }
    function je2(e3, t3, r4, n3, a2, o2) {
      var i2 = 2 & a2, u3 = e3.length, c2 = t3.length;
      if (u3 != c2 && !(i2 && c2 > u3))
        return false;
      var s2 = o2.get(e3);
      if (s2 && o2.get(t3))
        return s2 == t3;
      var l3 = -1, f2 = true, d2 = 1 & a2 ? new se2() : void 0;
      for (o2.set(e3, t3), o2.set(t3, e3); ++l3 < u3; ) {
        var p3 = e3[l3], h3 = t3[l3];
        if (n3)
          var m3 = i2 ? n3(h3, p3, l3, t3, e3, o2) : n3(p3, h3, l3, e3, t3, o2);
        if (m3 !== void 0) {
          if (m3)
            continue;
          f2 = false;
          break;
        }
        if (d2) {
          if (!j(t3, function(e4, t4) {
            if (!d2.has(t4) && (p3 === e4 || r4(p3, e4, n3, a2, o2)))
              return d2.add(t4);
          })) {
            f2 = false;
            break;
          }
        } else if (p3 !== h3 && !r4(p3, h3, n3, a2, o2)) {
          f2 = false;
          break;
        }
      }
      return o2.delete(e3), o2.delete(t3), f2;
    }
    function xe(e3, t3) {
      var r4, n3, a2 = e3.__data__;
      return ((n3 = typeof (r4 = t3)) == "string" || n3 == "number" || n3 == "symbol" || n3 == "boolean" ? r4 !== "__proto__" : r4 === null) ? a2[typeof t3 == "string" ? "string" : "hash"] : a2.map;
    }
    function Ne2(e3, t3) {
      var r4 = function(e4, t4) {
        return e4 == null ? void 0 : e4[t4];
      }(e3, t3);
      return Ce2(r4) ? r4 : void 0;
    }
    var Oe2 = function(e3) {
      return z2.call(e3);
    };
    function ke2(e3, t3) {
      return !!(t3 = t3 == null ? 9007199254740991 : t3) && (typeof e3 == "number" || p2.test(e3)) && e3 > -1 && e3 % 1 == 0 && e3 < t3;
    }
    function Ee2(e3, t3) {
      if (Le2(e3))
        return false;
      var r4 = typeof e3;
      return !(r4 != "number" && r4 != "symbol" && r4 != "boolean" && e3 != null && !Ke2(e3)) || (c.test(e3) || !u2.test(e3) || t3 != null && e3 in Object(t3));
    }
    function Te2(e3) {
      return e3 == e3 && !$e2(e3);
    }
    function Ie2(e3, t3) {
      return function(r4) {
        return r4 != null && (r4[e3] === t3 && (t3 !== void 0 || e3 in Object(r4)));
      };
    }
    (q2 && Oe2(new q2(new ArrayBuffer(1))) != "[object DataView]" || H2 && Oe2(new H2()) != a || W2 && Oe2(W2.resolve()) != "[object Promise]" || J2 && Oe2(new J2()) != i || Z2 && Oe2(new Z2()) != "[object WeakMap]") && (Oe2 = function(e3) {
      var t3 = z2.call(e3), r4 = t3 == o ? e3.constructor : void 0, n3 = r4 ? Pe2(r4) : void 0;
      if (n3)
        switch (n3) {
          case Y2:
            return "[object DataView]";
          case X2:
            return a;
          case ee2:
            return "[object Promise]";
          case te2:
            return i;
          case re2:
            return "[object WeakMap]";
        }
      return t3;
    });
    var Ae2 = Fe2(function(e3) {
      var t3;
      e3 = (t3 = e3) == null ? "" : function(e4) {
        if (typeof e4 == "string")
          return e4;
        if (Ke2(e4))
          return oe2 ? oe2.call(e4) : "";
        var t4 = e4 + "";
        return t4 == "0" && 1 / e4 == -1 / 0 ? "-0" : t4;
      }(t3);
      var r4 = [];
      return s.test(e3) && r4.push(""), e3.replace(l2, function(e4, t4, n3, a2) {
        r4.push(n3 ? a2.replace(f, "$1") : t4 || e4);
      }), r4;
    });
    function De2(e3) {
      if (typeof e3 == "string" || Ke2(e3))
        return e3;
      var t3 = e3 + "";
      return t3 == "0" && 1 / e3 == -1 / 0 ? "-0" : t3;
    }
    function Pe2(e3) {
      if (e3 != null) {
        try {
          return R2.call(e3);
        } catch (e4) {
        }
        try {
          return e3 + "";
        } catch (e4) {
        }
      }
      return "";
    }
    function Fe2(e3, t3) {
      if (typeof e3 != "function" || t3 && typeof t3 != "function")
        throw new TypeError("Expected a function");
      var r4 = function() {
        var n3 = arguments, a2 = t3 ? t3.apply(this, n3) : n3[0], o2 = r4.cache;
        if (o2.has(a2))
          return o2.get(a2);
        var i2 = e3.apply(this, n3);
        return r4.cache = o2.set(a2, i2), i2;
      };
      return r4.cache = new (Fe2.Cache || ce2)(), r4;
    }
    function Me2(e3, t3) {
      return e3 === t3 || e3 != e3 && t3 != t3;
    }
    function Re2(e3) {
      return function(e4) {
        return Ve(e4) && ze(e4);
      }(e3) && L2.call(e3, "callee") && (!V2.call(e3, "callee") || z2.call(e3) == n2);
    }
    Fe2.Cache = ce2;
    var Le2 = Array.isArray;
    function ze(e3) {
      return e3 != null && Ge2(e3.length) && !Be2(e3);
    }
    function Be2(e3) {
      var t3 = $e2(e3) ? z2.call(e3) : "";
      return t3 == "[object Function]" || t3 == "[object GeneratorFunction]";
    }
    function Ge2(e3) {
      return typeof e3 == "number" && e3 > -1 && e3 % 1 == 0 && e3 <= 9007199254740991;
    }
    function $e2(e3) {
      var t3 = typeof e3;
      return !!e3 && (t3 == "object" || t3 == "function");
    }
    function Ve(e3) {
      return !!e3 && typeof e3 == "object";
    }
    function Ke2(e3) {
      return typeof e3 == "symbol" || Ve(e3) && z2.call(e3) == "[object Symbol]";
    }
    var Ue2 = w ? function(e3) {
      return function(t3) {
        return e3(t3);
      };
    }(w) : function(e3) {
      return Ve(e3) && Ge2(e3.length) && !!h[z2.call(e3)];
    };
    function qe2(e3) {
      return ze(e3) ? fe2(e3) : we2(e3);
    }
    function He2(e3) {
      return e3;
    }
    r3.exports = function(e3, t3, r4) {
      var n3 = Le2(e3) ? S2 : x2, a2 = arguments.length < 3;
      return n3(e3, _e(t3), r4, a2, me2);
    };
  }).call(this, r2(3), r2(7)(e));
}, function(e, t2) {
  e.exports = function(e2) {
    return e2.webpackPolyfill || (e2.deprecate = function() {
    }, e2.paths = [], e2.children || (e2.children = []), Object.defineProperty(e2, "loaded", { enumerable: true, get: function() {
      return e2.l;
    } }), Object.defineProperty(e2, "id", { enumerable: true, get: function() {
      return e2.i;
    } }), e2.webpackPolyfill = 1), e2;
  };
}, function(e, t2) {
  String.prototype.padEnd || (String.prototype.padEnd = function(e2, t3) {
    return e2 >>= 0, t3 = String(t3 !== void 0 ? t3 : " "), this.length > e2 ? String(this) : ((e2 -= this.length) > t3.length && (t3 += t3.repeat(e2 / t3.length)), String(this) + t3.slice(0, e2));
  });
}, function(e, t2, r2) {
  function n2(e2, t3, r3) {
    return t3 in e2 ? Object.defineProperty(e2, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e2[t3] = r3, e2;
  }
  function a(e2) {
    if (Symbol.iterator in Object(e2) || Object.prototype.toString.call(e2) === "[object Arguments]")
      return Array.from(e2);
  }
  function o(e2) {
    return function(e3) {
      if (Array.isArray(e3)) {
        for (var t3 = 0, r3 = new Array(e3.length); t3 < e3.length; t3++)
          r3[t3] = e3[t3];
        return r3;
      }
    }(e2) || a(e2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }();
  }
  function i(e2) {
    if (Array.isArray(e2))
      return e2;
  }
  function u2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  function c(e2, t3) {
    if (!(e2 instanceof t3))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(e2, t3) {
    for (var r3 = 0; r3 < t3.length; r3++) {
      var n3 = t3[r3];
      n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e2, n3.key, n3);
    }
  }
  function l2(e2) {
    return (l2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
      return typeof e3;
    } : function(e3) {
      return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
    })(e2);
  }
  function f(e2) {
    return (f = typeof Symbol == "function" && l2(Symbol.iterator) === "symbol" ? function(e3) {
      return l2(e3);
    } : function(e3) {
      return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : l2(e3);
    })(e2);
  }
  function d(e2) {
    if (e2 === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e2;
  }
  function p2(e2) {
    return (p2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
      return e3.__proto__ || Object.getPrototypeOf(e3);
    })(e2);
  }
  function h(e2, t3) {
    return (h = Object.setPrototypeOf || function(e3, t4) {
      return e3.__proto__ = t4, e3;
    })(e2, t3);
  }
  r2.r(t2);
  var m2 = r2(0), y2 = r2.n(m2), b = r2(5), g = r2.n(b), v2 = r2(4), C2 = r2.n(v2), _ = r2(6), w = r2.n(_), S2 = r2(2), j = r2.n(S2), x2 = r2(1), N2 = r2.n(x2);
  r2(8);
  function O2(e2, t3) {
    return i(e2) || function(e3, t4) {
      var r3 = [], n3 = true, a2 = false, o2 = void 0;
      try {
        for (var i2, u3 = e3[Symbol.iterator](); !(n3 = (i2 = u3.next()).done) && (r3.push(i2.value), !t4 || r3.length !== t4); n3 = true)
          ;
      } catch (e4) {
        a2 = true, o2 = e4;
      } finally {
        try {
          n3 || u3.return == null || u3.return();
        } finally {
          if (a2)
            throw o2;
        }
      }
      return r3;
    }(e2, t3) || u2();
  }
  var k = [["Afghanistan", ["asia"], "af", "93"], ["Albania", ["europe"], "al", "355"], ["Algeria", ["africa", "north-africa"], "dz", "213"], ["Andorra", ["europe"], "ad", "376"], ["Angola", ["africa"], "ao", "244"], ["Antigua and Barbuda", ["america", "carribean"], "ag", "1268"], ["Argentina", ["america", "south-america"], "ar", "54", "(..) ........", 0, ["11", "221", "223", "261", "264", "2652", "280", "2905", "291", "2920", "2966", "299", "341", "342", "343", "351", "376", "379", "381", "3833", "385", "387", "388"]], ["Armenia", ["asia", "ex-ussr"], "am", "374", ".. ......"], ["Aruba", ["america", "carribean"], "aw", "297"], ["Australia", ["oceania"], "au", "61", "(..) .... ....", 0, ["2", "3", "4", "7", "8", "02", "03", "04", "07", "08"]], ["Austria", ["europe", "eu-union"], "at", "43"], ["Azerbaijan", ["asia", "ex-ussr"], "az", "994", "(..) ... .. .."], ["Bahamas", ["america", "carribean"], "bs", "1242"], ["Bahrain", ["middle-east"], "bh", "973"], ["Bangladesh", ["asia"], "bd", "880"], ["Barbados", ["america", "carribean"], "bb", "1246"], ["Belarus", ["europe", "ex-ussr"], "by", "375", "(..) ... .. .."], ["Belgium", ["europe", "eu-union"], "be", "32", "... .. .. .."], ["Belize", ["america", "central-america"], "bz", "501"], ["Benin", ["africa"], "bj", "229"], ["Bhutan", ["asia"], "bt", "975"], ["Bolivia", ["america", "south-america"], "bo", "591"], ["Bosnia and Herzegovina", ["europe", "ex-yugos"], "ba", "387"], ["Botswana", ["africa"], "bw", "267"], ["Brazil", ["america", "south-america"], "br", "55", "(..) ........."], ["British Indian Ocean Territory", ["asia"], "io", "246"], ["Brunei", ["asia"], "bn", "673"], ["Bulgaria", ["europe", "eu-union"], "bg", "359"], ["Burkina Faso", ["africa"], "bf", "226"], ["Burundi", ["africa"], "bi", "257"], ["Cambodia", ["asia"], "kh", "855"], ["Cameroon", ["africa"], "cm", "237"], ["Canada", ["america", "north-america"], "ca", "1", "(...) ...-....", 1, ["204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"]], ["Cape Verde", ["africa"], "cv", "238"], ["Caribbean Netherlands", ["america", "carribean"], "bq", "599", "", 1], ["Central African Republic", ["africa"], "cf", "236"], ["Chad", ["africa"], "td", "235"], ["Chile", ["america", "south-america"], "cl", "56"], ["China", ["asia"], "cn", "86", "..-........."], ["Colombia", ["america", "south-america"], "co", "57", "... ... ...."], ["Comoros", ["africa"], "km", "269"], ["Congo", ["africa"], "cd", "243"], ["Congo", ["africa"], "cg", "242"], ["Costa Rica", ["america", "central-america"], "cr", "506", "....-...."], ["C\xF4te d\u2019Ivoire", ["africa"], "ci", "225", ".. .. .. .."], ["Croatia", ["europe", "eu-union", "ex-yugos"], "hr", "385"], ["Cuba", ["america", "carribean"], "cu", "53"], ["Cura\xE7ao", ["america", "carribean"], "cw", "599", "", 0], ["Cyprus", ["europe", "eu-union"], "cy", "357", ".. ......"], ["Czech Republic", ["europe", "eu-union"], "cz", "420", "... ... ..."], ["Denmark", ["europe", "eu-union", "baltic"], "dk", "45", ".. .. .. .."], ["Djibouti", ["africa"], "dj", "253"], ["Dominica", ["america", "carribean"], "dm", "1767"], ["Dominican Republic", ["america", "carribean"], "do", "1", "", 2, ["809", "829", "849"]], ["Ecuador", ["america", "south-america"], "ec", "593"], ["Egypt", ["africa", "north-africa"], "eg", "20"], ["El Salvador", ["america", "central-america"], "sv", "503", "....-...."], ["Equatorial Guinea", ["africa"], "gq", "240"], ["Eritrea", ["africa"], "er", "291"], ["Estonia", ["europe", "eu-union", "ex-ussr", "baltic"], "ee", "372", ".... ......"], ["Ethiopia", ["africa"], "et", "251"], ["Fiji", ["oceania"], "fj", "679"], ["Finland", ["europe", "eu-union", "baltic"], "fi", "358", ".. ... .. .."], ["France", ["europe", "eu-union"], "fr", "33", ". .. .. .. .."], ["French Guiana", ["america", "south-america"], "gf", "594"], ["French Polynesia", ["oceania"], "pf", "689"], ["Gabon", ["africa"], "ga", "241"], ["Gambia", ["africa"], "gm", "220"], ["Georgia", ["asia", "ex-ussr"], "ge", "995"], ["Germany", ["europe", "eu-union", "baltic"], "de", "49", ".... ........"], ["Ghana", ["africa"], "gh", "233"], ["Greece", ["europe", "eu-union"], "gr", "30"], ["Grenada", ["america", "carribean"], "gd", "1473"], ["Guadeloupe", ["america", "carribean"], "gp", "590", "", 0], ["Guam", ["oceania"], "gu", "1671"], ["Guatemala", ["america", "central-america"], "gt", "502", "....-...."], ["Guinea", ["africa"], "gn", "224"], ["Guinea-Bissau", ["africa"], "gw", "245"], ["Guyana", ["america", "south-america"], "gy", "592"], ["Haiti", ["america", "carribean"], "ht", "509", "....-...."], ["Honduras", ["america", "central-america"], "hn", "504"], ["Hong Kong", ["asia"], "hk", "852", ".... ...."], ["Hungary", ["europe", "eu-union"], "hu", "36"], ["Iceland", ["europe"], "is", "354", "... ...."], ["India", ["asia"], "in", "91", ".....-....."], ["Indonesia", ["asia"], "id", "62"], ["Iran", ["middle-east"], "ir", "98", "... ... ...."], ["Iraq", ["middle-east"], "iq", "964"], ["Ireland", ["europe", "eu-union"], "ie", "353", ".. ......."], ["Israel", ["middle-east"], "il", "972", "... ... ...."], ["Italy", ["europe", "eu-union"], "it", "39", "... .......", 0], ["Jamaica", ["america", "carribean"], "jm", "1876"], ["Japan", ["asia"], "jp", "81", ".. .... ...."], ["Jordan", ["middle-east"], "jo", "962"], ["Kazakhstan", ["asia", "ex-ussr"], "kz", "7", "... ...-..-..", 1, ["310", "311", "312", "313", "315", "318", "321", "324", "325", "326", "327", "336", "7172", "73622"]], ["Kenya", ["africa"], "ke", "254"], ["Kiribati", ["oceania"], "ki", "686"], ["Kosovo", ["europe", "ex-yugos"], "xk", "383"], ["Kuwait", ["middle-east"], "kw", "965"], ["Kyrgyzstan", ["asia", "ex-ussr"], "kg", "996", "... ... ..."], ["Laos", ["asia"], "la", "856"], ["Latvia", ["europe", "eu-union", "ex-ussr", "baltic"], "lv", "371", ".. ... ..."], ["Lebanon", ["middle-east"], "lb", "961"], ["Lesotho", ["africa"], "ls", "266"], ["Liberia", ["africa"], "lr", "231"], ["Libya", ["africa", "north-africa"], "ly", "218"], ["Liechtenstein", ["europe"], "li", "423"], ["Lithuania", ["europe", "eu-union", "ex-ussr", "baltic"], "lt", "370"], ["Luxembourg", ["europe", "eu-union"], "lu", "352"], ["Macau", ["asia"], "mo", "853"], ["Macedonia", ["europe", "ex-yugos"], "mk", "389"], ["Madagascar", ["africa"], "mg", "261"], ["Malawi", ["africa"], "mw", "265"], ["Malaysia", ["asia"], "my", "60", "..-....-...."], ["Maldives", ["asia"], "mv", "960"], ["Mali", ["africa"], "ml", "223"], ["Malta", ["europe", "eu-union"], "mt", "356"], ["Marshall Islands", ["oceania"], "mh", "692"], ["Martinique", ["america", "carribean"], "mq", "596"], ["Mauritania", ["africa"], "mr", "222"], ["Mauritius", ["africa"], "mu", "230"], ["Mexico", ["america", "central-america"], "mx", "52", "... ... ....", 0, ["55", "81", "33", "656", "664", "998", "774", "229"]], ["Micronesia", ["oceania"], "fm", "691"], ["Moldova", ["europe"], "md", "373", "(..) ..-..-.."], ["Monaco", ["europe"], "mc", "377"], ["Mongolia", ["asia"], "mn", "976"], ["Montenegro", ["europe", "ex-yugos"], "me", "382"], ["Morocco", ["africa", "north-africa"], "ma", "212"], ["Mozambique", ["africa"], "mz", "258"], ["Myanmar", ["asia"], "mm", "95"], ["Namibia", ["africa"], "na", "264"], ["Nauru", ["africa"], "nr", "674"], ["Nepal", ["asia"], "np", "977"], ["Netherlands", ["europe", "eu-union"], "nl", "31", ".. ........"], ["New Caledonia", ["oceania"], "nc", "687"], ["New Zealand", ["oceania"], "nz", "64", "...-...-...."], ["Nicaragua", ["america", "central-america"], "ni", "505"], ["Niger", ["africa"], "ne", "227"], ["Nigeria", ["africa"], "ng", "234"], ["North Korea", ["asia"], "kp", "850"], ["Norway", ["europe", "baltic"], "no", "47", "... .. ..."], ["Oman", ["middle-east"], "om", "968"], ["Pakistan", ["asia"], "pk", "92", "...-......."], ["Palau", ["oceania"], "pw", "680"], ["Palestine", ["middle-east"], "ps", "970"], ["Panama", ["america", "central-america"], "pa", "507"], ["Papua New Guinea", ["oceania"], "pg", "675"], ["Paraguay", ["america", "south-america"], "py", "595"], ["Peru", ["america", "south-america"], "pe", "51"], ["Philippines", ["asia"], "ph", "63", ".... ......."], ["Poland", ["europe", "eu-union", "baltic"], "pl", "48", "...-...-..."], ["Portugal", ["europe", "eu-union"], "pt", "351"], ["Puerto Rico", ["america", "carribean"], "pr", "1", "", 3, ["787", "939"]], ["Qatar", ["middle-east"], "qa", "974"], ["R\xE9union", ["africa"], "re", "262"], ["Romania", ["europe", "eu-union"], "ro", "40"], ["Russia", ["europe", "asia", "ex-ussr", "baltic"], "ru", "7", "(...) ...-..-..", 0], ["Rwanda", ["africa"], "rw", "250"], ["Saint Kitts and Nevis", ["america", "carribean"], "kn", "1869"], ["Saint Lucia", ["america", "carribean"], "lc", "1758"], ["Saint Vincent and the Grenadines", ["america", "carribean"], "vc", "1784"], ["Samoa", ["oceania"], "ws", "685"], ["San Marino", ["europe"], "sm", "378"], ["S\xE3o Tom\xE9 and Pr\xEDncipe", ["africa"], "st", "239"], ["Saudi Arabia", ["middle-east"], "sa", "966"], ["Senegal", ["africa"], "sn", "221"], ["Serbia", ["europe", "ex-yugos"], "rs", "381"], ["Seychelles", ["africa"], "sc", "248"], ["Sierra Leone", ["africa"], "sl", "232"], ["Singapore", ["asia"], "sg", "65", "....-...."], ["Slovakia", ["europe", "eu-union"], "sk", "421"], ["Slovenia", ["europe", "eu-union", "ex-yugos"], "si", "386"], ["Solomon Islands", ["oceania"], "sb", "677"], ["Somalia", ["africa"], "so", "252"], ["South Africa", ["africa"], "za", "27"], ["South Korea", ["asia"], "kr", "82", "... .... ...."], ["South Sudan", ["africa", "north-africa"], "ss", "211"], ["Spain", ["europe", "eu-union"], "es", "34", "... ... ..."], ["Sri Lanka", ["asia"], "lk", "94"], ["Sudan", ["africa"], "sd", "249"], ["Suriname", ["america", "south-america"], "sr", "597"], ["Swaziland", ["africa"], "sz", "268"], ["Sweden", ["europe", "eu-union", "baltic"], "se", "46", "(...) ...-..."], ["Switzerland", ["europe"], "ch", "41", ".. ... .. .."], ["Syria", ["middle-east"], "sy", "963"], ["Taiwan", ["asia"], "tw", "886"], ["Tajikistan", ["asia", "ex-ussr"], "tj", "992"], ["Tanzania", ["africa"], "tz", "255"], ["Thailand", ["asia"], "th", "66"], ["Timor-Leste", ["asia"], "tl", "670"], ["Togo", ["africa"], "tg", "228"], ["Tonga", ["oceania"], "to", "676"], ["Trinidad and Tobago", ["america", "carribean"], "tt", "1868"], ["Tunisia", ["africa", "north-africa"], "tn", "216"], ["Turkey", ["europe"], "tr", "90", "... ... .. .."], ["Turkmenistan", ["asia", "ex-ussr"], "tm", "993"], ["Tuvalu", ["asia"], "tv", "688"], ["Uganda", ["africa"], "ug", "256"], ["Ukraine", ["europe", "ex-ussr"], "ua", "380", "(..) ... .. .."], ["United Arab Emirates", ["middle-east"], "ae", "971"], ["United Kingdom", ["europe", "eu-union"], "gb", "44", ".... ......"], ["United States", ["america", "north-america"], "us", "1", "(...) ...-....", 0, ["907", "205", "251", "256", "334", "479", "501", "870", "480", "520", "602", "623", "928", "209", "213", "310", "323", "408", "415", "510", "530", "559", "562", "619", "626", "650", "661", "707", "714", "760", "805", "818", "831", "858", "909", "916", "925", "949", "951", "303", "719", "970", "203", "860", "202", "302", "239", "305", "321", "352", "386", "407", "561", "727", "772", "813", "850", "863", "904", "941", "954", "229", "404", "478", "706", "770", "912", "808", "319", "515", "563", "641", "712", "208", "217", "309", "312", "618", "630", "708", "773", "815", "847", "219", "260", "317", "574", "765", "812", "316", "620", "785", "913", "270", "502", "606", "859", "225", "318", "337", "504", "985", "413", "508", "617", "781", "978", "301", "410", "207", "231", "248", "269", "313", "517", "586", "616", "734", "810", "906", "989", "218", "320", "507", "612", "651", "763", "952", "314", "417", "573", "636", "660", "816", "228", "601", "662", "406", "252", "336", "704", "828", "910", "919", "701", "308", "402", "603", "201", "609", "732", "856", "908", "973", "505", "575", "702", "775", "212", "315", "516", "518", "585", "607", "631", "716", "718", "845", "914", "216", "330", "419", "440", "513", "614", "740", "937", "405", "580", "918", "503", "541", "215", "412", "570", "610", "717", "724", "814", "401", "803", "843", "864", "605", "423", "615", "731", "865", "901", "931", "210", "214", "254", "281", "325", "361", "409", "432", "512", "713", "806", "817", "830", "903", "915", "936", "940", "956", "972", "979", "435", "801", "276", "434", "540", "703", "757", "804", "802", "206", "253", "360", "425", "509", "262", "414", "608", "715", "920", "304", "307"]], ["Uruguay", ["america", "south-america"], "uy", "598"], ["Uzbekistan", ["asia", "ex-ussr"], "uz", "998", ".. ... .. .."], ["Vanuatu", ["oceania"], "vu", "678"], ["Vatican City", ["europe"], "va", "39", ".. .... ....", 1], ["Venezuela", ["america", "south-america"], "ve", "58"], ["Vietnam", ["asia"], "vn", "84"], ["Yemen", ["middle-east"], "ye", "967"], ["Zambia", ["africa"], "zm", "260"], ["Zimbabwe", ["africa"], "zw", "263"]], E2 = [["American Samoa", ["oceania"], "as", "1684"], ["Anguilla", ["america", "carribean"], "ai", "1264"], ["Bermuda", ["america", "north-america"], "bm", "1441"], ["British Virgin Islands", ["america", "carribean"], "vg", "1284"], ["Cayman Islands", ["america", "carribean"], "ky", "1345"], ["Cook Islands", ["oceania"], "ck", "682"], ["Falkland Islands", ["america", "south-america"], "fk", "500"], ["Faroe Islands", ["europe"], "fo", "298"], ["Gibraltar", ["europe"], "gi", "350"], ["Greenland", ["america"], "gl", "299"], ["Jersey", ["europe", "eu-union"], "je", "44", ".... ......"], ["Montserrat", ["america", "carribean"], "ms", "1664"], ["Niue", ["asia"], "nu", "683"], ["Norfolk Island", ["oceania"], "nf", "672"], ["Northern Mariana Islands", ["oceania"], "mp", "1670"], ["Saint Barth\xE9lemy", ["america", "carribean"], "bl", "590", "", 1], ["Saint Helena", ["africa"], "sh", "290"], ["Saint Martin", ["america", "carribean"], "mf", "590", "", 2], ["Saint Pierre and Miquelon", ["america", "north-america"], "pm", "508"], ["Sint Maarten", ["america", "carribean"], "sx", "1721"], ["Tokelau", ["oceania"], "tk", "690"], ["Turks and Caicos Islands", ["america", "carribean"], "tc", "1649"], ["U.S. Virgin Islands", ["america", "carribean"], "vi", "1340"], ["Wallis and Futuna", ["oceania"], "wf", "681"]];
  function T2(e2, t3, r3, n3, a2) {
    return !r3 || a2 ? e2 + "".padEnd(t3.length, ".") + " " + n3 : e2 + "".padEnd(t3.length, ".") + " " + r3;
  }
  function I2(e2, t3, r3, a2, i2) {
    var u3, c2, s2 = [];
    return c2 = t3 === true, [(u3 = []).concat.apply(u3, o(e2.map(function(e3) {
      var o2 = { name: e3[0], regions: e3[1], iso2: e3[2], countryCode: e3[3], dialCode: e3[3], format: T2(r3, e3[3], e3[4], a2, i2), priority: e3[5] || 0 }, u4 = [];
      return e3[6] && e3[6].map(function(t4) {
        var r4 = function(e4) {
          for (var t5 = 1; t5 < arguments.length; t5++) {
            var r5 = arguments[t5] != null ? arguments[t5] : {}, a3 = Object.keys(r5);
            typeof Object.getOwnPropertySymbols == "function" && (a3 = a3.concat(Object.getOwnPropertySymbols(r5).filter(function(e5) {
              return Object.getOwnPropertyDescriptor(r5, e5).enumerable;
            }))), a3.forEach(function(t6) {
              n2(e4, t6, r5[t6]);
            });
          }
          return e4;
        }({}, o2);
        r4.dialCode = e3[3] + t4, r4.isAreaCode = true, r4.areaCodeLength = t4.length, u4.push(r4);
      }), u4.length > 0 ? (o2.mainCode = true, c2 || t3.constructor.name === "Array" && t3.includes(e3[2]) ? (o2.hasAreaCodes = true, [o2].concat(u4)) : (s2 = s2.concat(u4), [o2])) : [o2];
    }))), s2];
  }
  function A2(e2, t3, r3, n3) {
    if (r3 !== null) {
      var a2 = Object.keys(r3), o2 = Object.values(r3);
      a2.forEach(function(r4, a3) {
        if (n3)
          return e2.push([r4, o2[a3]]);
        var i2 = e2.findIndex(function(e3) {
          return e3[0] === r4;
        });
        if (i2 === -1) {
          var u3 = [r4];
          u3[t3] = o2[a3], e2.push(u3);
        } else
          e2[i2][t3] = o2[a3];
      });
    }
  }
  function D2(e2, t3) {
    return t3.length === 0 ? e2 : e2.map(function(e3) {
      var r3 = t3.findIndex(function(t4) {
        return t4[0] === e3[2];
      });
      if (r3 === -1)
        return e3;
      var n3 = t3[r3];
      return n3[1] && (e3[4] = n3[1]), n3[3] && (e3[5] = n3[3]), n3[2] && (e3[6] = n3[2]), e3;
    });
  }
  var P2 = function e2(t3, r3, n3, a2, i2, u3, s2, l3, f2, d2, p3, h3, m3, y3) {
    c(this, e2), this.filterRegions = function(e3, t4) {
      if (typeof e3 == "string") {
        var r4 = e3;
        return t4.filter(function(e4) {
          return e4.regions.some(function(e5) {
            return e5 === r4;
          });
        });
      }
      return t4.filter(function(t5) {
        return e3.map(function(e4) {
          return t5.regions.some(function(t6) {
            return t6 === e4;
          });
        }).some(function(e4) {
          return e4;
        });
      });
    }, this.sortTerritories = function(e3, t4) {
      var r4 = [].concat(o(e3), o(t4));
      return r4.sort(function(e4, t5) {
        return e4.name < t5.name ? -1 : e4.name > t5.name ? 1 : 0;
      }), r4;
    }, this.getFilteredCountryList = function(e3, t4, r4) {
      return e3.length === 0 ? t4 : r4 ? e3.map(function(e4) {
        var r5 = t4.find(function(t5) {
          return t5.iso2 === e4;
        });
        if (r5)
          return r5;
      }).filter(function(e4) {
        return e4;
      }) : t4.filter(function(t5) {
        return e3.some(function(e4) {
          return e4 === t5.iso2;
        });
      });
    }, this.localizeCountries = function(e3, t4, r4) {
      for (var n4 = 0; n4 < e3.length; n4++)
        t4[e3[n4].iso2] !== void 0 ? e3[n4].localName = t4[e3[n4].iso2] : t4[e3[n4].name] !== void 0 && (e3[n4].localName = t4[e3[n4].name]);
      return r4 || e3.sort(function(e4, t5) {
        return e4.localName < t5.localName ? -1 : e4.localName > t5.localName ? 1 : 0;
      }), e3;
    }, this.getCustomAreas = function(e3, t4) {
      for (var r4 = [], n4 = 0; n4 < t4.length; n4++) {
        var a3 = JSON.parse(JSON.stringify(e3));
        a3.dialCode += t4[n4], r4.push(a3);
      }
      return r4;
    }, this.excludeCountries = function(e3, t4) {
      return t4.length === 0 ? e3 : e3.filter(function(e4) {
        return !t4.includes(e4.iso2);
      });
    };
    var b2 = function(e3, t4, r4) {
      var n4 = [];
      return A2(n4, 1, e3, true), A2(n4, 3, t4), A2(n4, 2, r4), n4;
    }(l3, f2, d2), g2 = D2(JSON.parse(JSON.stringify(k)), b2), v3 = D2(JSON.parse(JSON.stringify(E2)), b2), C3 = O2(I2(g2, t3, h3, m3, y3), 2), _2 = C3[0], w2 = C3[1];
    if (r3) {
      var S3 = O2(I2(v3, t3, h3, m3, y3), 2), j2 = S3[0];
      S3[1];
      _2 = this.sortTerritories(j2, _2);
    }
    n3 && (_2 = this.filterRegions(n3, _2)), this.onlyCountries = this.localizeCountries(this.excludeCountries(this.getFilteredCountryList(a2, _2, s2.includes("onlyCountries")), u3), p3, s2.includes("onlyCountries")), this.preferredCountries = i2.length === 0 ? [] : this.localizeCountries(this.getFilteredCountryList(i2, _2, s2.includes("preferredCountries")), p3, s2.includes("preferredCountries")), this.hiddenAreaCodes = this.excludeCountries(this.getFilteredCountryList(a2, w2), u3);
  }, F2 = function(e2) {
    function t3(e3) {
      var r4;
      c(this, t3), (r4 = function(e4, t4) {
        return !t4 || f(t4) !== "object" && typeof t4 != "function" ? d(e4) : t4;
      }(this, p2(t3).call(this, e3))).getProbableCandidate = C2()(function(e4) {
        return e4 && e4.length !== 0 ? r4.state.onlyCountries.filter(function(t4) {
          return j()(t4.name.toLowerCase(), e4.toLowerCase());
        }, d(d(r4)))[0] : null;
      }), r4.guessSelectedCountry = C2()(function(e4, t4, n3, a2) {
        var o2;
        if (r4.props.enableAreaCodes === false && (a2.some(function(t5) {
          if (j()(e4, t5.dialCode))
            return n3.some(function(e5) {
              if (t5.iso2 === e5.iso2 && e5.mainCode)
                return o2 = e5, true;
            }), true;
        }), o2))
          return o2;
        var i2 = n3.find(function(e5) {
          return e5.iso2 == t4;
        });
        if (e4.trim() === "")
          return i2;
        var u3 = n3.reduce(function(t5, r5) {
          if (j()(e4, r5.dialCode)) {
            if (r5.dialCode.length > t5.dialCode.length)
              return r5;
            if (r5.dialCode.length === t5.dialCode.length && r5.priority < t5.priority)
              return r5;
          }
          return t5;
        }, { dialCode: "", priority: 10001 }, d(d(r4)));
        return u3.name ? u3 : i2;
      }), r4.updateCountry = function(e4) {
        var t4, n3 = r4.state.onlyCountries;
        (t4 = e4.indexOf(0) >= "0" && e4.indexOf(0) <= "9" ? n3.find(function(t5) {
          return t5.dialCode == +e4;
        }) : n3.find(function(t5) {
          return t5.iso2 == e4;
        })) && t4.dialCode && r4.setState({ selectedCountry: t4, formattedNumber: r4.props.disableCountryCode ? "" : r4.formatNumber(t4.dialCode, t4) });
      }, r4.scrollTo = function(e4, t4) {
        if (e4) {
          var n3 = r4.dropdownRef;
          if (n3 && document.body) {
            var a2 = n3.offsetHeight, o2 = n3.getBoundingClientRect().top + document.body.scrollTop, i2 = o2 + a2, u3 = e4, c2 = u3.getBoundingClientRect(), s3 = u3.offsetHeight, l5 = c2.top + document.body.scrollTop, f2 = l5 + s3, d2 = l5 - o2 + n3.scrollTop, p3 = a2 / 2 - s3 / 2;
            if (r4.props.enableSearch ? l5 < o2 + 32 : l5 < o2)
              t4 && (d2 -= p3), n3.scrollTop = d2;
            else if (f2 > i2) {
              t4 && (d2 += p3);
              var h4 = a2 - s3;
              n3.scrollTop = d2 - h4;
            }
          }
        }
      }, r4.scrollToTop = function() {
        var e4 = r4.dropdownRef;
        e4 && document.body && (e4.scrollTop = 0);
      }, r4.formatNumber = function(e4, t4) {
        if (!t4)
          return e4;
        var n3, o2 = t4.format, c2 = r4.props, s3 = c2.disableCountryCode, l5 = c2.enableAreaCodeStretch, f2 = c2.enableLongNumbers, d2 = c2.autoFormat;
        if (s3 ? ((n3 = o2.split(" ")).shift(), n3 = n3.join(" ")) : l5 && t4.isAreaCode ? ((n3 = o2.split(" "))[1] = n3[1].replace(/\.+/, "".padEnd(t4.areaCodeLength, ".")), n3 = n3.join(" ")) : n3 = o2, !e4 || e4.length === 0)
          return s3 ? "" : r4.props.prefix;
        if (e4 && e4.length < 2 || !n3 || !d2)
          return s3 ? e4 : r4.props.prefix + e4;
        var p3, h4 = w()(n3, function(e5, t5) {
          if (e5.remainingText.length === 0)
            return e5;
          if (t5 !== ".")
            return { formattedText: e5.formattedText + t5, remainingText: e5.remainingText };
          var r5, n4 = i(r5 = e5.remainingText) || a(r5) || u2(), o3 = n4[0], c3 = n4.slice(1);
          return { formattedText: e5.formattedText + o3, remainingText: c3 };
        }, { formattedText: "", remainingText: e4.split("") });
        return (p3 = f2 ? h4.formattedText + h4.remainingText.join("") : h4.formattedText).includes("(") && !p3.includes(")") && (p3 += ")"), p3;
      }, r4.cursorToEnd = function() {
        var e4 = r4.numberInputRef;
        if (document.activeElement === e4) {
          e4.focus();
          var t4 = e4.value.length;
          e4.value.charAt(t4 - 1) === ")" && (t4 -= 1), e4.setSelectionRange(t4, t4);
        }
      }, r4.getElement = function(e4) {
        return r4["flag_no_".concat(e4)];
      }, r4.getCountryData = function() {
        return r4.state.selectedCountry ? { name: r4.state.selectedCountry.name || "", dialCode: r4.state.selectedCountry.dialCode || "", countryCode: r4.state.selectedCountry.iso2 || "", format: r4.state.selectedCountry.format || "" } : {};
      }, r4.handleFlagDropdownClick = function(e4) {
        if (e4.preventDefault(), r4.state.showDropdown || !r4.props.disabled) {
          var t4 = r4.state, n3 = t4.preferredCountries, a2 = t4.onlyCountries, o2 = t4.selectedCountry, i2 = r4.concatPreferredCountries(n3, a2).findIndex(function(e5) {
            return e5.dialCode === o2.dialCode && e5.iso2 === o2.iso2;
          });
          r4.setState({ showDropdown: !r4.state.showDropdown, highlightCountryIndex: i2 }, function() {
            r4.state.showDropdown && r4.scrollTo(r4.getElement(r4.state.highlightCountryIndex));
          });
        }
      }, r4.handleInput = function(e4) {
        var t4 = e4.target.value, n3 = r4.props, a2 = n3.prefix, o2 = n3.onChange, i2 = r4.props.disableCountryCode ? "" : a2, u3 = r4.state.selectedCountry, c2 = r4.state.freezeSelection;
        if (!r4.props.countryCodeEditable) {
          var s3 = a2 + (u3.hasAreaCodes ? r4.state.onlyCountries.find(function(e5) {
            return e5.iso2 === u3.iso2 && e5.mainCode;
          }).dialCode : u3.dialCode);
          if (t4.slice(0, s3.length) !== s3)
            return;
        }
        if (t4 === a2)
          return o2 && o2("", r4.getCountryData(), e4, ""), r4.setState({ formattedNumber: "" });
        if (t4.replace(/\D/g, "").length > 15) {
          if (r4.props.enableLongNumbers === false)
            return;
          if (typeof r4.props.enableLongNumbers == "number" && t4.replace(/\D/g, "").length > r4.props.enableLongNumbers)
            return;
        }
        if (t4 !== r4.state.formattedNumber) {
          e4.preventDefault ? e4.preventDefault() : e4.returnValue = false;
          var l5 = r4.props.country, f2 = r4.state, d2 = f2.onlyCountries, p3 = f2.selectedCountry, h4 = f2.hiddenAreaCodes;
          if (o2 && e4.persist(), t4.length > 0) {
            var m4 = t4.replace(/\D/g, "");
            (!r4.state.freezeSelection || p3 && p3.dialCode.length > m4.length) && (u3 = r4.props.disableCountryGuess ? p3 : r4.guessSelectedCountry(m4.substring(0, 6), l5, d2, h4) || p3, c2 = false), i2 = r4.formatNumber(m4, u3), u3 = u3.dialCode ? u3 : p3;
          }
          var y3 = e4.target.selectionStart, b3 = e4.target.selectionStart, g2 = r4.state.formattedNumber, v4 = i2.length - g2.length;
          r4.setState({ formattedNumber: i2, freezeSelection: c2, selectedCountry: u3 }, function() {
            v4 > 0 && (b3 -= v4), i2.charAt(i2.length - 1) == ")" ? r4.numberInputRef.setSelectionRange(i2.length - 1, i2.length - 1) : b3 > 0 && g2.length >= i2.length ? r4.numberInputRef.setSelectionRange(b3, b3) : y3 < g2.length && r4.numberInputRef.setSelectionRange(y3, y3), o2 && o2(i2.replace(/[^0-9]+/g, ""), r4.getCountryData(), e4, i2);
          });
        }
      }, r4.handleInputClick = function(e4) {
        r4.setState({ showDropdown: false }), r4.props.onClick && r4.props.onClick(e4, r4.getCountryData());
      }, r4.handleDoubleClick = function(e4) {
        var t4 = e4.target.value.length;
        e4.target.setSelectionRange(0, t4);
      }, r4.handleFlagItemClick = function(e4, t4) {
        var n3 = r4.state.selectedCountry, a2 = r4.state.onlyCountries.find(function(t5) {
          return t5 == e4;
        });
        if (a2) {
          var o2 = r4.state.formattedNumber.replace(" ", "").replace("(", "").replace(")", "").replace("-", ""), i2 = o2.length > 1 ? o2.replace(n3.dialCode, a2.dialCode) : a2.dialCode, u3 = r4.formatNumber(i2.replace(/\D/g, ""), a2);
          r4.setState({ showDropdown: false, selectedCountry: a2, freezeSelection: true, formattedNumber: u3, searchValue: "" }, function() {
            r4.cursorToEnd(), r4.props.onChange && r4.props.onChange(u3.replace(/[^0-9]+/g, ""), r4.getCountryData(), t4, u3);
          });
        }
      }, r4.handleInputFocus = function(e4) {
        r4.numberInputRef && r4.numberInputRef.value === r4.props.prefix && r4.state.selectedCountry && !r4.props.disableCountryCode && r4.setState({ formattedNumber: r4.props.prefix + r4.state.selectedCountry.dialCode }, function() {
          r4.props.jumpCursorToEnd && setTimeout(r4.cursorToEnd, 0);
        }), r4.setState({ placeholder: "" }), r4.props.onFocus && r4.props.onFocus(e4, r4.getCountryData()), r4.props.jumpCursorToEnd && setTimeout(r4.cursorToEnd, 0);
      }, r4.handleInputBlur = function(e4) {
        e4.target.value || r4.setState({ placeholder: r4.props.placeholder }), r4.props.onBlur && r4.props.onBlur(e4, r4.getCountryData());
      }, r4.handleInputCopy = function(e4) {
        if (r4.props.copyNumbersOnly) {
          var t4 = window.getSelection().toString().replace(/[^0-9]+/g, "");
          e4.clipboardData.setData("text/plain", t4), e4.preventDefault();
        }
      }, r4.getHighlightCountryIndex = function(e4) {
        var t4 = r4.state.highlightCountryIndex + e4;
        return t4 < 0 || t4 >= r4.state.onlyCountries.length + r4.state.preferredCountries.length ? t4 - e4 : r4.props.enableSearch && t4 > r4.getSearchFilteredCountries().length ? 0 : t4;
      }, r4.searchCountry = function() {
        var e4 = r4.getProbableCandidate(r4.state.queryString) || r4.state.onlyCountries[0], t4 = r4.state.onlyCountries.findIndex(function(t5) {
          return t5 == e4;
        }) + r4.state.preferredCountries.length;
        r4.scrollTo(r4.getElement(t4), true), r4.setState({ queryString: "", highlightCountryIndex: t4 });
      }, r4.handleKeydown = function(e4) {
        var t4 = r4.props.keys, n3 = e4.target.className;
        if (n3.includes("selected-flag") && e4.which === t4.ENTER && !r4.state.showDropdown)
          return r4.handleFlagDropdownClick(e4);
        if (n3.includes("form-control") && (e4.which === t4.ENTER || e4.which === t4.ESC))
          return e4.target.blur();
        if (r4.state.showDropdown && !r4.props.disabled && (!n3.includes("search-box") || e4.which === t4.UP || e4.which === t4.DOWN || e4.which === t4.ENTER || e4.which === t4.ESC && e4.target.value === "")) {
          e4.preventDefault ? e4.preventDefault() : e4.returnValue = false;
          var a2 = function(e5) {
            r4.setState({ highlightCountryIndex: r4.getHighlightCountryIndex(e5) }, function() {
              r4.scrollTo(r4.getElement(r4.state.highlightCountryIndex), true);
            });
          };
          switch (e4.which) {
            case t4.DOWN:
              a2(1);
              break;
            case t4.UP:
              a2(-1);
              break;
            case t4.ENTER:
              r4.props.enableSearch ? r4.handleFlagItemClick(r4.getSearchFilteredCountries()[r4.state.highlightCountryIndex] || r4.getSearchFilteredCountries()[0], e4) : r4.handleFlagItemClick([].concat(o(r4.state.preferredCountries), o(r4.state.onlyCountries))[r4.state.highlightCountryIndex], e4);
              break;
            case t4.ESC:
            case t4.TAB:
              r4.setState({ showDropdown: false }, r4.cursorToEnd);
              break;
            default:
              (e4.which >= t4.A && e4.which <= t4.Z || e4.which === t4.SPACE) && r4.setState({ queryString: r4.state.queryString + String.fromCharCode(e4.which) }, r4.state.debouncedQueryStingSearcher);
          }
        }
      }, r4.handleInputKeyDown = function(e4) {
        var t4 = r4.props, n3 = t4.keys, a2 = t4.onEnterKeyPress, o2 = t4.onKeyDown;
        e4.which === n3.ENTER && a2 && a2(e4), o2 && o2(e4);
      }, r4.handleClickOutside = function(e4) {
        r4.dropdownRef && !r4.dropdownContainerRef.contains(e4.target) && r4.state.showDropdown && r4.setState({ showDropdown: false });
      }, r4.handleSearchChange = function(e4) {
        var t4 = e4.currentTarget.value, n3 = r4.state, a2 = n3.preferredCountries, o2 = n3.selectedCountry, i2 = 0;
        if (t4 === "" && o2) {
          var u3 = r4.state.onlyCountries;
          i2 = r4.concatPreferredCountries(a2, u3).findIndex(function(e5) {
            return e5 == o2;
          }), setTimeout(function() {
            return r4.scrollTo(r4.getElement(i2));
          }, 100);
        }
        r4.setState({ searchValue: t4, highlightCountryIndex: i2 });
      }, r4.concatPreferredCountries = function(e4, t4) {
        return e4.length > 0 ? o(new Set(e4.concat(t4))) : t4;
      }, r4.getDropdownCountryName = function(e4) {
        return e4.localName || e4.name;
      }, r4.getSearchFilteredCountries = function() {
        var e4 = r4.state, t4 = e4.preferredCountries, n3 = e4.onlyCountries, a2 = e4.searchValue, i2 = r4.props.enableSearch, u3 = r4.concatPreferredCountries(t4, n3), c2 = a2.trim().toLowerCase().replace("+", "");
        if (i2 && c2) {
          if (/^\d+$/.test(c2))
            return u3.filter(function(e5) {
              var t5 = e5.dialCode;
              return ["".concat(t5)].some(function(e6) {
                return e6.toLowerCase().includes(c2);
              });
            });
          var s3 = u3.filter(function(e5) {
            var t5 = e5.iso2;
            return ["".concat(t5)].some(function(e6) {
              return e6.toLowerCase().includes(c2);
            });
          }), l5 = u3.filter(function(e5) {
            var t5 = e5.name, r5 = e5.localName;
            e5.iso2;
            return ["".concat(t5), "".concat(r5 || "")].some(function(e6) {
              return e6.toLowerCase().includes(c2);
            });
          });
          return r4.scrollToTop(), o(new Set([].concat(s3, l5)));
        }
        return u3;
      }, r4.getCountryDropdownList = function() {
        var e4 = r4.state, t4 = e4.preferredCountries, a2 = e4.highlightCountryIndex, o2 = e4.showDropdown, i2 = e4.searchValue, u3 = r4.props, c2 = u3.disableDropdown, s3 = u3.prefix, l5 = r4.props, f2 = l5.enableSearch, d2 = l5.searchNotFound, p3 = l5.disableSearchIcon, h4 = l5.searchClass, m4 = l5.searchStyle, b3 = l5.searchPlaceholder, g2 = l5.autocompleteSearch, v4 = r4.getSearchFilteredCountries().map(function(e5, t5) {
          var n3 = a2 === t5, o3 = N2()({ country: true, preferred: e5.iso2 === "us" || e5.iso2 === "gb", active: e5.iso2 === "us", highlight: n3 }), i3 = "flag ".concat(e5.iso2);
          return y2.a.createElement("li", Object.assign({ ref: function(e6) {
            return r4["flag_no_".concat(t5)] = e6;
          }, key: "flag_no_".concat(t5), "data-flag-key": "flag_no_".concat(t5), className: o3, "data-dial-code": "1", tabIndex: c2 ? "-1" : "0", "data-country-code": e5.iso2, onClick: function(t6) {
            return r4.handleFlagItemClick(e5, t6);
          }, role: "option" }, n3 ? { "aria-selected": true } : {}), y2.a.createElement("div", { className: i3 }), y2.a.createElement("span", { className: "country-name" }, r4.getDropdownCountryName(e5)), y2.a.createElement("span", { className: "dial-code" }, e5.format ? r4.formatNumber(e5.dialCode, e5) : s3 + e5.dialCode));
        }), C3 = y2.a.createElement("li", { key: "dashes", className: "divider" });
        t4.length > 0 && (!f2 || f2 && !i2.trim()) && v4.splice(t4.length, 0, C3);
        var _3 = N2()(n2({ "country-list": true, hide: !o2 }, r4.props.dropdownClass, true));
        return y2.a.createElement("ul", { ref: function(e5) {
          return !f2 && e5 && e5.focus(), r4.dropdownRef = e5;
        }, className: _3, style: r4.props.dropdownStyle, role: "listbox", tabIndex: "0" }, f2 && y2.a.createElement("li", { className: N2()(n2({ search: true }, h4, h4)) }, !p3 && y2.a.createElement("span", { className: N2()(n2({ "search-emoji": true }, "".concat(h4, "-emoji"), h4)), role: "img", "aria-label": "Magnifying glass" }, "\u{1F50E}"), y2.a.createElement("input", { className: N2()(n2({ "search-box": true }, "".concat(h4, "-box"), h4)), style: m4, type: "search", placeholder: b3, autoFocus: true, autoComplete: g2 ? "on" : "off", value: i2, onChange: r4.handleSearchChange })), v4.length > 0 ? v4 : y2.a.createElement("li", { className: "no-entries-message" }, y2.a.createElement("span", null, d2)));
      };
      var s2, l4 = new P2(e3.enableAreaCodes, e3.enableTerritories, e3.regions, e3.onlyCountries, e3.preferredCountries, e3.excludeCountries, e3.preserveOrder, e3.masks, e3.priority, e3.areaCodes, e3.localization, e3.prefix, e3.defaultMask, e3.alwaysDefaultMask), h3 = l4.onlyCountries, m3 = l4.preferredCountries, b2 = l4.hiddenAreaCodes, v3 = e3.value ? e3.value.replace(/\D/g, "") : "";
      s2 = e3.disableInitialCountryGuess ? 0 : v3.length > 1 ? r4.guessSelectedCountry(v3.substring(0, 6), e3.country, h3, b2) || 0 : e3.country && h3.find(function(t4) {
        return t4.iso2 == e3.country;
      }) || 0;
      var _2, S3 = v3.length < 2 && s2 && !j()(v3, s2.dialCode) ? s2.dialCode : "";
      _2 = v3 === "" && s2 === 0 ? "" : r4.formatNumber((e3.disableCountryCode ? "" : S3) + v3, s2.name ? s2 : void 0);
      var x3 = h3.findIndex(function(e4) {
        return e4 == s2;
      });
      return r4.state = { showDropdown: e3.showDropdown, formattedNumber: _2, onlyCountries: h3, preferredCountries: m3, hiddenAreaCodes: b2, selectedCountry: s2, highlightCountryIndex: x3, queryString: "", freezeSelection: false, debouncedQueryStingSearcher: g()(r4.searchCountry, 250), searchValue: "" }, r4;
    }
    var r3, l3;
    return function(e3, t4) {
      if (typeof t4 != "function" && t4 !== null)
        throw new TypeError("Super expression must either be null or a function");
      e3.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e3, writable: true, configurable: true } }), t4 && h(e3, t4);
    }(t3, e2), r3 = t3, (l3 = [{ key: "componentDidMount", value: function() {
      document.addEventListener && this.props.enableClickOutside && document.addEventListener("mousedown", this.handleClickOutside), this.props.onMount && this.props.onMount(this.state.formattedNumber.replace(/[^0-9]+/g, ""), this.getCountryData(), this.state.formattedNumber);
    } }, { key: "componentWillUnmount", value: function() {
      document.removeEventListener && this.props.enableClickOutside && document.removeEventListener("mousedown", this.handleClickOutside);
    } }, { key: "componentDidUpdate", value: function(e3, t4, r4) {
      e3.country !== this.props.country ? this.updateCountry(this.props.country) : e3.value !== this.props.value && this.updateFormattedNumber(this.props.value);
    } }, { key: "updateFormattedNumber", value: function(e3) {
      if (e3 === null)
        return this.setState({ selectedCountry: 0, formattedNumber: "" });
      var t4 = this.state, r4 = t4.onlyCountries, n3 = t4.selectedCountry, a2 = t4.hiddenAreaCodes, o2 = this.props, i2 = o2.country, u3 = o2.prefix;
      if (e3 === "")
        return this.setState({ selectedCountry: n3, formattedNumber: "" });
      var c2, s2, l4 = e3.replace(/\D/g, "");
      if (n3 && j()(e3, u3 + n3.dialCode))
        s2 = this.formatNumber(l4, n3), this.setState({ formattedNumber: s2 });
      else {
        var f2 = (c2 = this.props.disableCountryGuess ? n3 : this.guessSelectedCountry(l4.substring(0, 6), i2, r4, a2) || n3) && j()(l4, u3 + c2.dialCode) ? c2.dialCode : "";
        s2 = this.formatNumber((this.props.disableCountryCode ? "" : f2) + l4, c2 || void 0), this.setState({ selectedCountry: c2, formattedNumber: s2 });
      }
    } }, { key: "render", value: function() {
      var e3, t4, r4, a2 = this, o2 = this.state, i2 = o2.onlyCountries, u3 = o2.selectedCountry, c2 = o2.showDropdown, s2 = o2.formattedNumber, l4 = o2.hiddenAreaCodes, f2 = this.props, d2 = f2.disableDropdown, p3 = f2.renderStringAsFlag, h3 = f2.isValid, m3 = f2.defaultErrorMessage, b2 = f2.specialLabel;
      if (typeof h3 == "boolean")
        t4 = h3;
      else {
        var g2 = h3(s2.replace(/\D/g, ""), u3, i2, l4);
        typeof g2 == "boolean" ? (t4 = g2) === false && (r4 = m3) : (t4 = false, r4 = g2);
      }
      var v3 = N2()((n2(e3 = {}, this.props.containerClass, true), n2(e3, "react-tel-input", true), e3)), C3 = N2()({ arrow: true, up: c2 }), _2 = N2()(n2({ "form-control": true, "invalid-number": !t4, open: c2 }, this.props.inputClass, true)), w2 = N2()({ "selected-flag": true, open: c2 }), S3 = N2()(n2({ "flag-dropdown": true, "invalid-number": !t4, open: c2 }, this.props.buttonClass, true)), j2 = "flag ".concat(u3 && u3.iso2);
      return y2.a.createElement("div", { className: "".concat(v3, " ").concat(this.props.className), style: this.props.style || this.props.containerStyle, onKeyDown: this.handleKeydown }, b2 && y2.a.createElement("div", { className: "special-label" }, b2), r4 && y2.a.createElement("div", { className: "invalid-number-message" }, r4), y2.a.createElement("input", Object.assign({ className: _2, style: this.props.inputStyle, onChange: this.handleInput, onClick: this.handleInputClick, onDoubleClick: this.handleDoubleClick, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur, onCopy: this.handleInputCopy, value: s2, onKeyDown: this.handleInputKeyDown, placeholder: this.props.placeholder, disabled: this.props.disabled, type: "tel" }, this.props.inputProps, { ref: function(e4) {
        a2.numberInputRef = e4, typeof a2.props.inputProps.ref == "function" ? a2.props.inputProps.ref(e4) : typeof a2.props.inputProps.ref == "object" && (a2.props.inputProps.ref.current = e4);
      } })), y2.a.createElement("div", { className: S3, style: this.props.buttonStyle, ref: function(e4) {
        return a2.dropdownContainerRef = e4;
      } }, p3 ? y2.a.createElement("div", { className: w2 }, p3) : y2.a.createElement("div", { onClick: d2 ? void 0 : this.handleFlagDropdownClick, className: w2, title: u3 ? "".concat(u3.localName || u3.name, ": + ").concat(u3.dialCode) : "", tabIndex: d2 ? "-1" : "0", role: "button", "aria-haspopup": "listbox", "aria-expanded": !!c2 || void 0 }, y2.a.createElement("div", { className: j2 }, !d2 && y2.a.createElement("div", { className: C3 }))), c2 && this.getCountryDropdownList()));
    } }]) && s(r3.prototype, l3), t3;
  }(y2.a.Component);
  F2.defaultProps = { country: "", value: "", onlyCountries: [], preferredCountries: [], excludeCountries: [], placeholder: "1 (702) 123-4567", searchPlaceholder: "search", searchNotFound: "No entries to show", flagsImagePath: "./flags.png", disabled: false, containerStyle: {}, inputStyle: {}, buttonStyle: {}, dropdownStyle: {}, searchStyle: {}, containerClass: "", inputClass: "", buttonClass: "", dropdownClass: "", searchClass: "", className: "", autoFormat: true, enableAreaCodes: false, enableTerritories: false, disableCountryCode: false, disableDropdown: false, enableLongNumbers: false, countryCodeEditable: true, enableSearch: false, disableSearchIcon: false, disableInitialCountryGuess: false, disableCountryGuess: false, regions: "", inputProps: {}, localization: {}, masks: null, priority: null, areaCodes: null, preserveOrder: [], defaultMask: "... ... ... ... ..", alwaysDefaultMask: false, prefix: "+", copyNumbersOnly: true, renderStringAsFlag: "", autocompleteSearch: false, jumpCursorToEnd: true, enableAreaCodeStretch: false, enableClickOutside: true, showDropdown: false, isValid: true, defaultErrorMessage: "", specialLabel: "Phone", onEnterKeyPress: null, keys: { UP: 38, DOWN: 40, RIGHT: 39, LEFT: 37, ENTER: 13, ESC: 27, PLUS: 43, A: 65, Z: 90, SPACE: 32, TAB: 9 } };
  t2.default = F2;
}]);
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to2.concat(ar || Array.prototype.slice.call(from2));
}
var COMMON_MIME_TYPES = new Map([
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function toFileWithPath(file2, path) {
  var f = withMimeType(file2);
  if (typeof f.path !== "string") {
    var webkitRelativePath = file2.webkitRelativePath;
    Object.defineProperty(f, "path", {
      value: typeof path === "string" ? path : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file2.name,
      writable: false,
      configurable: false,
      enumerable: true
    });
  }
  return f;
}
function withMimeType(file2) {
  var name = file2.name;
  var hasExtension = name && name.lastIndexOf(".") !== -1;
  if (hasExtension && !file2.type) {
    var ext = name.split(".").pop().toLowerCase();
    var type = COMMON_MIME_TYPES.get(ext);
    if (type) {
      Object.defineProperty(file2, "type", {
        value: type,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }
  }
  return file2;
}
var FILES_TO_IGNORE = [
  ".DS_Store",
  "Thumbs.db"
];
function fromEvent(evt) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      if (isObject$1(evt) && isDataTransfer(evt.dataTransfer)) {
        return [2, getDataTransferFiles(evt.dataTransfer, evt.type)];
      } else if (isChangeEvt(evt)) {
        return [2, getInputFiles(evt)];
      } else if (Array.isArray(evt) && evt.every(function(item) {
        return "getFile" in item && typeof item.getFile === "function";
      })) {
        return [2, getFsHandleFiles(evt)];
      }
      return [2, []];
    });
  });
}
function isDataTransfer(value2) {
  return isObject$1(value2);
}
function isChangeEvt(value2) {
  return isObject$1(value2) && isObject$1(value2.target);
}
function isObject$1(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function getInputFiles(evt) {
  return fromList(evt.target.files).map(function(file2) {
    return toFileWithPath(file2);
  });
}
function getFsHandleFiles(handles) {
  return __awaiter(this, void 0, void 0, function() {
    var files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, Promise.all(handles.map(function(h) {
            return h.getFile();
          }))];
        case 1:
          files = _a.sent();
          return [2, files.map(function(file2) {
            return toFileWithPath(file2);
          })];
      }
    });
  });
}
function getDataTransferFiles(dt, type) {
  return __awaiter(this, void 0, void 0, function() {
    var items, files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (!dt.items)
            return [3, 2];
          items = fromList(dt.items).filter(function(item) {
            return item.kind === "file";
          });
          if (type !== "drop") {
            return [2, items];
          }
          return [4, Promise.all(items.map(toFilePromises))];
        case 1:
          files = _a.sent();
          return [2, noIgnoredFiles(flatten(files))];
        case 2:
          return [2, noIgnoredFiles(fromList(dt.files).map(function(file2) {
            return toFileWithPath(file2);
          }))];
      }
    });
  });
}
function noIgnoredFiles(files) {
  return files.filter(function(file2) {
    return FILES_TO_IGNORE.indexOf(file2.name) === -1;
  });
}
function fromList(items) {
  if (items === null) {
    return [];
  }
  var files = [];
  for (var i = 0; i < items.length; i++) {
    var file2 = items[i];
    files.push(file2);
  }
  return files;
}
function toFilePromises(item) {
  if (typeof item.webkitGetAsEntry !== "function") {
    return fromDataTransferItem(item);
  }
  var entry = item.webkitGetAsEntry();
  if (entry && entry.isDirectory) {
    return fromDirEntry(entry);
  }
  return fromDataTransferItem(item);
}
function flatten(items) {
  return items.reduce(function(acc, files) {
    return __spreadArray(__spreadArray([], __read(acc), false), __read(Array.isArray(files) ? flatten(files) : [files]), false);
  }, []);
}
function fromDataTransferItem(item) {
  var file2 = item.getAsFile();
  if (!file2) {
    return Promise.reject("".concat(item, " is not a File"));
  }
  var fwp = toFileWithPath(file2);
  return Promise.resolve(fwp);
}
function fromEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
    });
  });
}
function fromDirEntry(entry) {
  var reader = entry.createReader();
  return new Promise(function(resolve2, reject) {
    var entries = [];
    function readEntries() {
      var _this = this;
      reader.readEntries(function(batch) {
        return __awaiter(_this, void 0, void 0, function() {
          var files, err_1, items;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!batch.length)
                  return [3, 5];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, Promise.all(entries)];
              case 2:
                files = _a.sent();
                resolve2(files);
                return [3, 4];
              case 3:
                err_1 = _a.sent();
                reject(err_1);
                return [3, 4];
              case 4:
                return [3, 6];
              case 5:
                items = Promise.all(batch.map(fromEntry));
                entries.push(items);
                readEntries();
                _a.label = 6;
              case 6:
                return [2];
            }
          });
        });
      }, function(err) {
        reject(err);
      });
    }
    readEntries();
  });
}
function fromFileEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve2, reject) {
        entry.file(function(file2) {
          var fwp = toFileWithPath(file2, entry.fullPath);
          resolve2(fwp);
        }, function(err) {
          reject(err);
        });
      })];
    });
  });
}
var _default = function(file2, acceptedFiles) {
  if (file2 && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    var fileName = file2.name || "";
    var mimeType = (file2.type || "").toLowerCase();
    var baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some(function(type) {
      var validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      } else if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
};
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source2), true).forEach(function(key) {
      _defineProperty$1(target, key, source2[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$1(Object(source2)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
    });
  }
  return target;
}
function _defineProperty$1(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
var FILE_INVALID_TYPE = "file-invalid-type";
var FILE_TOO_LARGE = "file-too-large";
var FILE_TOO_SMALL = "file-too-small";
var TOO_MANY_FILES = "too-many-files";
var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr2(accept) {
  accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
  var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(", ")) : accept;
  return {
    code: FILE_INVALID_TYPE,
    message: "File type must be ".concat(messageSuffix)
  };
};
var getTooLargeRejectionErr = function getTooLargeRejectionErr2(maxSize) {
  return {
    code: FILE_TOO_LARGE,
    message: "File is larger than ".concat(maxSize, " ").concat(maxSize === 1 ? "byte" : "bytes")
  };
};
var getTooSmallRejectionErr = function getTooSmallRejectionErr2(minSize) {
  return {
    code: FILE_TOO_SMALL,
    message: "File is smaller than ".concat(minSize, " ").concat(minSize === 1 ? "byte" : "bytes")
  };
};
var TOO_MANY_FILES_REJECTION = {
  code: TOO_MANY_FILES,
  message: "Too many files"
};
function fileAccepted(file2, accept) {
  var isAcceptable = file2.type === "application/x-moz-file" || _default(file2, accept);
  return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
}
function fileMatchSize(file2, minSize, maxSize) {
  if (isDefined(file2.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file2.size > maxSize)
        return [false, getTooLargeRejectionErr(maxSize)];
      if (file2.size < minSize)
        return [false, getTooSmallRejectionErr(minSize)];
    } else if (isDefined(minSize) && file2.size < minSize)
      return [false, getTooSmallRejectionErr(minSize)];
    else if (isDefined(maxSize) && file2.size > maxSize)
      return [false, getTooLargeRejectionErr(maxSize)];
  }
  return [true, null];
}
function isDefined(value2) {
  return value2 !== void 0 && value2 !== null;
}
function allFilesAccepted(_ref) {
  var files = _ref.files, accept = _ref.accept, minSize = _ref.minSize, maxSize = _ref.maxSize, multiple = _ref.multiple, maxFiles = _ref.maxFiles, validator2 = _ref.validator;
  if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {
    return false;
  }
  return files.every(function(file2) {
    var _fileAccepted = fileAccepted(file2, accept), _fileAccepted2 = _slicedToArray$1(_fileAccepted, 1), accepted = _fileAccepted2[0];
    var _fileMatchSize = fileMatchSize(file2, minSize, maxSize), _fileMatchSize2 = _slicedToArray$1(_fileMatchSize, 1), sizeMatch = _fileMatchSize2[0];
    var customErrors = validator2 ? validator2(file2) : null;
    return accepted && sizeMatch && !customErrors;
  });
}
function isPropagationStopped(event) {
  if (typeof event.isPropagationStopped === "function") {
    return event.isPropagationStopped();
  } else if (typeof event.cancelBubble !== "undefined") {
    return event.cancelBubble;
  }
  return false;
}
function isEvtWithFiles(event) {
  if (!event.dataTransfer) {
    return !!event.target && !!event.target.files;
  }
  return Array.prototype.some.call(event.dataTransfer.types, function(type) {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function onDocumentDragOver(event) {
  event.preventDefault();
}
function isIe(userAgent) {
  return userAgent.indexOf("MSIE") !== -1 || userAgent.indexOf("Trident/") !== -1;
}
function isEdge(userAgent) {
  return userAgent.indexOf("Edge/") !== -1;
}
function isIeOrEdge() {
  var userAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return isIe(userAgent) || isEdge(userAgent);
}
function composeEventHandlers() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return fns.some(function(fn) {
      if (!isPropagationStopped(event) && fn) {
        fn.apply(void 0, [event].concat(args));
      }
      return isPropagationStopped(event);
    });
  };
}
function canUseFileSystemAccessAPI() {
  return "showOpenFilePicker" in window;
}
function pickerOptionsFromAccept(accept) {
  if (isDefined(accept)) {
    var acceptForPicker = Object.entries(accept).filter(function(_ref2) {
      var _ref3 = _slicedToArray$1(_ref2, 2), mimeType = _ref3[0], ext = _ref3[1];
      var ok2 = true;
      if (!isMIMEType(mimeType)) {
        console.warn('Skipped "'.concat(mimeType, '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.'));
        ok2 = false;
      }
      if (!Array.isArray(ext) || !ext.every(isExt)) {
        console.warn('Skipped "'.concat(mimeType, '" because an invalid file extension was provided.'));
        ok2 = false;
      }
      return ok2;
    }).reduce(function(agg, _ref4) {
      var _ref5 = _slicedToArray$1(_ref4, 2), mimeType = _ref5[0], ext = _ref5[1];
      return _objectSpread$1(_objectSpread$1({}, agg), {}, _defineProperty$1({}, mimeType, ext));
    }, {});
    return [{
      accept: acceptForPicker
    }];
  }
  return accept;
}
function acceptPropAsAcceptAttr(accept) {
  if (isDefined(accept)) {
    return Object.entries(accept).reduce(function(a, _ref6) {
      var _ref7 = _slicedToArray$1(_ref6, 2), mimeType = _ref7[0], ext = _ref7[1];
      return [].concat(_toConsumableArray$1(a), [mimeType], _toConsumableArray$1(ext));
    }, []).filter(function(v2) {
      return isMIMEType(v2) || isExt(v2);
    }).join(",");
  }
  return void 0;
}
function isAbort(v2) {
  return v2 instanceof DOMException && (v2.name === "AbortError" || v2.code === v2.ABORT_ERR);
}
function isSecurityError(v2) {
  return v2 instanceof DOMException && (v2.name === "SecurityError" || v2.code === v2.SECURITY_ERR);
}
function isMIMEType(v2) {
  return v2 === "audio/*" || v2 === "video/*" || v2 === "image/*" || v2 === "text/*" || /\w+\/[-+.\w]+/g.test(v2);
}
function isExt(v2) {
  return /^.*\.[\w]+$/.test(v2);
}
var _excluded = ["children"], _excluded2 = ["open"], _excluded3 = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"], _excluded4 = ["refKey", "onChange", "onClick"];
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source2), true).forEach(function(key) {
      _defineProperty(target, key, source2[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source2, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key))
        continue;
      target[key] = source2[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
var Dropzone = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var children = _ref.children, params = _objectWithoutProperties(_ref, _excluded);
  var _useDropzone = useDropzone(params), open = _useDropzone.open, props = _objectWithoutProperties(_useDropzone, _excluded2);
  react.exports.useImperativeHandle(ref, function() {
    return {
      open
    };
  }, [open]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(jsxDevRuntime.exports.Fragment, {
    children: children(_objectSpread(_objectSpread({}, props), {}, {
      open
    }))
  }, void 0, false);
});
Dropzone.displayName = "Dropzone";
var defaultProps$3 = {
  disabled: false,
  getFilesFromEvent: fromEvent,
  maxSize: Infinity,
  minSize: 0,
  multiple: true,
  maxFiles: 0,
  preventDropOnDocument: true,
  noClick: false,
  noKeyboard: false,
  noDrag: false,
  noDragEventsBubbling: false,
  validator: null,
  useFsAccessApi: true,
  autoFocus: false
};
Dropzone.defaultProps = defaultProps$3;
Dropzone.propTypes = {
  children: PropTypes.func,
  accept: PropTypes.objectOf(PropTypes.arrayOf(PropTypes.string)),
  multiple: PropTypes.bool,
  preventDropOnDocument: PropTypes.bool,
  noClick: PropTypes.bool,
  noKeyboard: PropTypes.bool,
  noDrag: PropTypes.bool,
  noDragEventsBubbling: PropTypes.bool,
  minSize: PropTypes.number,
  maxSize: PropTypes.number,
  maxFiles: PropTypes.number,
  disabled: PropTypes.bool,
  getFilesFromEvent: PropTypes.func,
  onFileDialogCancel: PropTypes.func,
  onFileDialogOpen: PropTypes.func,
  useFsAccessApi: PropTypes.bool,
  autoFocus: PropTypes.bool,
  onDragEnter: PropTypes.func,
  onDragLeave: PropTypes.func,
  onDragOver: PropTypes.func,
  onDrop: PropTypes.func,
  onDropAccepted: PropTypes.func,
  onDropRejected: PropTypes.func,
  onError: PropTypes.func,
  validator: PropTypes.func
};
var initialState = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  acceptedFiles: [],
  fileRejections: []
};
function useDropzone() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _defaultProps$props = _objectSpread(_objectSpread({}, defaultProps$3), props), accept = _defaultProps$props.accept, disabled = _defaultProps$props.disabled, getFilesFromEvent = _defaultProps$props.getFilesFromEvent, maxSize = _defaultProps$props.maxSize, minSize = _defaultProps$props.minSize, multiple = _defaultProps$props.multiple, maxFiles = _defaultProps$props.maxFiles, onDragEnter = _defaultProps$props.onDragEnter, onDragLeave = _defaultProps$props.onDragLeave, onDragOver = _defaultProps$props.onDragOver, onDrop = _defaultProps$props.onDrop, onDropAccepted = _defaultProps$props.onDropAccepted, onDropRejected = _defaultProps$props.onDropRejected, onFileDialogCancel = _defaultProps$props.onFileDialogCancel, onFileDialogOpen = _defaultProps$props.onFileDialogOpen, useFsAccessApi = _defaultProps$props.useFsAccessApi, autoFocus = _defaultProps$props.autoFocus, preventDropOnDocument = _defaultProps$props.preventDropOnDocument, noClick = _defaultProps$props.noClick, noKeyboard = _defaultProps$props.noKeyboard, noDrag = _defaultProps$props.noDrag, noDragEventsBubbling = _defaultProps$props.noDragEventsBubbling, onError = _defaultProps$props.onError, validator2 = _defaultProps$props.validator;
  var acceptAttr = react.exports.useMemo(function() {
    return acceptPropAsAcceptAttr(accept);
  }, [accept]);
  var pickerTypes = react.exports.useMemo(function() {
    return pickerOptionsFromAccept(accept);
  }, [accept]);
  var onFileDialogOpenCb = react.exports.useMemo(function() {
    return typeof onFileDialogOpen === "function" ? onFileDialogOpen : noop;
  }, [onFileDialogOpen]);
  var onFileDialogCancelCb = react.exports.useMemo(function() {
    return typeof onFileDialogCancel === "function" ? onFileDialogCancel : noop;
  }, [onFileDialogCancel]);
  var rootRef = react.exports.useRef(null);
  var inputRef = react.exports.useRef(null);
  var _useReducer = react.exports.useReducer(reducer, initialState), _useReducer2 = _slicedToArray(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var isFocused = state.isFocused, isFileDialogActive = state.isFileDialogActive;
  var fsAccessApiWorksRef = react.exports.useRef(typeof window !== "undefined" && window.isSecureContext && useFsAccessApi && canUseFileSystemAccessAPI());
  var onWindowFocus = function onWindowFocus2() {
    if (!fsAccessApiWorksRef.current && isFileDialogActive) {
      setTimeout(function() {
        if (inputRef.current) {
          var files = inputRef.current.files;
          if (!files.length) {
            dispatch({
              type: "closeDialog"
            });
            onFileDialogCancelCb();
          }
        }
      }, 300);
    }
  };
  react.exports.useEffect(function() {
    window.addEventListener("focus", onWindowFocus, false);
    return function() {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [inputRef, isFileDialogActive, onFileDialogCancelCb, fsAccessApiWorksRef]);
  var dragTargetsRef = react.exports.useRef([]);
  var onDocumentDrop = function onDocumentDrop2(event) {
    if (rootRef.current && rootRef.current.contains(event.target)) {
      return;
    }
    event.preventDefault();
    dragTargetsRef.current = [];
  };
  react.exports.useEffect(function() {
    if (preventDropOnDocument) {
      document.addEventListener("dragover", onDocumentDragOver, false);
      document.addEventListener("drop", onDocumentDrop, false);
    }
    return function() {
      if (preventDropOnDocument) {
        document.removeEventListener("dragover", onDocumentDragOver);
        document.removeEventListener("drop", onDocumentDrop);
      }
    };
  }, [rootRef, preventDropOnDocument]);
  react.exports.useEffect(function() {
    if (!disabled && autoFocus && rootRef.current) {
      rootRef.current.focus();
    }
    return function() {
    };
  }, [rootRef, autoFocus, disabled]);
  var onErrCb = react.exports.useCallback(function(e) {
    if (onError) {
      onError(e);
    } else {
      console.error(e);
    }
  }, [onError]);
  var onDragEnterCb = react.exports.useCallback(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [].concat(_toConsumableArray(dragTargetsRef.current), [event.target]);
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        var fileCount = files.length;
        var isDragAccept = fileCount > 0 && allFilesAccepted({
          files,
          accept: acceptAttr,
          minSize,
          maxSize,
          multiple,
          maxFiles,
          validator: validator2
        });
        var isDragReject = fileCount > 0 && !isDragAccept;
        dispatch({
          isDragAccept,
          isDragReject,
          isDragActive: true,
          type: "setDraggedFiles"
        });
        if (onDragEnter) {
          onDragEnter(event);
        }
      }).catch(function(e) {
        return onErrCb(e);
      });
    }
  }, [getFilesFromEvent, onDragEnter, onErrCb, noDragEventsBubbling, acceptAttr, minSize, maxSize, multiple, maxFiles, validator2]);
  var onDragOverCb = react.exports.useCallback(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var hasFiles = isEvtWithFiles(event);
    if (hasFiles && event.dataTransfer) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch (_unused) {
      }
    }
    if (hasFiles && onDragOver) {
      onDragOver(event);
    }
    return false;
  }, [onDragOver, noDragEventsBubbling]);
  var onDragLeaveCb = react.exports.useCallback(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var targets = dragTargetsRef.current.filter(function(target) {
      return rootRef.current && rootRef.current.contains(target);
    });
    var targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1) {
      targets.splice(targetIdx, 1);
    }
    dragTargetsRef.current = targets;
    if (targets.length > 0) {
      return;
    }
    dispatch({
      type: "setDraggedFiles",
      isDragActive: false,
      isDragAccept: false,
      isDragReject: false
    });
    if (isEvtWithFiles(event) && onDragLeave) {
      onDragLeave(event);
    }
  }, [rootRef, onDragLeave, noDragEventsBubbling]);
  var setFiles = react.exports.useCallback(function(files, event) {
    var acceptedFiles = [];
    var fileRejections = [];
    files.forEach(function(file2) {
      var _fileAccepted = fileAccepted(file2, acceptAttr), _fileAccepted2 = _slicedToArray(_fileAccepted, 2), accepted = _fileAccepted2[0], acceptError = _fileAccepted2[1];
      var _fileMatchSize = fileMatchSize(file2, minSize, maxSize), _fileMatchSize2 = _slicedToArray(_fileMatchSize, 2), sizeMatch = _fileMatchSize2[0], sizeError = _fileMatchSize2[1];
      var customErrors = validator2 ? validator2(file2) : null;
      if (accepted && sizeMatch && !customErrors) {
        acceptedFiles.push(file2);
      } else {
        var errors = [acceptError, sizeError];
        if (customErrors) {
          errors = errors.concat(customErrors);
        }
        fileRejections.push({
          file: file2,
          errors: errors.filter(function(e) {
            return e;
          })
        });
      }
    });
    if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {
      acceptedFiles.forEach(function(file2) {
        fileRejections.push({
          file: file2,
          errors: [TOO_MANY_FILES_REJECTION]
        });
      });
      acceptedFiles.splice(0);
    }
    dispatch({
      acceptedFiles,
      fileRejections,
      type: "setFiles"
    });
    if (onDrop) {
      onDrop(acceptedFiles, fileRejections, event);
    }
    if (fileRejections.length > 0 && onDropRejected) {
      onDropRejected(fileRejections, event);
    }
    if (acceptedFiles.length > 0 && onDropAccepted) {
      onDropAccepted(acceptedFiles, event);
    }
  }, [dispatch, multiple, acceptAttr, minSize, maxSize, maxFiles, onDrop, onDropAccepted, onDropRejected, validator2]);
  var onDropCb = react.exports.useCallback(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [];
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        setFiles(files, event);
      }).catch(function(e) {
        return onErrCb(e);
      });
    }
    dispatch({
      type: "reset"
    });
  }, [getFilesFromEvent, setFiles, onErrCb, noDragEventsBubbling]);
  var openFileDialog = react.exports.useCallback(function() {
    if (fsAccessApiWorksRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      var opts = {
        multiple,
        types: pickerTypes
      };
      window.showOpenFilePicker(opts).then(function(handles) {
        return getFilesFromEvent(handles);
      }).then(function(files) {
        setFiles(files, null);
        dispatch({
          type: "closeDialog"
        });
      }).catch(function(e) {
        if (isAbort(e)) {
          onFileDialogCancelCb(e);
          dispatch({
            type: "closeDialog"
          });
        } else if (isSecurityError(e)) {
          fsAccessApiWorksRef.current = false;
          if (inputRef.current) {
            inputRef.current.value = null;
            inputRef.current.click();
          } else {
            onErrCb(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."));
          }
        } else {
          onErrCb(e);
        }
      });
      return;
    }
    if (inputRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      inputRef.current.value = null;
      inputRef.current.click();
    }
  }, [dispatch, onFileDialogOpenCb, onFileDialogCancelCb, useFsAccessApi, setFiles, onErrCb, pickerTypes, multiple]);
  var onKeyDownCb = react.exports.useCallback(function(event) {
    if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {
      return;
    }
    if (event.key === " " || event.key === "Enter" || event.keyCode === 32 || event.keyCode === 13) {
      event.preventDefault();
      openFileDialog();
    }
  }, [rootRef, openFileDialog]);
  var onFocusCb = react.exports.useCallback(function() {
    dispatch({
      type: "focus"
    });
  }, []);
  var onBlurCb = react.exports.useCallback(function() {
    dispatch({
      type: "blur"
    });
  }, []);
  var onClickCb = react.exports.useCallback(function() {
    if (noClick) {
      return;
    }
    if (isIeOrEdge()) {
      setTimeout(openFileDialog, 0);
    } else {
      openFileDialog();
    }
  }, [noClick, openFileDialog]);
  var composeHandler = function composeHandler2(fn) {
    return disabled ? null : fn;
  };
  var composeKeyboardHandler = function composeKeyboardHandler2(fn) {
    return noKeyboard ? null : composeHandler(fn);
  };
  var composeDragHandler = function composeDragHandler2(fn) {
    return noDrag ? null : composeHandler(fn);
  };
  var stopPropagation = function stopPropagation2(event) {
    if (noDragEventsBubbling) {
      event.stopPropagation();
    }
  };
  var getRootProps = react.exports.useMemo(function() {
    return function() {
      var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$refKey = _ref2.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, role = _ref2.role, onKeyDown = _ref2.onKeyDown, onFocus = _ref2.onFocus, onBlur = _ref2.onBlur, onClick = _ref2.onClick, onDragEnter2 = _ref2.onDragEnter, onDragOver2 = _ref2.onDragOver, onDragLeave2 = _ref2.onDragLeave, onDrop2 = _ref2.onDrop, rest = _objectWithoutProperties(_ref2, _excluded3);
      return _objectSpread(_objectSpread(_defineProperty({
        onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
        onFocus: composeKeyboardHandler(composeEventHandlers(onFocus, onFocusCb)),
        onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
        onDragEnter: composeDragHandler(composeEventHandlers(onDragEnter2, onDragEnterCb)),
        onDragOver: composeDragHandler(composeEventHandlers(onDragOver2, onDragOverCb)),
        onDragLeave: composeDragHandler(composeEventHandlers(onDragLeave2, onDragLeaveCb)),
        onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb)),
        role: typeof role === "string" && role !== "" ? role : "presentation"
      }, refKey, rootRef), !disabled && !noKeyboard ? {
        tabIndex: 0
      } : {}), rest);
    };
  }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled]);
  var onInputElementClick = react.exports.useCallback(function(event) {
    event.stopPropagation();
  }, []);
  var getInputProps = react.exports.useMemo(function() {
    return function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, onChange = _ref3.onChange, onClick = _ref3.onClick, rest = _objectWithoutProperties(_ref3, _excluded4);
      var inputProps = _defineProperty({
        accept: acceptAttr,
        multiple,
        type: "file",
        style: {
          display: "none"
        },
        onChange: composeHandler(composeEventHandlers(onChange, onDropCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
        tabIndex: -1
      }, refKey, inputRef);
      return _objectSpread(_objectSpread({}, inputProps), rest);
    };
  }, [inputRef, accept, multiple, onDropCb, disabled]);
  return _objectSpread(_objectSpread({}, state), {}, {
    isFocused: isFocused && !disabled,
    getRootProps,
    getInputProps,
    rootRef,
    inputRef,
    open: composeHandler(openFileDialog)
  });
}
function reducer(state, action) {
  switch (action.type) {
    case "focus":
      return _objectSpread(_objectSpread({}, state), {}, {
        isFocused: true
      });
    case "blur":
      return _objectSpread(_objectSpread({}, state), {}, {
        isFocused: false
      });
    case "openDialog":
      return _objectSpread(_objectSpread({}, initialState), {}, {
        isFileDialogActive: true
      });
    case "closeDialog":
      return _objectSpread(_objectSpread({}, state), {}, {
        isFileDialogActive: false
      });
    case "setDraggedFiles":
      return _objectSpread(_objectSpread({}, state), {}, {
        isDragActive: action.isDragActive,
        isDragAccept: action.isDragAccept,
        isDragReject: action.isDragReject
      });
    case "setFiles":
      return _objectSpread(_objectSpread({}, state), {}, {
        acceptedFiles: action.acceptedFiles,
        fileRejections: action.fileRejections
      });
    case "reset":
      return _objectSpread({}, initialState);
    default:
      return state;
  }
}
function noop() {
}
const MountedMapsContext = react.exports.createContext(null);
function cloneTransform(tr) {
  const newTransform = tr.clone();
  newTransform.pixelsToGLUnits = tr.pixelsToGLUnits;
  return newTransform;
}
function transformToViewState(tr) {
  return {
    longitude: tr.center.lng,
    latitude: tr.center.lat,
    zoom: tr.zoom,
    pitch: tr.pitch,
    bearing: tr.bearing,
    padding: tr.padding
  };
}
function applyViewStateToTransform(tr, props) {
  const v2 = props.viewState || props;
  let changed = false;
  if ("longitude" in v2 && "latitude" in v2) {
    const center = tr.center;
    tr.center = new center.constructor(v2.longitude, v2.latitude);
    changed = changed || center !== tr.center;
  }
  if ("zoom" in v2) {
    const zoom = tr.zoom;
    tr.zoom = v2.zoom;
    changed = changed || zoom !== tr.zoom;
  }
  if ("bearing" in v2) {
    const bearing = tr.bearing;
    tr.bearing = v2.bearing;
    changed = changed || bearing !== tr.bearing;
  }
  if ("pitch" in v2) {
    const pitch = tr.pitch;
    tr.pitch = v2.pitch;
    changed = changed || pitch !== tr.pitch;
  }
  if (v2.padding && !tr.isPaddingEqual(v2.padding)) {
    changed = true;
    tr.padding = v2.padding;
  }
  return changed;
}
const refProps = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function normalizeStyle(style) {
  if (!style) {
    return null;
  }
  if (typeof style === "string") {
    return style;
  }
  if ("toJS" in style) {
    style = style.toJS();
  }
  if (!style.layers) {
    return style;
  }
  const layerIndex = {};
  for (const layer of style.layers) {
    layerIndex[layer.id] = layer;
  }
  const layers = style.layers.map((layer) => {
    const layerRef = layerIndex[layer.ref];
    let normalizedLayer = null;
    if ("interactive" in layer) {
      normalizedLayer = __spreadValues({}, layer);
      delete normalizedLayer.interactive;
    }
    if (layerRef) {
      normalizedLayer = normalizedLayer || __spreadValues({}, layer);
      delete normalizedLayer.ref;
      for (const propName of refProps) {
        if (propName in layerRef) {
          normalizedLayer[propName] = layerRef[propName];
        }
      }
    }
    return normalizedLayer || layer;
  });
  return __spreadProps(__spreadValues({}, style), { layers });
}
function arePointsEqual(a, b) {
  const ax = Array.isArray(a) ? a[0] : a ? a.x : 0;
  const ay = Array.isArray(a) ? a[1] : a ? a.y : 0;
  const bx = Array.isArray(b) ? b[0] : b ? b.x : 0;
  const by = Array.isArray(b) ? b[1] : b ? b.y : 0;
  return ax === bx && ay === by;
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (Array.isArray(b)) {
    return false;
  }
  if (typeof a === "object" && typeof b === "object") {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
const pointerEvents = {
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  click: "onClick",
  dblclick: "onDblClick",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  mouseout: "onMouseOut",
  contextmenu: "onContextMenu",
  touchstart: "onTouchStart",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchcancel: "onTouchCancel"
};
const cameraEvents = {
  movestart: "onMoveStart",
  move: "onMove",
  moveend: "onMoveEnd",
  dragstart: "onDragStart",
  drag: "onDrag",
  dragend: "onDragEnd",
  zoomstart: "onZoomStart",
  zoom: "onZoom",
  zoomend: "onZoomEnd",
  rotatestart: "onRotateStart",
  rotate: "onRotate",
  rotateend: "onRotateEnd",
  pitchstart: "onPitchStart",
  pitch: "onPitch",
  pitchend: "onPitchEnd"
};
const otherEvents = {
  wheel: "onWheel",
  boxzoomstart: "onBoxZoomStart",
  boxzoomend: "onBoxZoomEnd",
  boxzoomcancel: "onBoxZoomCancel",
  resize: "onResize",
  load: "onLoad",
  render: "onRender",
  idle: "onIdle",
  remove: "onRemove",
  data: "onData",
  styledata: "onStyleData",
  sourcedata: "onSourceData",
  error: "onError"
};
const settingNames = [
  "minZoom",
  "maxZoom",
  "minPitch",
  "maxPitch",
  "maxBounds",
  "projection",
  "renderWorldCopies"
];
const handlerNames = [
  "scrollZoom",
  "boxZoom",
  "dragRotate",
  "dragPan",
  "keyboard",
  "doubleClickZoom",
  "touchZoomRotate",
  "touchPitch"
];
class Mapbox {
  constructor(MapClass, props, container) {
    this._map = null;
    this._internalUpdate = false;
    this._inRender = false;
    this._hoveredFeatures = null;
    this._deferredEvents = {
      move: false,
      zoom: false,
      pitch: false,
      rotate: false
    };
    this._onEvent = (e) => {
      const cb2 = this.props[otherEvents[e.type]];
      if (cb2) {
        cb2(e);
      }
    };
    this._onPointerEvent = (e) => {
      if (e.type === "mousemove" || e.type === "mouseout") {
        this._updateHover(e);
      }
      const cb2 = this.props[pointerEvents[e.type]];
      if (cb2) {
        if (this.props.interactiveLayerIds && e.type !== "mouseover" && e.type !== "mouseout") {
          const features = this._hoveredFeatures || this._map.queryRenderedFeatures(e.point, {
            layers: this.props.interactiveLayerIds
          });
          e.features = features;
        }
        cb2(e);
        delete e.features;
      }
    };
    this._onCameraEvent = (e) => {
      if (!this._internalUpdate) {
        const cb2 = this.props[cameraEvents[e.type]];
        if (cb2) {
          cb2(e);
        }
      }
      if (e.type in this._deferredEvents) {
        this._deferredEvents[e.type] = false;
      }
    };
    this._MapClass = MapClass;
    this.props = props;
    this._initialize(container);
  }
  get map() {
    return this._map;
  }
  get transform() {
    return this._renderTransform;
  }
  setProps(props) {
    const oldProps = this.props;
    this.props = props;
    const settingsChanged = this._updateSettings(props, oldProps);
    if (settingsChanged) {
      this._createShadowTransform(this._map);
    }
    const sizeChanged = this._updateSize(props);
    const viewStateChanged = this._updateViewState(props, true);
    this._updateStyle(props, oldProps);
    this._updateStyleComponents(props, oldProps);
    this._updateHandlers(props, oldProps);
    if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {
      this.redraw();
    }
  }
  static reuse(props, container) {
    const that = Mapbox.savedMaps.pop();
    if (!that) {
      return null;
    }
    const map2 = that.map;
    const oldContainer = map2.getContainer();
    container.className = oldContainer.className;
    while (oldContainer.childNodes.length > 0) {
      container.appendChild(oldContainer.childNodes[0]);
    }
    map2._container = container;
    that.setProps(__spreadProps(__spreadValues({}, props), { styleDiffing: false }));
    map2.resize();
    const { initialViewState } = props;
    if (initialViewState) {
      if (initialViewState.bounds) {
        map2.fitBounds(initialViewState.bounds, __spreadProps(__spreadValues({}, initialViewState.fitBoundsOptions), { duration: 0 }));
      } else {
        that._updateViewState(initialViewState, false);
      }
    }
    if (map2.isStyleLoaded()) {
      map2.fire("load");
    } else {
      map2.once("styledata", () => map2.fire("load"));
    }
    return that;
  }
  _initialize(container) {
    const { props } = this;
    const mapOptions = __spreadProps(__spreadValues(__spreadValues({}, props), props.initialViewState), {
      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,
      container,
      style: normalizeStyle(props.mapStyle)
    });
    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;
    Object.assign(mapOptions, {
      center: [viewState.longitude || 0, viewState.latitude || 0],
      zoom: viewState.zoom || 0,
      pitch: viewState.pitch || 0,
      bearing: viewState.bearing || 0
    });
    if (props.gl) {
      const getContext = HTMLCanvasElement.prototype.getContext;
      HTMLCanvasElement.prototype.getContext = () => {
        HTMLCanvasElement.prototype.getContext = getContext;
        return props.gl;
      };
    }
    const map2 = new this._MapClass(mapOptions);
    if (viewState.padding) {
      map2.setPadding(viewState.padding);
    }
    if (props.cursor) {
      map2.getCanvas().style.cursor = props.cursor;
    }
    this._createShadowTransform(map2);
    const renderMap = map2._render;
    map2._render = (arg) => {
      this._inRender = true;
      renderMap.call(map2, arg);
      this._inRender = false;
    };
    const runRenderTaskQueue = map2._renderTaskQueue.run;
    map2._renderTaskQueue.run = (arg) => {
      runRenderTaskQueue.call(map2._renderTaskQueue, arg);
      this._onBeforeRepaint();
    };
    map2.on("render", () => this._onAfterRepaint());
    const fireEvent = map2.fire;
    map2.fire = this._fireEvent.bind(this, fireEvent);
    map2.on("resize", () => {
      this._renderTransform.resize(map2.transform.width, map2.transform.height);
    });
    map2.on("styledata", () => this._updateStyleComponents(this.props, {}));
    map2.on("sourcedata", () => this._updateStyleComponents(this.props, {}));
    for (const eventName in pointerEvents) {
      map2.on(eventName, this._onPointerEvent);
    }
    for (const eventName in cameraEvents) {
      map2.on(eventName, this._onCameraEvent);
    }
    for (const eventName in otherEvents) {
      map2.on(eventName, this._onEvent);
    }
    this._map = map2;
  }
  recycle() {
    Mapbox.savedMaps.push(this);
  }
  destroy() {
    this._map.remove();
  }
  redraw() {
    const map2 = this._map;
    if (!this._inRender && map2.style) {
      if (map2._frame) {
        map2._frame.cancel();
        map2._frame = null;
      }
      map2._render();
    }
  }
  _createShadowTransform(map2) {
    const renderTransform = cloneTransform(map2.transform);
    map2.painter.transform = renderTransform;
    this._renderTransform = renderTransform;
  }
  _updateSize(nextProps) {
    const { viewState } = nextProps;
    if (viewState) {
      const map2 = this._map;
      if (viewState.width !== map2.transform.width || viewState.height !== map2.transform.height) {
        map2.resize();
        return true;
      }
    }
    return false;
  }
  _updateViewState(nextProps, triggerEvents) {
    if (this._internalUpdate) {
      return false;
    }
    const map2 = this._map;
    const tr = this._renderTransform;
    const { zoom, pitch, bearing } = tr;
    const isMoving = map2.isMoving();
    if (isMoving) {
      tr.cameraElevationReference = "sea";
    }
    const changed = applyViewStateToTransform(tr, __spreadValues(__spreadValues({}, transformToViewState(map2.transform)), nextProps));
    if (isMoving) {
      tr.cameraElevationReference = "ground";
    }
    if (changed && triggerEvents) {
      const deferredEvents = this._deferredEvents;
      deferredEvents.move = true;
      deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);
      deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);
      deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);
    }
    if (!isMoving) {
      applyViewStateToTransform(map2.transform, nextProps);
    }
    return changed;
  }
  _updateSettings(nextProps, currProps) {
    const map2 = this._map;
    let changed = false;
    for (const propName of settingNames) {
      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {
        changed = true;
        map2[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);
      }
    }
    return changed;
  }
  _updateStyle(nextProps, currProps) {
    if (nextProps.cursor !== currProps.cursor) {
      this._map.getCanvas().style.cursor = nextProps.cursor;
    }
    if (nextProps.mapStyle !== currProps.mapStyle) {
      const options = {
        diff: nextProps.styleDiffing
      };
      if ("localIdeographFontFamily" in nextProps) {
        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;
      }
      this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);
      return true;
    }
    return false;
  }
  _updateStyleComponents(nextProps, currProps) {
    const map2 = this._map;
    let changed = false;
    if (map2.style.loaded()) {
      if ("light" in nextProps && !deepEqual(nextProps.light, currProps.light)) {
        changed = true;
        map2.setLight(nextProps.light);
      }
      if ("fog" in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {
        changed = true;
        map2.setFog(nextProps.fog);
      }
      if ("terrain" in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {
        if (!nextProps.terrain || map2.getSource(nextProps.terrain.source)) {
          changed = true;
          map2.setTerrain(nextProps.terrain);
        }
      }
    }
    return changed;
  }
  _updateHandlers(nextProps, currProps) {
    const map2 = this._map;
    let changed = false;
    for (const propName of handlerNames) {
      const newValue = nextProps[propName];
      if (!deepEqual(newValue, currProps[propName])) {
        changed = true;
        if (newValue) {
          map2[propName].enable(newValue);
        } else {
          map2[propName].disable();
        }
      }
    }
    return changed;
  }
  _updateHover(e) {
    var _a;
    const { props } = this;
    const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);
    if (shouldTrackHoveredFeatures) {
      const eventType = e.type;
      const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;
      let features;
      if (eventType === "mousemove") {
        try {
          features = this._map.queryRenderedFeatures(e.point, {
            layers: props.interactiveLayerIds
          });
        } catch (_b) {
          features = [];
        }
      } else {
        features = [];
      }
      const isHovering = features.length > 0;
      if (!isHovering && wasHovering) {
        e.type = "mouseleave";
        this._onPointerEvent(e);
      }
      this._hoveredFeatures = features;
      if (isHovering && !wasHovering) {
        e.type = "mouseenter";
        this._onPointerEvent(e);
      }
      e.type = eventType;
    } else {
      this._hoveredFeatures = null;
    }
  }
  _fireEvent(baseFire, event, properties) {
    const map2 = this._map;
    const tr = map2.transform;
    const eventType = typeof event === "string" ? event : event.type;
    if (eventType === "move") {
      this._updateViewState(this.props, false);
    }
    if (eventType in cameraEvents) {
      if (typeof event === "object") {
        event.viewState = transformToViewState(tr);
      }
      if (this._map.isMoving()) {
        map2.transform = this._renderTransform;
        baseFire.call(map2, event, properties);
        map2.transform = tr;
        return map2;
      }
    }
    baseFire.call(map2, event, properties);
    return map2;
  }
  _onBeforeRepaint() {
    const map2 = this._map;
    this._internalUpdate = true;
    for (const eventType in this._deferredEvents) {
      if (this._deferredEvents[eventType]) {
        map2.fire(eventType);
      }
    }
    this._internalUpdate = false;
    const tr = this._map.transform;
    this._map.transform = this._renderTransform;
    this._onAfterRepaint = () => {
      this._map.transform = tr;
    };
  }
}
Mapbox.savedMaps = [];
function getAccessTokenFromEnv() {
  let accessToken = null;
  if (typeof location !== "undefined") {
    const match = /access_token=([^&\/]*)/.exec(location.search);
    accessToken = match && match[1];
  }
  try {
    accessToken = accessToken || { "TERM_PROGRAM": "vscode", "NODE": "/usr/local/bin/node", "INIT_CWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "TERM": "xterm-256color", "SHELL": "/bin/zsh", "npm_config_metrics_registry": "https://registry.npmjs.org/", "TMPDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/", "npm_config_global_prefix": "/usr/local", "TERM_PROGRAM_VERSION": "1.71.1", "ZDOTDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-zsh", "ORIGINAL_XDG_CURRENT_DESKTOP": "undefined", "MallocNanoZone": "0", "COLOR": "1", "npm_config_noproxy": "", "npm_config_local_prefix": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "USER": "obm_89", "COMMAND_MODE": "unix2003", "npm_config_globalconfig": "/usr/local/etc/npmrc", "SSH_AUTH_SOCK": "/private/tmp/com.apple.launchd.zCfsJph0oN/Listeners", "__CF_USER_TEXT_ENCODING": "0x1F5:0x0:0x0", "npm_execpath": "/usr/local/lib/node_modules/npm/bin/npm-cli.js", "PATH": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin:/Users/obm_89/Documents/hubmine/node_modules/.bin:/Users/obm_89/Documents/node_modules/.bin:/Users/obm_89/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/usr/local/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/Library/Frameworks/Python.framework/Versions/3.10/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Frameworks/Python.framework/Versions/3.10/bin", "npm_package_json": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/package.json", "_": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin/vite", "npm_config_userconfig": "/Users/obm_89/.npmrc", "npm_config_init_module": "/Users/obm_89/.npm-init.js", "__CFBundleIdentifier": "com.microsoft.VSCode", "npm_command": "run-script", "PWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "npm_lifecycle_event": "build", "EDITOR": "vi", "npm_package_name": "mosaic-react", "LANG": "en_US.UTF-8", "VSCODE_GIT_ASKPASS_EXTRA_ARGS": "--ms-enable-electron-run-as-node", "XPC_FLAGS": "0x0", "npm_config_node_gyp": "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "npm_package_version": "0.1.0", "XPC_SERVICE_NAME": "0", "VSCODE_INJECTION": "1", "SHLVL": "2", "HOME": "/Users/obm_89", "VSCODE_GIT_ASKPASS_MAIN": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js", "npm_config_cache": "/Users/obm_89/.npm", "LOGNAME": "obm_89", "npm_lifecycle_script": "vite build", "VSCODE_GIT_IPC_HANDLE": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-git-c8614585f1.sock", "npm_config_user_agent": "npm/8.15.0 node/v16.17.0 darwin x64 workspaces/false", "VSCODE_GIT_ASKPASS_NODE": "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper.app/Contents/MacOS/Code Helper", "GIT_ASKPASS": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh", "npm_node_execpath": "/usr/local/bin/node", "npm_config_prefix": "/usr/local", "COLORTERM": "truecolor", "NODE_ENV": "production" }.MapboxAccessToken;
  } catch (_a) {
  }
  try {
    accessToken = accessToken || { "TERM_PROGRAM": "vscode", "NODE": "/usr/local/bin/node", "INIT_CWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "TERM": "xterm-256color", "SHELL": "/bin/zsh", "npm_config_metrics_registry": "https://registry.npmjs.org/", "TMPDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/", "npm_config_global_prefix": "/usr/local", "TERM_PROGRAM_VERSION": "1.71.1", "ZDOTDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-zsh", "ORIGINAL_XDG_CURRENT_DESKTOP": "undefined", "MallocNanoZone": "0", "COLOR": "1", "npm_config_noproxy": "", "npm_config_local_prefix": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "USER": "obm_89", "COMMAND_MODE": "unix2003", "npm_config_globalconfig": "/usr/local/etc/npmrc", "SSH_AUTH_SOCK": "/private/tmp/com.apple.launchd.zCfsJph0oN/Listeners", "__CF_USER_TEXT_ENCODING": "0x1F5:0x0:0x0", "npm_execpath": "/usr/local/lib/node_modules/npm/bin/npm-cli.js", "PATH": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin:/Users/obm_89/Documents/hubmine/node_modules/.bin:/Users/obm_89/Documents/node_modules/.bin:/Users/obm_89/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/usr/local/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/Library/Frameworks/Python.framework/Versions/3.10/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Frameworks/Python.framework/Versions/3.10/bin", "npm_package_json": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/package.json", "_": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin/vite", "npm_config_userconfig": "/Users/obm_89/.npmrc", "npm_config_init_module": "/Users/obm_89/.npm-init.js", "__CFBundleIdentifier": "com.microsoft.VSCode", "npm_command": "run-script", "PWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "npm_lifecycle_event": "build", "EDITOR": "vi", "npm_package_name": "mosaic-react", "LANG": "en_US.UTF-8", "VSCODE_GIT_ASKPASS_EXTRA_ARGS": "--ms-enable-electron-run-as-node", "XPC_FLAGS": "0x0", "npm_config_node_gyp": "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "npm_package_version": "0.1.0", "XPC_SERVICE_NAME": "0", "VSCODE_INJECTION": "1", "SHLVL": "2", "HOME": "/Users/obm_89", "VSCODE_GIT_ASKPASS_MAIN": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js", "npm_config_cache": "/Users/obm_89/.npm", "LOGNAME": "obm_89", "npm_lifecycle_script": "vite build", "VSCODE_GIT_IPC_HANDLE": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-git-c8614585f1.sock", "npm_config_user_agent": "npm/8.15.0 node/v16.17.0 darwin x64 workspaces/false", "VSCODE_GIT_ASKPASS_NODE": "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper.app/Contents/MacOS/Code Helper", "GIT_ASKPASS": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh", "npm_node_execpath": "/usr/local/bin/node", "npm_config_prefix": "/usr/local", "COLORTERM": "truecolor", "NODE_ENV": "production" }.REACT_APP_MAPBOX_ACCESS_TOKEN;
  } catch (_b) {
  }
  return accessToken;
}
const skipMethods = [
  "setMaxBounds",
  "setMinZoom",
  "setMaxZoom",
  "setMinPitch",
  "setMaxPitch",
  "setRenderWorldCopies",
  "setProjection",
  "setStyle",
  "addSource",
  "removeSource",
  "addLayer",
  "removeLayer",
  "setLayerZoomRange",
  "setFilter",
  "setPaintProperty",
  "setLayoutProperty",
  "setLight",
  "setTerrain",
  "setFog",
  "remove"
];
function createRef(mapInstance, mapLib) {
  if (!mapInstance) {
    return null;
  }
  const map2 = mapInstance.map;
  const result = {
    getMap: () => map2,
    getCenter: () => mapInstance.transform.center,
    getZoom: () => mapInstance.transform.zoom,
    getBearing: () => mapInstance.transform.bearing,
    getPitch: () => mapInstance.transform.pitch,
    getPadding: () => mapInstance.transform.padding,
    getBounds: () => mapInstance.transform.getBounds(),
    project: (lnglat) => {
      return mapInstance.transform.locationPoint(mapLib.LngLat.convert(lnglat));
    },
    unproject: (point) => {
      return mapInstance.transform.pointLocation(mapLib.Point.convert(point));
    },
    queryTerrainElevation: (lnglat, options) => {
      const tr = map2.transform;
      map2.transform = mapInstance.transform;
      const result2 = map2.queryTerrainElevation(lnglat, options);
      map2.transform = tr;
      return result2;
    }
  };
  for (const key of getMethodNames(map2)) {
    if (!(key in result) && !skipMethods.includes(key)) {
      result[key] = map2[key].bind(map2);
    }
  }
  return result;
}
function getMethodNames(obj) {
  const result = new Set();
  let proto2 = obj;
  while (proto2) {
    for (const key of Object.getOwnPropertyNames(proto2)) {
      if (key[0] !== "_" && typeof obj[key] === "function" && key !== "fire" && key !== "setEventedParent") {
        result.add(key);
      }
    }
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Array.from(result);
}
const useIsomorphicLayoutEffect = typeof document !== "undefined" ? react.exports.useLayoutEffect : react.exports.useEffect;
const globalSettings = [
  "baseApiUrl",
  "maxParallelImageRequests",
  "workerClass",
  "workerCount",
  "workerUrl"
];
function setGlobals(mapLib, props) {
  for (const key of globalSettings) {
    if (key in props) {
      mapLib[key] = props[key];
    }
  }
  if (props.RTLTextPlugin && mapLib.getRTLTextPluginStatus && mapLib.getRTLTextPluginStatus() === "unavailable") {
    mapLib.setRTLTextPlugin(props.RTLTextPlugin, (error) => {
      if (error) {
        console.error(error);
      }
    }, false);
  }
}
const MapContext = react.exports.createContext(null);
const defaultProps$2 = {
  minZoom: 0,
  maxZoom: 22,
  minPitch: 0,
  maxPitch: 60,
  scrollZoom: true,
  boxZoom: true,
  dragRotate: true,
  dragPan: true,
  keyboard: true,
  doubleClickZoom: true,
  touchZoomRotate: true,
  touchPitch: true,
  mapStyle: { version: 8, sources: {}, layers: [] },
  styleDiffing: true,
  projection: "mercator",
  renderWorldCopies: true,
  onError: (e) => console.error(e.error),
  RTLTextPlugin: "https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js"
};
const Map$1 = react.exports.forwardRef((props, ref) => {
  const mountedMapsContext = react.exports.useContext(MountedMapsContext);
  const [mapInstance, setMapInstance] = react.exports.useState(null);
  const containerRef = react.exports.useRef();
  const { current: contextValue } = react.exports.useRef({ mapLib: null, map: null });
  react.exports.useEffect(() => {
    const mapLib = props.mapLib;
    let isMounted = true;
    let mapbox;
    Promise.resolve(mapLib || Promise.resolve().then(function() {
      return mapboxGl;
    })).then((mapboxgl2) => {
      if (!isMounted) {
        return;
      }
      if (!mapboxgl2.Map) {
        mapboxgl2 = mapboxgl2.default;
      }
      if (!mapboxgl2 || !mapboxgl2.Map) {
        throw new Error("Invalid mapLib");
      }
      if (mapboxgl2.supported(props)) {
        setGlobals(mapboxgl2, props);
        if (props.reuseMaps) {
          mapbox = Mapbox.reuse(props, containerRef.current);
        }
        if (!mapbox) {
          mapbox = new Mapbox(mapboxgl2.Map, props, containerRef.current);
        }
        contextValue.map = createRef(mapbox, mapboxgl2);
        contextValue.mapLib = mapboxgl2;
        setMapInstance(mapbox);
        mountedMapsContext === null || mountedMapsContext === void 0 ? void 0 : mountedMapsContext.onMapMount(contextValue.map, props.id);
      } else {
        throw new Error("Map is not supported by this browser");
      }
    }).catch((error) => {
      props.onError({
        type: "error",
        target: null,
        originalEvent: null,
        error
      });
    });
    return () => {
      isMounted = false;
      if (mapbox) {
        mountedMapsContext === null || mountedMapsContext === void 0 ? void 0 : mountedMapsContext.onMapUnmount(props.id);
        if (props.reuseMaps) {
          mapbox.recycle();
        } else {
          mapbox.destroy();
        }
      }
    };
  }, []);
  useIsomorphicLayoutEffect(() => {
    if (mapInstance) {
      mapInstance.setProps(props);
    }
  });
  react.exports.useImperativeHandle(ref, () => contextValue.map, [mapInstance]);
  const style = react.exports.useMemo(() => __spreadValues({
    position: "relative",
    width: "100%",
    height: "100%"
  }, props.style), [props.style]);
  return react.exports.createElement("div", { id: props.id, ref: containerRef, style }, mapInstance && react.exports.createElement(MapContext.Provider, { value: contextValue }, props.children));
});
Map$1.displayName = "Map";
Map$1.defaultProps = defaultProps$2;
const unitlessNumber = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;
function applyReactStyle(element, styles2) {
  if (!element || !styles2) {
    return;
  }
  const style = element.style;
  for (const key in styles2) {
    const value2 = styles2[key];
    if (Number.isFinite(value2) && !unitlessNumber.test(key)) {
      style[key] = `${value2}px`;
    } else {
      style[key] = value2;
    }
  }
}
const defaultProps$1 = {
  draggable: false,
  popup: null,
  rotation: 0,
  rotationAlignment: "auto",
  pitchAlignment: "auto"
};
function Marker(props) {
  const { map: map2, mapLib } = react.exports.useContext(MapContext);
  const thisRef = react.exports.useRef({ props });
  thisRef.current.props = props;
  const marker = react.exports.useMemo(() => {
    let hasChildren = false;
    react.exports.Children.forEach(props.children, (el) => {
      if (el) {
        hasChildren = true;
      }
    });
    const options = __spreadProps(__spreadValues({}, props), {
      element: hasChildren ? document.createElement("div") : null
    });
    const mk2 = new mapLib.Marker(options).setLngLat([props.longitude, props.latitude]);
    mk2.getElement().addEventListener("click", (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, {
        type: "click",
        target: mk2,
        originalEvent: e
      });
    });
    mk2.on("dragstart", (e) => {
      var _a, _b;
      const evt = e;
      evt.lngLat = marker.getLngLat();
      (_b = (_a = thisRef.current.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, evt);
    });
    mk2.on("drag", (e) => {
      var _a, _b;
      const evt = e;
      evt.lngLat = marker.getLngLat();
      (_b = (_a = thisRef.current.props).onDrag) === null || _b === void 0 ? void 0 : _b.call(_a, evt);
    });
    mk2.on("dragend", (e) => {
      var _a, _b;
      const evt = e;
      evt.lngLat = marker.getLngLat();
      (_b = (_a = thisRef.current.props).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, evt);
    });
    return mk2;
  }, []);
  react.exports.useEffect(() => {
    marker.addTo(map2.getMap());
    return () => {
      marker.remove();
    };
  }, []);
  react.exports.useEffect(() => {
    applyReactStyle(marker.getElement(), props.style);
  }, [props.style]);
  if (marker.getLngLat().lng !== props.longitude || marker.getLngLat().lat !== props.latitude) {
    marker.setLngLat([props.longitude, props.latitude]);
  }
  if (props.offset && !arePointsEqual(marker.getOffset(), props.offset)) {
    marker.setOffset(props.offset);
  }
  if (marker.isDraggable() !== props.draggable) {
    marker.setDraggable(props.draggable);
  }
  if (marker.getRotation() !== props.rotation) {
    marker.setRotation(props.rotation);
  }
  if (marker.getRotationAlignment() !== props.rotationAlignment) {
    marker.setRotationAlignment(props.rotationAlignment);
  }
  if (marker.getPitchAlignment() !== props.pitchAlignment) {
    marker.setPitchAlignment(props.pitchAlignment);
  }
  if (marker.getPopup() !== props.popup) {
    marker.setPopup(props.popup);
  }
  return reactDom.exports.createPortal(props.children, marker.getElement());
}
Marker.defaultProps = defaultProps$1;
var Marker$1 = react.exports.memo(Marker);
function getClassList(className) {
  return new Set(className ? className.trim().split(/\s+/) : []);
}
function Popup(props) {
  const { map: map2, mapLib } = react.exports.useContext(MapContext);
  const container = react.exports.useMemo(() => {
    return document.createElement("div");
  }, []);
  const thisRef = react.exports.useRef({ props });
  thisRef.current.props = props;
  const popup = react.exports.useMemo(() => {
    const options = __spreadValues({}, props);
    const pp = new mapLib.Popup(options).setLngLat([props.longitude, props.latitude]);
    pp.once("open", (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onOpen) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    });
    return pp;
  }, []);
  react.exports.useEffect(() => {
    const onClose = (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onClose) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    };
    popup.on("close", onClose);
    popup.setDOMContent(container).addTo(map2.getMap());
    return () => {
      popup.off("close", onClose);
      if (popup.isOpen()) {
        popup.remove();
      }
    };
  }, []);
  react.exports.useEffect(() => {
    applyReactStyle(popup.getElement(), props.style);
  }, [props.style]);
  if (popup.isOpen()) {
    if (popup.getLngLat().lng !== props.longitude || popup.getLngLat().lat !== props.latitude) {
      popup.setLngLat([props.longitude, props.latitude]);
    }
    if (props.offset && !deepEqual(popup.options.offset, props.offset)) {
      popup.setOffset(props.offset);
    }
    if (popup.options.anchor !== props.anchor || popup.options.maxWidth !== props.maxWidth) {
      popup.options.anchor = props.anchor;
      popup.setMaxWidth(props.maxWidth);
    }
    if (popup.options.className !== props.className) {
      const prevClassList = getClassList(popup.options.className);
      const nextClassList = getClassList(props.className);
      for (const c of prevClassList) {
        if (!nextClassList.has(c)) {
          popup.removeClassName(c);
        }
      }
      for (const c of nextClassList) {
        if (!prevClassList.has(c)) {
          popup.addClassName(c);
        }
      }
      popup.options.className = props.className;
    }
  }
  return reactDom.exports.createPortal(props.children, container);
}
react.exports.memo(Popup);
function useControl(onCreate, arg1, arg2, arg3) {
  const context = react.exports.useContext(MapContext);
  const ctrl = react.exports.useMemo(() => onCreate(context), []);
  react.exports.useEffect(() => {
    const opts = arg3 || arg2 || arg1;
    const onAdd = typeof arg1 === "function" && typeof arg2 === "function" ? arg1 : null;
    const onRemove = typeof arg2 === "function" ? arg2 : typeof arg1 === "function" ? arg1 : null;
    const { map: map2 } = context;
    if (!map2.hasControl(ctrl)) {
      map2.addControl(ctrl, opts === null || opts === void 0 ? void 0 : opts.position);
      if (onAdd) {
        onAdd(context);
      }
    }
    return () => {
      if (onRemove) {
        onRemove(context);
      }
      if (map2.hasControl(ctrl)) {
        map2.removeControl(ctrl);
      }
    };
  }, []);
  return ctrl;
}
function AttributionControl(props) {
  const ctrl = useControl(({ mapLib }) => new mapLib.AttributionControl(props), {
    position: props.position
  });
  react.exports.useEffect(() => {
    applyReactStyle(ctrl._container, props.style);
  }, [props.style]);
  return null;
}
react.exports.memo(AttributionControl);
function FullscreenControl(props) {
  const ctrl = useControl(({ mapLib }) => new mapLib.FullscreenControl({
    container: props.containerId && document.getElementById(props.containerId)
  }), { position: props.position });
  react.exports.useEffect(() => {
    applyReactStyle(ctrl._controlContainer, props.style);
  }, [props.style]);
  return null;
}
react.exports.memo(FullscreenControl);
const GeolocateControl = react.exports.forwardRef((props, ref) => {
  const thisRef = react.exports.useRef({ props });
  const ctrl = useControl(({ mapLib }) => {
    const gc2 = new mapLib.GeolocateControl(props);
    const setupUI = gc2._setupUI;
    gc2._setupUI = (args) => {
      if (!gc2._container.hasChildNodes()) {
        setupUI(args);
      }
    };
    gc2.on("geolocate", (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onGeolocate) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    });
    gc2.on("error", (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onError) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    });
    gc2.on("outofmaxbounds", (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onOutOfMaxBounds) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    });
    gc2.on("trackuserlocationstart", (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onTrackUserLocationStart) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    });
    gc2.on("trackuserlocationend", (e) => {
      var _a, _b;
      (_b = (_a = thisRef.current.props).onTrackUserLocationEnd) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    });
    return gc2;
  }, { position: props.position });
  thisRef.current.props = props;
  react.exports.useImperativeHandle(ref, () => ({
    trigger: () => ctrl.trigger()
  }), []);
  react.exports.useEffect(() => {
    applyReactStyle(ctrl._container, props.style);
  }, [props.style]);
  return null;
});
GeolocateControl.displayName = "GeolocateControl";
var GeolocateControl$1 = react.exports.memo(GeolocateControl);
function NavigationControl(props) {
  const ctrl = useControl(({ mapLib }) => new mapLib.NavigationControl(props), {
    position: props.position
  });
  react.exports.useEffect(() => {
    applyReactStyle(ctrl._container, props.style);
  }, [props.style]);
  return null;
}
var NavigationControl$1 = react.exports.memo(NavigationControl);
const defaultProps = {
  unit: "metric",
  maxWidth: 100
};
function ScaleControl(props) {
  const ctrl = useControl(({ mapLib }) => new mapLib.ScaleControl(props), {
    position: props.position
  });
  if (ctrl.options.unit !== props.unit || ctrl.options.maxWidth !== props.maxWidth) {
    ctrl.options.maxWidth = props.maxWidth;
    ctrl.setUnit(props.unit);
  }
  react.exports.useEffect(() => {
    applyReactStyle(ctrl._container, props.style);
  }, [props.style]);
  return null;
}
ScaleControl.defaultProps = defaultProps;
react.exports.memo(ScaleControl);
var immutable = extend$2;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend$2() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source2 = arguments[i];
    for (var key in source2) {
      if (hasOwnProperty.call(source2, key)) {
        target[key] = source2[key];
      }
    }
  }
  return target;
}
var fuzzy$1 = { exports: {} };
(function(module2, exports) {
  (function() {
    var fuzzy2 = {};
    {
      module2.exports = fuzzy2;
    }
    fuzzy2.simpleFilter = function(pattern, array) {
      return array.filter(function(str) {
        return fuzzy2.test(pattern, str);
      });
    };
    fuzzy2.test = function(pattern, str) {
      return fuzzy2.match(pattern, str) !== null;
    };
    fuzzy2.match = function(pattern, str, opts) {
      opts = opts || {};
      var patternIdx = 0, result = [], len = str.length, totalScore = 0, currScore = 0, pre = opts.pre || "", post = opts.post || "", compareString = opts.caseSensitive && str || str.toLowerCase(), ch2;
      pattern = opts.caseSensitive && pattern || pattern.toLowerCase();
      for (var idx = 0; idx < len; idx++) {
        ch2 = str[idx];
        if (compareString[idx] === pattern[patternIdx]) {
          ch2 = pre + ch2 + post;
          patternIdx += 1;
          currScore += 1 + currScore;
        } else {
          currScore = 0;
        }
        totalScore += currScore;
        result[result.length] = ch2;
      }
      if (patternIdx === pattern.length) {
        totalScore = compareString === pattern ? Infinity : totalScore;
        return { rendered: result.join(""), score: totalScore };
      }
      return null;
    };
    fuzzy2.filter = function(pattern, arr, opts) {
      if (!arr || arr.length === 0) {
        return [];
      }
      if (typeof pattern !== "string") {
        return arr;
      }
      opts = opts || {};
      return arr.reduce(function(prev, element, idx, arr2) {
        var str = element;
        if (opts.extract) {
          str = opts.extract(element);
        }
        var rendered = fuzzy2.match(pattern, str, opts);
        if (rendered != null) {
          prev[prev.length] = {
            string: rendered.rendered,
            score: rendered.score,
            index: idx,
            original: element
          };
        }
        return prev;
      }, []).sort(function(a, b) {
        var compare = b.score - a.score;
        if (compare)
          return compare;
        return a.index - b.index;
      });
    };
  })();
})(fuzzy$1);
var List$1 = function(component) {
  this.component = component;
  this.items = [];
  this.active = 0;
  this.wrapper = document.createElement("div");
  this.wrapper.className = "suggestions-wrapper";
  this.element = document.createElement("ul");
  this.element.className = "suggestions";
  this.wrapper.appendChild(this.element);
  this.selectingListItem = false;
  component.el.parentNode.insertBefore(this.wrapper, component.el.nextSibling);
  return this;
};
List$1.prototype.show = function() {
  this.element.style.display = "block";
};
List$1.prototype.hide = function() {
  this.element.style.display = "none";
};
List$1.prototype.add = function(item) {
  this.items.push(item);
};
List$1.prototype.clear = function() {
  this.items = [];
  this.active = 0;
};
List$1.prototype.isEmpty = function() {
  return !this.items.length;
};
List$1.prototype.isVisible = function() {
  return this.element.style.display === "block";
};
List$1.prototype.draw = function() {
  this.element.innerHTML = "";
  if (this.items.length === 0) {
    this.hide();
    return;
  }
  for (var i = 0; i < this.items.length; i++) {
    this.drawItem(this.items[i], this.active === i);
  }
  this.show();
};
List$1.prototype.drawItem = function(item, active) {
  var li2 = document.createElement("li"), a = document.createElement("a");
  if (active)
    li2.className += " active";
  a.innerHTML = item.string;
  li2.appendChild(a);
  this.element.appendChild(li2);
  li2.addEventListener("mousedown", function() {
    this.selectingListItem = true;
  }.bind(this));
  li2.addEventListener("mouseup", function() {
    this.handleMouseUp.call(this, item);
  }.bind(this));
};
List$1.prototype.handleMouseUp = function(item) {
  this.selectingListItem = false;
  this.component.value(item.original);
  this.clear();
  this.draw();
};
List$1.prototype.move = function(index) {
  this.active = index;
  this.draw();
};
List$1.prototype.previous = function() {
  this.move(this.active === 0 ? this.items.length - 1 : this.active - 1);
};
List$1.prototype.next = function() {
  this.move(this.active === this.items.length - 1 ? 0 : this.active + 1);
};
List$1.prototype.drawError = function(msg) {
  var li2 = document.createElement("li");
  li2.innerHTML = msg;
  this.element.appendChild(li2);
  this.show();
};
var list = List$1;
var extend$1 = immutable;
var fuzzy = fuzzy$1.exports;
var List = list;
var Suggestions$1 = function(el, data, options) {
  options = options || {};
  this.options = extend$1({
    minLength: 2,
    limit: 5,
    filter: true,
    hideOnBlur: true
  }, options);
  this.el = el;
  this.data = data || [];
  this.list = new List(this);
  this.query = "";
  this.selected = null;
  this.list.draw();
  this.el.addEventListener("keyup", function(e) {
    this.handleKeyUp(e.keyCode);
  }.bind(this), false);
  this.el.addEventListener("keydown", function(e) {
    this.handleKeyDown(e);
  }.bind(this));
  this.el.addEventListener("focus", function() {
    this.handleFocus();
  }.bind(this));
  this.el.addEventListener("blur", function() {
    this.handleBlur();
  }.bind(this));
  this.el.addEventListener("paste", function(e) {
    this.handlePaste(e);
  }.bind(this));
  this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this);
  this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this);
  return this;
};
Suggestions$1.prototype.handleKeyUp = function(keyCode) {
  if (keyCode === 40 || keyCode === 38 || keyCode === 27 || keyCode === 13 || keyCode === 9)
    return;
  this.handleInputChange(this.el.value);
};
Suggestions$1.prototype.handleKeyDown = function(e) {
  switch (e.keyCode) {
    case 13:
    case 9:
      if (!this.list.isEmpty()) {
        if (this.list.isVisible()) {
          e.preventDefault();
        }
        this.value(this.list.items[this.list.active].original);
        this.list.hide();
      }
      break;
    case 27:
      if (!this.list.isEmpty())
        this.list.hide();
      break;
    case 38:
      this.list.previous();
      break;
    case 40:
      this.list.next();
      break;
  }
};
Suggestions$1.prototype.handleBlur = function() {
  if (!this.list.selectingListItem && this.options.hideOnBlur) {
    this.list.hide();
  }
};
Suggestions$1.prototype.handlePaste = function(e) {
  if (e.clipboardData) {
    this.handleInputChange(e.clipboardData.getData("Text"));
  } else {
    var self2 = this;
    setTimeout(function() {
      self2.handleInputChange(e.target.value);
    }, 100);
  }
};
Suggestions$1.prototype.handleInputChange = function(query) {
  this.query = this.normalize(query);
  this.list.clear();
  if (this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }
  this.getCandidates(function(data) {
    for (var i = 0; i < data.length; i++) {
      this.list.add(data[i]);
      if (i === this.options.limit - 1)
        break;
    }
    this.list.draw();
  }.bind(this));
};
Suggestions$1.prototype.handleFocus = function() {
  if (!this.list.isEmpty())
    this.list.show();
  this.list.selectingListItem = false;
};
Suggestions$1.prototype.update = function(revisedData) {
  this.data = revisedData;
  this.handleKeyUp();
};
Suggestions$1.prototype.clear = function() {
  this.data = [];
  this.list.clear();
};
Suggestions$1.prototype.normalize = function(value2) {
  value2 = value2.toLowerCase();
  return value2;
};
Suggestions$1.prototype.match = function(candidate, query) {
  return candidate.indexOf(query) > -1;
};
Suggestions$1.prototype.value = function(value2) {
  this.selected = value2;
  this.el.value = this.getItemValue(value2);
  if (document.createEvent) {
    var e = document.createEvent("HTMLEvents");
    e.initEvent("change", true, false);
    this.el.dispatchEvent(e);
  } else {
    this.el.fireEvent("onchange");
  }
};
Suggestions$1.prototype.getCandidates = function(callback2) {
  var options = {
    pre: "<strong>",
    post: "</strong>",
    extract: function(d) {
      return this.getItemValue(d);
    }.bind(this)
  };
  var results;
  if (this.options.filter) {
    results = fuzzy.filter(this.query, this.data, options);
    results = results.map(function(item) {
      return {
        original: item.original,
        string: this.render(item.original, item.string)
      };
    }.bind(this));
  } else {
    results = this.data.map(function(d) {
      var renderedString = this.render(d);
      return {
        original: d,
        string: renderedString
      };
    }.bind(this));
  }
  callback2(results);
};
Suggestions$1.prototype.getItemValue = function(item) {
  return item;
};
Suggestions$1.prototype.render = function(item, sourceFormatting) {
  if (sourceFormatting) {
    return sourceFormatting;
  }
  var boldString = item.original ? this.getItemValue(item.original) : this.getItemValue(item);
  var indexString = this.normalize(boldString);
  var indexOfQuery = indexString.lastIndexOf(this.query);
  while (indexOfQuery > -1) {
    var endIndexOfQuery = indexOfQuery + this.query.length;
    boldString = boldString.slice(0, indexOfQuery) + "<strong>" + boldString.slice(indexOfQuery, endIndexOfQuery) + "</strong>" + boldString.slice(endIndexOfQuery);
    indexOfQuery = indexString.slice(0, indexOfQuery).lastIndexOf(this.query);
  }
  return boldString;
};
Suggestions$1.prototype.renderError = function(msg) {
  this.list.drawError(msg);
};
var suggestions$1 = Suggestions$1;
var Suggestions = suggestions$1;
var suggestions = Suggestions;
if (typeof window !== "undefined") {
  window.Suggestions = Suggestions;
}
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var nativeMax = Math.max, nativeMin = Math.min;
var now = function() {
  return root.Date.now();
};
function debounce$2(func2, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func2.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isObject(value2) {
  var type = typeof value2;
  return !!value2 && (type == "object" || type == "function");
}
function isObjectLike(value2) {
  return !!value2 && typeof value2 == "object";
}
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
}
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = value2.replace(reTrim, "");
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var lodash_debounce = debounce$2;
var events$1 = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
  return value2 !== value2;
};
function EventEmitter$2() {
  EventEmitter$2.init.call(this);
}
events$1.exports = EventEmitter$2;
events$1.exports.once = once2;
EventEmitter$2.EventEmitter = EventEmitter$2;
EventEmitter$2.prototype._events = void 0;
EventEmitter$2.prototype._eventsCount = 0;
EventEmitter$2.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$2, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$2.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$2.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$2.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$2.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$2.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter$2.prototype.addListener = function addListener2(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$2.prototype.on = EventEmitter$2.prototype.addListener;
EventEmitter$2.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$2.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$2.prototype.removeListener = function removeListener2(type, listener) {
  var list2, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list2 = events2[type];
  if (list2 === void 0)
    return this;
  if (list2 === listener || list2.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list2.listener || listener);
    }
  } else if (typeof list2 !== "function") {
    position = -1;
    for (i = list2.length - 1; i >= 0; i--) {
      if (list2[i] === listener || list2[i].listener === listener) {
        originalListener = list2[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list2.shift();
    else {
      spliceOne(list2, position);
    }
    if (list2.length === 1)
      events2[type] = list2[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$2.prototype.off = EventEmitter$2.prototype.removeListener;
EventEmitter$2.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key;
    for (i = 0; i < keys2.length; ++i) {
      key = keys2[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$2.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$2.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$2.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$2.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$2.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy = new Array(n2);
  for (var i = 0; i < n2; ++i)
    copy[i] = arr[i];
  return copy;
}
function spliceOne(list2, index) {
  for (; index + 1 < list2.length; index++)
    list2[index] = list2[index + 1];
  list2.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve2, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var exceptions$1 = {
  "fr": {
    "name": "France",
    "bbox": [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  "us": {
    "name": "United States",
    "bbox": [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  "ru": {
    "name": "Russia",
    "bbox": [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  "ca": {
    "name": "Canada",
    "bbox": [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
};
function parseParam(param) {
  var parts = param.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
  if (!parts)
    return null;
  return {
    key: parts[1],
    value: parts[2]
  };
}
function parseLink(link2) {
  var parts = link2.match(/<?([^>]*)>(.*)/);
  if (!parts)
    return null;
  var linkUrl = parts[1];
  var linkParams = parts[2].split(";");
  var rel = null;
  var parsedLinkParams = linkParams.reduce(function(result, param) {
    var parsed = parseParam(param);
    if (!parsed)
      return result;
    if (parsed.key === "rel") {
      if (!rel) {
        rel = parsed.value;
      }
      return result;
    }
    result[parsed.key] = parsed.value;
    return result;
  }, {});
  if (!rel)
    return null;
  return {
    url: linkUrl,
    rel,
    params: parsedLinkParams
  };
}
function parseLinkHeader$1(linkHeader) {
  if (!linkHeader)
    return {};
  return linkHeader.split(/,\s*</).reduce(function(result, link2) {
    var parsed = parseLink(link2);
    if (!parsed)
      return result;
    var splitRel = parsed.rel.split(/\s+/);
    splitRel.forEach(function(rel) {
      if (!result[rel]) {
        result[rel] = {
          url: parsed.url,
          params: parsed.params
        };
      }
    });
    return result;
  }, {});
}
var parseLinkHeader_1 = parseLinkHeader$1;
var parseLinkHeader = parseLinkHeader_1;
function MapiResponse$1(request, responseData) {
  this.request = request;
  this.headers = responseData.headers;
  this.rawBody = responseData.body;
  this.statusCode = responseData.statusCode;
  try {
    this.body = JSON.parse(responseData.body || "{}");
  } catch (parseError) {
    this.body = responseData.body;
  }
  this.links = parseLinkHeader(this.headers.link);
}
MapiResponse$1.prototype.hasNextPage = function hasNextPage() {
  return !!this.links.next;
};
MapiResponse$1.prototype.nextPage = function nextPage() {
  if (!this.hasNextPage())
    return null;
  return this.request._extend({
    path: this.links.next.url
  });
};
var mapiResponse = MapiResponse$1;
var constants$4 = {
  API_ORIGIN: "https://api.mapbox.com",
  EVENT_PROGRESS_DOWNLOAD: "downloadProgress",
  EVENT_PROGRESS_UPLOAD: "uploadProgress",
  EVENT_ERROR: "error",
  EVENT_RESPONSE: "response",
  ERROR_HTTP: "HttpError",
  ERROR_REQUEST_ABORTED: "RequestAbortedError"
};
var constants$3 = constants$4;
function MapiError$1(options) {
  var errorType = options.type || constants$3.ERROR_HTTP;
  var body;
  if (options.body) {
    try {
      body = JSON.parse(options.body);
    } catch (e) {
      body = options.body;
    }
  } else {
    body = null;
  }
  var message = options.message || null;
  if (!message) {
    if (typeof body === "string") {
      message = body;
    } else if (body && typeof body.message === "string") {
      message = body.message;
    } else if (errorType === constants$3.ERROR_REQUEST_ABORTED) {
      message = "Request aborted";
    }
  }
  this.message = message;
  this.type = errorType;
  this.statusCode = options.statusCode || null;
  this.request = options.request;
  this.body = body;
}
var mapiError = MapiError$1;
function parseSingleHeader(raw) {
  var boundary = raw.indexOf(":");
  var name = raw.substring(0, boundary).trim().toLowerCase();
  var value2 = raw.substring(boundary + 1).trim();
  return {
    name,
    value: value2
  };
}
function parseHeaders$1(raw) {
  var headers = {};
  if (!raw) {
    return headers;
  }
  raw.trim().split(/[\r|\n]+/).forEach(function(rawHeader) {
    var parsed = parseSingleHeader(rawHeader);
    headers[parsed.name] = parsed.value;
  });
  return headers;
}
var parseHeaders_1 = parseHeaders$1;
var MapiResponse = mapiResponse;
var MapiError = mapiError;
var constants$2 = constants$4;
var parseHeaders = parseHeaders_1;
var requestsUnderway = {};
function browserAbort(request) {
  var xhr = requestsUnderway[request.id];
  if (!xhr)
    return;
  xhr.abort();
  delete requestsUnderway[request.id];
}
function createResponse(request, xhr) {
  return new MapiResponse(request, {
    body: xhr.response,
    headers: parseHeaders(xhr.getAllResponseHeaders()),
    statusCode: xhr.status
  });
}
function normalizeBrowserProgressEvent(event) {
  var total = event.total;
  var transferred = event.loaded;
  var percent = 100 * transferred / total;
  return {
    total,
    transferred,
    percent
  };
}
function sendRequestXhr(request, xhr) {
  return new Promise(function(resolve2, reject) {
    xhr.onprogress = function(event) {
      request.emitter.emit(constants$2.EVENT_PROGRESS_DOWNLOAD, normalizeBrowserProgressEvent(event));
    };
    var file2 = request.file;
    if (file2) {
      xhr.upload.onprogress = function(event) {
        request.emitter.emit(constants$2.EVENT_PROGRESS_UPLOAD, normalizeBrowserProgressEvent(event));
      };
    }
    xhr.onerror = function(error) {
      reject(error);
    };
    xhr.onabort = function() {
      var mapiError2 = new MapiError({
        request,
        type: constants$2.ERROR_REQUEST_ABORTED
      });
      reject(mapiError2);
    };
    xhr.onload = function() {
      delete requestsUnderway[request.id];
      if (xhr.status < 200 || xhr.status >= 400) {
        var mapiError2 = new MapiError({
          request,
          body: xhr.response,
          statusCode: xhr.status
        });
        reject(mapiError2);
        return;
      }
      resolve2(xhr);
    };
    var body = request.body;
    if (typeof body === "string") {
      xhr.send(body);
    } else if (body) {
      xhr.send(JSON.stringify(body));
    } else if (file2) {
      xhr.send(file2);
    } else {
      xhr.send();
    }
    requestsUnderway[request.id] = xhr;
  }).then(function(xhr2) {
    return createResponse(request, xhr2);
  });
}
function createRequestXhr(request, accessToken) {
  var url2 = request.url(accessToken);
  var xhr = new window.XMLHttpRequest();
  xhr.open(request.method, url2);
  Object.keys(request.headers).forEach(function(key) {
    xhr.setRequestHeader(key, request.headers[key]);
  });
  return xhr;
}
function browserSend(request) {
  return Promise.resolve().then(function() {
    var xhr = createRequestXhr(request, request.client.accessToken);
    return sendRequestXhr(request, xhr);
  });
}
var browserLayer = {
  browserAbort,
  sendRequestXhr,
  browserSend,
  createRequestXhr
};
var base64$1 = { exports: {} };
/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
(function(module2, exports) {
  (function(root2) {
    var freeExports = exports;
    var freeModule = module2 && module2.exports == freeExports && module2;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2) {
      root2 = freeGlobal2;
    }
    var InvalidCharacterError = function(message) {
      this.message = message;
    };
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = "InvalidCharacterError";
    var error = function(message) {
      throw new InvalidCharacterError(message);
    };
    var TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;
    var decode = function(input) {
      input = String(input).replace(REGEX_SPACE_CHARACTERS, "");
      var length = input.length;
      if (length % 4 == 0) {
        input = input.replace(/==?$/, "");
        length = input.length;
      }
      if (length % 4 == 1 || /[^+a-zA-Z0-9/]/.test(input)) {
        error("Invalid character: the string to be decoded is not correctly encoded.");
      }
      var bitCounter = 0;
      var bitStorage;
      var buffer;
      var output = "";
      var position = -1;
      while (++position < length) {
        buffer = TABLE.indexOf(input.charAt(position));
        bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
        if (bitCounter++ % 4) {
          output += String.fromCharCode(255 & bitStorage >> (-2 * bitCounter & 6));
        }
      }
      return output;
    };
    var encode = function(input) {
      input = String(input);
      if (/[^\0-\xFF]/.test(input)) {
        error("The string to be encoded contains characters outside of the Latin1 range.");
      }
      var padding = input.length % 3;
      var output = "";
      var position = -1;
      var a;
      var b;
      var c;
      var buffer;
      var length = input.length - padding;
      while (++position < length) {
        a = input.charCodeAt(position) << 16;
        b = input.charCodeAt(++position) << 8;
        c = input.charCodeAt(++position);
        buffer = a + b + c;
        output += TABLE.charAt(buffer >> 18 & 63) + TABLE.charAt(buffer >> 12 & 63) + TABLE.charAt(buffer >> 6 & 63) + TABLE.charAt(buffer & 63);
      }
      if (padding == 2) {
        a = input.charCodeAt(position) << 8;
        b = input.charCodeAt(++position);
        buffer = a + b;
        output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 63) + TABLE.charAt(buffer << 2 & 63) + "=";
      } else if (padding == 1) {
        buffer = input.charCodeAt(position);
        output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 63) + "==";
      }
      return output;
    };
    var base642 = {
      "encode": encode,
      "decode": decode,
      "version": "0.1.0"
    };
    if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = base642;
      } else {
        for (var key in base642) {
          base642.hasOwnProperty(key) && (freeExports[key] = base642[key]);
        }
      }
    } else {
      root2.base64 = base642;
    }
  })(commonjsGlobal);
})(base64$1, base64$1.exports);
var base64 = base64$1.exports;
var tokenCache = {};
function parseToken$2(token2) {
  if (tokenCache[token2]) {
    return tokenCache[token2];
  }
  var parts = token2.split(".");
  var usage = parts[0];
  var rawPayload = parts[1];
  if (!rawPayload) {
    throw new Error("Invalid token");
  }
  var parsedPayload = parsePaylod(rawPayload);
  var result = {
    usage,
    user: parsedPayload.u
  };
  if (has(parsedPayload, "a"))
    result.authorization = parsedPayload.a;
  if (has(parsedPayload, "exp"))
    result.expires = parsedPayload.exp * 1e3;
  if (has(parsedPayload, "iat"))
    result.created = parsedPayload.iat * 1e3;
  if (has(parsedPayload, "scopes"))
    result.scopes = parsedPayload.scopes;
  if (has(parsedPayload, "client"))
    result.client = parsedPayload.client;
  if (has(parsedPayload, "ll"))
    result.lastLogin = parsedPayload.ll;
  if (has(parsedPayload, "iu"))
    result.impersonator = parsedPayload.iu;
  tokenCache[token2] = result;
  return result;
}
function parsePaylod(rawPayload) {
  try {
    return JSON.parse(base64.decode(rawPayload));
  } catch (parseError) {
    throw new Error("Invalid token");
  }
}
function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var parseMapboxToken = parseToken$2;
var eventemitter3 = { exports: {} };
(function(module2) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once3) {
    this.fn = fn;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener3(emitter, event, fn, context, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name;
    if (this._eventsCount === 0)
      return names2;
    for (name in events2 = this._events) {
      if (has2.call(events2, name))
        names2.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener3(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn, context) {
    return addListener3(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener3(event, fn, context, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length = listeners2.length; i < length; i++) {
        if (listeners2[i].fn !== fn || once3 && !listeners2[i].once || context && listeners2[i].context !== context) {
          events2.push(listeners2[i]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
function encodeArray(arrayValue) {
  return arrayValue.map(encodeURIComponent).join(",");
}
function encodeValue(value2) {
  if (Array.isArray(value2)) {
    return encodeArray(value2);
  }
  return encodeURIComponent(String(value2));
}
function appendQueryParam(url2, key, value2) {
  if (value2 === false || value2 === null) {
    return url2;
  }
  var punctuation = /\?/.test(url2) ? "&" : "?";
  var query = encodeURIComponent(key);
  if (value2 !== void 0 && value2 !== "" && value2 !== true) {
    query += "=" + encodeValue(value2);
  }
  return "" + url2 + punctuation + query;
}
function appendQueryObject(url2, queryObject) {
  if (!queryObject) {
    return url2;
  }
  var result = url2;
  Object.keys(queryObject).forEach(function(key) {
    var value2 = queryObject[key];
    if (value2 === void 0) {
      return;
    }
    if (Array.isArray(value2)) {
      value2 = value2.filter(function(v2) {
        return v2 !== null && v2 !== void 0;
      }).join(",");
    }
    result = appendQueryParam(result, key, value2);
  });
  return result;
}
function prependOrigin(url2, origin) {
  if (!origin) {
    return url2;
  }
  if (url2.slice(0, 4) === "http") {
    return url2;
  }
  var delimiter = url2[0] === "/" ? "" : "/";
  return "" + origin.replace(/\/$/, "") + delimiter + url2;
}
function interpolateRouteParams(route2, params) {
  if (!params) {
    return route2;
  }
  return route2.replace(/\/:([a-zA-Z0-9]+)/g, function(_, paramId) {
    var value2 = params[paramId];
    if (value2 === void 0) {
      throw new Error("Unspecified route parameter " + paramId);
    }
    var preppedValue = encodeValue(value2);
    return "/" + preppedValue;
  });
}
var urlUtils$1 = {
  appendQueryObject,
  appendQueryParam,
  prependOrigin,
  interpolateRouteParams
};
var parseToken$1 = parseMapboxToken;
var xtend$3 = immutable;
var EventEmitter$1 = eventemitter3.exports;
var urlUtils = urlUtils$1;
var constants$1 = constants$4;
var requestId = 1;
function MapiRequest$1(client2, options) {
  if (!client2) {
    throw new Error("MapiRequest requires a client");
  }
  if (!options || !options.path || !options.method) {
    throw new Error("MapiRequest requires an options object with path and method properties");
  }
  var defaultHeaders = {};
  if (options.body) {
    defaultHeaders["content-type"] = "application/json";
  }
  var headersWithDefaults = xtend$3(defaultHeaders, options.headers);
  var headers = Object.keys(headersWithDefaults).reduce(function(memo, name) {
    memo[name.toLowerCase()] = headersWithDefaults[name];
    return memo;
  }, {});
  this.id = requestId++;
  this._options = options;
  this.emitter = new EventEmitter$1();
  this.client = client2;
  this.response = null;
  this.error = null;
  this.sent = false;
  this.aborted = false;
  this.path = options.path;
  this.method = options.method;
  this.origin = options.origin || client2.origin;
  this.query = options.query || {};
  this.params = options.params || {};
  this.body = options.body || null;
  this.file = options.file || null;
  this.encoding = options.encoding || "utf8";
  this.sendFileAs = options.sendFileAs || null;
  this.headers = headers;
}
MapiRequest$1.prototype.url = function url(accessToken) {
  var url2 = urlUtils.prependOrigin(this.path, this.origin);
  url2 = urlUtils.appendQueryObject(url2, this.query);
  var routeParams = this.params;
  var actualAccessToken = accessToken == null ? this.client.accessToken : accessToken;
  if (actualAccessToken) {
    url2 = urlUtils.appendQueryParam(url2, "access_token", actualAccessToken);
    var accessTokenOwnerId = parseToken$1(actualAccessToken).user;
    routeParams = xtend$3({ ownerId: accessTokenOwnerId }, routeParams);
  }
  url2 = urlUtils.interpolateRouteParams(url2, routeParams);
  return url2;
};
MapiRequest$1.prototype.send = function send() {
  var self2 = this;
  if (self2.sent) {
    throw new Error("This request has already been sent. Check the response and error properties. Create a new request with clone().");
  }
  self2.sent = true;
  return self2.client.sendRequest(self2).then(function(response) {
    self2.response = response;
    self2.emitter.emit(constants$1.EVENT_RESPONSE, response);
    return response;
  }, function(error) {
    self2.error = error;
    self2.emitter.emit(constants$1.EVENT_ERROR, error);
    throw error;
  });
};
MapiRequest$1.prototype.abort = function abort() {
  if (this._nextPageRequest) {
    this._nextPageRequest.abort();
    delete this._nextPageRequest;
  }
  if (this.response || this.error || this.aborted)
    return;
  this.aborted = true;
  this.client.abortRequest(this);
};
MapiRequest$1.prototype.eachPage = function eachPage(callback2) {
  var self2 = this;
  function handleResponse(response) {
    function getNextPage() {
      delete self2._nextPageRequest;
      var nextPageRequest = response.nextPage();
      if (nextPageRequest) {
        self2._nextPageRequest = nextPageRequest;
        getPage(nextPageRequest);
      }
    }
    callback2(null, response, getNextPage);
  }
  function handleError(error) {
    callback2(error, null, function() {
    });
  }
  function getPage(request) {
    request.send().then(handleResponse, handleError);
  }
  getPage(this);
};
MapiRequest$1.prototype.clone = function clone2() {
  return this._extend();
};
MapiRequest$1.prototype._extend = function _extend(options) {
  var extendedOptions = xtend$3(this._options, options);
  return new MapiRequest$1(this.client, extendedOptions);
};
var mapiRequest = MapiRequest$1;
var parseToken = parseMapboxToken;
var MapiRequest = mapiRequest;
var constants = constants$4;
function MapiClient$2(options) {
  if (!options || !options.accessToken) {
    throw new Error("Cannot create a client without an access token");
  }
  parseToken(options.accessToken);
  this.accessToken = options.accessToken;
  this.origin = options.origin || constants.API_ORIGIN;
}
MapiClient$2.prototype.createRequest = function createRequest(requestOptions) {
  return new MapiRequest(this, requestOptions);
};
var mapiClient = MapiClient$2;
var browser = browserLayer;
var MapiClient$1 = mapiClient;
function BrowserClient(options) {
  MapiClient$1.call(this, options);
}
BrowserClient.prototype = Object.create(MapiClient$1.prototype);
BrowserClient.prototype.constructor = BrowserClient;
BrowserClient.prototype.sendRequest = browser.browserSend;
BrowserClient.prototype.abortRequest = browser.browserAbort;
function createBrowserClient(options) {
  return new BrowserClient(options);
}
var browserClient = createBrowserClient;
var client = browserClient;
var mapboxSdk = client;
var toString = Object.prototype.toString;
var isPlainObj = function(x2) {
  var prototype;
  return toString.call(x2) === "[object Object]" && (prototype = Object.getPrototypeOf(x2), prototype === null || prototype === Object.getPrototypeOf({}));
};
var isPlainObject = isPlainObj;
var xtend$2 = immutable;
var DEFAULT_ERROR_PATH = "value";
var NEWLINE_INDENT = "\n  ";
var v$2 = {};
v$2.assert = function(rootValidator, options) {
  options = options || {};
  return function(value2) {
    var message = validate(rootValidator, value2);
    if (!message) {
      return;
    }
    var errorMessage = processMessage(message, options);
    if (options.apiName) {
      errorMessage = options.apiName + ": " + errorMessage;
    }
    throw new Error(errorMessage);
  };
};
v$2.shape = function shape(validatorObj) {
  var validators = objectEntries(validatorObj);
  return function shapeValidator(value2) {
    var validationResult = validate(v$2.plainObject, value2);
    if (validationResult) {
      return validationResult;
    }
    var key, validator2;
    var errorMessages = [];
    for (var i = 0; i < validators.length; i++) {
      key = validators[i].key;
      validator2 = validators[i].value;
      validationResult = validate(validator2, value2[key]);
      if (validationResult) {
        errorMessages.push([key].concat(validationResult));
      }
    }
    if (errorMessages.length < 2) {
      return errorMessages[0];
    }
    return function(options) {
      errorMessages = errorMessages.map(function(message) {
        var key2 = message[0];
        var renderedMessage = processMessage(message, options).split("\n").join(NEWLINE_INDENT);
        return "- " + key2 + ": " + renderedMessage;
      });
      var objectId = options.path.join(".");
      var ofPhrase = objectId === DEFAULT_ERROR_PATH ? "" : " of " + objectId;
      return "The following properties" + ofPhrase + " have invalid values:" + NEWLINE_INDENT + errorMessages.join(NEWLINE_INDENT);
    };
  };
};
v$2.strictShape = function strictShape(validatorObj) {
  var shapeValidator = v$2.shape(validatorObj);
  return function strictShapeValidator(value2) {
    var shapeResult = shapeValidator(value2);
    if (shapeResult) {
      return shapeResult;
    }
    var invalidKeys = Object.keys(value2).reduce(function(memo, valueKey) {
      if (validatorObj[valueKey] === void 0) {
        memo.push(valueKey);
      }
      return memo;
    }, []);
    if (invalidKeys.length !== 0) {
      return function() {
        return "The following keys are invalid: " + invalidKeys.join(", ");
      };
    }
  };
};
v$2.arrayOf = function arrayOf(validator2) {
  return createArrayValidator(validator2);
};
v$2.tuple = function tuple() {
  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  return createArrayValidator(validators);
};
function createArrayValidator(validators) {
  var validatingTuple = Array.isArray(validators);
  var getValidator = function(index) {
    if (validatingTuple) {
      return validators[index];
    }
    return validators;
  };
  return function arrayValidator(value2) {
    var validationResult = validate(v$2.plainArray, value2);
    if (validationResult) {
      return validationResult;
    }
    if (validatingTuple && value2.length !== validators.length) {
      return "an array with " + validators.length + " items";
    }
    for (var i = 0; i < value2.length; i++) {
      validationResult = validate(getValidator(i), value2[i]);
      if (validationResult) {
        return [i].concat(validationResult);
      }
    }
  };
}
v$2.required = function required(validator2) {
  function requiredValidator(value2) {
    if (value2 == null) {
      return function(options) {
        return formatErrorMessage(options, isArrayCulprit(options.path) ? "cannot be undefined/null." : "is required.");
      };
    }
    return validator2.apply(this, arguments);
  }
  requiredValidator.__required = true;
  return requiredValidator;
};
v$2.oneOfType = function oneOfType() {
  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  return function oneOfTypeValidator(value2) {
    var messages = validators.map(function(validator2) {
      return validate(validator2, value2);
    }).filter(Boolean);
    if (messages.length !== validators.length) {
      return;
    }
    if (messages.every(function(message) {
      return message.length === 1 && typeof message[0] === "string";
    })) {
      return orList(messages.map(function(m2) {
        return m2[0];
      }));
    }
    return messages.reduce(function(max2, arr) {
      return arr.length > max2.length ? arr : max2;
    });
  };
};
v$2.equal = function equal(compareWith) {
  return function equalValidator(value2) {
    if (value2 !== compareWith) {
      return JSON.stringify(compareWith);
    }
  };
};
v$2.oneOf = function oneOf() {
  var options = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  var validators = options.map(function(value2) {
    return v$2.equal(value2);
  });
  return v$2.oneOfType.apply(this, validators);
};
v$2.range = function range(compareWith) {
  var min2 = compareWith[0];
  var max2 = compareWith[1];
  return function rangeValidator(value2) {
    var validationResult = validate(v$2.number, value2);
    if (validationResult || value2 < min2 || value2 > max2) {
      return "number between " + min2 + " & " + max2 + " (inclusive)";
    }
  };
};
v$2.any = function any() {
  return;
};
v$2.boolean = function boolean(value2) {
  if (typeof value2 !== "boolean") {
    return "boolean";
  }
};
v$2.number = function number(value2) {
  if (typeof value2 !== "number") {
    return "number";
  }
};
v$2.plainArray = function plainArray(value2) {
  if (!Array.isArray(value2)) {
    return "array";
  }
};
v$2.plainObject = function plainObject(value2) {
  if (!isPlainObject(value2)) {
    return "object";
  }
};
v$2.string = function string(value2) {
  if (typeof value2 !== "string") {
    return "string";
  }
};
v$2.func = function func(value2) {
  if (typeof value2 !== "function") {
    return "function";
  }
};
function validate(validator2, value2) {
  if (value2 == null && !validator2.hasOwnProperty("__required")) {
    return;
  }
  var result = validator2(value2);
  if (result) {
    return Array.isArray(result) ? result : [result];
  }
}
function processMessage(message, options) {
  var len = message.length;
  var result = message[len - 1];
  var path = message.slice(0, len - 1);
  if (path.length === 0) {
    path = [DEFAULT_ERROR_PATH];
  }
  options = xtend$2(options, { path });
  return typeof result === "function" ? result(options) : formatErrorMessage(options, prettifyResult(result));
}
function orList(list2) {
  if (list2.length < 2) {
    return list2[0];
  }
  if (list2.length === 2) {
    return list2.join(" or ");
  }
  return list2.slice(0, -1).join(", ") + ", or " + list2.slice(-1);
}
function prettifyResult(result) {
  return "must be " + addArticle(result) + ".";
}
function addArticle(nounPhrase) {
  if (/^an? /.test(nounPhrase)) {
    return nounPhrase;
  }
  if (/^[aeiou]/i.test(nounPhrase)) {
    return "an " + nounPhrase;
  }
  if (/^[a-z]/i.test(nounPhrase)) {
    return "a " + nounPhrase;
  }
  return nounPhrase;
}
function formatErrorMessage(options, prettyResult) {
  var arrayCulprit = isArrayCulprit(options.path);
  var output = options.path.join(".") + " " + prettyResult;
  var prepend = arrayCulprit ? "Item at position " : "";
  return prepend + output;
}
function isArrayCulprit(path) {
  return typeof path[path.length - 1] == "number" || typeof path[0] == "number";
}
function objectEntries(obj) {
  return Object.keys(obj || {}).map(function(key) {
    return { key, value: obj[key] };
  });
}
v$2.validate = validate;
v$2.processMessage = processMessage;
var lib$1 = v$2;
var xtend$1 = immutable;
var v$1 = lib$1;
function file(value2) {
  if (typeof window !== "undefined") {
    if (value2 instanceof commonjsGlobal.Blob || value2 instanceof commonjsGlobal.ArrayBuffer) {
      return;
    }
    return "Blob or ArrayBuffer";
  }
  if (typeof value2 === "string" || value2.pipe !== void 0) {
    return;
  }
  return "Filename or Readable stream";
}
function assertShape(validatorObj, apiName) {
  return v$1.assert(v$1.strictShape(validatorObj), apiName);
}
function date(value2) {
  var msg = "date";
  if (typeof value2 === "boolean") {
    return msg;
  }
  try {
    var date2 = new Date(value2);
    if (date2.getTime && isNaN(date2.getTime())) {
      return msg;
    }
  } catch (e) {
    return msg;
  }
}
function coordinates(value2) {
  return v$1.tuple(v$1.number, v$1.number)(value2);
}
var validator = xtend$1(v$1, {
  file,
  date,
  coordinates,
  assertShape
});
function pick$1(source2, keys2) {
  var filter = function(key, val) {
    return keys2.indexOf(key) !== -1 && val !== void 0;
  };
  if (typeof keys2 === "function") {
    filter = keys2;
  }
  return Object.keys(source2).filter(function(key) {
    return filter(key, source2[key]);
  }).reduce(function(result, key) {
    result[key] = source2[key];
    return result;
  }, {});
}
var pick_1 = pick$1;
function objectMap$1(obj, cb2) {
  return Object.keys(obj).reduce(function(result, key) {
    result[key] = cb2(key, obj[key]);
    return result;
  }, {});
}
var objectMap_1 = objectMap$1;
var objectMap = objectMap_1;
function stringifyBoolean(obj) {
  return objectMap(obj, function(_, value2) {
    return typeof value2 === "boolean" ? JSON.stringify(value2) : value2;
  });
}
var stringifyBooleans$1 = stringifyBoolean;
var MapiClient = mapiClient;
var createClient = browserClient;
function createServiceFactory$1(ServicePrototype) {
  return function(clientOrConfig) {
    var client2;
    if (MapiClient.prototype.isPrototypeOf(clientOrConfig)) {
      client2 = clientOrConfig;
    } else {
      client2 = createClient(clientOrConfig);
    }
    var service = Object.create(ServicePrototype);
    service.client = client2;
    return service;
  };
}
var createServiceFactory_1 = createServiceFactory$1;
var xtend = immutable;
var v = validator;
var pick = pick_1;
var stringifyBooleans = stringifyBooleans$1;
var createServiceFactory = createServiceFactory_1;
var Geocoding = {};
var featureTypes = [
  "country",
  "region",
  "postcode",
  "district",
  "place",
  "locality",
  "neighborhood",
  "address",
  "poi",
  "poi.landmark"
];
Geocoding.forwardGeocode = function(config2) {
  v.assertShape({
    query: v.required(v.string),
    mode: v.oneOf("mapbox.places", "mapbox.places-permanent"),
    countries: v.arrayOf(v.string),
    proximity: v.oneOf(v.coordinates, "ip"),
    types: v.arrayOf(v.oneOf(featureTypes)),
    autocomplete: v.boolean,
    bbox: v.arrayOf(v.number),
    limit: v.number,
    language: v.arrayOf(v.string),
    routing: v.boolean,
    fuzzyMatch: v.boolean,
    worldview: v.string
  })(config2);
  config2.mode = config2.mode || "mapbox.places";
  var query = stringifyBooleans(xtend({ country: config2.countries }, pick(config2, [
    "proximity",
    "types",
    "autocomplete",
    "bbox",
    "limit",
    "language",
    "routing",
    "fuzzyMatch",
    "worldview"
  ])));
  return this.client.createRequest({
    method: "GET",
    path: "/geocoding/v5/:mode/:query.json",
    params: pick(config2, ["mode", "query"]),
    query
  });
};
Geocoding.reverseGeocode = function(config2) {
  v.assertShape({
    query: v.required(v.coordinates),
    mode: v.oneOf("mapbox.places", "mapbox.places-permanent"),
    countries: v.arrayOf(v.string),
    types: v.arrayOf(v.oneOf(featureTypes)),
    bbox: v.arrayOf(v.number),
    limit: v.number,
    language: v.arrayOf(v.string),
    reverseMode: v.oneOf("distance", "score"),
    routing: v.boolean,
    worldview: v.string
  })(config2);
  config2.mode = config2.mode || "mapbox.places";
  var query = stringifyBooleans(xtend({ country: config2.countries }, pick(config2, [
    "country",
    "types",
    "bbox",
    "limit",
    "language",
    "reverseMode",
    "routing",
    "worldview"
  ])));
  return this.client.createRequest({
    method: "GET",
    path: "/geocoding/v5/:mode/:query.json",
    params: pick(config2, ["mode", "query"]),
    query
  });
};
var geocoding = createServiceFactory(Geocoding);
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
{
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative" && typeof crypto === "undefined") {
    throw new Error("React Native does not have a built-in secure random generator. If you don\u2019t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID.");
  }
  if (typeof msCrypto !== "undefined" && typeof crypto === "undefined") {
    throw new Error("Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support");
  }
  if (typeof crypto === "undefined") {
    throw new Error("Your browser does not have secure random generator. If you don\u2019t need unpredictable IDs, you can use nanoid/non-secure.");
  }
}
let random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, size, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * size / alphabet.length);
  return () => {
    let id2 = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id2 += alphabet[bytes[j] & mask] || "";
        if (id2.length === size)
          return id2;
      }
    }
  };
};
let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);
let nanoid$1 = (size = 21) => {
  let id2 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    let byte = bytes[size] & 63;
    if (byte < 36) {
      id2 += byte.toString(36);
    } else if (byte < 62) {
      id2 += (byte - 26).toString(36).toUpperCase();
    } else if (byte < 63) {
      id2 += "_";
    } else {
      id2 += "-";
    }
  }
  return id2;
};
var index_dev = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  nanoid: nanoid$1,
  customAlphabet,
  customRandom,
  urlAlphabet,
  random
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(index_dev);
var nanoid = require$$0.nanoid;
function MapboxEventManager$1(options) {
  this.origin = options.origin || "https://api.mapbox.com";
  this.endpoint = "events/v2";
  this.access_token = options.accessToken;
  this.version = "0.2.0";
  this.sessionID = this.generateSessionID();
  this.userAgent = this.getUserAgent();
  this.options = options;
  this.send = this.send.bind(this);
  this.countries = options.countries ? options.countries.split(",") : null;
  this.types = options.types ? options.types.split(",") : null;
  this.bbox = options.bbox ? options.bbox : null;
  this.language = options.language ? options.language.split(",") : null;
  this.limit = options.limit ? +options.limit : null;
  this.locale = navigator.language || null;
  this.enableEventLogging = this.shouldEnableLogging(options);
  this.eventQueue = new Array();
  this.flushInterval = options.flushInterval || 1e3;
  this.maxQueueSize = options.maxQueueSize || 100;
  this.timer = this.flushInterval ? setTimeout(this.flush.bind(this), this.flushInterval) : null;
  this.lastSentInput = "";
  this.lastSentIndex = 0;
}
MapboxEventManager$1.prototype = {
  select: function(selected, geocoder) {
    var resultIndex = this.getSelectedIndex(selected, geocoder);
    var payload = this.getEventPayload("search.select", geocoder);
    payload.resultIndex = resultIndex;
    payload.resultPlaceName = selected.place_name;
    payload.resultId = selected.id;
    if (resultIndex === this.lastSentIndex && payload.queryString === this.lastSentInput || resultIndex == -1) {
      return;
    }
    this.lastSentIndex = resultIndex;
    this.lastSentInput = payload.queryString;
    if (!payload.queryString)
      return;
    return this.push(payload);
  },
  start: function(geocoder) {
    var payload = this.getEventPayload("search.start", geocoder);
    if (!payload.queryString)
      return;
    return this.push(payload);
  },
  keyevent: function(keyEvent, geocoder) {
    if (!keyEvent.key)
      return;
    if (keyEvent.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(keyEvent.keyCode) !== -1)
      return;
    var payload = this.getEventPayload("search.keystroke", geocoder);
    payload.lastAction = keyEvent.key;
    if (!payload.queryString)
      return;
    return this.push(payload);
  },
  send: function(payload, callback2) {
    if (!this.enableEventLogging) {
      if (callback2)
        return callback2();
      return;
    }
    var options = this.getRequestOptions(payload);
    this.request(options, function(err) {
      if (err)
        return this.handleError(err, callback2);
      if (callback2) {
        return callback2();
      }
    }.bind(this));
  },
  getRequestOptions: function(payload) {
    if (!Array.isArray(payload))
      payload = [payload];
    var options = {
      method: "POST",
      host: this.origin,
      path: this.endpoint + "?access_token=" + this.access_token,
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payload)
    };
    return options;
  },
  getEventPayload: function(event, geocoder) {
    var proximity;
    if (!geocoder.options.proximity) {
      proximity = null;
    } else if (typeof geocoder.options.proximity === "object") {
      proximity = [geocoder.options.proximity.longitude, geocoder.options.proximity.latitude];
    } else if (geocoder.options.proximity === "ip") {
      proximity = [999, 999];
    } else {
      proximity = geocoder.options.proximity;
    }
    var zoom = geocoder._map ? geocoder._map.getZoom() : void 0;
    var payload = {
      event,
      created: +new Date(),
      sessionIdentifier: this.sessionID,
      country: this.countries,
      userAgent: this.userAgent,
      language: this.language,
      bbox: this.bbox,
      types: this.types,
      endpoint: "mapbox.places",
      autocomplete: geocoder.options.autocomplete,
      fuzzyMatch: geocoder.options.fuzzyMatch,
      proximity,
      limit: geocoder.options.limit,
      routing: geocoder.options.routing,
      worldview: geocoder.options.worldview,
      mapZoom: zoom,
      keyboardLocale: this.locale
    };
    if (event === "search.select") {
      payload.queryString = geocoder.inputString;
    } else if (event != "search.select" && geocoder._inputEl) {
      payload.queryString = geocoder._inputEl.value;
    } else {
      payload.queryString = geocoder.inputString;
    }
    return payload;
  },
  request: function(opts, callback2) {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
      if (this.readyState == 4) {
        if (this.status == 204) {
          return callback2(null);
        } else {
          return callback2(this.statusText);
        }
      }
    };
    xhttp.open(opts.method, opts.host + "/" + opts.path, true);
    for (var header in opts.headers) {
      var headerValue = opts.headers[header];
      xhttp.setRequestHeader(header, headerValue);
    }
    xhttp.send(opts.body);
  },
  handleError: function(err, callback2) {
    if (callback2)
      return callback2(err);
  },
  generateSessionID: function() {
    return nanoid();
  },
  getUserAgent: function() {
    return "mapbox-gl-geocoder." + this.version + "." + navigator.userAgent;
  },
  getSelectedIndex: function(selected, geocoder) {
    if (!geocoder._typeahead)
      return;
    var results = geocoder._typeahead.data;
    var selectedID = selected.id;
    var resultIDs = results.map(function(feature) {
      return feature.id;
    });
    var selectedIdx = resultIDs.indexOf(selectedID);
    return selectedIdx;
  },
  shouldEnableLogging: function(options) {
    if (options.enableEventLogging === false)
      return false;
    if (options.origin && options.origin !== "https://api.mapbox.com")
      return false;
    if (options.localGeocoder)
      return false;
    if (options.filter)
      return false;
    return true;
  },
  flush: function() {
    if (this.eventQueue.length > 0) {
      this.send(this.eventQueue);
      this.eventQueue = new Array();
    }
    if (this.timer)
      clearTimeout(this.timer);
    if (this.flushInterval)
      this.timer = setTimeout(this.flush.bind(this), this.flushInterval);
  },
  push: function(evt, forceFlush) {
    this.eventQueue.push(evt);
    if (this.eventQueue.length >= this.maxQueueSize || forceFlush) {
      this.flush();
    }
  },
  remove: function() {
    this.flush();
  }
};
var events = MapboxEventManager$1;
var placeholder = {
  "de": "Suche",
  "it": "Ricerca",
  "en": "Search",
  "nl": "Zoeken",
  "fr": "Chercher",
  "ca": "Cerca",
  "he": "\u05DC\u05D7\u05E4\u05E9",
  "ja": "\u30B5\u30FC\u30C1",
  "lv": "Mekl\u0113t",
  "pt": "Procurar",
  "sr": "\u041F\u0440\u0435\u0442\u0440\u0430\u0433\u0430",
  "zh": "\u641C\u7D22",
  "cs": "Vyhled\xE1v\xE1n\xED",
  "hu": "Keres\xE9s",
  "ka": "\u10EB\u10D8\u10D4\u10D1\u10D0",
  "nb": "S\xF8ke",
  "sk": "Vyh\u013Ead\xE1vanie",
  "th": "\u0E04\u0E49\u0E19\u0E2B\u0E32",
  "fi": "Hae",
  "is": "Leita",
  "ko": "\uC218\uC0C9",
  "pl": "Szukaj",
  "sl": "Iskanje",
  "fa": "\u062C\u0633\u062A\u062C\u0648",
  "ru": "\u041F\u043E\u0438\u0441\u043A"
};
var localization$1 = { placeholder };
var subtag$1 = { exports: {} };
(function(module2) {
  !function(root2, name, make) {
    if (module2.exports)
      module2.exports = make();
    else
      root2[name] = make();
  }(commonjsGlobal, "subtag", function() {
    var empty = "";
    var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
    function match(tag) {
      return tag.match(pattern) || [];
    }
    function split(tag) {
      return match(tag).filter(function(v2, i) {
        return v2 && i;
      });
    }
    function api(tag) {
      tag = match(tag);
      return {
        language: tag[1] || empty,
        extlang: tag[2] || empty,
        script: tag[3] || empty,
        region: tag[4] || empty
      };
    }
    function expose(target, key, value2) {
      Object.defineProperty(target, key, {
        value: value2,
        enumerable: true
      });
    }
    function part(position, pattern2, type) {
      function method(tag) {
        return match(tag)[position] || empty;
      }
      expose(method, "pattern", pattern2);
      expose(api, type, method);
    }
    part(1, /^[a-zA-Z]{2,3}$/, "language");
    part(2, /^[a-zA-Z]{3}$/, "extlang");
    part(3, /^[a-zA-Z]{4}$/, "script");
    part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region");
    expose(api, "split", split);
    return api;
  });
})(subtag$1);
function Geolocation$1() {
}
Geolocation$1.prototype = {
  isSupport: function() {
    return Boolean(window.navigator.geolocation);
  },
  getCurrentPosition: function() {
    const positionOptions = {
      enableHighAccuracy: true
    };
    return new Promise(function(resolve2, reject) {
      window.navigator.geolocation.getCurrentPosition(resolve2, reject, positionOptions);
    });
  }
};
var geolocation = Geolocation$1;
function transformFeatureToGeolocationText(feature, accuracy) {
  const addrInfo = getAddressInfo(feature);
  const addressAccuracy = ["address", "street", "place", "country"];
  var currentAccuracy;
  if (typeof accuracy === "function") {
    return accuracy(addrInfo);
  }
  const accuracyIndex = addressAccuracy.indexOf(accuracy);
  if (accuracyIndex === -1) {
    currentAccuracy = addressAccuracy;
  } else {
    currentAccuracy = addressAccuracy.slice(accuracyIndex);
  }
  return currentAccuracy.reduce(function(acc, name) {
    if (!addrInfo[name]) {
      return acc;
    }
    if (acc !== "") {
      acc = acc + ", ";
    }
    return acc + addrInfo[name];
  }, "");
}
function getAddressInfo(feature) {
  const houseNumber = feature.address || "";
  const street = feature.text || "";
  const placeName = feature.place_name || "";
  const address = placeName.split(",")[0];
  const addrInfo = {
    address,
    houseNumber,
    street,
    placeName
  };
  feature.context.forEach(function(context) {
    const layer = context.id.split(".")[0];
    addrInfo[layer] = context.text;
  });
  return addrInfo;
}
const REVERSE_GEOCODE_COORD_RGX = /^[ ]*(-?\d{1,3}(\.\d{0,256})?)[, ]+(-?\d{1,3}(\.\d{0,256})?)[ ]*$/;
var utils$1 = {
  transformFeatureToGeolocationText,
  getAddressInfo,
  REVERSE_GEOCODE_COORD_RGX
};
var Typeahead = suggestions;
var debounce$1 = lodash_debounce;
var extend = immutable;
var EventEmitter = events$1.exports.EventEmitter;
var exceptions = exceptions$1;
var MapboxClient = mapboxSdk;
var mbxGeocoder = geocoding;
var MapboxEventManager = events;
var localization = localization$1;
var subtag = subtag$1.exports;
var Geolocation = geolocation;
var utils = utils$1;
const GEOCODE_REQUEST_TYPE = {
  FORWARD: 0,
  LOCAL: 1,
  REVERSE: 2
};
function getFooterNode() {
  var div = document.createElement("div");
  div.className = "mapboxgl-ctrl-geocoder--powered-by";
  div.innerHTML = '<a href="https://www.mapbox.com/search-service" target="_blank">Powered by Mapbox</a>';
  return div;
}
function MapboxGeocoder(options) {
  this._eventEmitter = new EventEmitter();
  this.options = extend({}, this.options, options);
  this.inputString = "";
  this.fresh = true;
  this.lastSelected = null;
  this.geolocation = new Geolocation();
}
MapboxGeocoder.prototype = {
  options: {
    zoom: 16,
    flyTo: true,
    trackProximity: true,
    minLength: 2,
    reverseGeocode: false,
    flipCoordinates: false,
    limit: 5,
    origin: "https://api.mapbox.com",
    enableEventLogging: true,
    marker: true,
    mapboxgl: null,
    collapsed: false,
    clearAndBlurOnEsc: false,
    clearOnBlur: false,
    enableGeolocation: false,
    addressAccuracy: "street",
    getItemValue: function(item) {
      return item.place_name;
    },
    render: function(item) {
      var placeName = item.place_name.split(",");
      return '<div class="mapboxgl-ctrl-geocoder--suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title">' + placeName[0] + '</div><div class="mapboxgl-ctrl-geocoder--suggestion-address">' + placeName.splice(1, placeName.length).join(",") + "</div></div>";
    }
  },
  addTo: function(container) {
    function addToExistingContainer(geocoder, container2) {
      if (!document.body.contains(container2)) {
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      }
      const el = geocoder.onAdd();
      container2.appendChild(el);
    }
    if (container._controlContainer) {
      container.addControl(this);
    } else if (container instanceof HTMLElement) {
      addToExistingContainer(this, container);
    } else if (typeof container == "string") {
      const parent = document.querySelectorAll(container);
      if (parent.length === 0) {
        throw new Error("Element ", container, "not found.");
      }
      if (parent.length > 1) {
        throw new Error("Geocoder can only be added to a single html element");
      }
      addToExistingContainer(this, parent[0]);
    } else {
      throw new Error("Error: addTo must be a mapbox-gl-js map, an html element, or a CSS selector query for a single html element");
    }
  },
  onAdd: function(map2) {
    if (map2 && typeof map2 != "string") {
      this._map = map2;
    }
    this.setLanguage();
    if (!this.options.localGeocoderOnly) {
      this.geocoderService = mbxGeocoder(MapboxClient({
        accessToken: this.options.accessToken,
        origin: this.options.origin
      }));
    }
    if (this.options.localGeocoderOnly && !this.options.localGeocoder) {
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    }
    this.eventManager = new MapboxEventManager(this.options);
    this._onChange = this._onChange.bind(this);
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onPaste = this._onPaste.bind(this);
    this._onBlur = this._onBlur.bind(this);
    this._showButton = this._showButton.bind(this);
    this._hideButton = this._hideButton.bind(this);
    this._onQueryResult = this._onQueryResult.bind(this);
    this.clear = this.clear.bind(this);
    this._updateProximity = this._updateProximity.bind(this);
    this._collapse = this._collapse.bind(this);
    this._unCollapse = this._unCollapse.bind(this);
    this._clear = this._clear.bind(this);
    this._clearOnBlur = this._clearOnBlur.bind(this);
    this._geolocateUser = this._geolocateUser.bind(this);
    var el = this.container = document.createElement("div");
    el.className = "mapboxgl-ctrl-geocoder mapboxgl-ctrl";
    var searchIcon = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input");
    this._inputEl.type = "text";
    this._inputEl.className = "mapboxgl-ctrl-geocoder--input";
    this.setPlaceholder();
    if (this.options.collapsed) {
      this._collapse();
      this.container.addEventListener("mouseenter", this._unCollapse);
      this.container.addEventListener("mouseleave", this._collapse);
      this._inputEl.addEventListener("focus", this._unCollapse);
    }
    if (this.options.collapsed || this.options.clearOnBlur) {
      this._inputEl.addEventListener("blur", this._onBlur);
    }
    this._inputEl.addEventListener("keydown", debounce$1(this._onKeyDown, 200));
    this._inputEl.addEventListener("paste", this._onPaste);
    this._inputEl.addEventListener("change", this._onChange);
    this.container.addEventListener("mouseenter", this._showButton);
    this.container.addEventListener("mouseleave", this._hideButton);
    this._inputEl.addEventListener("keyup", function(e) {
      this.eventManager.keyevent(e, this);
    }.bind(this));
    var actions = document.createElement("div");
    actions.classList.add("mapboxgl-ctrl-geocoder--pin-right");
    this._clearEl = document.createElement("button");
    this._clearEl.setAttribute("aria-label", "Clear");
    this._clearEl.addEventListener("click", this.clear);
    this._clearEl.className = "mapboxgl-ctrl-geocoder--button";
    var buttonIcon = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    this._clearEl.appendChild(buttonIcon);
    this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>');
    actions.appendChild(this._clearEl);
    actions.appendChild(this._loadingEl);
    el.appendChild(searchIcon);
    el.appendChild(this._inputEl);
    el.appendChild(actions);
    if (this.options.enableGeolocation && this.geolocation.isSupport()) {
      this._geolocateEl = document.createElement("button");
      this._geolocateEl.setAttribute("aria-label", "Geolocate");
      this._geolocateEl.addEventListener("click", this._geolocateUser);
      this._geolocateEl.className = "mapboxgl-ctrl-geocoder--button";
      var geolocateIcon = this.createIcon("geolocate", '<path d="M12.999 3.677L2.042 8.269c-.962.403-.747 1.823.29 1.912l5.032.431.431 5.033c.089 1.037 1.509 1.252 1.912.29l4.592-10.957c.345-.822-.477-1.644-1.299-1.299z" fill="#4264fb"/>');
      this._geolocateEl.appendChild(geolocateIcon);
      actions.appendChild(this._geolocateEl);
      this._showGeolocateButton();
    }
    var typeahead = this._typeahead = new Typeahead(this._inputEl, [], {
      filter: false,
      minLength: this.options.minLength,
      limit: this.options.limit
    });
    this.setRenderFunction(this.options.render);
    typeahead.getItemValue = this.options.getItemValue;
    var parentDraw = typeahead.list.draw;
    var footerNode = this._footerNode = getFooterNode();
    typeahead.list.draw = function() {
      parentDraw.call(this);
      footerNode.addEventListener("mousedown", function() {
        this.selectingListItem = true;
      }.bind(this));
      footerNode.addEventListener("mouseup", function() {
        this.selectingListItem = false;
      }.bind(this));
      this.element.appendChild(footerNode);
    };
    this.mapMarker = null;
    this._handleMarker = this._handleMarker.bind(this);
    if (this._map) {
      if (this.options.trackProximity) {
        this._updateProximity();
        this._map.on("moveend", this._updateProximity);
      }
      this._mapboxgl = this.options.mapboxgl;
      if (!this._mapboxgl && this.options.marker) {
        console.error("No mapboxgl detected in options. Map markers are disabled. Please set options.mapboxgl.");
        this.options.marker = false;
      }
    }
    return el;
  },
  _geolocateUser: function() {
    this._hideGeolocateButton();
    this._showLoadingIcon();
    this.geolocation.getCurrentPosition().then(function(geolocationPosition) {
      this._hideLoadingIcon();
      const geojson = {
        geometry: {
          type: "Point",
          coordinates: [geolocationPosition.coords.longitude, geolocationPosition.coords.latitude]
        }
      };
      this._handleMarker(geojson);
      this._fly(geojson);
      this._typeahead.clear();
      this._typeahead.selected = true;
      this.lastSelected = JSON.stringify(geojson);
      this._showClearButton();
      this.fresh = false;
      const config2 = {
        limit: 1,
        language: [this.options.language],
        query: geojson.geometry.coordinates,
        types: ["address"]
      };
      if (this.options.localGeocoderOnly) {
        const text = geojson.geometry.coordinates[0] + "," + geojson.geometry.coordinates[1];
        this._setInputValue(text);
        this._eventEmitter.emit("result", { result: geojson });
      } else {
        this.geocoderService.reverseGeocode(config2).send().then(function(resp) {
          const feature = resp.body.features[0];
          if (feature) {
            const locationText = utils.transformFeatureToGeolocationText(feature, this.options.addressAccuracy);
            this._setInputValue(locationText);
            feature.user_coordinates = geojson.geometry.coordinates;
            this._eventEmitter.emit("result", { result: feature });
          } else {
            this._eventEmitter.emit("result", { result: { user_coordinates: geojson.geometry.coordinates } });
          }
        }.bind(this));
      }
    }.bind(this)).catch(function(error) {
      if (error.code === 1) {
        this._renderUserDeniedGeolocationError();
      } else {
        this._renderLocationError();
      }
      this._hideLoadingIcon();
      this._showGeolocateButton();
      this._hideAttribution();
    }.bind(this));
  },
  createIcon: function(name, path) {
    var icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    icon.setAttribute("class", "mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-" + name);
    icon.setAttribute("viewBox", "0 0 18 18");
    icon.setAttribute("xml:space", "preserve");
    icon.setAttribute("width", 18);
    icon.setAttribute("height", 18);
    icon.innerHTML = path;
    return icon;
  },
  onRemove: function() {
    this.container.parentNode.removeChild(this.container);
    if (this.options.trackProximity && this._map) {
      this._map.off("moveend", this._updateProximity);
    }
    this._removeMarker();
    this._map = null;
    return this;
  },
  _setInputValue: function(value2) {
    this._inputEl.value = value2;
    setTimeout(function() {
      this._inputEl.focus();
      this._inputEl.scrollLeft = 0;
      this._inputEl.setSelectionRange(0, 0);
    }.bind(this), 1);
  },
  _onPaste: function(e) {
    var value2 = (e.clipboardData || window.clipboardData).getData("text");
    if (value2.length >= this.options.minLength) {
      this._geocode(value2);
    }
  },
  _onKeyDown: function(e) {
    var ESC_KEY_CODE = 27, TAB_KEY_CODE = 9;
    if (e.keyCode === ESC_KEY_CODE && this.options.clearAndBlurOnEsc) {
      this._clear(e);
      return this._inputEl.blur();
    }
    var target = e.target && e.target.shadowRoot ? e.target.shadowRoot.activeElement : e.target;
    var value2 = target ? target.value : "";
    if (!value2) {
      this.fresh = true;
      if (e.keyCode !== TAB_KEY_CODE)
        this.clear(e);
      this._showGeolocateButton();
      return this._hideClearButton();
    }
    this._hideGeolocateButton();
    if (e.metaKey || [TAB_KEY_CODE, ESC_KEY_CODE, 37, 39, 13, 38, 40].indexOf(e.keyCode) !== -1)
      return;
    if (target.value.length >= this.options.minLength) {
      this._geocode(target.value);
    }
  },
  _showButton: function() {
    if (this._typeahead.selected)
      this._showClearButton();
  },
  _hideButton: function() {
    if (this._typeahead.selected)
      this._hideClearButton();
  },
  _showClearButton: function() {
    this._clearEl.style.display = "block";
  },
  _hideClearButton: function() {
    this._clearEl.style.display = "none";
  },
  _showGeolocateButton: function() {
    if (this._geolocateEl && this.geolocation.isSupport()) {
      this._geolocateEl.style.display = "block";
    }
  },
  _hideGeolocateButton: function() {
    if (this._geolocateEl) {
      this._geolocateEl.style.display = "none";
    }
  },
  _showLoadingIcon: function() {
    this._loadingEl.style.display = "block";
  },
  _hideLoadingIcon: function() {
    this._loadingEl.style.display = "none";
  },
  _showAttribution: function() {
    this._footerNode.style.display = "block";
  },
  _hideAttribution: function() {
    this._footerNode.style.display = "none";
  },
  _onBlur: function(e) {
    if (this.options.clearOnBlur) {
      this._clearOnBlur(e);
    }
    if (this.options.collapsed) {
      this._collapse();
    }
  },
  _onChange: function() {
    var selected = this._typeahead.selected;
    if (selected && JSON.stringify(selected) !== this.lastSelected) {
      this._hideClearButton();
      if (this.options.flyTo) {
        this._fly(selected);
      }
      if (this.options.marker && this._mapboxgl) {
        this._handleMarker(selected);
      }
      this._inputEl.focus();
      this._inputEl.scrollLeft = 0;
      this._inputEl.setSelectionRange(0, 0);
      this.lastSelected = JSON.stringify(selected);
      this._eventEmitter.emit("result", { result: selected });
      this.eventManager.select(selected, this);
    }
  },
  _fly: function(selected) {
    var flyOptions;
    if (selected.properties && exceptions[selected.properties.short_code]) {
      flyOptions = extend({}, this.options.flyTo);
      if (this._map) {
        this._map.fitBounds(exceptions[selected.properties.short_code].bbox, flyOptions);
      }
    } else if (selected.bbox) {
      var bbox = selected.bbox;
      flyOptions = extend({}, this.options.flyTo);
      if (this._map) {
        this._map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], flyOptions);
      }
    } else {
      var defaultFlyOptions = {
        zoom: this.options.zoom
      };
      flyOptions = extend({}, defaultFlyOptions, this.options.flyTo);
      if (selected.center) {
        flyOptions.center = selected.center;
      } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
        flyOptions.center = selected.geometry.coordinates;
      }
      if (this._map) {
        this._map.flyTo(flyOptions);
      }
    }
  },
  _requestType: function(options, search) {
    var type;
    if (options.localGeocoderOnly) {
      type = GEOCODE_REQUEST_TYPE.LOCAL;
    } else if (options.reverseGeocode && utils.REVERSE_GEOCODE_COORD_RGX.test(search)) {
      type = GEOCODE_REQUEST_TYPE.REVERSE;
    } else {
      type = GEOCODE_REQUEST_TYPE.FORWARD;
    }
    return type;
  },
  _setupConfig: function(requestType, search) {
    const keys2 = [
      "bbox",
      "limit",
      "proximity",
      "countries",
      "types",
      "language",
      "reverseMode",
      "mode",
      "autocomplete",
      "fuzzyMatch",
      "routing",
      "worldview"
    ];
    const spacesOrCommaRgx = /[\s,]+/;
    var self2 = this;
    var config2 = keys2.reduce(function(config3, key) {
      if (self2.options[key] === void 0 || self2.options[key] === null) {
        return config3;
      }
      ["countries", "types", "language"].indexOf(key) > -1 ? config3[key] = self2.options[key].split(spacesOrCommaRgx) : config3[key] = self2.options[key];
      const isCoordKey = typeof self2.options[key].longitude === "number" && typeof self2.options[key].latitude === "number";
      if (key === "proximity" && isCoordKey) {
        const lng = self2.options[key].longitude;
        const lat = self2.options[key].latitude;
        config3[key] = [lng, lat];
      }
      return config3;
    }, {});
    switch (requestType) {
      case GEOCODE_REQUEST_TYPE.REVERSE:
        {
          var coords = search.split(spacesOrCommaRgx).map(function(c) {
            return parseFloat(c, 10);
          });
          if (!self2.options.flipCoordinates) {
            coords.reverse();
          }
          config2.types ? [config2.types[0]] : ["poi"];
          config2 = extend(config2, { query: coords, limit: 1 });
          ["proximity", "autocomplete", "fuzzyMatch", "bbox"].forEach(function(key) {
            if (key in config2) {
              delete config2[key];
            }
          });
        }
        break;
      case GEOCODE_REQUEST_TYPE.FORWARD:
        {
          const trimmedSearch = search.trim();
          const reverseGeocodeCoordRgx = /^(-?\d{1,3}(\.\d{0,256})?)[, ]+(-?\d{1,3}(\.\d{0,256})?)?$/;
          if (reverseGeocodeCoordRgx.test(trimmedSearch)) {
            search = search.replace(/,/g, " ");
          }
          config2 = extend(config2, { query: search });
        }
        break;
    }
    return config2;
  },
  _geocode: function(searchInput) {
    this.inputString = searchInput;
    this._showLoadingIcon();
    this._eventEmitter.emit("loading", { query: searchInput });
    const requestType = this._requestType(this.options, searchInput);
    const config2 = this._setupConfig(requestType, searchInput);
    var request;
    switch (requestType) {
      case GEOCODE_REQUEST_TYPE.LOCAL:
        request = Promise.resolve();
        break;
      case GEOCODE_REQUEST_TYPE.FORWARD:
        request = this.geocoderService.forwardGeocode(config2).send();
        break;
      case GEOCODE_REQUEST_TYPE.REVERSE:
        request = this.geocoderService.reverseGeocode(config2).send();
        break;
    }
    var localGeocoderRes = this.options.localGeocoder ? this.options.localGeocoder(searchInput) || [] : [];
    var externalGeocoderRes = [];
    var geocoderError = null;
    request.catch(function(error) {
      geocoderError = error;
    }.bind(this)).then(function(response) {
      this._hideLoadingIcon();
      var res = {};
      if (!response) {
        res = {
          type: "FeatureCollection",
          features: []
        };
      } else if (response.statusCode == "200") {
        res = response.body;
        res.request = response.request;
        res.headers = response.headers;
      }
      res.config = config2;
      if (this.fresh) {
        this.eventManager.start(this);
        this.fresh = false;
      }
      res.features = res.features ? localGeocoderRes.concat(res.features) : localGeocoderRes;
      if (this.options.externalGeocoder) {
        externalGeocoderRes = this.options.externalGeocoder(searchInput, res.features) || Promise.resolve([]);
        return externalGeocoderRes.then(function(features) {
          res.features = res.features ? features.concat(res.features) : features;
          return res;
        }, function() {
          return res;
        });
      }
      return res;
    }.bind(this)).then(function(res) {
      if (geocoderError) {
        throw geocoderError;
      }
      if (this.options.filter && res.features.length) {
        res.features = res.features.filter(this.options.filter);
      }
      if (res.features.length) {
        this._showClearButton();
        this._hideGeolocateButton();
        this._showAttribution();
        this._eventEmitter.emit("results", res);
        this._typeahead.update(res.features);
      } else {
        this._hideClearButton();
        this._hideAttribution();
        this._typeahead.selected = null;
        this._renderNoResults();
        this._eventEmitter.emit("results", res);
      }
    }.bind(this)).catch(function(err) {
      this._hideLoadingIcon();
      this._hideAttribution();
      if (localGeocoderRes.length && this.options.localGeocoder || externalGeocoderRes.length && this.options.externalGeocoder) {
        this._showClearButton();
        this._hideGeolocateButton();
        this._typeahead.update(localGeocoderRes);
      } else {
        this._hideClearButton();
        this._typeahead.selected = null;
        this._renderError();
      }
      this._eventEmitter.emit("results", { features: localGeocoderRes });
      this._eventEmitter.emit("error", { error: err });
    }.bind(this));
    return request;
  },
  _clear: function(ev) {
    if (ev)
      ev.preventDefault();
    this._inputEl.value = "";
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._onChange();
    this._hideClearButton();
    this._showGeolocateButton();
    this._removeMarker();
    this.lastSelected = null;
    this._eventEmitter.emit("clear");
    this.fresh = true;
  },
  clear: function(ev) {
    this._clear(ev);
    this._inputEl.focus();
  },
  _clearOnBlur: function(ev) {
    var ctx = this;
    if (ev.relatedTarget) {
      ctx._clear(ev);
    }
  },
  _onQueryResult: function(response) {
    var results = response.body;
    if (!results.features.length)
      return;
    var result = results.features[0];
    this._typeahead.selected = result;
    this._inputEl.value = result.place_name;
    this._onChange();
  },
  _updateProximity: function() {
    if (!this._map || !this.options.trackProximity) {
      return;
    }
    if (this._map.getZoom() > 9) {
      var center = this._map.getCenter().wrap();
      this.setProximity({ longitude: center.lng, latitude: center.lat }, false);
    } else {
      this.setProximity(null, false);
    }
  },
  _collapse: function() {
    if (!this._inputEl.value && this._inputEl !== document.activeElement)
      this.container.classList.add("mapboxgl-ctrl-geocoder--collapsed");
  },
  _unCollapse: function() {
    this.container.classList.remove("mapboxgl-ctrl-geocoder--collapsed");
  },
  query: function(searchInput) {
    this._geocode(searchInput).then(this._onQueryResult);
    return this;
  },
  _renderError: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error'>There was an error reaching the server</div>";
    this._renderMessage(errorMessage);
  },
  _renderLocationError: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error'>A location error has occurred</div>";
    this._renderMessage(errorMessage);
  },
  _renderNoResults: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results'>No results found</div>";
    this._renderMessage(errorMessage);
  },
  _renderUserDeniedGeolocationError: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error'>Geolocation permission denied</div>";
    this._renderMessage(errorMessage);
  },
  _renderMessage: function(msg) {
    this._typeahead.update([]);
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._typeahead.renderError(msg);
  },
  _getPlaceholderText: function() {
    if (this.options.placeholder)
      return this.options.placeholder;
    if (this.options.language) {
      var firstLanguage = this.options.language.split(",")[0];
      var language = subtag.language(firstLanguage);
      var localizedValue = localization.placeholder[language];
      if (localizedValue)
        return localizedValue;
    }
    return "Search";
  },
  setInput: function(searchInput) {
    this._inputEl.value = searchInput;
    this._typeahead.selected = null;
    this._typeahead.clear();
    if (searchInput.length >= this.options.minLength) {
      this._geocode(searchInput);
    }
    return this;
  },
  setProximity: function(proximity, disableTrackProximity = true) {
    this.options.proximity = proximity;
    if (disableTrackProximity) {
      this.options.trackProximity = false;
    }
    return this;
  },
  getProximity: function() {
    return this.options.proximity;
  },
  setRenderFunction: function(fn) {
    if (fn && typeof fn == "function") {
      this._typeahead.render = fn;
    }
    return this;
  },
  getRenderFunction: function() {
    return this._typeahead.render;
  },
  setLanguage: function(language) {
    var browserLocale = navigator.language || navigator.userLanguage || navigator.browserLanguage;
    this.options.language = language || this.options.language || browserLocale;
    return this;
  },
  getLanguage: function() {
    return this.options.language;
  },
  getZoom: function() {
    return this.options.zoom;
  },
  setZoom: function(zoom) {
    this.options.zoom = zoom;
    return this;
  },
  getFlyTo: function() {
    return this.options.flyTo;
  },
  setFlyTo: function(flyTo) {
    this.options.flyTo = flyTo;
    return this;
  },
  getPlaceholder: function() {
    return this.options.placeholder;
  },
  setPlaceholder: function(placeholder2) {
    this.placeholder = placeholder2 ? placeholder2 : this._getPlaceholderText();
    this._inputEl.placeholder = this.placeholder;
    this._inputEl.setAttribute("aria-label", this.placeholder);
    return this;
  },
  getBbox: function() {
    return this.options.bbox;
  },
  setBbox: function(bbox) {
    this.options.bbox = bbox;
    return this;
  },
  getCountries: function() {
    return this.options.countries;
  },
  setCountries: function(countries) {
    this.options.countries = countries;
    return this;
  },
  getTypes: function() {
    return this.options.types;
  },
  setTypes: function(types) {
    this.options.types = types;
    return this;
  },
  getMinLength: function() {
    return this.options.minLength;
  },
  setMinLength: function(minLength) {
    this.options.minLength = minLength;
    if (this._typeahead)
      this._typeahead.options.minLength = minLength;
    return this;
  },
  getLimit: function() {
    return this.options.limit;
  },
  setLimit: function(limit) {
    this.options.limit = limit;
    if (this._typeahead)
      this._typeahead.options.limit = limit;
    return this;
  },
  getFilter: function() {
    return this.options.filter;
  },
  setFilter: function(filter) {
    this.options.filter = filter;
    return this;
  },
  setOrigin: function(origin) {
    this.options.origin = origin;
    this.geocoderService = mbxGeocoder(MapboxClient({
      accessToken: this.options.accessToken,
      origin: this.options.origin
    }));
    return this;
  },
  getOrigin: function() {
    return this.options.origin;
  },
  setAccessToken: function(accessToken) {
    this.options.accessToken = accessToken;
    this.geocoderService = mbxGeocoder(MapboxClient({
      accessToken: this.options.accessToken,
      origin: this.options.origin
    }));
    return this;
  },
  setAutocomplete: function(value2) {
    this.options.autocomplete = value2;
    return this;
  },
  getAutocomplete: function() {
    return this.options.autocomplete;
  },
  setFuzzyMatch: function(value2) {
    this.options.fuzzyMatch = value2;
    return this;
  },
  getFuzzyMatch: function() {
    return this.options.fuzzyMatch;
  },
  setRouting: function(value2) {
    this.options.routing = value2;
    return this;
  },
  getRouting: function() {
    return this.options.routing;
  },
  setWorldview: function(code) {
    this.options.worldview = code;
    return this;
  },
  getWorldview: function() {
    return this.options.worldview;
  },
  _handleMarker: function(selected) {
    if (!this._map) {
      return;
    }
    this._removeMarker();
    var defaultMarkerOptions = {
      color: "#4668F2"
    };
    var markerOptions = extend({}, defaultMarkerOptions, this.options.marker);
    this.mapMarker = new this._mapboxgl.Marker(markerOptions);
    if (selected.center) {
      this.mapMarker.setLngLat(selected.center).addTo(this._map);
    } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
      this.mapMarker.setLngLat(selected.geometry.coordinates).addTo(this._map);
    }
    return this;
  },
  _removeMarker: function() {
    if (this.mapMarker) {
      this.mapMarker.remove();
      this.mapMarker = null;
    }
  },
  on: function(type, fn) {
    this._eventEmitter.on(type, fn);
    return this;
  },
  off: function(type, fn) {
    this._eventEmitter.removeListener(type, fn);
    this.eventManager.remove();
    return this;
  }
};
var lib = MapboxGeocoder;
var mapboxGl$1 = { exports: {} };
(function(module2, exports) {
  (function(global2, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    var shared, worker, mapboxgl2;
    function define(_, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
        if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
          mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define(["exports"], function(t2) {
      var e = typeof self != "undefined" ? self : {}, r2 = n2;
      function n2(t3, e2, r3, n3) {
        this.cx = 3 * t3, this.bx = 3 * (r3 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n3 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = n3, this.p2x = r3, this.p2y = n3;
      }
      n2.prototype.sampleCurveX = function(t3) {
        return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
      }, n2.prototype.sampleCurveY = function(t3) {
        return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
      }, n2.prototype.sampleCurveDerivativeX = function(t3) {
        return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
      }, n2.prototype.solveCurveX = function(t3, e2) {
        var r3, n3, i2, s2, a2;
        for (e2 === void 0 && (e2 = 1e-6), i2 = t3, a2 = 0; a2 < 8; a2++) {
          if (s2 = this.sampleCurveX(i2) - t3, Math.abs(s2) < e2)
            return i2;
          var o2 = this.sampleCurveDerivativeX(i2);
          if (Math.abs(o2) < 1e-6)
            break;
          i2 -= s2 / o2;
        }
        if ((i2 = t3) < (r3 = 0))
          return r3;
        if (i2 > (n3 = 1))
          return n3;
        for (; r3 < n3; ) {
          if (s2 = this.sampleCurveX(i2), Math.abs(s2 - t3) < e2)
            return i2;
          t3 > s2 ? r3 = i2 : n3 = i2, i2 = 0.5 * (n3 - r3) + r3;
        }
        return i2;
      }, n2.prototype.solve = function(t3, e2) {
        return this.sampleCurveY(this.solveCurveX(t3, e2));
      };
      var i = s;
      function s(t3, e2) {
        this.x = t3, this.y = e2;
      }
      s.prototype = { clone: function() {
        return new s(this.x, this.y);
      }, add: function(t3) {
        return this.clone()._add(t3);
      }, sub: function(t3) {
        return this.clone()._sub(t3);
      }, multByPoint: function(t3) {
        return this.clone()._multByPoint(t3);
      }, divByPoint: function(t3) {
        return this.clone()._divByPoint(t3);
      }, mult: function(t3) {
        return this.clone()._mult(t3);
      }, div: function(t3) {
        return this.clone()._div(t3);
      }, rotate: function(t3) {
        return this.clone()._rotate(t3);
      }, rotateAround: function(t3, e2) {
        return this.clone()._rotateAround(t3, e2);
      }, matMult: function(t3) {
        return this.clone()._matMult(t3);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t3) {
        return this.x === t3.x && this.y === t3.y;
      }, dist: function(t3) {
        return Math.sqrt(this.distSqr(t3));
      }, distSqr: function(t3) {
        var e2 = t3.x - this.x, r3 = t3.y - this.y;
        return e2 * e2 + r3 * r3;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t3) {
        return Math.atan2(this.y - t3.y, this.x - t3.x);
      }, angleWith: function(t3) {
        return this.angleWithSep(t3.x, t3.y);
      }, angleWithSep: function(t3, e2) {
        return Math.atan2(this.x * e2 - this.y * t3, this.x * t3 + this.y * e2);
      }, _matMult: function(t3) {
        var e2 = t3[2] * this.x + t3[3] * this.y;
        return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e2, this;
      }, _add: function(t3) {
        return this.x += t3.x, this.y += t3.y, this;
      }, _sub: function(t3) {
        return this.x -= t3.x, this.y -= t3.y, this;
      }, _mult: function(t3) {
        return this.x *= t3, this.y *= t3, this;
      }, _div: function(t3) {
        return this.x /= t3, this.y /= t3, this;
      }, _multByPoint: function(t3) {
        return this.x *= t3.x, this.y *= t3.y, this;
      }, _divByPoint: function(t3) {
        return this.x /= t3.x, this.y /= t3.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t3 = this.y;
        return this.y = this.x, this.x = -t3, this;
      }, _rotate: function(t3) {
        var e2 = Math.cos(t3), r3 = Math.sin(t3), n3 = r3 * this.x + e2 * this.y;
        return this.x = e2 * this.x - r3 * this.y, this.y = n3, this;
      }, _rotateAround: function(t3, e2) {
        var r3 = Math.cos(t3), n3 = Math.sin(t3), i2 = e2.y + n3 * (this.x - e2.x) + r3 * (this.y - e2.y);
        return this.x = e2.x + r3 * (this.x - e2.x) - n3 * (this.y - e2.y), this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, s.convert = function(t3) {
        return t3 instanceof s ? t3 : Array.isArray(t3) ? new s(t3[0], t3[1]) : t3;
      };
      const a = Math.PI / 180, o = 180 / Math.PI;
      function l2(t3) {
        return t3 * a;
      }
      function u2(t3) {
        return t3 * o;
      }
      const c = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function h(t3) {
        if (t3 <= 0)
          return 0;
        if (t3 >= 1)
          return 1;
        const e2 = t3 * t3, r3 = e2 * t3;
        return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e2) + r3 - 0.75);
      }
      function p2(t3, e2, n3, i2) {
        const s2 = new r2(t3, e2, n3, i2);
        return function(t4) {
          return s2.solve(t4);
        };
      }
      const f = p2(0.25, 0.1, 0.25, 1);
      function d(t3, e2, r3) {
        return Math.min(r3, Math.max(e2, t3));
      }
      function y2(t3, e2, r3) {
        return (r3 = d((r3 - t3) / (e2 - t3), 0, 1)) * r3 * (3 - 2 * r3);
      }
      function m2(t3, e2, r3) {
        const n3 = r3 - e2, i2 = ((t3 - e2) % n3 + n3) % n3 + e2;
        return i2 === e2 ? r3 : i2;
      }
      function g(t3, e2, r3) {
        if (!t3.length)
          return r3(null, []);
        let n3 = t3.length;
        const i2 = new Array(t3.length);
        let s2 = null;
        t3.forEach((t4, a2) => {
          e2(t4, (t5, e3) => {
            t5 && (s2 = t5), i2[a2] = e3, --n3 == 0 && r3(s2, i2);
          });
        });
      }
      function x2(t3) {
        const e2 = [];
        for (const r3 in t3)
          e2.push(t3[r3]);
        return e2;
      }
      function v2(t3, ...e2) {
        for (const r3 of e2)
          for (const e3 in r3)
            t3[e3] = r3[e3];
        return t3;
      }
      let b = 1;
      function _() {
        return b++;
      }
      function w() {
        return function t3(e2) {
          return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t3);
        }();
      }
      function A2(t3) {
        return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
      }
      function S2(t3) {
        return !!t3 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t3);
      }
      function k(t3, e2) {
        t3.forEach((t4) => {
          e2[t4] && (e2[t4] = e2[t4].bind(e2));
        });
      }
      function I2(t3, e2) {
        return t3.indexOf(e2, t3.length - e2.length) !== -1;
      }
      function M2(t3, e2, r3) {
        const n3 = {};
        for (const i2 in t3)
          n3[i2] = e2.call(r3 || this, t3[i2], i2, t3);
        return n3;
      }
      function z2(t3, e2, r3) {
        const n3 = {};
        for (const i2 in t3)
          e2.call(r3 || this, t3[i2], i2, t3) && (n3[i2] = t3[i2]);
        return n3;
      }
      function T2(t3) {
        return Array.isArray(t3) ? t3.map(T2) : typeof t3 == "object" && t3 ? M2(t3, T2) : t3;
      }
      const B2 = {};
      function E2(t3) {
        B2[t3] || (typeof console != "undefined" && console.warn(t3), B2[t3] = true);
      }
      function C2(t3, e2, r3) {
        return (r3.y - t3.y) * (e2.x - t3.x) > (e2.y - t3.y) * (r3.x - t3.x);
      }
      function P2(t3) {
        let e2 = 0;
        for (let r3, n3, i2 = 0, s2 = t3.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          r3 = t3[i2], n3 = t3[a2], e2 += (n3.x - r3.x) * (r3.y + n3.y);
        return e2;
      }
      function D2() {
        return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope;
      }
      function V2(t3) {
        const e2 = {};
        if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r3, n3, i2) => {
          const s2 = n3 || i2;
          return e2[r3] = !s2 || s2.toLowerCase(), "";
        }), e2["max-age"]) {
          const t4 = parseInt(e2["max-age"], 10);
          isNaN(t4) ? delete e2["max-age"] : e2["max-age"] = t4;
        }
        return e2;
      }
      let F2 = null;
      function L2(t3) {
        if (F2 == null) {
          const e2 = t3.navigator ? t3.navigator.userAgent : null;
          F2 = !!t3.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return F2;
      }
      function R2(t3) {
        try {
          const r3 = e[t3];
          return r3.setItem("_mapbox_test_", 1), r3.removeItem("_mapbox_test_"), true;
        } catch (t4) {
          return false;
        }
      }
      function U2(t3, e2) {
        return [t3[4 * e2], t3[4 * e2 + 1], t3[4 * e2 + 2], t3[4 * e2 + 3]];
      }
      const j = e.performance;
      function $(t3) {
        const e2 = t3 ? t3.url.toString() : void 0;
        return j.getEntriesByName(e2);
      }
      var O2 = "2.10.0";
      let q2, N2, G2, Z2;
      const X2 = { now: () => G2 !== void 0 ? G2 : e.performance.now(), setNow(t3) {
        G2 = t3;
      }, restoreNow() {
        G2 = void 0;
      }, frame(t3) {
        const r3 = e.requestAnimationFrame(t3);
        return { cancel: () => e.cancelAnimationFrame(r3) };
      }, getImageData(t3, r3 = 0) {
        const { width: n3, height: i2 } = t3;
        Z2 || (Z2 = e.document.createElement("canvas"));
        const s2 = Z2.getContext("2d");
        if (!s2)
          throw new Error("failed to create canvas 2d context");
        return (n3 > Z2.width || i2 > Z2.height) && (Z2.width = n3, Z2.height = i2), s2.clearRect(-r3, -r3, n3 + 2 * r3, i2 + 2 * r3), s2.drawImage(t3, 0, 0, n3, i2), s2.getImageData(-r3, -r3, n3 + 2 * r3, i2 + 2 * r3);
      }, resolveURL: (t3) => (q2 || (q2 = e.document.createElement("a")), q2.href = t3, q2.href), get devicePixelRatio() {
        return e.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!e.matchMedia && (N2 == null && (N2 = e.matchMedia("(prefers-reduced-motion: reduce)")), N2.matches);
      } };
      let K2;
      const H2 = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (K2 == null) {
          const t3 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            K2 = { "TERM_PROGRAM": "vscode", "NODE": "/usr/local/bin/node", "INIT_CWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "TERM": "xterm-256color", "SHELL": "/bin/zsh", "npm_config_metrics_registry": "https://registry.npmjs.org/", "TMPDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/", "npm_config_global_prefix": "/usr/local", "TERM_PROGRAM_VERSION": "1.71.1", "ZDOTDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-zsh", "ORIGINAL_XDG_CURRENT_DESKTOP": "undefined", "MallocNanoZone": "0", "COLOR": "1", "npm_config_noproxy": "", "npm_config_local_prefix": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "USER": "obm_89", "COMMAND_MODE": "unix2003", "npm_config_globalconfig": "/usr/local/etc/npmrc", "SSH_AUTH_SOCK": "/private/tmp/com.apple.launchd.zCfsJph0oN/Listeners", "__CF_USER_TEXT_ENCODING": "0x1F5:0x0:0x0", "npm_execpath": "/usr/local/lib/node_modules/npm/bin/npm-cli.js", "PATH": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin:/Users/obm_89/Documents/hubmine/node_modules/.bin:/Users/obm_89/Documents/node_modules/.bin:/Users/obm_89/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/usr/local/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/Library/Frameworks/Python.framework/Versions/3.10/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Frameworks/Python.framework/Versions/3.10/bin", "npm_package_json": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/package.json", "_": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin/vite", "npm_config_userconfig": "/Users/obm_89/.npmrc", "npm_config_init_module": "/Users/obm_89/.npm-init.js", "__CFBundleIdentifier": "com.microsoft.VSCode", "npm_command": "run-script", "PWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "npm_lifecycle_event": "build", "EDITOR": "vi", "npm_package_name": "mosaic-react", "LANG": "en_US.UTF-8", "VSCODE_GIT_ASKPASS_EXTRA_ARGS": "--ms-enable-electron-run-as-node", "XPC_FLAGS": "0x0", "npm_config_node_gyp": "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "npm_package_version": "0.1.0", "XPC_SERVICE_NAME": "0", "VSCODE_INJECTION": "1", "SHLVL": "2", "HOME": "/Users/obm_89", "VSCODE_GIT_ASKPASS_MAIN": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js", "npm_config_cache": "/Users/obm_89/.npm", "LOGNAME": "obm_89", "npm_lifecycle_script": "vite build", "VSCODE_GIT_IPC_HANDLE": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-git-c8614585f1.sock", "npm_config_user_agent": "npm/8.15.0 node/v16.17.0 darwin x64 workspaces/false", "VSCODE_GIT_ASKPASS_NODE": "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper.app/Contents/MacOS/Code Helper", "GIT_ASKPASS": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh", "npm_node_execpath": "/usr/local/bin/node", "npm_config_prefix": "/usr/local", "COLORTERM": "truecolor", "NODE_ENV": "production" }.API_URL_REGEX != null ? new RegExp({ "TERM_PROGRAM": "vscode", "NODE": "/usr/local/bin/node", "INIT_CWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "TERM": "xterm-256color", "SHELL": "/bin/zsh", "npm_config_metrics_registry": "https://registry.npmjs.org/", "TMPDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/", "npm_config_global_prefix": "/usr/local", "TERM_PROGRAM_VERSION": "1.71.1", "ZDOTDIR": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-zsh", "ORIGINAL_XDG_CURRENT_DESKTOP": "undefined", "MallocNanoZone": "0", "COLOR": "1", "npm_config_noproxy": "", "npm_config_local_prefix": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "USER": "obm_89", "COMMAND_MODE": "unix2003", "npm_config_globalconfig": "/usr/local/etc/npmrc", "SSH_AUTH_SOCK": "/private/tmp/com.apple.launchd.zCfsJph0oN/Listeners", "__CF_USER_TEXT_ENCODING": "0x1F5:0x0:0x0", "npm_execpath": "/usr/local/lib/node_modules/npm/bin/npm-cli.js", "PATH": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin:/Users/obm_89/Documents/hubmine/node_modules/.bin:/Users/obm_89/Documents/node_modules/.bin:/Users/obm_89/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/usr/local/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/Library/Frameworks/Python.framework/Versions/3.10/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Frameworks/Python.framework/Versions/3.10/bin", "npm_package_json": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/package.json", "_": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0/node_modules/.bin/vite", "npm_config_userconfig": "/Users/obm_89/.npmrc", "npm_config_init_module": "/Users/obm_89/.npm-init.js", "__CFBundleIdentifier": "com.microsoft.VSCode", "npm_command": "run-script", "PWD": "/Users/obm_89/Documents/hubmine/supplier-dashboard2.0", "npm_lifecycle_event": "build", "EDITOR": "vi", "npm_package_name": "mosaic-react", "LANG": "en_US.UTF-8", "VSCODE_GIT_ASKPASS_EXTRA_ARGS": "--ms-enable-electron-run-as-node", "XPC_FLAGS": "0x0", "npm_config_node_gyp": "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "npm_package_version": "0.1.0", "XPC_SERVICE_NAME": "0", "VSCODE_INJECTION": "1", "SHLVL": "2", "HOME": "/Users/obm_89", "VSCODE_GIT_ASKPASS_MAIN": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js", "npm_config_cache": "/Users/obm_89/.npm", "LOGNAME": "obm_89", "npm_lifecycle_script": "vite build", "VSCODE_GIT_IPC_HANDLE": "/var/folders/f4/2qq8zkcs4r53yjjf133vjlhc0000gn/T/vscode-git-c8614585f1.sock", "npm_config_user_agent": "npm/8.15.0 node/v16.17.0 darwin x64 workspaces/false", "VSCODE_GIT_ASKPASS_NODE": "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper.app/Contents/MacOS/Code Helper", "GIT_ASKPASS": "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh", "npm_node_execpath": "/usr/local/bin/node", "npm_config_prefix": "/usr/local", "COLORTERM": "truecolor", "NODE_ENV": "production" }.API_URL_REGEX) : t3;
          } catch (e2) {
            K2 = t3;
          }
        }
        return K2;
      }, get EVENTS_URL() {
        return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, Y2 = { supported: false, testSupport: function(t3) {
        !Q2 && J2 && (tt ? et(t3) : W2 = t3);
      } };
      let W2, J2, Q2 = false, tt = false;
      function et(t3) {
        const e2 = t3.createTexture();
        t3.bindTexture(t3.TEXTURE_2D, e2);
        try {
          if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, J2), t3.isContextLost())
            return;
          Y2.supported = true;
        } catch (t4) {
        }
        t3.deleteTexture(e2), Q2 = true;
      }
      e.document && (J2 = e.document.createElement("img"), J2.onload = function() {
        W2 && et(W2), W2 = null, tt = true;
      }, J2.onerror = function() {
        Q2 = true, W2 = null;
      }, J2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const rt = "01", nt = "NO_ACCESS_TOKEN";
      function it(t3) {
        return t3.indexOf("mapbox:") === 0;
      }
      function st(t3) {
        return H2.API_URL_REGEX.test(t3);
      }
      const at = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function ot(t3) {
        const e2 = t3.match(at);
        if (!e2)
          throw new Error("Unable to parse URL object");
        return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
      }
      function lt(t3) {
        const e2 = t3.params.length ? `?${t3.params.join("&")}` : "";
        return `${t3.protocol}://${t3.authority}${t3.path}${e2}`;
      }
      function ut(t3) {
        if (!t3)
          return null;
        const r3 = t3.split(".");
        if (!r3 || r3.length !== 3)
          return null;
        try {
          return JSON.parse(decodeURIComponent(e.atob(r3[1]).split("").map((t4) => "%" + ("00" + t4.charCodeAt(0).toString(16)).slice(-2)).join("")));
        } catch (t4) {
          return null;
        }
      }
      class ct {
        constructor(t3) {
          this.type = t3, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t3) {
          const r3 = ut(H2.ACCESS_TOKEN);
          let n3 = "";
          return n3 = r3 && r3.u ? e.btoa(encodeURIComponent(r3.u).replace(/%([0-9A-F]{2})/g, (t4, e2) => String.fromCharCode(Number("0x" + e2)))) : H2.ACCESS_TOKEN || "", t3 ? `mapbox.eventData.${t3}:${n3}` : `mapbox.eventData:${n3}`;
        }
        fetchEventData() {
          const t3 = R2("localStorage"), r3 = this.getStorageKey(), n3 = this.getStorageKey("uuid");
          if (t3)
            try {
              const t4 = e.localStorage.getItem(r3);
              t4 && (this.eventData = JSON.parse(t4));
              const i2 = e.localStorage.getItem(n3);
              i2 && (this.anonId = i2);
            } catch (t4) {
              E2("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t3 = R2("localStorage"), r3 = this.getStorageKey(), n3 = this.getStorageKey("uuid");
          if (t3)
            try {
              e.localStorage.setItem(n3, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r3, JSON.stringify(this.eventData));
            } catch (t4) {
              E2("Unable to write to LocalStorage");
            }
        }
        processRequests(t3) {
        }
        postEvent(t3, e2, r3, n3) {
          if (!H2.EVENTS_URL)
            return;
          const i2 = ot(H2.EVENTS_URL);
          i2.params.push(`access_token=${n3 || H2.ACCESS_TOKEN || ""}`);
          const s2 = { event: this.type, created: new Date(t3).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: O2, skuId: rt, userId: this.anonId }, a2 = e2 ? v2(s2, e2) : s2, o2 = { url: lt(i2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([a2]) };
          this.pendingRequest = Pt(o2, (t4) => {
            this.pendingRequest = null, r3(t4), this.saveEventData(), this.processRequests(n3);
          });
        }
        queueRequest(t3, e2) {
          this.queue.push(t3), this.processRequests(e2);
        }
      }
      const ht = new class extends ct {
        constructor(t3) {
          super("appUserTurnstile"), this._customAccessToken = t3;
        }
        postTurnstileEvent(t3, e2) {
          H2.EVENTS_URL && H2.ACCESS_TOKEN && Array.isArray(t3) && t3.some((t4) => it(t4) || st(t4)) && this.queueRequest(Date.now(), e2);
        }
        processRequests(t3) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const e2 = ut(H2.ACCESS_TOKEN), r3 = e2 ? e2.u : H2.ACCESS_TOKEN;
          let n3 = r3 !== this.eventData.tokenU;
          S2(this.anonId) || (this.anonId = w(), n3 = true);
          const i2 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const t4 = new Date(this.eventData.lastSuccess), e3 = new Date(i2), r4 = (i2 - this.eventData.lastSuccess) / 864e5;
            n3 = n3 || r4 >= 1 || r4 < -1 || t4.getDate() !== e3.getDate();
          } else
            n3 = true;
          n3 ? this.postEvent(i2, { "enabled.telemetry": false }, (t4) => {
            t4 || (this.eventData.lastSuccess = i2, this.eventData.tokenU = r3);
          }, t3) : this.processRequests();
        }
      }(), pt = ht.postTurnstileEvent.bind(ht), ft = new class extends ct {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t3, e2, r3, n3) {
          this.skuToken = e2, this.errorCb = n3, H2.EVENTS_URL && (r3 || H2.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r3) : this.errorCb(new Error(nt)));
        }
        processRequests(t3) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: e2, timestamp: r3 } = this.queue.shift();
          e2 && this.success[e2] || (this.anonId || this.fetchEventData(), S2(this.anonId) || (this.anonId = w()), this.postEvent(r3, { skuToken: this.skuToken }, (t4) => {
            t4 ? this.errorCb(t4) : e2 && (this.success[e2] = true);
          }, t3));
        }
      }(), dt = ft.postMapLoadEvent.bind(ft), yt = new class extends ct {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t3, e2, r3, n3) {
          if (!H2.API_URL || !H2.SESSION_PATH)
            return;
          const i2 = ot(H2.API_URL + H2.SESSION_PATH);
          i2.params.push(`sku=${e2 || ""}`), i2.params.push(`access_token=${n3 || H2.ACCESS_TOKEN || ""}`);
          const s2 = { url: lt(i2), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = Dt(s2, (t4) => {
            this.pendingRequest = null, r3(t4), this.saveEventData(), this.processRequests(n3);
          });
        }
        getSessionAPI(t3, e2, r3, n3) {
          this.skuToken = e2, this.errorCb = n3, H2.SESSION_PATH && H2.API_URL && (r3 || H2.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r3) : this.errorCb(new Error(nt)));
        }
        processRequests(t3) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: e2, timestamp: r3 } = this.queue.shift();
          e2 && this.success[e2] || this.getSession(r3, this.skuToken, (t4) => {
            t4 ? this.errorCb(t4) : e2 && (this.success[e2] = true);
          }, t3);
        }
      }(), mt = yt.getSessionAPI.bind(yt), gt = new Set();
      let xt, vt = 500, bt = 50, _t = {};
      function wt(t3) {
        const e2 = kt(t3);
        let r3, n3;
        e2 && e2.forEach((t4) => {
          const e3 = t4.split("=");
          e3[0] === "language" ? r3 = e3[1] : e3[0] === "worldview" && (n3 = e3[1]);
        });
        let i2 = "mapbox-tiles";
        return r3 && (i2 += `-${r3}`), n3 && (i2 += `-${n3}`), i2;
      }
      function At() {
        try {
          return e.caches;
        } catch (t3) {
        }
      }
      function St(t3) {
        const e2 = At();
        e2 && !_t[t3] && (_t[t3] = e2.open(t3));
      }
      function kt(t3) {
        const e2 = t3.indexOf("?");
        return e2 > 0 ? t3.slice(e2 + 1).split("&") : [];
      }
      function It(t3) {
        const e2 = t3.indexOf("?");
        if (e2 < 0)
          return t3;
        const r3 = kt(t3).filter((t4) => {
          const e3 = t4.split("=");
          return e3[0] === "language" || e3[0] === "worldview";
        });
        return r3.length ? `${t3.slice(0, e2)}?${r3.join("&")}` : t3.slice(0, e2);
      }
      let Mt = 1 / 0;
      const zt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(zt);
      class Tt extends Error {
        constructor(t3, e2, r3) {
          e2 === 401 && st(r3) && (t3 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), super(t3), this.status = e2, this.url = r3;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const Bt = D2() ? () => self.worker && self.worker.referrer : () => (e.location.protocol === "blob:" ? e.parent : e).location.href;
      const Et = function(t3, r3) {
        if (!(/^file:/.test(n3 = t3.url) || /^file:/.test(Bt()) && !/^\w+:/.test(n3))) {
          if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
            return function(t4, r4) {
              const n4 = new e.AbortController(), i2 = new e.Request(t4.url, { method: t4.method || "GET", body: t4.body, credentials: t4.credentials, headers: t4.headers, referrer: Bt(), signal: n4.signal });
              let s2 = false, a2 = false;
              const o2 = (l3 = i2.url).indexOf("sku=") > 0 && st(l3);
              var l3;
              t4.type === "json" && i2.headers.set("Accept", "application/json");
              const u3 = (n5, s3, l4) => {
                if (a2)
                  return;
                if (n5 && n5.message !== "SecurityError" && E2(n5), s3 && l4)
                  return c2(s3);
                const u4 = Date.now();
                e.fetch(i2).then((e2) => {
                  if (e2.ok) {
                    const t5 = o2 ? e2.clone() : null;
                    return c2(e2, t5, u4);
                  }
                  return r4(new Tt(e2.statusText, e2.status, t4.url));
                }).catch((t5) => {
                  t5.code !== 20 && r4(new Error(t5.message));
                });
              }, c2 = (n5, o3, l4) => {
                (t4.type === "arrayBuffer" ? n5.arrayBuffer() : t4.type === "json" ? n5.json() : n5.text()).then((t5) => {
                  a2 || (o3 && l4 && function(t6, r5, n6) {
                    const i3 = wt(t6.url);
                    if (St(i3), !_t[i3])
                      return;
                    const s3 = { status: r5.status, statusText: r5.statusText, headers: new e.Headers() };
                    r5.headers.forEach((t7, e2) => s3.headers.set(e2, t7));
                    const a3 = V2(r5.headers.get("Cache-Control") || "");
                    if (a3["no-store"])
                      return;
                    a3["max-age"] && s3.headers.set("Expires", new Date(n6 + 1e3 * a3["max-age"]).toUTCString());
                    const o4 = s3.headers.get("Expires");
                    o4 && (new Date(o4).getTime() - n6 < 42e4 || function(t7, e2) {
                      if (xt === void 0)
                        try {
                          new Response(new ReadableStream()), xt = true;
                        } catch (t8) {
                          xt = false;
                        }
                      xt ? e2(t7.body) : t7.blob().then(e2);
                    }(r5, (r6) => {
                      const n7 = new e.Response(r6, s3);
                      St(i3), _t[i3] && _t[i3].then((e2) => e2.put(It(t6.url), n7)).catch((t7) => E2(t7.message));
                    }));
                  }(i2, o3, l4), s2 = true, r4(null, t5, n5.headers.get("Cache-Control"), n5.headers.get("Expires")));
                }).catch((t5) => {
                  a2 || r4(new Error(t5.message));
                });
              };
              return o2 ? function(t5, e2) {
                const r5 = wt(t5.url);
                if (St(r5), !_t[r5])
                  return e2(null);
                const n5 = It(t5.url);
                _t[r5].then((t6) => {
                  t6.match(n5).then((r6) => {
                    const i3 = function(t7) {
                      if (!t7)
                        return false;
                      const e3 = new Date(t7.headers.get("Expires") || 0), r7 = V2(t7.headers.get("Cache-Control") || "");
                      return e3 > Date.now() && !r7["no-cache"];
                    }(r6);
                    t6.delete(n5), i3 && t6.put(n5, r6.clone()), e2(null, r6, i3);
                  }).catch(e2);
                }).catch(e2);
              }(i2, u3) : u3(null, null), { cancel: () => {
                a2 = true, s2 || n4.abort();
              } };
            }(t3, r3);
          if (D2() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", t3, r3, void 0, true);
        }
        var n3;
        return function(t4, r4) {
          const n4 = new e.XMLHttpRequest();
          n4.open(t4.method || "GET", t4.url, true), t4.type === "arrayBuffer" && (n4.responseType = "arraybuffer");
          for (const e2 in t4.headers)
            n4.setRequestHeader(e2, t4.headers[e2]);
          return t4.type === "json" && (n4.responseType = "text", n4.setRequestHeader("Accept", "application/json")), n4.withCredentials = t4.credentials === "include", n4.onerror = () => {
            r4(new Error(n4.statusText));
          }, n4.onload = () => {
            if ((n4.status >= 200 && n4.status < 300 || n4.status === 0) && n4.response !== null) {
              let e2 = n4.response;
              if (t4.type === "json")
                try {
                  e2 = JSON.parse(n4.response);
                } catch (t5) {
                  return r4(t5);
                }
              r4(null, e2, n4.getResponseHeader("Cache-Control"), n4.getResponseHeader("Expires"));
            } else
              r4(new Tt(n4.statusText, n4.status, t4.url));
          }, n4.send(t4.body), { cancel: () => n4.abort() };
        }(t3, r3);
      }, Ct = function(t3, e2) {
        return Et(v2(t3, { type: "arrayBuffer" }), e2);
      }, Pt = function(t3, e2) {
        return Et(v2(t3, { method: "POST" }), e2);
      }, Dt = function(t3, e2) {
        return Et(v2(t3, { method: "GET" }), e2);
      };
      function Vt(t3) {
        const r3 = e.document.createElement("a");
        return r3.href = t3, r3.protocol === e.document.location.protocol && r3.host === e.document.location.host;
      }
      const Ft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let Lt, Rt;
      Lt = [], Rt = 0;
      const Ut = function(t3, r3) {
        if (Y2.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), Rt >= H2.MAX_PARALLEL_IMAGE_REQUESTS) {
          const e2 = { requestParameters: t3, callback: r3, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return Lt.push(e2), e2;
        }
        Rt++;
        let n3 = false;
        const i2 = () => {
          if (!n3)
            for (n3 = true, Rt--; Lt.length && Rt < H2.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t4 = Lt.shift(), { requestParameters: e2, callback: r4, cancelled: n4 } = t4;
              n4 || (t4.cancel = Ut(e2, r4).cancel);
            }
        }, s2 = Ct(t3, (t4, n4, s3, a2) => {
          i2(), t4 ? r3(t4) : n4 && (e.createImageBitmap ? function(t5, r4) {
            const n5 = new e.Blob([new Uint8Array(t5)], { type: "image/png" });
            e.createImageBitmap(n5).then((t6) => {
              r4(null, t6);
            }).catch((t6) => {
              r4(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(n4, (t5, e2) => r3(t5, e2, s3, a2)) : function(t5, r4) {
            const n5 = new e.Image(), i3 = e.URL;
            n5.onload = () => {
              r4(null, n5), i3.revokeObjectURL(n5.src), n5.onload = null, e.requestAnimationFrame(() => {
                n5.src = Ft;
              });
            }, n5.onerror = () => r4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const s4 = new e.Blob([new Uint8Array(t5)], { type: "image/png" });
            n5.src = t5.byteLength ? i3.createObjectURL(s4) : Ft;
          }(n4, (t5, e2) => r3(t5, e2, s3, a2)));
        });
        return { cancel: () => {
          s2.cancel(), i2();
        } };
      };
      function jt(t3, e2, r3) {
        r3[t3] && r3[t3].indexOf(e2) !== -1 || (r3[t3] = r3[t3] || [], r3[t3].push(e2));
      }
      function $t(t3, e2, r3) {
        if (r3 && r3[t3]) {
          const n3 = r3[t3].indexOf(e2);
          n3 !== -1 && r3[t3].splice(n3, 1);
        }
      }
      class Ot {
        constructor(t3, e2 = {}) {
          v2(this, e2), this.type = t3;
        }
      }
      class qt extends Ot {
        constructor(t3, e2 = {}) {
          super("error", v2({ error: t3 }, e2));
        }
      }
      class Nt {
        on(t3, e2) {
          return this._listeners = this._listeners || {}, jt(t3, e2, this._listeners), this;
        }
        off(t3, e2) {
          return $t(t3, e2, this._listeners), $t(t3, e2, this._oneTimeListeners), this;
        }
        once(t3, e2) {
          return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, jt(t3, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t3, e3));
        }
        fire(t3, e2) {
          typeof t3 == "string" && (t3 = new Ot(t3, e2 || {}));
          const r3 = t3.type;
          if (this.listens(r3)) {
            t3.target = this;
            const e3 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
            for (const r4 of e3)
              r4.call(this, t3);
            const n3 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
            for (const e4 of n3)
              $t(r3, e4, this._oneTimeListeners), e4.call(this, t3);
            const i2 = this._eventedParent;
            i2 && (v2(t3, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t3));
          } else
            t3 instanceof qt && console.error(t3.error);
          return this;
        }
        listens(t3) {
          return !!(this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3));
        }
        setEventedParent(t3, e2) {
          return this._eventedParent = t3, this._eventedParentData = e2, this;
        }
      }
      var Gt = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"cross-faded"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"cross-faded":{"type":"property-type"},"cross-faded-data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      function Zt(t3, ...e2) {
        for (const r3 of e2)
          for (const e3 in r3)
            t3[e3] = r3[e3];
        return t3;
      }
      function Xt(t3) {
        return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
      }
      function Kt(t3) {
        if (Array.isArray(t3))
          return t3.map(Kt);
        if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
          const e2 = {};
          for (const r3 in t3)
            e2[r3] = Kt(t3[r3]);
          return e2;
        }
        return Xt(t3);
      }
      class Ht extends Error {
        constructor(t3, e2) {
          super(e2), this.message = e2, this.key = t3;
        }
      }
      var Yt = Ht;
      class Wt {
        constructor(t3, e2 = []) {
          this.parent = t3, this.bindings = {};
          for (const [t4, r3] of e2)
            this.bindings[t4] = r3;
        }
        concat(t3) {
          return new Wt(this, t3);
        }
        get(t3) {
          if (this.bindings[t3])
            return this.bindings[t3];
          if (this.parent)
            return this.parent.get(t3);
          throw new Error(`${t3} not found in scope.`);
        }
        has(t3) {
          return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
        }
      }
      var Jt = Wt;
      const Qt = { kind: "null" }, te2 = { kind: "number" }, ee2 = { kind: "string" }, re2 = { kind: "boolean" }, ne2 = { kind: "color" }, ie2 = { kind: "object" }, se2 = { kind: "value" }, ae2 = { kind: "collator" }, oe2 = { kind: "formatted" }, le2 = { kind: "resolvedImage" };
      function ue2(t3, e2) {
        return { kind: "array", itemType: t3, N: e2 };
      }
      function ce2(t3) {
        if (t3.kind === "array") {
          const e2 = ce2(t3.itemType);
          return typeof t3.N == "number" ? `array<${e2}, ${t3.N}>` : t3.itemType.kind === "value" ? "array" : `array<${e2}>`;
        }
        return t3.kind;
      }
      const he2 = [Qt, te2, ee2, re2, ne2, oe2, ie2, ue2(se2), le2];
      function pe2(t3, e2) {
        if (e2.kind === "error")
          return null;
        if (t3.kind === "array") {
          if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !pe2(t3.itemType, e2.itemType)) && (typeof t3.N != "number" || t3.N === e2.N))
            return null;
        } else {
          if (t3.kind === e2.kind)
            return null;
          if (t3.kind === "value") {
            for (const t4 of he2)
              if (!pe2(t4, e2))
                return null;
          }
        }
        return `Expected ${ce2(t3)} but found ${ce2(e2)} instead.`;
      }
      function fe2(t3, e2) {
        return e2.some((e3) => e3.kind === t3.kind);
      }
      function de2(t3, e2) {
        return e2.some((e3) => e3 === "null" ? t3 === null : e3 === "array" ? Array.isArray(t3) : e3 === "object" ? t3 && !Array.isArray(t3) && typeof t3 == "object" : e3 === typeof t3);
      }
      function ye(t3) {
        var e2 = { exports: {} };
        return t3(e2, e2.exports), e2.exports;
      }
      var me2 = ye(function(t3, e2) {
        var r3 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function n3(t4) {
          return (t4 = Math.round(t4)) < 0 ? 0 : t4 > 255 ? 255 : t4;
        }
        function i2(t4) {
          return n3(t4[t4.length - 1] === "%" ? parseFloat(t4) / 100 * 255 : parseInt(t4));
        }
        function s2(t4) {
          return (e3 = t4[t4.length - 1] === "%" ? parseFloat(t4) / 100 : parseFloat(t4)) < 0 ? 0 : e3 > 1 ? 1 : e3;
          var e3;
        }
        function a2(t4, e3, r4) {
          return r4 < 0 ? r4 += 1 : r4 > 1 && (r4 -= 1), 6 * r4 < 1 ? t4 + (e3 - t4) * r4 * 6 : 2 * r4 < 1 ? e3 : 3 * r4 < 2 ? t4 + (e3 - t4) * (2 / 3 - r4) * 6 : t4;
        }
        try {
          e2.parseCSSColor = function(t4) {
            var e3, o2 = t4.replace(/ /g, "").toLowerCase();
            if (o2 in r3)
              return r3[o2].slice();
            if (o2[0] === "#")
              return o2.length === 4 ? (e3 = parseInt(o2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : o2.length === 7 && (e3 = parseInt(o2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
            var l3 = o2.indexOf("("), u3 = o2.indexOf(")");
            if (l3 !== -1 && u3 + 1 === o2.length) {
              var c2 = o2.substr(0, l3), h3 = o2.substr(l3 + 1, u3 - (l3 + 1)).split(","), p3 = 1;
              switch (c2) {
                case "rgba":
                  if (h3.length !== 4)
                    return null;
                  p3 = s2(h3.pop());
                case "rgb":
                  return h3.length !== 3 ? null : [i2(h3[0]), i2(h3[1]), i2(h3[2]), p3];
                case "hsla":
                  if (h3.length !== 4)
                    return null;
                  p3 = s2(h3.pop());
                case "hsl":
                  if (h3.length !== 3)
                    return null;
                  var f2 = (parseFloat(h3[0]) % 360 + 360) % 360 / 360, d2 = s2(h3[1]), y3 = s2(h3[2]), m3 = y3 <= 0.5 ? y3 * (d2 + 1) : y3 + d2 - y3 * d2, g2 = 2 * y3 - m3;
                  return [n3(255 * a2(g2, m3, f2 + 1 / 3)), n3(255 * a2(g2, m3, f2)), n3(255 * a2(g2, m3, f2 - 1 / 3)), p3];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t4) {
        }
      });
      class ge2 {
        constructor(t3, e2, r3, n3 = 1) {
          this.r = t3, this.g = e2, this.b = r3, this.a = n3;
        }
        static parse(t3) {
          if (!t3)
            return;
          if (t3 instanceof ge2)
            return t3;
          if (typeof t3 != "string")
            return;
          const e2 = me2.parseCSSColor(t3);
          return e2 ? new ge2(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
        }
        toString() {
          const [t3, e2, r3, n3] = this.toArray();
          return `rgba(${Math.round(t3)},${Math.round(e2)},${Math.round(r3)},${n3})`;
        }
        toArray() {
          const { r: t3, g: e2, b: r3, a: n3 } = this;
          return n3 === 0 ? [0, 0, 0, 0] : [255 * t3 / n3, 255 * e2 / n3, 255 * r3 / n3, n3];
        }
        toArray01() {
          const { r: t3, g: e2, b: r3, a: n3 } = this;
          return n3 === 0 ? [0, 0, 0, 0] : [t3 / n3, e2 / n3, r3 / n3, n3];
        }
        toArray01PremultipliedAlpha() {
          const { r: t3, g: e2, b: r3, a: n3 } = this;
          return [t3, e2, r3, n3];
        }
      }
      ge2.black = new ge2(0, 0, 0, 1), ge2.white = new ge2(1, 1, 1, 1), ge2.transparent = new ge2(0, 0, 0, 0), ge2.red = new ge2(1, 0, 0, 1), ge2.blue = new ge2(0, 0, 1, 1);
      var xe = ge2;
      class ve2 {
        constructor(t3, e2, r3) {
          this.sensitivity = t3 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t3, e2) {
          return this.collator.compare(t3, e2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class be2 {
        constructor(t3, e2, r3, n3, i2) {
          this.text = t3.normalize ? t3.normalize() : t3, this.image = e2, this.scale = r3, this.fontStack = n3, this.textColor = i2;
        }
      }
      class _e {
        constructor(t3) {
          this.sections = t3;
        }
        static fromString(t3) {
          return new _e([new be2(t3, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t3) => t3.text.length !== 0 || t3.image && t3.image.name.length !== 0);
        }
        static factory(t3) {
          return t3 instanceof _e ? t3 : _e.fromString(t3);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t3) => t3.text).join("");
        }
        serialize() {
          const t3 = ["format"];
          for (const e2 of this.sections) {
            if (e2.image) {
              t3.push(["image", e2.image.name]);
              continue;
            }
            t3.push(e2.text);
            const r3 = {};
            e2.fontStack && (r3["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r3["font-scale"] = e2.scale), e2.textColor && (r3["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t3.push(r3);
          }
          return t3;
        }
      }
      class we2 {
        constructor(t3) {
          this.name = t3.name, this.available = t3.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t3) {
          return t3 ? new we2({ name: t3, available: false }) : null;
        }
        serialize() {
          return ["image", this.name];
        }
      }
      function Ae2(t3, e2, r3, n3) {
        return typeof t3 == "number" && t3 >= 0 && t3 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r3 == "number" && r3 >= 0 && r3 <= 255 ? n3 === void 0 || typeof n3 == "number" && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t3, e2, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n3 == "number" ? [t3, e2, r3, n3] : [t3, e2, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Se2(t3) {
        if (t3 === null)
          return true;
        if (typeof t3 == "string")
          return true;
        if (typeof t3 == "boolean")
          return true;
        if (typeof t3 == "number")
          return true;
        if (t3 instanceof xe)
          return true;
        if (t3 instanceof ve2)
          return true;
        if (t3 instanceof _e)
          return true;
        if (t3 instanceof we2)
          return true;
        if (Array.isArray(t3)) {
          for (const e2 of t3)
            if (!Se2(e2))
              return false;
          return true;
        }
        if (typeof t3 == "object") {
          for (const e2 in t3)
            if (!Se2(t3[e2]))
              return false;
          return true;
        }
        return false;
      }
      function ke2(t3) {
        if (t3 === null)
          return Qt;
        if (typeof t3 == "string")
          return ee2;
        if (typeof t3 == "boolean")
          return re2;
        if (typeof t3 == "number")
          return te2;
        if (t3 instanceof xe)
          return ne2;
        if (t3 instanceof ve2)
          return ae2;
        if (t3 instanceof _e)
          return oe2;
        if (t3 instanceof we2)
          return le2;
        if (Array.isArray(t3)) {
          const e2 = t3.length;
          let r3;
          for (const e3 of t3) {
            const t4 = ke2(e3);
            if (r3) {
              if (r3 === t4)
                continue;
              r3 = se2;
              break;
            }
            r3 = t4;
          }
          return ue2(r3 || se2, e2);
        }
        return ie2;
      }
      function Ie2(t3) {
        const e2 = typeof t3;
        return t3 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t3) : t3 instanceof xe || t3 instanceof _e || t3 instanceof we2 ? t3.toString() : JSON.stringify(t3);
      }
      class Me2 {
        constructor(t3, e2) {
          this.type = t3, this.value = e2;
        }
        static parse(t3, e2) {
          if (t3.length !== 2)
            return e2.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
          if (!Se2(t3[1]))
            return e2.error("invalid value");
          const r3 = t3[1];
          let n3 = ke2(r3);
          const i2 = e2.expectedType;
          return n3.kind !== "array" || n3.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n3 = i2), new Me2(n3, r3);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof xe ? ["rgba"].concat(this.value.toArray()) : this.value instanceof _e ? this.value.serialize() : this.value;
        }
      }
      var ze = Me2, Te2 = class {
        constructor(t3) {
          this.name = "ExpressionEvaluationError", this.message = t3;
        }
        toJSON() {
          return this.message;
        }
      };
      const Be2 = { string: ee2, number: te2, boolean: re2, object: ie2 };
      class Ee2 {
        constructor(t3, e2) {
          this.type = t3, this.args = e2;
        }
        static parse(t3, e2) {
          if (t3.length < 2)
            return e2.error("Expected at least one argument.");
          let r3, n3 = 1;
          const i2 = t3[0];
          if (i2 === "array") {
            let i3, s3;
            if (t3.length > 2) {
              const r4 = t3[1];
              if (typeof r4 != "string" || !(r4 in Be2) || r4 === "object")
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = Be2[r4], n3++;
            } else
              i3 = se2;
            if (t3.length > 3) {
              if (t3[2] !== null && (typeof t3[2] != "number" || t3[2] < 0 || t3[2] !== Math.floor(t3[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t3[2], n3++;
            }
            r3 = ue2(i3, s3);
          } else
            r3 = Be2[i2];
          const s2 = [];
          for (; n3 < t3.length; n3++) {
            const r4 = e2.parse(t3[n3], n3, se2);
            if (!r4)
              return null;
            s2.push(r4);
          }
          return new Ee2(r3, s2);
        }
        evaluate(t3) {
          for (let e2 = 0; e2 < this.args.length; e2++) {
            const r3 = this.args[e2].evaluate(t3);
            if (!pe2(this.type, ke2(r3)))
              return r3;
            if (e2 === this.args.length - 1)
              throw new Te2(`Expected value to be of type ${ce2(this.type)}, but found ${ce2(ke2(r3))} instead.`);
          }
          return null;
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return this.args.every((t3) => t3.outputDefined());
        }
        serialize() {
          const t3 = this.type, e2 = [t3.kind];
          if (t3.kind === "array") {
            const r3 = t3.itemType;
            if (r3.kind === "string" || r3.kind === "number" || r3.kind === "boolean") {
              e2.push(r3.kind);
              const n3 = t3.N;
              (typeof n3 == "number" || this.args.length > 1) && e2.push(n3);
            }
          }
          return e2.concat(this.args.map((t4) => t4.serialize()));
        }
      }
      var Ce2 = Ee2;
      class Pe2 {
        constructor(t3) {
          this.type = oe2, this.sections = t3;
        }
        static parse(t3, e2) {
          if (t3.length < 2)
            return e2.error("Expected at least one argument.");
          const r3 = t3[1];
          if (!Array.isArray(r3) && typeof r3 == "object")
            return e2.error("First argument must be an image or text section.");
          const n3 = [];
          let i2 = false;
          for (let r4 = 1; r4 <= t3.length - 1; ++r4) {
            const s2 = t3[r4];
            if (i2 && typeof s2 == "object" && !Array.isArray(s2)) {
              i2 = false;
              let t4 = null;
              if (s2["font-scale"] && (t4 = e2.parse(s2["font-scale"], 1, te2), !t4))
                return null;
              let r5 = null;
              if (s2["text-font"] && (r5 = e2.parse(s2["text-font"], 1, ue2(ee2)), !r5))
                return null;
              let a2 = null;
              if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, ne2), !a2))
                return null;
              const o2 = n3[n3.length - 1];
              o2.scale = t4, o2.font = r5, o2.textColor = a2;
            } else {
              const s3 = e2.parse(t3[r4], 1, se2);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n3.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new Pe2(n3);
        }
        evaluate(t3) {
          return new _e(this.sections.map((e2) => {
            const r3 = e2.content.evaluate(t3);
            return ke2(r3) === le2 ? new be2("", r3, null, null, null) : new be2(Ie2(r3), null, e2.scale ? e2.scale.evaluate(t3) : null, e2.font ? e2.font.evaluate(t3).join(",") : null, e2.textColor ? e2.textColor.evaluate(t3) : null);
          }));
        }
        eachChild(t3) {
          for (const e2 of this.sections)
            t3(e2.content), e2.scale && t3(e2.scale), e2.font && t3(e2.font), e2.textColor && t3(e2.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t3 = ["format"];
          for (const e2 of this.sections) {
            t3.push(e2.content.serialize());
            const r3 = {};
            e2.scale && (r3["font-scale"] = e2.scale.serialize()), e2.font && (r3["text-font"] = e2.font.serialize()), e2.textColor && (r3["text-color"] = e2.textColor.serialize()), t3.push(r3);
          }
          return t3;
        }
      }
      class De2 {
        constructor(t3) {
          this.type = le2, this.input = t3;
        }
        static parse(t3, e2) {
          if (t3.length !== 2)
            return e2.error("Expected two arguments.");
          const r3 = e2.parse(t3[1], 1, ee2);
          return r3 ? new De2(r3) : e2.error("No image name provided.");
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3), r3 = we2.fromString(e2);
          return r3 && t3.availableImages && (r3.available = t3.availableImages.indexOf(e2) > -1), r3;
        }
        eachChild(t3) {
          t3(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["image", this.input.serialize()];
        }
      }
      const Ve = { "to-boolean": re2, "to-color": ne2, "to-number": te2, "to-string": ee2 };
      class Fe2 {
        constructor(t3, e2) {
          this.type = t3, this.args = e2;
        }
        static parse(t3, e2) {
          if (t3.length < 2)
            return e2.error("Expected at least one argument.");
          const r3 = t3[0];
          if ((r3 === "to-boolean" || r3 === "to-string") && t3.length !== 2)
            return e2.error("Expected one argument.");
          const n3 = Ve[r3], i2 = [];
          for (let r4 = 1; r4 < t3.length; r4++) {
            const n4 = e2.parse(t3[r4], r4, se2);
            if (!n4)
              return null;
            i2.push(n4);
          }
          return new Fe2(n3, i2);
        }
        evaluate(t3) {
          if (this.type.kind === "boolean")
            return Boolean(this.args[0].evaluate(t3));
          if (this.type.kind === "color") {
            let e2, r3;
            for (const n3 of this.args) {
              if (e2 = n3.evaluate(t3), r3 = null, e2 instanceof xe)
                return e2;
              if (typeof e2 == "string") {
                const r4 = t3.parseColor(e2);
                if (r4)
                  return r4;
              } else if (Array.isArray(e2) && (r3 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Ae2(e2[0], e2[1], e2[2], e2[3]), !r3))
                return new xe(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
            }
            throw new Te2(r3 || `Could not parse color from value '${typeof e2 == "string" ? e2 : String(JSON.stringify(e2))}'`);
          }
          if (this.type.kind === "number") {
            let e2 = null;
            for (const r3 of this.args) {
              if (e2 = r3.evaluate(t3), e2 === null)
                return 0;
              const n3 = Number(e2);
              if (!isNaN(n3))
                return n3;
            }
            throw new Te2(`Could not convert ${JSON.stringify(e2)} to number.`);
          }
          return this.type.kind === "formatted" ? _e.fromString(Ie2(this.args[0].evaluate(t3))) : this.type.kind === "resolvedImage" ? we2.fromString(Ie2(this.args[0].evaluate(t3))) : Ie2(this.args[0].evaluate(t3));
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return this.args.every((t3) => t3.outputDefined());
        }
        serialize() {
          if (this.type.kind === "formatted")
            return new Pe2([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if (this.type.kind === "resolvedImage")
            return new De2(this.args[0]).serialize();
          const t3 = [`to-${this.type.kind}`];
          return this.eachChild((e2) => {
            t3.push(e2.serialize());
          }), t3;
        }
      }
      var Le2 = Fe2;
      const Re2 = ["Unknown", "Point", "LineString", "Polygon"];
      var Ue2 = class {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
        }
        id() {
          return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Re2[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const t3 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r3, y: n3 } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (r3 * e2 - t3[0]) + this.featureDistanceData.bearing[1] * (n3 * e2 - t3[1]);
          }
          return 0;
        }
        parseColor(t3) {
          let e2 = this._parseColorCache[t3];
          return e2 || (e2 = this._parseColorCache[t3] = xe.parse(t3)), e2;
        }
      };
      class je2 {
        constructor(t3, e2, r3, n3) {
          this.name = t3, this.type = e2, this._evaluate = r3, this.args = n3;
        }
        evaluate(t3) {
          return this._evaluate(t3, this.args);
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((t3) => t3.serialize()));
        }
        static parse(t3, e2) {
          const r3 = t3[0], n3 = je2.definitions[r3];
          if (!n3)
            return e2.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i2 = Array.isArray(n3) ? n3[0] : n3.type, s2 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t3.length - 1);
          let o2 = null;
          for (const [n4, s3] of a2) {
            o2 = new fr(e2.registry, e2.path, null, e2.scope);
            const a3 = [];
            let l3 = false;
            for (let e3 = 1; e3 < t3.length; e3++) {
              const r4 = t3[e3], i3 = Array.isArray(n4) ? n4[e3 - 1] : n4.type, s4 = o2.parse(r4, 1 + a3.length, i3);
              if (!s4) {
                l3 = true;
                break;
              }
              a3.push(s4);
            }
            if (!l3)
              if (Array.isArray(n4) && n4.length !== a3.length)
                o2.error(`Expected ${n4.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t4 = 0; t4 < a3.length; t4++) {
                  const e3 = Array.isArray(n4) ? n4[t4] : n4.type, r4 = a3[t4];
                  o2.concat(t4 + 1).checkSubtype(e3, r4.type);
                }
                if (o2.errors.length === 0)
                  return new je2(r3, i2, s3, a3);
              }
          }
          if (a2.length === 1)
            e2.errors.push(...o2.errors);
          else {
            const r4 = (a2.length ? a2 : s2).map(([t4]) => {
              return e3 = t4, Array.isArray(e3) ? `(${e3.map(ce2).join(", ")})` : `(${ce2(e3.type)}...)`;
              var e3;
            }).join(" | "), n4 = [];
            for (let r5 = 1; r5 < t3.length; r5++) {
              const i3 = e2.parse(t3[r5], 1 + n4.length);
              if (!i3)
                return null;
              n4.push(ce2(i3.type));
            }
            e2.error(`Expected arguments of type ${r4}, but found (${n4.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t3, e2) {
          je2.definitions = e2;
          for (const r3 in e2)
            t3[r3] = je2;
        }
      }
      var $e2 = je2;
      class Oe2 {
        constructor(t3, e2, r3) {
          this.type = ae2, this.locale = r3, this.caseSensitive = t3, this.diacriticSensitive = e2;
        }
        static parse(t3, e2) {
          if (t3.length !== 2)
            return e2.error("Expected one argument.");
          const r3 = t3[1];
          if (typeof r3 != "object" || Array.isArray(r3))
            return e2.error("Collator options argument must be an object.");
          const n3 = e2.parse(r3["case-sensitive"] !== void 0 && r3["case-sensitive"], 1, re2);
          if (!n3)
            return null;
          const i2 = e2.parse(r3["diacritic-sensitive"] !== void 0 && r3["diacritic-sensitive"], 1, re2);
          if (!i2)
            return null;
          let s2 = null;
          return r3.locale && (s2 = e2.parse(r3.locale, 1, ee2), !s2) ? null : new Oe2(n3, i2, s2);
        }
        evaluate(t3) {
          return new ve2(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
        }
        eachChild(t3) {
          t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t3 = {};
          return t3["case-sensitive"] = this.caseSensitive.serialize(), t3["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t3.locale = this.locale.serialize()), ["collator", t3];
        }
      }
      const qe2 = 8192;
      function Ne2(t3, e2) {
        t3[0] = Math.min(t3[0], e2[0]), t3[1] = Math.min(t3[1], e2[1]), t3[2] = Math.max(t3[2], e2[0]), t3[3] = Math.max(t3[3], e2[1]);
      }
      function Ge2(t3, e2) {
        return !(t3[0] <= e2[0] || t3[2] >= e2[2] || t3[1] <= e2[1] || t3[3] >= e2[3]);
      }
      function Ze2(t3, e2) {
        const r3 = (180 + t3[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
        return [Math.round(r3 * i2 * qe2), Math.round(n3 * i2 * qe2)];
      }
      function Xe2(t3, e2, r3) {
        const n3 = t3[0] - e2[0], i2 = t3[1] - e2[1], s2 = t3[0] - r3[0], a2 = t3[1] - r3[1];
        return n3 * a2 - s2 * i2 == 0 && n3 * s2 <= 0 && i2 * a2 <= 0;
      }
      function Ke2(t3, e2) {
        let r3 = false;
        for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
          const o3 = e2[a2];
          for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
            if (Xe2(t3, o3[e3], o3[e3 + 1]))
              return false;
            (i2 = o3[e3])[1] > (n3 = t3)[1] != (s2 = o3[e3 + 1])[1] > n3[1] && n3[0] < (s2[0] - i2[0]) * (n3[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r3 = !r3);
          }
        }
        var n3, i2, s2;
        return r3;
      }
      function He2(t3, e2) {
        for (let r3 = 0; r3 < e2.length; r3++)
          if (Ke2(t3, e2[r3]))
            return true;
        return false;
      }
      function Ye2(t3, e2, r3, n3) {
        const i2 = n3[0] - r3[0], s2 = n3[1] - r3[1], a2 = (t3[0] - r3[0]) * s2 - i2 * (t3[1] - r3[1]), o2 = (e2[0] - r3[0]) * s2 - i2 * (e2[1] - r3[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function We(t3, e2, r3) {
        for (const u3 of r3)
          for (let r4 = 0; r4 < u3.length - 1; ++r4)
            if ((o2 = [(a2 = u3[r4 + 1])[0] - (s2 = u3[r4])[0], a2[1] - s2[1]])[0] * (l3 = [(i2 = e2)[0] - (n3 = t3)[0], i2[1] - n3[1]])[1] - o2[1] * l3[0] != 0 && Ye2(n3, i2, s2, a2) && Ye2(s2, a2, n3, i2))
              return true;
        var n3, i2, s2, a2, o2, l3;
        return false;
      }
      function Je2(t3, e2) {
        for (let r3 = 0; r3 < t3.length; ++r3)
          if (!Ke2(t3[r3], e2))
            return false;
        for (let r3 = 0; r3 < t3.length - 1; ++r3)
          if (We(t3[r3], t3[r3 + 1], e2))
            return false;
        return true;
      }
      function Qe2(t3, e2) {
        for (let r3 = 0; r3 < e2.length; r3++)
          if (Je2(t3, e2[r3]))
            return true;
        return false;
      }
      function tr(t3, e2, r3) {
        const n3 = [];
        for (let i2 = 0; i2 < t3.length; i2++) {
          const s2 = [];
          for (let n4 = 0; n4 < t3[i2].length; n4++) {
            const a2 = Ze2(t3[i2][n4], r3);
            Ne2(e2, a2), s2.push(a2);
          }
          n3.push(s2);
        }
        return n3;
      }
      function er(t3, e2, r3) {
        const n3 = [];
        for (let i2 = 0; i2 < t3.length; i2++) {
          const s2 = tr(t3[i2], e2, r3);
          n3.push(s2);
        }
        return n3;
      }
      function rr(t3, e2, r3, n3) {
        if (t3[0] < r3[0] || t3[0] > r3[2]) {
          const e3 = 0.5 * n3;
          let i2 = t3[0] - r3[0] > e3 ? -n3 : r3[0] - t3[0] > e3 ? n3 : 0;
          i2 === 0 && (i2 = t3[0] - r3[2] > e3 ? -n3 : r3[2] - t3[0] > e3 ? n3 : 0), t3[0] += i2;
        }
        Ne2(e2, t3);
      }
      function nr(t3, e2, r3, n3) {
        const i2 = Math.pow(2, n3.z) * qe2, s2 = [n3.x * qe2, n3.y * qe2], a2 = [];
        if (!t3)
          return a2;
        for (const n4 of t3)
          for (const t4 of n4) {
            const n5 = [t4.x + s2[0], t4.y + s2[1]];
            rr(n5, e2, r3, i2), a2.push(n5);
          }
        return a2;
      }
      function ir(t3, e2, r3, n3) {
        const i2 = Math.pow(2, n3.z) * qe2, s2 = [n3.x * qe2, n3.y * qe2], a2 = [];
        if (!t3)
          return a2;
        for (const r4 of t3) {
          const t4 = [];
          for (const n4 of r4) {
            const r5 = [n4.x + s2[0], n4.y + s2[1]];
            Ne2(e2, r5), t4.push(r5);
          }
          a2.push(t4);
        }
        if (e2[2] - e2[0] <= i2 / 2) {
          (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t4 of a2)
            for (const n4 of t4)
              rr(n4, e2, r3, i2);
        }
        var o2;
        return a2;
      }
      class sr {
        constructor(t3, e2) {
          this.type = re2, this.geojson = t3, this.geometries = e2;
        }
        static parse(t3, e2) {
          if (t3.length !== 2)
            return e2.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
          if (Se2(t3[1])) {
            const e3 = t3[1];
            if (e3.type === "FeatureCollection")
              for (let t4 = 0; t4 < e3.features.length; ++t4) {
                const r3 = e3.features[t4].geometry.type;
                if (r3 === "Polygon" || r3 === "MultiPolygon")
                  return new sr(e3, e3.features[t4].geometry);
              }
            else if (e3.type === "Feature") {
              const t4 = e3.geometry.type;
              if (t4 === "Polygon" || t4 === "MultiPolygon")
                return new sr(e3, e3.geometry);
            } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
              return new sr(e3, e3);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t3) {
          if (t3.geometry() != null && t3.canonicalID() != null) {
            if (t3.geometryType() === "Point")
              return function(t4, e2) {
                const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t4.canonicalID();
                if (!i2)
                  return false;
                if (e2.type === "Polygon") {
                  const s2 = tr(e2.coordinates, n3, i2), a2 = nr(t4.geometry(), r3, n3, i2);
                  if (!Ge2(r3, n3))
                    return false;
                  for (const t5 of a2)
                    if (!Ke2(t5, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = er(e2.coordinates, n3, i2), a2 = nr(t4.geometry(), r3, n3, i2);
                  if (!Ge2(r3, n3))
                    return false;
                  for (const t5 of a2)
                    if (!He2(t5, s2))
                      return false;
                }
                return true;
              }(t3, this.geometries);
            if (t3.geometryType() === "LineString")
              return function(t4, e2) {
                const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t4.canonicalID();
                if (!i2)
                  return false;
                if (e2.type === "Polygon") {
                  const s2 = tr(e2.coordinates, n3, i2), a2 = ir(t4.geometry(), r3, n3, i2);
                  if (!Ge2(r3, n3))
                    return false;
                  for (const t5 of a2)
                    if (!Je2(t5, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = er(e2.coordinates, n3, i2), a2 = ir(t4.geometry(), r3, n3, i2);
                  if (!Ge2(r3, n3))
                    return false;
                  for (const t5 of a2)
                    if (!Qe2(t5, s2))
                      return false;
                }
                return true;
              }(t3, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      var ar = sr;
      function or(t3) {
        if (t3 instanceof $e2) {
          if (t3.name === "get" && t3.args.length === 1)
            return false;
          if (t3.name === "feature-state")
            return false;
          if (t3.name === "has" && t3.args.length === 1)
            return false;
          if (t3.name === "properties" || t3.name === "geometry-type" || t3.name === "id")
            return false;
          if (/^filter-/.test(t3.name))
            return false;
        }
        if (t3 instanceof ar)
          return false;
        let e2 = true;
        return t3.eachChild((t4) => {
          e2 && !or(t4) && (e2 = false);
        }), e2;
      }
      function lr(t3) {
        if (t3 instanceof $e2 && t3.name === "feature-state")
          return false;
        let e2 = true;
        return t3.eachChild((t4) => {
          e2 && !lr(t4) && (e2 = false);
        }), e2;
      }
      function ur(t3, e2) {
        if (t3 instanceof $e2 && e2.indexOf(t3.name) >= 0)
          return false;
        let r3 = true;
        return t3.eachChild((t4) => {
          r3 && !ur(t4, e2) && (r3 = false);
        }), r3;
      }
      class cr {
        constructor(t3, e2) {
          this.type = e2.type, this.name = t3, this.boundExpression = e2;
        }
        static parse(t3, e2) {
          if (t3.length !== 2 || typeof t3[1] != "string")
            return e2.error("'var' expression requires exactly one string literal argument.");
          const r3 = t3[1];
          return e2.scope.has(r3) ? new cr(r3, e2.scope.get(r3)) : e2.error(`Unknown variable "${r3}". Make sure "${r3}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t3) {
          return this.boundExpression.evaluate(t3);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      var hr = cr;
      class pr {
        constructor(t3, e2 = [], r3, n3 = new Jt(), i2 = []) {
          this.registry = t3, this.path = e2, this.key = e2.map((t4) => `[${t4}]`).join(""), this.scope = n3, this.errors = i2, this.expectedType = r3;
        }
        parse(t3, e2, r3, n3, i2 = {}) {
          return e2 ? this.concat(e2, r3, n3)._parse(t3, i2) : this._parse(t3, i2);
        }
        _parse(t3, e2) {
          function r3(t4, e3, r4) {
            return r4 === "assert" ? new Ce2(e3, [t4]) : r4 === "coerce" ? new Le2(e3, [t4]) : t4;
          }
          if (t3 !== null && typeof t3 != "string" && typeof t3 != "boolean" && typeof t3 != "number" || (t3 = ["literal", t3]), Array.isArray(t3)) {
            if (t3.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n3 = t3[0];
            if (typeof n3 != "string")
              return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const i2 = this.registry[n3];
            if (i2) {
              let n4 = i2.parse(t3, this);
              if (!n4)
                return null;
              if (this.expectedType) {
                const t4 = this.expectedType, i3 = n4.type;
                if (t4.kind !== "string" && t4.kind !== "number" && t4.kind !== "boolean" && t4.kind !== "object" && t4.kind !== "array" || i3.kind !== "value")
                  if (t4.kind !== "color" && t4.kind !== "formatted" && t4.kind !== "resolvedImage" || i3.kind !== "value" && i3.kind !== "string") {
                    if (this.checkSubtype(t4, i3))
                      return null;
                  } else
                    n4 = r3(n4, t4, e2.typeAnnotation || "coerce");
                else
                  n4 = r3(n4, t4, e2.typeAnnotation || "assert");
              }
              if (!(n4 instanceof ze) && n4.type.kind !== "resolvedImage" && dr(n4)) {
                const t4 = new Ue2();
                try {
                  n4 = new ze(n4.type, n4.evaluate(t4));
                } catch (t5) {
                  return this.error(t5.message), null;
                }
              }
              return n4;
            }
            return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t3 === void 0 ? "'undefined' value invalid. Use null instead." : typeof t3 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
        }
        concat(t3, e2, r3) {
          const n3 = typeof t3 == "number" ? this.path.concat(t3) : this.path, i2 = r3 ? this.scope.concat(r3) : this.scope;
          return new pr(this.registry, n3, e2 || null, i2, this.errors);
        }
        error(t3, ...e2) {
          const r3 = `${this.key}${e2.map((t4) => `[${t4}]`).join("")}`;
          this.errors.push(new Yt(r3, t3));
        }
        checkSubtype(t3, e2) {
          const r3 = pe2(t3, e2);
          return r3 && this.error(r3), r3;
        }
      }
      var fr = pr;
      function dr(t3) {
        if (t3 instanceof hr)
          return dr(t3.boundExpression);
        if (t3 instanceof $e2 && t3.name === "error")
          return false;
        if (t3 instanceof Oe2)
          return false;
        if (t3 instanceof ar)
          return false;
        const e2 = t3 instanceof Le2 || t3 instanceof Ce2;
        let r3 = true;
        return t3.eachChild((t4) => {
          r3 = e2 ? r3 && dr(t4) : r3 && t4 instanceof ze;
        }), !!r3 && or(t3) && ur(t3, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
      }
      function yr(t3, e2) {
        const r3 = t3.length - 1;
        let n3, i2, s2 = 0, a2 = r3, o2 = 0;
        for (; s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n3 = t3[o2], i2 = t3[o2 + 1], n3 <= e2) {
            if (o2 === r3 || e2 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n3 > e2))
              throw new Te2("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }
      class mr {
        constructor(t3, e2, r3) {
          this.type = t3, this.input = e2, this.labels = [], this.outputs = [];
          for (const [t4, e3] of r3)
            this.labels.push(t4), this.outputs.push(e3);
        }
        static parse(t3, e2) {
          if (t3.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
          if ((t3.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          const r3 = e2.parse(t3[1], 1, te2);
          if (!r3)
            return null;
          const n3 = [];
          let i2 = null;
          e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
          for (let r4 = 1; r4 < t3.length; r4 += 2) {
            const s2 = r4 === 1 ? -1 / 0 : t3[r4], a2 = t3[r4 + 1], o2 = r4, l3 = r4 + 1;
            if (typeof s2 != "number")
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n3.length && n3[n3.length - 1][0] >= s2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u3 = e2.parse(a2, l3, i2);
            if (!u3)
              return null;
            i2 = i2 || u3.type, n3.push([s2, u3]);
          }
          return new mr(i2, r3, n3);
        }
        evaluate(t3) {
          const e2 = this.labels, r3 = this.outputs;
          if (e2.length === 1)
            return r3[0].evaluate(t3);
          const n3 = this.input.evaluate(t3);
          if (n3 <= e2[0])
            return r3[0].evaluate(t3);
          const i2 = e2.length;
          return n3 >= e2[i2 - 1] ? r3[i2 - 1].evaluate(t3) : r3[yr(e2, n3)].evaluate(t3);
        }
        eachChild(t3) {
          t3(this.input);
          for (const e2 of this.outputs)
            t3(e2);
        }
        outputDefined() {
          return this.outputs.every((t3) => t3.outputDefined());
        }
        serialize() {
          const t3 = ["step", this.input.serialize()];
          for (let e2 = 0; e2 < this.labels.length; e2++)
            e2 > 0 && t3.push(this.labels[e2]), t3.push(this.outputs[e2].serialize());
          return t3;
        }
      }
      var gr = mr;
      function xr(t3, e2, r3) {
        return t3 * (1 - r3) + e2 * r3;
      }
      function vr(t3, e2, r3) {
        return t3.map((t4, n3) => xr(t4, e2[n3], r3));
      }
      var br = Object.freeze({ __proto__: null, number: xr, color: function(t3, e2, r3) {
        return new xe(xr(t3.r, e2.r, r3), xr(t3.g, e2.g, r3), xr(t3.b, e2.b, r3), xr(t3.a, e2.a, r3));
      }, array: vr });
      const _r = 0.95047, wr = 1.08883, Ar = 4 / 29, Sr = 6 / 29, kr = 3 * Sr * Sr, Ir = Math.PI / 180, Mr = 180 / Math.PI;
      function zr(t3) {
        return t3 > 0.008856451679035631 ? Math.pow(t3, 1 / 3) : t3 / kr + Ar;
      }
      function Tr(t3) {
        return t3 > Sr ? t3 * t3 * t3 : kr * (t3 - Ar);
      }
      function Br(t3) {
        return 255 * (t3 <= 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055);
      }
      function Er(t3) {
        return (t3 /= 255) <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
      }
      function Cr(t3) {
        const e2 = Er(t3.r), r3 = Er(t3.g), n3 = Er(t3.b), i2 = zr((0.4124564 * e2 + 0.3575761 * r3 + 0.1804375 * n3) / _r), s2 = zr((0.2126729 * e2 + 0.7151522 * r3 + 0.072175 * n3) / 1);
        return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - zr((0.0193339 * e2 + 0.119192 * r3 + 0.9503041 * n3) / wr)), alpha: t3.a };
      }
      function Pr(t3) {
        let e2 = (t3.l + 16) / 116, r3 = isNaN(t3.a) ? e2 : e2 + t3.a / 500, n3 = isNaN(t3.b) ? e2 : e2 - t3.b / 200;
        return e2 = 1 * Tr(e2), r3 = _r * Tr(r3), n3 = wr * Tr(n3), new xe(Br(3.2404542 * r3 - 1.5371385 * e2 - 0.4985314 * n3), Br(-0.969266 * r3 + 1.8760108 * e2 + 0.041556 * n3), Br(0.0556434 * r3 - 0.2040259 * e2 + 1.0572252 * n3), t3.alpha);
      }
      function Dr(t3, e2, r3) {
        const n3 = e2 - t3;
        return t3 + r3 * (n3 > 180 || n3 < -180 ? n3 - 360 * Math.round(n3 / 360) : n3);
      }
      const Vr = { forward: Cr, reverse: Pr, interpolate: function(t3, e2, r3) {
        return { l: xr(t3.l, e2.l, r3), a: xr(t3.a, e2.a, r3), b: xr(t3.b, e2.b, r3), alpha: xr(t3.alpha, e2.alpha, r3) };
      } }, Fr = { forward: function(t3) {
        const { l: e2, a: r3, b: n3 } = Cr(t3), i2 = Math.atan2(n3, r3) * Mr;
        return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r3 * r3 + n3 * n3), l: e2, alpha: t3.a };
      }, reverse: function(t3) {
        const e2 = t3.h * Ir, r3 = t3.c;
        return Pr({ l: t3.l, a: Math.cos(e2) * r3, b: Math.sin(e2) * r3, alpha: t3.alpha });
      }, interpolate: function(t3, e2, r3) {
        return { h: Dr(t3.h, e2.h, r3), c: xr(t3.c, e2.c, r3), l: xr(t3.l, e2.l, r3), alpha: xr(t3.alpha, e2.alpha, r3) };
      } };
      var Lr = Object.freeze({ __proto__: null, lab: Vr, hcl: Fr });
      class Rr {
        constructor(t3, e2, r3, n3, i2) {
          this.type = t3, this.operator = e2, this.interpolation = r3, this.input = n3, this.labels = [], this.outputs = [];
          for (const [t4, e3] of i2)
            this.labels.push(t4), this.outputs.push(e3);
        }
        static interpolationFactor(t3, e2, n3, i2) {
          let s2 = 0;
          if (t3.name === "exponential")
            s2 = Ur(e2, t3.base, n3, i2);
          else if (t3.name === "linear")
            s2 = Ur(e2, 1, n3, i2);
          else if (t3.name === "cubic-bezier") {
            const a2 = t3.controlPoints;
            s2 = new r2(a2[0], a2[1], a2[2], a2[3]).solve(Ur(e2, 1, n3, i2));
          }
          return s2;
        }
        static parse(t3, e2) {
          let [r3, n3, i2, ...s2] = t3;
          if (!Array.isArray(n3) || n3.length === 0)
            return e2.error("Expected an interpolation type expression.", 1);
          if (n3[0] === "linear")
            n3 = { name: "linear" };
          else if (n3[0] === "exponential") {
            const t4 = n3[1];
            if (typeof t4 != "number")
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n3 = { name: "exponential", base: t4 };
          } else {
            if (n3[0] !== "cubic-bezier")
              return e2.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
            {
              const t4 = n3.slice(1);
              if (t4.length !== 4 || t4.some((t5) => typeof t5 != "number" || t5 < 0 || t5 > 1))
                return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n3 = { name: "cubic-bezier", controlPoints: t4 };
            }
          }
          if (t3.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
          if ((t3.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (i2 = e2.parse(i2, 2, te2), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          r3 === "interpolate-hcl" || r3 === "interpolate-lab" ? o2 = ne2 : e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType);
          for (let t4 = 0; t4 < s2.length; t4 += 2) {
            const r4 = s2[t4], n4 = s2[t4 + 1], i3 = t4 + 3, l3 = t4 + 4;
            if (typeof r4 != "number")
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r4)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u3 = e2.parse(n4, l3, o2);
            if (!u3)
              return null;
            o2 = o2 || u3.type, a2.push([r4, u3]);
          }
          return o2.kind === "number" || o2.kind === "color" || o2.kind === "array" && o2.itemType.kind === "number" && typeof o2.N == "number" ? new Rr(o2, r3, n3, i2, a2) : e2.error(`Type ${ce2(o2)} is not interpolatable.`);
        }
        evaluate(t3) {
          const e2 = this.labels, r3 = this.outputs;
          if (e2.length === 1)
            return r3[0].evaluate(t3);
          const n3 = this.input.evaluate(t3);
          if (n3 <= e2[0])
            return r3[0].evaluate(t3);
          const i2 = e2.length;
          if (n3 >= e2[i2 - 1])
            return r3[i2 - 1].evaluate(t3);
          const s2 = yr(e2, n3), a2 = Rr.interpolationFactor(this.interpolation, n3, e2[s2], e2[s2 + 1]), o2 = r3[s2].evaluate(t3), l3 = r3[s2 + 1].evaluate(t3);
          return this.operator === "interpolate" ? br[this.type.kind.toLowerCase()](o2, l3, a2) : this.operator === "interpolate-hcl" ? Fr.reverse(Fr.interpolate(Fr.forward(o2), Fr.forward(l3), a2)) : Vr.reverse(Vr.interpolate(Vr.forward(o2), Vr.forward(l3), a2));
        }
        eachChild(t3) {
          t3(this.input);
          for (const e2 of this.outputs)
            t3(e2);
        }
        outputDefined() {
          return this.outputs.every((t3) => t3.outputDefined());
        }
        serialize() {
          let t3;
          t3 = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const e2 = [this.operator, t3, this.input.serialize()];
          for (let t4 = 0; t4 < this.labels.length; t4++)
            e2.push(this.labels[t4], this.outputs[t4].serialize());
          return e2;
        }
      }
      function Ur(t3, e2, r3, n3) {
        const i2 = n3 - r3, s2 = t3 - r3;
        return i2 === 0 ? 0 : e2 === 1 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
      }
      var jr = Rr;
      class $r {
        constructor(t3, e2) {
          this.type = t3, this.args = e2;
        }
        static parse(t3, e2) {
          if (t3.length < 2)
            return e2.error("Expectected at least one argument.");
          let r3 = null;
          const n3 = e2.expectedType;
          n3 && n3.kind !== "value" && (r3 = n3);
          const i2 = [];
          for (const n4 of t3.slice(1)) {
            const t4 = e2.parse(n4, 1 + i2.length, r3, void 0, { typeAnnotation: "omit" });
            if (!t4)
              return null;
            r3 = r3 || t4.type, i2.push(t4);
          }
          const s2 = n3 && i2.some((t4) => pe2(n3, t4.type));
          return new $r(s2 ? se2 : r3, i2);
        }
        evaluate(t3) {
          let e2, r3 = null, n3 = 0;
          for (const i2 of this.args) {
            if (n3++, r3 = i2.evaluate(t3), r3 && r3 instanceof we2 && !r3.available && (e2 || (e2 = r3), r3 = null, n3 === this.args.length))
              return e2;
            if (r3 !== null)
              break;
          }
          return r3;
        }
        eachChild(t3) {
          this.args.forEach(t3);
        }
        outputDefined() {
          return this.args.every((t3) => t3.outputDefined());
        }
        serialize() {
          const t3 = ["coalesce"];
          return this.eachChild((e2) => {
            t3.push(e2.serialize());
          }), t3;
        }
      }
      var Or = $r;
      class qr {
        constructor(t3, e2) {
          this.type = e2.type, this.bindings = [].concat(t3), this.result = e2;
        }
        evaluate(t3) {
          return this.result.evaluate(t3);
        }
        eachChild(t3) {
          for (const e2 of this.bindings)
            t3(e2[1]);
          t3(this.result);
        }
        static parse(t3, e2) {
          if (t3.length < 4)
            return e2.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
          const r3 = [];
          for (let n4 = 1; n4 < t3.length - 1; n4 += 2) {
            const i2 = t3[n4];
            if (typeof i2 != "string")
              return e2.error(`Expected string, but found ${typeof i2} instead.`, n4);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n4);
            const s2 = e2.parse(t3[n4 + 1], n4 + 1);
            if (!s2)
              return null;
            r3.push([i2, s2]);
          }
          const n3 = e2.parse(t3[t3.length - 1], t3.length - 1, e2.expectedType, r3);
          return n3 ? new qr(r3, n3) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const t3 = ["let"];
          for (const [e2, r3] of this.bindings)
            t3.push(e2, r3.serialize());
          return t3.push(this.result.serialize()), t3;
        }
      }
      var Nr = qr;
      class Gr {
        constructor(t3, e2, r3) {
          this.type = t3, this.index = e2, this.input = r3;
        }
        static parse(t3, e2) {
          if (t3.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, te2), n3 = e2.parse(t3[2], 2, ue2(e2.expectedType || se2));
          return r3 && n3 ? new Gr(n3.type.itemType, r3, n3) : null;
        }
        evaluate(t3) {
          const e2 = this.index.evaluate(t3), r3 = this.input.evaluate(t3);
          if (e2 < 0)
            throw new Te2(`Array index out of bounds: ${e2} < 0.`);
          if (e2 >= r3.length)
            throw new Te2(`Array index out of bounds: ${e2} > ${r3.length - 1}.`);
          if (e2 !== Math.floor(e2))
            throw new Te2(`Array index must be an integer, but found ${e2} instead.`);
          return r3[e2];
        }
        eachChild(t3) {
          t3(this.index), t3(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      var Zr = Gr;
      class Xr {
        constructor(t3, e2) {
          this.type = re2, this.needle = t3, this.haystack = e2;
        }
        static parse(t3, e2) {
          if (t3.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, se2), n3 = e2.parse(t3[2], 2, se2);
          return r3 && n3 ? fe2(r3.type, [re2, ee2, te2, Qt, se2]) ? new Xr(r3, n3) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ce2(r3.type)} instead`) : null;
        }
        evaluate(t3) {
          const e2 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
          if (r3 == null)
            return false;
          if (!de2(e2, ["boolean", "string", "number", "null"]))
            throw new Te2(`Expected first argument to be of type boolean, string, number or null, but found ${ce2(ke2(e2))} instead.`);
          if (!de2(r3, ["string", "array"]))
            throw new Te2(`Expected second argument to be of type array or string, but found ${ce2(ke2(r3))} instead.`);
          return r3.indexOf(e2) >= 0;
        }
        eachChild(t3) {
          t3(this.needle), t3(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var Kr = Xr;
      class Hr {
        constructor(t3, e2, r3) {
          this.type = te2, this.needle = t3, this.haystack = e2, this.fromIndex = r3;
        }
        static parse(t3, e2) {
          if (t3.length <= 2 || t3.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, se2), n3 = e2.parse(t3[2], 2, se2);
          if (!r3 || !n3)
            return null;
          if (!fe2(r3.type, [re2, ee2, te2, Qt, se2]))
            return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ce2(r3.type)} instead`);
          if (t3.length === 4) {
            const i2 = e2.parse(t3[3], 3, te2);
            return i2 ? new Hr(r3, n3, i2) : null;
          }
          return new Hr(r3, n3);
        }
        evaluate(t3) {
          const e2 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
          if (!de2(e2, ["boolean", "string", "number", "null"]))
            throw new Te2(`Expected first argument to be of type boolean, string, number or null, but found ${ce2(ke2(e2))} instead.`);
          if (!de2(r3, ["string", "array"]))
            throw new Te2(`Expected second argument to be of type array or string, but found ${ce2(ke2(r3))} instead.`);
          if (this.fromIndex) {
            const n3 = this.fromIndex.evaluate(t3);
            return r3.indexOf(e2, n3);
          }
          return r3.indexOf(e2);
        }
        eachChild(t3) {
          t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (this.fromIndex != null && this.fromIndex !== void 0) {
            const t3 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t3];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var Yr = Hr;
      class Wr {
        constructor(t3, e2, r3, n3, i2, s2) {
          this.inputType = t3, this.type = e2, this.input = r3, this.cases = n3, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t3, e2) {
          if (t3.length < 5)
            return e2.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
          if (t3.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          let r3, n3;
          e2.expectedType && e2.expectedType.kind !== "value" && (n3 = e2.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2; a3 < t3.length - 1; a3 += 2) {
            let o3 = t3[a3];
            const l3 = t3[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u3 = e2.concat(a3);
            if (o3.length === 0)
              return u3.error("Expected at least one branch label.");
            for (const t4 of o3) {
              if (typeof t4 != "number" && typeof t4 != "string")
                return u3.error("Branch labels must be numbers or strings.");
              if (typeof t4 == "number" && Math.abs(t4) > Number.MAX_SAFE_INTEGER)
                return u3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof t4 == "number" && Math.floor(t4) !== t4)
                return u3.error("Numeric branch labels must be integer values.");
              if (r3) {
                if (u3.checkSubtype(r3, ke2(t4)))
                  return null;
              } else
                r3 = ke2(t4);
              if (i2[String(t4)] !== void 0)
                return u3.error("Branch labels must be unique.");
              i2[String(t4)] = s2.length;
            }
            const c2 = e2.parse(l3, a3, n3);
            if (!c2)
              return null;
            n3 = n3 || c2.type, s2.push(c2);
          }
          const a2 = e2.parse(t3[1], 1, se2);
          if (!a2)
            return null;
          const o2 = e2.parse(t3[t3.length - 1], t3.length - 1, n3);
          return o2 ? a2.type.kind !== "value" && e2.concat(1).checkSubtype(r3, a2.type) ? null : new Wr(r3, n3, a2, i2, s2, o2) : null;
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3);
          return (ke2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t3);
        }
        eachChild(t3) {
          t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t3 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r3 = [], n3 = {};
          for (const t4 of e2) {
            const e3 = n3[this.cases[t4]];
            e3 === void 0 ? (n3[this.cases[t4]] = r3.length, r3.push([this.cases[t4], [t4]])) : r3[e3][1].push(t4);
          }
          const i2 = (t4) => this.inputType.kind === "number" ? Number(t4) : t4;
          for (const [e3, n4] of r3)
            t3.push(n4.length === 1 ? i2(n4[0]) : n4.map(i2)), t3.push(this.outputs[e3].serialize());
          return t3.push(this.otherwise.serialize()), t3;
        }
      }
      var Jr = Wr;
      class Qr {
        constructor(t3, e2, r3) {
          this.type = t3, this.branches = e2, this.otherwise = r3;
        }
        static parse(t3, e2) {
          if (t3.length < 4)
            return e2.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
          if (t3.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          let r3;
          e2.expectedType && e2.expectedType.kind !== "value" && (r3 = e2.expectedType);
          const n3 = [];
          for (let i3 = 1; i3 < t3.length - 1; i3 += 2) {
            const s2 = e2.parse(t3[i3], i3, re2);
            if (!s2)
              return null;
            const a2 = e2.parse(t3[i3 + 1], i3 + 1, r3);
            if (!a2)
              return null;
            n3.push([s2, a2]), r3 = r3 || a2.type;
          }
          const i2 = e2.parse(t3[t3.length - 1], t3.length - 1, r3);
          return i2 ? new Qr(r3, n3, i2) : null;
        }
        evaluate(t3) {
          for (const [e2, r3] of this.branches)
            if (e2.evaluate(t3))
              return r3.evaluate(t3);
          return this.otherwise.evaluate(t3);
        }
        eachChild(t3) {
          for (const [e2, r3] of this.branches)
            t3(e2), t3(r3);
          t3(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t3, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t3 = ["case"];
          return this.eachChild((e2) => {
            t3.push(e2.serialize());
          }), t3;
        }
      }
      var tn = Qr;
      class en {
        constructor(t3, e2, r3, n3) {
          this.type = t3, this.input = e2, this.beginIndex = r3, this.endIndex = n3;
        }
        static parse(t3, e2) {
          if (t3.length <= 2 || t3.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1, se2), n3 = e2.parse(t3[2], 2, te2);
          if (!r3 || !n3)
            return null;
          if (!fe2(r3.type, [ue2(se2), ee2, se2]))
            return e2.error(`Expected first argument to be of type array or string, but found ${ce2(r3.type)} instead`);
          if (t3.length === 4) {
            const i2 = e2.parse(t3[3], 3, te2);
            return i2 ? new en(r3.type, r3, n3, i2) : null;
          }
          return new en(r3.type, r3, n3);
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3), r3 = this.beginIndex.evaluate(t3);
          if (!de2(e2, ["string", "array"]))
            throw new Te2(`Expected first argument to be of type array or string, but found ${ce2(ke2(e2))} instead.`);
          if (this.endIndex) {
            const n3 = this.endIndex.evaluate(t3);
            return e2.slice(r3, n3);
          }
          return e2.slice(r3);
        }
        eachChild(t3) {
          t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (this.endIndex != null && this.endIndex !== void 0) {
            const t3 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t3];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      var rn = en;
      function nn(t3, e2) {
        return t3 === "==" || t3 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
      }
      function sn(t3, e2, r3, n3) {
        return n3.compare(e2, r3) === 0;
      }
      function an(t3, e2, r3) {
        const n3 = t3 !== "==" && t3 !== "!=";
        return class i2 {
          constructor(t4, e3, r4) {
            this.type = re2, this.lhs = t4, this.rhs = e3, this.collator = r4, this.hasUntypedArgument = t4.type.kind === "value" || e3.type.kind === "value";
          }
          static parse(t4, e3) {
            if (t4.length !== 3 && t4.length !== 4)
              return e3.error("Expected two or three arguments.");
            const r4 = t4[0];
            let s2 = e3.parse(t4[1], 1, se2);
            if (!s2)
              return null;
            if (!nn(r4, s2.type))
              return e3.concat(1).error(`"${r4}" comparisons are not supported for type '${ce2(s2.type)}'.`);
            let a2 = e3.parse(t4[2], 2, se2);
            if (!a2)
              return null;
            if (!nn(r4, a2.type))
              return e3.concat(2).error(`"${r4}" comparisons are not supported for type '${ce2(a2.type)}'.`);
            if (s2.type.kind !== a2.type.kind && s2.type.kind !== "value" && a2.type.kind !== "value")
              return e3.error(`Cannot compare types '${ce2(s2.type)}' and '${ce2(a2.type)}'.`);
            n3 && (s2.type.kind === "value" && a2.type.kind !== "value" ? s2 = new Ce2(a2.type, [s2]) : s2.type.kind !== "value" && a2.type.kind === "value" && (a2 = new Ce2(s2.type, [a2])));
            let o2 = null;
            if (t4.length === 4) {
              if (s2.type.kind !== "string" && a2.type.kind !== "string" && s2.type.kind !== "value" && a2.type.kind !== "value")
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t4[3], 3, ae2), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n3 && this.hasUntypedArgument) {
              const e3 = ke2(s2), r4 = ke2(a2);
              if (e3.kind !== r4.kind || e3.kind !== "string" && e3.kind !== "number")
                throw new Te2(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e3.kind}, ${r4.kind}) instead.`);
            }
            if (this.collator && !n3 && this.hasUntypedArgument) {
              const t4 = ke2(s2), r4 = ke2(a2);
              if (t4.kind !== "string" || r4.kind !== "string")
                return e2(i3, s2, a2);
            }
            return this.collator ? r3(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
          }
          eachChild(t4) {
            t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const e3 = [t3];
            return this.eachChild((t4) => {
              e3.push(t4.serialize());
            }), e3;
          }
        };
      }
      const on = an("==", function(t3, e2, r3) {
        return e2 === r3;
      }, sn), ln = an("!=", function(t3, e2, r3) {
        return e2 !== r3;
      }, function(t3, e2, r3, n3) {
        return !sn(0, e2, r3, n3);
      }), un = an("<", function(t3, e2, r3) {
        return e2 < r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) < 0;
      }), cn = an(">", function(t3, e2, r3) {
        return e2 > r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) > 0;
      }), hn = an("<=", function(t3, e2, r3) {
        return e2 <= r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) <= 0;
      }), pn = an(">=", function(t3, e2, r3) {
        return e2 >= r3;
      }, function(t3, e2, r3, n3) {
        return n3.compare(e2, r3) >= 0;
      });
      class fn {
        constructor(t3, e2, r3, n3, i2, s2) {
          this.type = ee2, this.number = t3, this.locale = e2, this.currency = r3, this.unit = n3, this.minFractionDigits = i2, this.maxFractionDigits = s2;
        }
        static parse(t3, e2) {
          if (t3.length !== 3)
            return e2.error("Expected two arguments.");
          const r3 = e2.parse(t3[1], 1, te2);
          if (!r3)
            return null;
          const n3 = t3[2];
          if (typeof n3 != "object" || Array.isArray(n3))
            return e2.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n3.locale && (i2 = e2.parse(n3.locale, 1, ee2), !i2))
            return null;
          let s2 = null;
          if (n3.currency && (s2 = e2.parse(n3.currency, 1, ee2), !s2))
            return null;
          let a2 = null;
          if (n3.unit && (a2 = e2.parse(n3.unit, 1, ee2), !a2))
            return null;
          let o2 = null;
          if (n3["min-fraction-digits"] && (o2 = e2.parse(n3["min-fraction-digits"], 1, te2), !o2))
            return null;
          let l3 = null;
          return n3["max-fraction-digits"] && (l3 = e2.parse(n3["max-fraction-digits"], 1, te2), !l3) ? null : new fn(r3, i2, s2, a2, o2, l3);
        }
        evaluate(t3) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, unit: this.unit ? this.unit.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
        }
        eachChild(t3) {
          t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.unit && t3(this.unit), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t3 = {};
          return this.locale && (t3.locale = this.locale.serialize()), this.currency && (t3.currency = this.currency.serialize()), this.unit && (t3.unit = this.unit.serialize()), this.minFractionDigits && (t3["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t3["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t3];
        }
      }
      class dn {
        constructor(t3) {
          this.type = te2, this.input = t3;
        }
        static parse(t3, e2) {
          if (t3.length !== 2)
            return e2.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
          const r3 = e2.parse(t3[1], 1);
          return r3 ? r3.type.kind !== "array" && r3.type.kind !== "string" && r3.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${ce2(r3.type)} instead.`) : new dn(r3) : null;
        }
        evaluate(t3) {
          const e2 = this.input.evaluate(t3);
          if (typeof e2 == "string")
            return e2.length;
          if (Array.isArray(e2))
            return e2.length;
          throw new Te2(`Expected value to be of type string or array, but found ${ce2(ke2(e2))} instead.`);
        }
        eachChild(t3) {
          t3(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t3 = ["length"];
          return this.eachChild((e2) => {
            t3.push(e2.serialize());
          }), t3;
        }
      }
      const yn = { "==": on, "!=": ln, ">": cn, "<": un, ">=": pn, "<=": hn, array: Ce2, at: Zr, boolean: Ce2, case: tn, coalesce: Or, collator: Oe2, format: Pe2, image: De2, in: Kr, "index-of": Yr, interpolate: jr, "interpolate-hcl": jr, "interpolate-lab": jr, length: dn, let: Nr, literal: ze, match: Jr, number: Ce2, "number-format": fn, object: Ce2, slice: rn, step: gr, string: Ce2, "to-boolean": Le2, "to-color": Le2, "to-number": Le2, "to-string": Le2, var: hr, within: ar };
      function mn(t3, [e2, r3, n3, i2]) {
        e2 = e2.evaluate(t3), r3 = r3.evaluate(t3), n3 = n3.evaluate(t3);
        const s2 = i2 ? i2.evaluate(t3) : 1, a2 = Ae2(e2, r3, n3, s2);
        if (a2)
          throw new Te2(a2);
        return new xe(e2 / 255 * s2, r3 / 255 * s2, n3 / 255 * s2, s2);
      }
      function gn(t3, e2) {
        return t3 in e2;
      }
      function xn(t3, e2) {
        const r3 = e2[t3];
        return r3 === void 0 ? null : r3;
      }
      function vn(t3) {
        return { type: t3 };
      }
      $e2.register(yn, { error: [{ kind: "error" }, [ee2], (t3, [e2]) => {
        throw new Te2(e2.evaluate(t3));
      }], typeof: [ee2, [se2], (t3, [e2]) => ce2(ke2(e2.evaluate(t3)))], "to-rgba": [ue2(te2, 4), [ne2], (t3, [e2]) => e2.evaluate(t3).toArray()], rgb: [ne2, [te2, te2, te2], mn], rgba: [ne2, [te2, te2, te2, te2], mn], has: { type: re2, overloads: [[[ee2], (t3, [e2]) => gn(e2.evaluate(t3), t3.properties())], [[ee2, ie2], (t3, [e2, r3]) => gn(e2.evaluate(t3), r3.evaluate(t3))]] }, get: { type: se2, overloads: [[[ee2], (t3, [e2]) => xn(e2.evaluate(t3), t3.properties())], [[ee2, ie2], (t3, [e2, r3]) => xn(e2.evaluate(t3), r3.evaluate(t3))]] }, "feature-state": [se2, [ee2], (t3, [e2]) => xn(e2.evaluate(t3), t3.featureState || {})], properties: [ie2, [], (t3) => t3.properties()], "geometry-type": [ee2, [], (t3) => t3.geometryType()], id: [se2, [], (t3) => t3.id()], zoom: [te2, [], (t3) => t3.globals.zoom], pitch: [te2, [], (t3) => t3.globals.pitch || 0], "distance-from-center": [te2, [], (t3) => t3.distanceFromCenter()], "heatmap-density": [te2, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [te2, [], (t3) => t3.globals.lineProgress || 0], "sky-radial-progress": [te2, [], (t3) => t3.globals.skyRadialProgress || 0], accumulated: [se2, [], (t3) => t3.globals.accumulated === void 0 ? null : t3.globals.accumulated], "+": [te2, vn(te2), (t3, e2) => {
        let r3 = 0;
        for (const n3 of e2)
          r3 += n3.evaluate(t3);
        return r3;
      }], "*": [te2, vn(te2), (t3, e2) => {
        let r3 = 1;
        for (const n3 of e2)
          r3 *= n3.evaluate(t3);
        return r3;
      }], "-": { type: te2, overloads: [[[te2, te2], (t3, [e2, r3]) => e2.evaluate(t3) - r3.evaluate(t3)], [[te2], (t3, [e2]) => -e2.evaluate(t3)]] }, "/": [te2, [te2, te2], (t3, [e2, r3]) => e2.evaluate(t3) / r3.evaluate(t3)], "%": [te2, [te2, te2], (t3, [e2, r3]) => e2.evaluate(t3) % r3.evaluate(t3)], ln2: [te2, [], () => Math.LN2], pi: [te2, [], () => Math.PI], e: [te2, [], () => Math.E], "^": [te2, [te2, te2], (t3, [e2, r3]) => Math.pow(e2.evaluate(t3), r3.evaluate(t3))], sqrt: [te2, [te2], (t3, [e2]) => Math.sqrt(e2.evaluate(t3))], log10: [te2, [te2], (t3, [e2]) => Math.log(e2.evaluate(t3)) / Math.LN10], ln: [te2, [te2], (t3, [e2]) => Math.log(e2.evaluate(t3))], log2: [te2, [te2], (t3, [e2]) => Math.log(e2.evaluate(t3)) / Math.LN2], sin: [te2, [te2], (t3, [e2]) => Math.sin(e2.evaluate(t3))], cos: [te2, [te2], (t3, [e2]) => Math.cos(e2.evaluate(t3))], tan: [te2, [te2], (t3, [e2]) => Math.tan(e2.evaluate(t3))], asin: [te2, [te2], (t3, [e2]) => Math.asin(e2.evaluate(t3))], acos: [te2, [te2], (t3, [e2]) => Math.acos(e2.evaluate(t3))], atan: [te2, [te2], (t3, [e2]) => Math.atan(e2.evaluate(t3))], min: [te2, vn(te2), (t3, e2) => Math.min(...e2.map((e3) => e3.evaluate(t3)))], max: [te2, vn(te2), (t3, e2) => Math.max(...e2.map((e3) => e3.evaluate(t3)))], abs: [te2, [te2], (t3, [e2]) => Math.abs(e2.evaluate(t3))], round: [te2, [te2], (t3, [e2]) => {
        const r3 = e2.evaluate(t3);
        return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
      }], floor: [te2, [te2], (t3, [e2]) => Math.floor(e2.evaluate(t3))], ceil: [te2, [te2], (t3, [e2]) => Math.ceil(e2.evaluate(t3))], "filter-==": [re2, [ee2, se2], (t3, [e2, r3]) => t3.properties()[e2.value] === r3.value], "filter-id-==": [re2, [se2], (t3, [e2]) => t3.id() === e2.value], "filter-type-==": [re2, [ee2], (t3, [e2]) => t3.geometryType() === e2.value], "filter-<": [re2, [ee2, se2], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i2 = r3.value;
        return typeof n3 == typeof i2 && n3 < i2;
      }], "filter-id-<": [re2, [se2], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 < n3;
      }], "filter->": [re2, [ee2, se2], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i2 = r3.value;
        return typeof n3 == typeof i2 && n3 > i2;
      }], "filter-id->": [re2, [se2], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 > n3;
      }], "filter-<=": [re2, [ee2, se2], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i2 = r3.value;
        return typeof n3 == typeof i2 && n3 <= i2;
      }], "filter-id-<=": [re2, [se2], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 <= n3;
      }], "filter->=": [re2, [ee2, se2], (t3, [e2, r3]) => {
        const n3 = t3.properties()[e2.value], i2 = r3.value;
        return typeof n3 == typeof i2 && n3 >= i2;
      }], "filter-id->=": [re2, [se2], (t3, [e2]) => {
        const r3 = t3.id(), n3 = e2.value;
        return typeof r3 == typeof n3 && r3 >= n3;
      }], "filter-has": [re2, [se2], (t3, [e2]) => e2.value in t3.properties()], "filter-has-id": [re2, [], (t3) => t3.id() !== null && t3.id() !== void 0], "filter-type-in": [re2, [ue2(ee2)], (t3, [e2]) => e2.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [re2, [ue2(se2)], (t3, [e2]) => e2.value.indexOf(t3.id()) >= 0], "filter-in-small": [re2, [ee2, ue2(se2)], (t3, [e2, r3]) => r3.value.indexOf(t3.properties()[e2.value]) >= 0], "filter-in-large": [re2, [ee2, ue2(se2)], (t3, [e2, r3]) => function(t4, e3, r4, n3) {
        for (; r4 <= n3; ) {
          const i2 = r4 + n3 >> 1;
          if (e3[i2] === t4)
            return true;
          e3[i2] > t4 ? n3 = i2 - 1 : r4 = i2 + 1;
        }
        return false;
      }(t3.properties()[e2.value], r3.value, 0, r3.value.length - 1)], all: { type: re2, overloads: [[[re2, re2], (t3, [e2, r3]) => e2.evaluate(t3) && r3.evaluate(t3)], [vn(re2), (t3, e2) => {
        for (const r3 of e2)
          if (!r3.evaluate(t3))
            return false;
        return true;
      }]] }, any: { type: re2, overloads: [[[re2, re2], (t3, [e2, r3]) => e2.evaluate(t3) || r3.evaluate(t3)], [vn(re2), (t3, e2) => {
        for (const r3 of e2)
          if (r3.evaluate(t3))
            return true;
        return false;
      }]] }, "!": [re2, [re2], (t3, [e2]) => !e2.evaluate(t3)], "is-supported-script": [re2, [ee2], (t3, [e2]) => {
        const r3 = t3.globals && t3.globals.isSupportedScript;
        return !r3 || r3(e2.evaluate(t3));
      }], upcase: [ee2, [ee2], (t3, [e2]) => e2.evaluate(t3).toUpperCase()], downcase: [ee2, [ee2], (t3, [e2]) => e2.evaluate(t3).toLowerCase()], concat: [ee2, vn(se2), (t3, e2) => e2.map((e3) => Ie2(e3.evaluate(t3))).join("")], "resolved-locale": [ee2, [ae2], (t3, [e2]) => e2.evaluate(t3).resolvedLocale()] });
      var bn = yn;
      function _n(t3) {
        return { result: "success", value: t3 };
      }
      function wn(t3) {
        return { result: "error", value: t3 };
      }
      function An(t3) {
        return t3["property-type"] === "data-driven" || t3["property-type"] === "cross-faded-data-driven";
      }
      function Sn(t3) {
        return !!t3.expression && t3.expression.parameters.indexOf("zoom") > -1;
      }
      function kn(t3) {
        return !!t3.expression && t3.expression.interpolated;
      }
      function In(t3) {
        return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : t3 === null ? "null" : typeof t3;
      }
      function Mn(t3) {
        return typeof t3 == "object" && t3 !== null && !Array.isArray(t3);
      }
      function zn(t3) {
        return t3;
      }
      function Tn(t3, e2) {
        const r3 = e2.type === "color", n3 = t3.stops && typeof t3.stops[0][0] == "object", i2 = n3 || !(n3 || t3.property !== void 0), s2 = t3.type || (kn(e2) ? "exponential" : "interval");
        if (r3 && ((t3 = Zt({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], xe.parse(t4[1])])), t3.default = xe.parse(t3.default ? t3.default : e2.default)), t3.colorSpace && t3.colorSpace !== "rgb" && !Lr[t3.colorSpace])
          throw new Error(`Unknown color space: ${t3.colorSpace}`);
        let a2, o2, l3;
        if (s2 === "exponential")
          a2 = Pn;
        else if (s2 === "interval")
          a2 = Cn;
        else if (s2 === "categorical") {
          a2 = En, o2 = Object.create(null);
          for (const e3 of t3.stops)
            o2[e3[0]] = e3[1];
          l3 = typeof t3.stops[0][0];
        } else {
          if (s2 !== "identity")
            throw new Error(`Unknown function type "${s2}"`);
          a2 = Dn;
        }
        if (n3) {
          const r4 = {}, n4 = [];
          for (let e3 = 0; e3 < t3.stops.length; e3++) {
            const i4 = t3.stops[e3], s4 = i4[0].zoom;
            r4[s4] === void 0 && (r4[s4] = { zoom: s4, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n4.push(s4)), r4[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t4 of n4)
            i3.push([r4[t4].zoom, Tn(r4[t4], e2)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: jr.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t4) => t4[0]), evaluate: ({ zoom: r5 }, n5) => Pn({ stops: i3, base: t3.base }, e2, r5).evaluate(r5, n5) };
        }
        if (i2) {
          const r4 = s2 === "exponential" ? { name: "exponential", base: t3.base !== void 0 ? t3.base : 1 } : null;
          return { kind: "camera", interpolationType: r4, interpolationFactor: jr.interpolationFactor.bind(void 0, r4), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r5 }) => a2(t3, e2, r5, o2, l3) };
        }
        return { kind: "source", evaluate(r4, n4) {
          const i3 = n4 && n4.properties ? n4.properties[t3.property] : void 0;
          return i3 === void 0 ? Bn(t3.default, e2.default) : a2(t3, e2, i3, o2, l3);
        } };
      }
      function Bn(t3, e2, r3) {
        return t3 !== void 0 ? t3 : e2 !== void 0 ? e2 : r3 !== void 0 ? r3 : void 0;
      }
      function En(t3, e2, r3, n3, i2) {
        return Bn(typeof r3 === i2 ? n3[r3] : void 0, t3.default, e2.default);
      }
      function Cn(t3, e2, r3) {
        if (In(r3) !== "number")
          return Bn(t3.default, e2.default);
        const n3 = t3.stops.length;
        if (n3 === 1)
          return t3.stops[0][1];
        if (r3 <= t3.stops[0][0])
          return t3.stops[0][1];
        if (r3 >= t3.stops[n3 - 1][0])
          return t3.stops[n3 - 1][1];
        const i2 = yr(t3.stops.map((t4) => t4[0]), r3);
        return t3.stops[i2][1];
      }
      function Pn(t3, e2, r3) {
        const n3 = t3.base !== void 0 ? t3.base : 1;
        if (In(r3) !== "number")
          return Bn(t3.default, e2.default);
        const i2 = t3.stops.length;
        if (i2 === 1)
          return t3.stops[0][1];
        if (r3 <= t3.stops[0][0])
          return t3.stops[0][1];
        if (r3 >= t3.stops[i2 - 1][0])
          return t3.stops[i2 - 1][1];
        const s2 = yr(t3.stops.map((t4) => t4[0]), r3), a2 = function(t4, e3, r4, n4) {
          const i3 = n4 - r4, s3 = t4 - r4;
          return i3 === 0 ? 0 : e3 === 1 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r3, n3, t3.stops[s2][0], t3.stops[s2 + 1][0]), o2 = t3.stops[s2][1], l3 = t3.stops[s2 + 1][1];
        let u3 = br[e2.type] || zn;
        if (t3.colorSpace && t3.colorSpace !== "rgb") {
          const e3 = Lr[t3.colorSpace];
          u3 = (t4, r4) => e3.reverse(e3.interpolate(e3.forward(t4), e3.forward(r4), a2));
        }
        return typeof o2.evaluate == "function" ? { evaluate(...t4) {
          const e3 = o2.evaluate.apply(void 0, t4), r4 = l3.evaluate.apply(void 0, t4);
          if (e3 !== void 0 && r4 !== void 0)
            return u3(e3, r4, a2);
        } } : u3(o2, l3, a2);
      }
      function Dn(t3, e2, r3) {
        return e2.type === "color" ? r3 = xe.parse(r3) : e2.type === "formatted" ? r3 = _e.fromString(r3.toString()) : e2.type === "resolvedImage" ? r3 = we2.fromString(r3.toString()) : In(r3) === e2.type || e2.type === "enum" && e2.values[r3] || (r3 = void 0), Bn(r3, t3.default, e2.default);
      }
      class Vn {
        constructor(t3, e2) {
          this.expression = t3, this._warningHistory = {}, this._evaluator = new Ue2(), this._defaultValue = e2 ? function(t4) {
            return t4.type === "color" && (Mn(t4.default) || Array.isArray(t4.default)) ? new xe(0, 0, 0, 0) : t4.type === "color" ? xe.parse(t4.default) || null : t4.default === void 0 ? null : t4.default;
          }(e2) : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
        }
        evaluateWithoutErrorHandling(t3, e2, r3, n3, i2, s2, a2, o2) {
          return this._evaluator.globals = t3, this._evaluator.feature = e2, this._evaluator.featureState = r3, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(t3, e2, r3, n3, i2, s2, a2, o2) {
          this._evaluator.globals = t3, this._evaluator.feature = e2 || null, this._evaluator.featureState = r3 || null, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
          try {
            const t4 = this.expression.evaluate(this._evaluator);
            if (t4 == null || typeof t4 == "number" && t4 != t4)
              return this._defaultValue;
            if (this._enumValues && !(t4 in this._enumValues))
              throw new Te2(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
            return t4;
          } catch (t4) {
            return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, typeof console != "undefined" && console.warn(t4.message)), this._defaultValue;
          }
        }
      }
      function Fn(t3) {
        return Array.isArray(t3) && t3.length > 0 && typeof t3[0] == "string" && t3[0] in bn;
      }
      function Ln(t3, e2) {
        const r3 = new fr(bn, [], e2 ? function(t4) {
          const e3 = { color: ne2, string: ee2, number: te2, enum: ee2, boolean: re2, formatted: oe2, resolvedImage: le2 };
          return t4.type === "array" ? ue2(e3[t4.value] || se2, t4.length) : e3[t4.type];
        }(e2) : void 0), n3 = r3.parse(t3, void 0, void 0, void 0, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return n3 ? _n(new Vn(n3, e2)) : wn(r3.errors);
      }
      class Rn {
        constructor(t3, e2) {
          this.kind = t3, this._styleExpression = e2, this.isStateDependent = t3 !== "constant" && !lr(e2.expression);
        }
        evaluateWithoutErrorHandling(t3, e2, r3, n3, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t3, e2, r3, n3, i2, s2);
        }
        evaluate(t3, e2, r3, n3, i2, s2) {
          return this._styleExpression.evaluate(t3, e2, r3, n3, i2, s2);
        }
      }
      class Un {
        constructor(t3, e2, r3, n3) {
          this.kind = t3, this.zoomStops = r3, this._styleExpression = e2, this.isStateDependent = t3 !== "camera" && !lr(e2.expression), this.interpolationType = n3;
        }
        evaluateWithoutErrorHandling(t3, e2, r3, n3, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t3, e2, r3, n3, i2, s2);
        }
        evaluate(t3, e2, r3, n3, i2, s2) {
          return this._styleExpression.evaluate(t3, e2, r3, n3, i2, s2);
        }
        interpolationFactor(t3, e2, r3) {
          return this.interpolationType ? jr.interpolationFactor(this.interpolationType, t3, e2, r3) : 0;
        }
      }
      function jn(t3, e2) {
        if ((t3 = Ln(t3, e2)).result === "error")
          return t3;
        const r3 = t3.value.expression, n3 = or(r3);
        if (!n3 && !An(e2))
          return wn([new Yt("", "data expressions not supported")]);
        const i2 = ur(r3, ["zoom", "pitch", "distance-from-center"]);
        if (!i2 && !Sn(e2))
          return wn([new Yt("", "zoom expressions not supported")]);
        const s2 = On(r3);
        return s2 || i2 ? s2 instanceof Yt ? wn([s2]) : s2 instanceof jr && !kn(e2) ? wn([new Yt("", '"interpolate" expressions cannot be used with this property')]) : _n(s2 ? new Un(n3 ? "camera" : "composite", t3.value, s2.labels, s2 instanceof jr ? s2.interpolation : void 0) : new Rn(n3 ? "constant" : "source", t3.value)) : wn([new Yt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class $n {
        constructor(t3, e2) {
          this._parameters = t3, this._specification = e2, Zt(this, Tn(this._parameters, this._specification));
        }
        static deserialize(t3) {
          return new $n(t3._parameters, t3._specification);
        }
        static serialize(t3) {
          return { _parameters: t3._parameters, _specification: t3._specification };
        }
      }
      function On(t3) {
        let e2 = null;
        if (t3 instanceof Nr)
          e2 = On(t3.result);
        else if (t3 instanceof Or) {
          for (const r3 of t3.args)
            if (e2 = On(r3), e2)
              break;
        } else
          (t3 instanceof gr || t3 instanceof jr) && t3.input instanceof $e2 && t3.input.name === "zoom" && (e2 = t3);
        return e2 instanceof Yt || t3.eachChild((t4) => {
          const r3 = On(t4);
          r3 instanceof Yt ? e2 = r3 : !e2 && r3 ? e2 = new Yt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r3 && e2 !== r3 && (e2 = new Yt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e2;
      }
      class qn {
        constructor(t3, e2, r3, n3) {
          this.message = (t3 ? `${t3}: ` : "") + r3, n3 && (this.identifier = n3), e2 != null && e2.__line__ && (this.line = e2.__line__);
        }
      }
      function Nn(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec || {}, i2 = t3.objectElementValidators || {}, s2 = t3.style, a2 = t3.styleSpec;
        let o2 = [];
        const l3 = In(r3);
        if (l3 !== "object")
          return [new qn(e2, r3, `object expected, ${l3} found`)];
        for (const t4 in r3) {
          const l4 = t4.split(".")[0], u3 = n3[l4] || n3["*"];
          let c2;
          i2[l4] ? c2 = i2[l4] : n3[l4] ? c2 = Ai2 : i2["*"] ? c2 = i2["*"] : n3["*"] && (c2 = Ai2), c2 ? o2 = o2.concat(c2({ key: (e2 ? `${e2}.` : e2) + t4, value: r3[t4], valueSpec: u3, style: s2, styleSpec: a2, object: r3, objectKey: t4 }, r3)) : o2.push(new qn(e2, r3[t4], `unknown property "${t4}"`));
        }
        for (const t4 in n3)
          i2[t4] || n3[t4].required && n3[t4].default === void 0 && r3[t4] === void 0 && o2.push(new qn(e2, r3, `missing required property "${t4}"`));
        return o2;
      }
      function Gn(t3) {
        const e2 = t3.value, r3 = t3.valueSpec, n3 = t3.style, i2 = t3.styleSpec, s2 = t3.key, a2 = t3.arrayElementValidator || Ai2;
        if (In(e2) !== "array")
          return [new qn(s2, e2, `array expected, ${In(e2)} found`)];
        if (r3.length && e2.length !== r3.length)
          return [new qn(s2, e2, `array length ${r3.length} expected, length ${e2.length} found`)];
        if (r3["min-length"] && e2.length < r3["min-length"])
          return [new qn(s2, e2, `array length at least ${r3["min-length"]} expected, length ${e2.length} found`)];
        let o2 = { type: r3.value, values: r3.values, minimum: r3.minimum, maximum: r3.maximum, function: void 0 };
        i2.$version < 7 && (o2.function = r3.function), In(r3.value) === "object" && (o2 = r3.value);
        let l3 = [];
        for (let t4 = 0; t4 < e2.length; t4++)
          l3 = l3.concat(a2({ array: e2, arrayIndex: t4, value: e2[t4], valueSpec: o2, style: n3, styleSpec: i2, key: `${s2}[${t4}]` }));
        return l3;
      }
      function Zn(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec;
        let i2 = In(r3);
        if (i2 === "number" && r3 != r3 && (i2 = "NaN"), i2 !== "number")
          return [new qn(e2, r3, `number expected, ${i2} found`)];
        if ("minimum" in n3) {
          let i3 = n3.minimum;
          if (In(n3.minimum) === "array" && (i3 = n3.minimum[t3.arrayIndex]), r3 < i3)
            return [new qn(e2, r3, `${r3} is less than the minimum value ${i3}`)];
        }
        if ("maximum" in n3) {
          let i3 = n3.maximum;
          if (In(n3.maximum) === "array" && (i3 = n3.maximum[t3.arrayIndex]), r3 > i3)
            return [new qn(e2, r3, `${r3} is greater than the maximum value ${i3}`)];
        }
        return [];
      }
      function Xn(t3) {
        const e2 = t3.valueSpec, r3 = Xt(t3.value.type);
        let n3, i2, s2, a2 = {};
        const o2 = r3 !== "categorical" && t3.value.property === void 0, l3 = !o2, u3 = In(t3.value.stops) === "array" && In(t3.value.stops[0]) === "array" && In(t3.value.stops[0][0]) === "object", c2 = Nn({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
          if (r3 === "identity")
            return [new qn(t4.key, t4.value, 'identity function may not have a "stops" property')];
          let e3 = [];
          const n4 = t4.value;
          return e3 = e3.concat(Gn({ key: t4.key, value: n4, valueSpec: t4.valueSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: h3 })), In(n4) === "array" && n4.length === 0 && e3.push(new qn(t4.key, n4, "array must have at least one stop")), e3;
        }, default: function(t4) {
          return Ai2({ key: t4.key, value: t4.value, valueSpec: e2, style: t4.style, styleSpec: t4.styleSpec });
        } } });
        return r3 === "identity" && o2 && c2.push(new qn(t3.key, t3.value, 'missing required property "property"')), r3 === "identity" || t3.value.stops || c2.push(new qn(t3.key, t3.value, 'missing required property "stops"')), r3 === "exponential" && t3.valueSpec.expression && !kn(t3.valueSpec) && c2.push(new qn(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (l3 && !An(t3.valueSpec) ? c2.push(new qn(t3.key, t3.value, "property functions not supported")) : o2 && !Sn(t3.valueSpec) && c2.push(new qn(t3.key, t3.value, "zoom functions not supported"))), r3 !== "categorical" && !u3 || t3.value.property !== void 0 || c2.push(new qn(t3.key, t3.value, '"property" property is required')), c2;
        function h3(t4) {
          let r4 = [];
          const n4 = t4.value, o3 = t4.key;
          if (In(n4) !== "array")
            return [new qn(o3, n4, `array expected, ${In(n4)} found`)];
          if (n4.length !== 2)
            return [new qn(o3, n4, `array length 2 expected, length ${n4.length} found`)];
          if (u3) {
            if (In(n4[0]) !== "object")
              return [new qn(o3, n4, `object expected, ${In(n4[0])} found`)];
            if (n4[0].zoom === void 0)
              return [new qn(o3, n4, "object stop key must have zoom")];
            if (n4[0].value === void 0)
              return [new qn(o3, n4, "object stop key must have value")];
            const e3 = Xt(n4[0].zoom);
            if (typeof e3 != "number")
              return [new qn(o3, n4[0].zoom, "stop zoom values must be numbers")];
            if (s2 && s2 > e3)
              return [new qn(o3, n4[0].zoom, "stop zoom values must appear in ascending order")];
            e3 !== s2 && (s2 = e3, i2 = void 0, a2 = {}), r4 = r4.concat(Nn({ key: `${o3}[0]`, value: n4[0], valueSpec: { zoom: {} }, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: Zn, value: p3 } }));
          } else
            r4 = r4.concat(p3({ key: `${o3}[0]`, value: n4[0], valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec }, n4));
          return Fn(Kt(n4[1])) ? r4.concat([new qn(`${o3}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r4.concat(Ai2({ key: `${o3}[1]`, value: n4[1], valueSpec: e2, style: t4.style, styleSpec: t4.styleSpec }));
        }
        function p3(t4, s3) {
          const o3 = In(t4.value), l4 = Xt(t4.value), u4 = t4.value !== null ? t4.value : s3;
          if (n3) {
            if (o3 !== n3)
              return [new qn(t4.key, u4, `${o3} stop domain type must match previous stop domain type ${n3}`)];
          } else
            n3 = o3;
          if (o3 !== "number" && o3 !== "string" && o3 !== "boolean" && typeof l4 != "number" && typeof l4 != "string" && typeof l4 != "boolean")
            return [new qn(t4.key, u4, "stop domain value must be a number, string, or boolean")];
          if (o3 !== "number" && r3 !== "categorical") {
            let n4 = `number expected, ${o3} found`;
            return An(e2) && r3 === void 0 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new qn(t4.key, u4, n4)];
          }
          return r3 !== "categorical" || o3 !== "number" || typeof l4 == "number" && isFinite(l4) && Math.floor(l4) === l4 ? r3 !== "categorical" && o3 === "number" && typeof l4 == "number" && typeof i2 == "number" && i2 !== void 0 && l4 < i2 ? [new qn(t4.key, u4, "stop domain values must appear in ascending order")] : (i2 = l4, r3 === "categorical" && l4 in a2 ? [new qn(t4.key, u4, "stop domain values must be unique")] : (a2[l4] = true, [])) : [new qn(t4.key, u4, `integer expected, found ${String(l4)}`)];
        }
      }
      function Kn(t3) {
        const e2 = (t3.expressionContext === "property" ? jn : Ln)(Kt(t3.value), t3.valueSpec);
        if (e2.result === "error")
          return e2.value.map((e3) => new qn(`${t3.key}${e3.key}`, t3.value, e3.message));
        const r3 = e2.value.expression || e2.value._styleExpression.expression;
        if (t3.expressionContext === "property" && t3.propertyKey === "text-font" && !r3.outputDefined())
          return [new qn(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (t3.expressionContext === "property" && t3.propertyType === "layout" && !lr(r3))
          return [new qn(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (t3.expressionContext === "filter")
          return Hn(r3, t3);
        if (t3.expressionContext && t3.expressionContext.indexOf("cluster") === 0) {
          if (!ur(r3, ["zoom", "feature-state"]))
            return [new qn(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (t3.expressionContext === "cluster-initial" && !or(r3))
            return [new qn(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Hn(t3, e2) {
        const r3 = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (e2.valueSpec && e2.valueSpec.expression)
          for (const t4 of e2.valueSpec.expression.parameters)
            r3.delete(t4);
        if (r3.size === 0)
          return [];
        const n3 = [];
        return t3 instanceof $e2 && r3.has(t3.name) ? [new qn(e2.key, e2.value, `["${t3.name}"] expression is not supported in a filter for a ${e2.object.type} layer with id: ${e2.object.id}`)] : (t3.eachChild((t4) => {
          n3.push(...Hn(t4, e2));
        }), n3);
      }
      function Yn(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = t3.valueSpec, i2 = [];
        return Array.isArray(n3.values) ? n3.values.indexOf(Xt(r3)) === -1 && i2.push(new qn(e2, r3, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r3)} found`)) : Object.keys(n3.values).indexOf(Xt(r3)) === -1 && i2.push(new qn(e2, r3, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r3)} found`)), i2;
      }
      function Wn(t3) {
        if (t3 === true || t3 === false)
          return true;
        if (!Array.isArray(t3) || t3.length === 0)
          return false;
        switch (t3[0]) {
          case "has":
            return t3.length >= 2 && t3[1] !== "$id" && t3[1] !== "$type";
          case "in":
            return t3.length >= 3 && (typeof t3[1] != "string" || Array.isArray(t3[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return t3.length !== 3 || Array.isArray(t3[1]) || Array.isArray(t3[2]);
          case "any":
          case "all":
            for (const e2 of t3.slice(1))
              if (!Wn(e2) && typeof e2 != "boolean")
                return false;
            return true;
          default:
            return true;
        }
      }
      function Jn(t3, e2 = "fill") {
        if (t3 == null)
          return { filter: () => true, needGeometry: false, needFeature: false };
        Wn(t3) || (t3 = si2(t3));
        const r3 = t3;
        let n3 = true;
        try {
          n3 = function(t4) {
            if (!ei2(t4))
              return t4;
            let e3 = Kt(t4);
            return ti2(e3), e3 = Qn(e3), e3;
          }(r3);
        } catch (t4) {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r3, null, 2)}
        `);
        }
        const i2 = Gt[`filter_${e2}`], s2 = Ln(n3, i2);
        let a2 = null;
        if (s2.result === "error")
          throw new Error(s2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
        a2 = (t4, e3, r4) => s2.value.evaluate(t4, e3, {}, r4);
        let o2 = null, l3 = null;
        if (n3 !== r3) {
          const t4 = Ln(r3, i2);
          if (t4.result === "error")
            throw new Error(t4.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
          o2 = (e3, r4, n4, i3, s3) => t4.value.evaluate(e3, r4, {}, n4, void 0, void 0, i3, s3), l3 = !or(t4.value.expression);
        }
        return a2 = a2, { filter: a2, dynamicFilter: o2 || void 0, needGeometry: ii2(n3), needFeature: !!l3 };
      }
      function Qn(t3) {
        if (!Array.isArray(t3))
          return t3;
        const e2 = function(t4) {
          if (ri2.has(t4[0])) {
            for (let e3 = 1; e3 < t4.length; e3++)
              if (ei2(t4[e3]))
                return true;
          }
          return t4;
        }(t3);
        return e2 === true ? e2 : e2.map((t4) => Qn(t4));
      }
      function ti2(t3) {
        let e2 = false;
        const r3 = [];
        if (t3[0] === "case") {
          for (let n3 = 1; n3 < t3.length - 1; n3 += 2)
            e2 = e2 || ei2(t3[n3]), r3.push(t3[n3 + 1]);
          r3.push(t3[t3.length - 1]);
        } else if (t3[0] === "match") {
          e2 = e2 || ei2(t3[1]);
          for (let e3 = 2; e3 < t3.length - 1; e3 += 2)
            r3.push(t3[e3 + 1]);
          r3.push(t3[t3.length - 1]);
        } else if (t3[0] === "step") {
          e2 = e2 || ei2(t3[1]);
          for (let e3 = 1; e3 < t3.length - 1; e3 += 2)
            r3.push(t3[e3 + 1]);
        }
        e2 && (t3.length = 0, t3.push("any", ...r3));
        for (let e3 = 1; e3 < t3.length; e3++)
          ti2(t3[e3]);
      }
      function ei2(t3) {
        if (!Array.isArray(t3))
          return false;
        if ((e2 = t3[0]) === "pitch" || e2 === "distance-from-center")
          return true;
        var e2;
        for (let e3 = 1; e3 < t3.length; e3++)
          if (ei2(t3[e3]))
            return true;
        return false;
      }
      const ri2 = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function ni2(t3, e2) {
        return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
      }
      function ii2(t3) {
        if (!Array.isArray(t3))
          return false;
        if (t3[0] === "within")
          return true;
        for (let e2 = 1; e2 < t3.length; e2++)
          if (ii2(t3[e2]))
            return true;
        return false;
      }
      function si2(t3) {
        if (!t3)
          return true;
        const e2 = t3[0];
        return t3.length <= 1 ? e2 !== "any" : e2 === "==" ? ai2(t3[1], t3[2], "==") : e2 === "!=" ? ui2(ai2(t3[1], t3[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? ai2(t3[1], t3[2], e2) : e2 === "any" ? (r3 = t3.slice(1), ["any"].concat(r3.map(si2))) : e2 === "all" ? ["all"].concat(t3.slice(1).map(si2)) : e2 === "none" ? ["all"].concat(t3.slice(1).map(si2).map(ui2)) : e2 === "in" ? oi2(t3[1], t3.slice(2)) : e2 === "!in" ? ui2(oi2(t3[1], t3.slice(2))) : e2 === "has" ? li2(t3[1]) : e2 === "!has" ? ui2(li2(t3[1])) : e2 !== "within" || t3;
        var r3;
      }
      function ai2(t3, e2, r3) {
        switch (t3) {
          case "$type":
            return [`filter-type-${r3}`, e2];
          case "$id":
            return [`filter-id-${r3}`, e2];
          default:
            return [`filter-${r3}`, t3, e2];
        }
      }
      function oi2(t3, e2) {
        if (e2.length === 0)
          return false;
        switch (t3) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some((t4) => typeof t4 != typeof e2[0]) ? ["filter-in-large", t3, ["literal", e2.sort(ni2)]] : ["filter-in-small", t3, ["literal", e2]];
        }
      }
      function li2(t3) {
        switch (t3) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t3];
        }
      }
      function ui2(t3) {
        return ["!", t3];
      }
      function ci2(t3) {
        return Wn(Kt(t3.value)) ? Kn(Zt({}, t3, { expressionContext: "filter", valueSpec: t3.styleSpec[`filter_${t3.layerType || "fill"}`] })) : hi2(t3);
      }
      function hi2(t3) {
        const e2 = t3.value, r3 = t3.key;
        if (In(e2) !== "array")
          return [new qn(r3, e2, `array expected, ${In(e2)} found`)];
        const n3 = t3.styleSpec;
        let i2, s2 = [];
        if (e2.length < 1)
          return [new qn(r3, e2, "filter array must have at least 1 element")];
        switch (s2 = s2.concat(Yn({ key: `${r3}[0]`, value: e2[0], valueSpec: n3.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), Xt(e2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e2.length >= 2 && Xt(e2[1]) === "$type" && s2.push(new qn(r3, e2, `"$type" cannot be use with operator "${e2[0]}"`));
          case "==":
          case "!=":
            e2.length !== 3 && s2.push(new qn(r3, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e2.length >= 2 && (i2 = In(e2[1]), i2 !== "string" && s2.push(new qn(`${r3}[1]`, e2[1], `string expected, ${i2} found`)));
            for (let a2 = 2; a2 < e2.length; a2++)
              i2 = In(e2[a2]), Xt(e2[1]) === "$type" ? s2 = s2.concat(Yn({ key: `${r3}[${a2}]`, value: e2[a2], valueSpec: n3.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && s2.push(new qn(`${r3}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n4 = 1; n4 < e2.length; n4++)
              s2 = s2.concat(hi2({ key: `${r3}[${n4}]`, value: e2[n4], style: t3.style, styleSpec: t3.styleSpec }));
            break;
          case "has":
          case "!has":
            i2 = In(e2[1]), e2.length !== 2 ? s2.push(new qn(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && s2.push(new qn(`${r3}[1]`, e2[1], `string expected, ${i2} found`));
            break;
          case "within":
            i2 = In(e2[1]), e2.length !== 2 ? s2.push(new qn(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "object" && s2.push(new qn(`${r3}[1]`, e2[1], `object expected, ${i2} found`));
        }
        return s2;
      }
      function pi2(t3, e2) {
        const r3 = t3.key, n3 = t3.style, i2 = t3.styleSpec, s2 = t3.value, a2 = t3.objectKey, o2 = i2[`${e2}_${t3.layerType}`];
        if (!o2)
          return [];
        const l3 = a2.match(/^(.*)-transition$/);
        if (e2 === "paint" && l3 && o2[l3[1]] && o2[l3[1]].transition)
          return Ai2({ key: r3, value: s2, valueSpec: i2.transition, style: n3, styleSpec: i2 });
        const u3 = t3.valueSpec || o2[a2];
        if (!u3)
          return [new qn(r3, s2, `unknown property "${a2}"`)];
        let c2;
        if (In(s2) === "string" && An(u3) && !u3.tokens && (c2 = /^{([^}]+)}$/.exec(s2)))
          return [new qn(r3, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
        const h3 = [];
        return t3.layerType === "symbol" && (a2 === "text-field" && n3 && !n3.glyphs && h3.push(new qn(r3, s2, 'use of "text-field" requires a style "glyphs" property')), a2 === "text-font" && Mn(Kt(s2)) && Xt(s2.type) === "identity" && h3.push(new qn(r3, s2, '"text-font" does not support identity functions'))), h3.concat(Ai2({ key: t3.key, value: s2, valueSpec: u3, style: n3, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
      }
      function fi2(t3) {
        return pi2(t3, "paint");
      }
      function di2(t3) {
        return pi2(t3, "layout");
      }
      function yi2(t3) {
        let e2 = [];
        const r3 = t3.value, n3 = t3.key, i2 = t3.style, s2 = t3.styleSpec;
        r3.type || r3.ref || e2.push(new qn(n3, r3, 'either "type" or "ref" is required'));
        let a2 = Xt(r3.type);
        const o2 = Xt(r3.ref);
        if (r3.id) {
          const s3 = Xt(r3.id);
          for (let a3 = 0; a3 < t3.arrayIndex; a3++) {
            const t4 = i2.layers[a3];
            Xt(t4.id) === s3 && e2.push(new qn(n3, r3.id, `duplicate layer id "${r3.id}", previously used at line ${t4.id.__line__}`));
          }
        }
        if ("ref" in r3) {
          let t4;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
            t5 in r3 && e2.push(new qn(n3, r3[t5], `"${t5}" is prohibited for ref layers`));
          }), i2.layers.forEach((e3) => {
            Xt(e3.id) === o2 && (t4 = e3);
          }), t4 ? t4.ref ? e2.push(new qn(n3, r3.ref, "ref cannot reference another ref layer")) : a2 = Xt(t4.type) : typeof o2 == "string" && e2.push(new qn(n3, r3.ref, `ref layer "${o2}" not found`));
        } else if (a2 !== "background" && a2 !== "sky")
          if (r3.source) {
            const t4 = i2.sources && i2.sources[r3.source], s3 = t4 && Xt(t4.type);
            t4 ? s3 === "vector" && a2 === "raster" ? e2.push(new qn(n3, r3.source, `layer "${r3.id}" requires a raster source`)) : s3 === "raster" && a2 !== "raster" ? e2.push(new qn(n3, r3.source, `layer "${r3.id}" requires a vector source`)) : s3 !== "vector" || r3["source-layer"] ? s3 === "raster-dem" && a2 !== "hillshade" ? e2.push(new qn(n3, r3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r3.paint || !r3.paint["line-gradient"] && !r3.paint["line-trim-offset"] || s3 === "geojson" && t4.lineMetrics || e2.push(new qn(n3, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new qn(n3, r3, `layer "${r3.id}" must specify a "source-layer"`)) : e2.push(new qn(n3, r3.source, `source "${r3.source}" not found`));
          } else
            e2.push(new qn(n3, r3, 'missing required property "source"'));
        return e2 = e2.concat(Nn({ key: n3, value: r3, valueSpec: s2.layer, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": () => [], type: () => Ai2({ key: `${n3}.type`, value: r3.type, valueSpec: s2.layer.type, style: t3.style, styleSpec: t3.styleSpec, object: r3, objectKey: "type" }), filter: (t4) => ci2(Zt({ layerType: a2 }, t4)), layout: (t4) => Nn({ layer: r3, key: t4.key, value: t4.value, valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => di2(Zt({ layerType: a2 }, t5)) } }), paint: (t4) => Nn({ layer: r3, key: t4.key, value: t4.value, valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => fi2(Zt({ layerType: a2 }, t5)) } }) } })), e2;
      }
      function mi2(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = In(e2);
        return n3 !== "string" ? [new qn(r3, e2, `string expected, ${n3} found`)] : [];
      }
      const gi2 = { promoteId: function({ key: t3, value: e2 }) {
        if (In(e2) === "string")
          return mi2({ key: t3, value: e2 });
        {
          const r3 = [];
          for (const n3 in e2)
            r3.push(...mi2({ key: `${t3}.${n3}`, value: e2[n3] }));
          return r3;
        }
      } };
      function xi2(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = t3.styleSpec, i2 = t3.style;
        if (!e2.type)
          return [new qn(r3, e2, '"type" is required')];
        const s2 = Xt(e2.type);
        let a2;
        switch (s2) {
          case "vector":
          case "raster":
          case "raster-dem":
            return a2 = Nn({ key: r3, value: e2, valueSpec: n3[`source_${s2.replace("-", "_")}`], style: t3.style, styleSpec: n3, objectElementValidators: gi2 }), a2;
          case "geojson":
            if (a2 = Nn({ key: r3, value: e2, valueSpec: n3.source_geojson, style: i2, styleSpec: n3, objectElementValidators: gi2 }), e2.cluster)
              for (const t4 in e2.clusterProperties) {
                const [n4, i3] = e2.clusterProperties[t4], s3 = typeof n4 == "string" ? [n4, ["accumulated"], ["get", t4]] : n4;
                a2.push(...Kn({ key: `${r3}.${t4}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...Kn({ key: `${r3}.${t4}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
              }
            return a2;
          case "video":
            return Nn({ key: r3, value: e2, valueSpec: n3.source_video, style: i2, styleSpec: n3 });
          case "image":
            return Nn({ key: r3, value: e2, valueSpec: n3.source_image, style: i2, styleSpec: n3 });
          case "canvas":
            return [new qn(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Yn({ key: `${r3}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n3 });
        }
      }
      function vi2(t3) {
        const e2 = t3.value, r3 = t3.styleSpec, n3 = r3.light, i2 = t3.style;
        let s2 = [];
        const a2 = In(e2);
        if (e2 === void 0)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new qn("light", e2, `object expected, ${a2} found`)]), s2;
        for (const t4 in e2) {
          const a3 = t4.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && n3[a3[1]] && n3[a3[1]].transition ? Ai2({ key: t4, value: e2[t4], valueSpec: r3.transition, style: i2, styleSpec: r3 }) : n3[t4] ? Ai2({ key: t4, value: e2[t4], valueSpec: n3[t4], style: i2, styleSpec: r3 }) : [new qn(t4, e2[t4], `unknown property "${t4}"`)]);
        }
        return s2;
      }
      function bi2(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = t3.style, i2 = t3.styleSpec, s2 = i2.terrain;
        let a2 = [];
        const o2 = In(e2);
        if (e2 === void 0)
          return a2;
        if (o2 !== "object")
          return a2 = a2.concat([new qn("terrain", e2, `object expected, ${o2} found`)]), a2;
        for (const t4 in e2) {
          const r4 = t4.match(/^(.*)-transition$/);
          a2 = a2.concat(r4 && s2[r4[1]] && s2[r4[1]].transition ? Ai2({ key: t4, value: e2[t4], valueSpec: i2.transition, style: n3, styleSpec: i2 }) : s2[t4] ? Ai2({ key: t4, value: e2[t4], valueSpec: s2[t4], style: n3, styleSpec: i2 }) : [new qn(t4, e2[t4], `unknown property "${t4}"`)]);
        }
        if (e2.source) {
          const t4 = n3.sources && n3.sources[e2.source], i3 = t4 && Xt(t4.type);
          t4 ? i3 !== "raster-dem" && a2.push(new qn(r3, e2.source, `terrain cannot be used with a source of type ${String(i3)}, it only be used with a "raster-dem" source type`)) : a2.push(new qn(r3, e2.source, `source "${e2.source}" not found`));
        } else
          a2.push(new qn(r3, e2, 'terrain is missing required property "source"'));
        return a2;
      }
      function _i(t3) {
        const e2 = t3.value, r3 = t3.style, n3 = t3.styleSpec, i2 = n3.fog;
        let s2 = [];
        const a2 = In(e2);
        if (e2 === void 0)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new qn("fog", e2, `object expected, ${a2} found`)]), s2;
        for (const t4 in e2) {
          const a3 = t4.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Ai2({ key: t4, value: e2[t4], valueSpec: n3.transition, style: r3, styleSpec: n3 }) : i2[t4] ? Ai2({ key: t4, value: e2[t4], valueSpec: i2[t4], style: r3, styleSpec: n3 }) : [new qn(t4, e2[t4], `unknown property "${t4}"`)]);
        }
        return s2;
      }
      const wi2 = { "*": () => [], array: Gn, boolean: function(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = In(e2);
        return n3 !== "boolean" ? [new qn(r3, e2, `boolean expected, ${n3} found`)] : [];
      }, number: Zn, color: function(t3) {
        const e2 = t3.key, r3 = t3.value, n3 = In(r3);
        return n3 !== "string" ? [new qn(e2, r3, `color expected, ${n3} found`)] : me2.parseCSSColor(r3) === null ? [new qn(e2, r3, `color expected, "${r3}" found`)] : [];
      }, enum: Yn, filter: ci2, function: Xn, layer: yi2, object: Nn, source: xi2, light: vi2, terrain: bi2, fog: _i, string: mi2, formatted: function(t3) {
        return mi2(t3).length === 0 ? [] : Kn(t3);
      }, resolvedImage: function(t3) {
        return mi2(t3).length === 0 ? [] : Kn(t3);
      }, projection: function(t3) {
        const e2 = t3.value, r3 = t3.styleSpec, n3 = r3.projection, i2 = t3.style;
        let s2 = [];
        const a2 = In(e2);
        if (a2 === "object")
          for (const t4 in e2)
            s2 = s2.concat(Ai2({ key: t4, value: e2[t4], valueSpec: n3[t4], style: i2, styleSpec: r3 }));
        else
          a2 !== "string" && (s2 = s2.concat([new qn("projection", e2, `object or string expected, ${a2} found`)]));
        return s2;
      } };
      function Ai2(t3) {
        const e2 = t3.value, r3 = t3.valueSpec, n3 = t3.styleSpec;
        return r3.expression && Mn(Xt(e2)) ? Xn(t3) : r3.expression && Fn(Kt(e2)) ? Kn(t3) : r3.type && wi2[r3.type] ? wi2[r3.type](t3) : Nn(Zt({}, t3, { valueSpec: r3.type ? n3[r3.type] : r3 }));
      }
      function Si2(t3) {
        const e2 = t3.value, r3 = t3.key, n3 = mi2(t3);
        return n3.length || (e2.indexOf("{fontstack}") === -1 && n3.push(new qn(r3, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n3.push(new qn(r3, e2, '"glyphs" url must include a "{range}" token'))), n3;
      }
      function ki2(t3, e2 = Gt) {
        return zi2(Ai2({ key: "", value: t3, valueSpec: e2.$root, styleSpec: e2, style: t3, objectElementValidators: { glyphs: Si2, "*": () => [] } }));
      }
      const Ii2 = (t3) => zi2(fi2(t3)), Mi2 = (t3) => zi2(di2(t3));
      function zi2(t3) {
        return t3.slice().sort((t4, e2) => t4.line && e2.line ? t4.line - e2.line : 0);
      }
      function Ti2(t3, e2) {
        let r3 = false;
        if (e2 && e2.length)
          for (const n3 of e2)
            t3.fire(new qt(new Error(n3.message))), r3 = true;
        return r3;
      }
      var Bi2 = Ei2;
      function Ei2(t3, e2, r3) {
        var n3 = this.cells = [];
        if (t3 instanceof ArrayBuffer) {
          this.arrayBuffer = t3;
          var i2 = new Int32Array(this.arrayBuffer);
          t3 = i2[0], this.d = (e2 = i2[1]) + 2 * (r3 = i2[2]);
          for (var s2 = 0; s2 < this.d * this.d; s2++) {
            var a2 = i2[3 + s2], o2 = i2[3 + s2 + 1];
            n3.push(a2 === o2 ? null : i2.subarray(a2, o2));
          }
          var l3 = i2[3 + n3.length + 1];
          this.keys = i2.subarray(i2[3 + n3.length], l3), this.bboxes = i2.subarray(l3), this.insert = this._insertReadonly;
        } else {
          this.d = e2 + 2 * r3;
          for (var u3 = 0; u3 < this.d * this.d; u3++)
            n3.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = e2, this.extent = t3, this.padding = r3, this.scale = e2 / t3, this.uid = 0;
        var c2 = r3 / e2 * t3;
        this.min = -c2, this.max = t3 + c2;
      }
      Ei2.prototype.insert = function(t3, e2, r3, n3, i2) {
        this._forEachCell(e2, r3, n3, i2, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e2), this.bboxes.push(r3), this.bboxes.push(n3), this.bboxes.push(i2);
      }, Ei2.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Ei2.prototype._insertCell = function(t3, e2, r3, n3, i2, s2) {
        this.cells[i2].push(s2);
      }, Ei2.prototype.query = function(t3, e2, r3, n3, i2) {
        var s2 = this.min, a2 = this.max;
        if (t3 <= s2 && e2 <= s2 && a2 <= r3 && a2 <= n3 && !i2)
          return Array.prototype.slice.call(this.keys);
        var o2 = [];
        return this._forEachCell(t3, e2, r3, n3, this._queryCell, o2, {}, i2), o2;
      }, Ei2.prototype._queryCell = function(t3, e2, r3, n3, i2, s2, a2, o2) {
        var l3 = this.cells[i2];
        if (l3 !== null)
          for (var u3 = this.keys, c2 = this.bboxes, h3 = 0; h3 < l3.length; h3++) {
            var p3 = l3[h3];
            if (a2[p3] === void 0) {
              var f2 = 4 * p3;
              (o2 ? o2(c2[f2 + 0], c2[f2 + 1], c2[f2 + 2], c2[f2 + 3]) : t3 <= c2[f2 + 2] && e2 <= c2[f2 + 3] && r3 >= c2[f2 + 0] && n3 >= c2[f2 + 1]) ? (a2[p3] = true, s2.push(u3[p3])) : a2[p3] = false;
            }
          }
      }, Ei2.prototype._forEachCell = function(t3, e2, r3, n3, i2, s2, a2, o2) {
        for (var l3 = this._convertToCellCoord(t3), u3 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r3), h3 = this._convertToCellCoord(n3), p3 = l3; p3 <= c2; p3++)
          for (var f2 = u3; f2 <= h3; f2++) {
            var d2 = this.d * f2 + p3;
            if ((!o2 || o2(this._convertFromCellCoord(p3), this._convertFromCellCoord(f2), this._convertFromCellCoord(p3 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t3, e2, r3, n3, d2, s2, a2, o2))
              return;
          }
      }, Ei2.prototype._convertFromCellCoord = function(t3) {
        return (t3 - this.padding) / this.scale;
      }, Ei2.prototype._convertToCellCoord = function(t3) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
      }, Ei2.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var t3 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r3 = 0, n3 = 0; n3 < this.cells.length; n3++)
          r3 += this.cells[n3].length;
        var i2 = new Int32Array(e2 + r3 + this.keys.length + this.bboxes.length);
        i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
        for (var s2 = e2, a2 = 0; a2 < t3.length; a2++) {
          var o2 = t3[a2];
          i2[3 + a2] = s2, i2.set(o2, s2), s2 += o2.length;
        }
        return i2[3 + t3.length] = s2, i2.set(this.keys, s2), i2[3 + t3.length + 1] = s2 += this.keys.length, i2.set(this.bboxes, s2), s2 += this.bboxes.length, i2.buffer;
      };
      const Ci2 = {};
      function Pi2(t3, e2, r3 = {}) {
        Object.defineProperty(t3, "_classRegistryKey", { value: e2, writeable: false }), Ci2[e2] = { klass: t3, omit: r3.omit || [] };
      }
      Pi2(Object, "Object"), Bi2.serialize = function(t3, e2) {
        const r3 = t3.toArrayBuffer();
        return e2 && e2.push(r3), { buffer: r3 };
      }, Bi2.deserialize = function(t3) {
        return new Bi2(t3.buffer);
      }, Object.defineProperty(Bi2, "name", { value: "Grid" }), Pi2(Bi2, "Grid"), Pi2(xe, "Color"), Pi2(Error, "Error"), Pi2(Tt, "AJAXError"), Pi2(we2, "ResolvedImage"), Pi2($n, "StylePropertyFunction"), Pi2(Vn, "StyleExpression", { omit: ["_evaluator"] }), Pi2(Un, "ZoomDependentExpression"), Pi2(Rn, "ZoomConstantExpression"), Pi2($e2, "CompoundExpression", { omit: ["_evaluate"] });
      for (const t3 in bn)
        Ci2[bn[t3]._classRegistryKey] || Pi2(bn[t3], `Expression${t3}`);
      function Di2(t3) {
        return t3 && typeof ArrayBuffer != "undefined" && (t3 instanceof ArrayBuffer || t3.constructor && t3.constructor.name === "ArrayBuffer");
      }
      function Vi2(t3) {
        return e.ImageBitmap && t3 instanceof e.ImageBitmap;
      }
      function Fi2(t3, r3) {
        if (t3 == null || typeof t3 == "boolean" || typeof t3 == "number" || typeof t3 == "string" || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp)
          return t3;
        if (Di2(t3) || Vi2(t3))
          return r3 && r3.push(t3), t3;
        if (ArrayBuffer.isView(t3)) {
          const e2 = t3;
          return r3 && r3.push(e2.buffer), e2;
        }
        if (t3 instanceof e.ImageData)
          return r3 && r3.push(t3.data.buffer), t3;
        if (Array.isArray(t3)) {
          const e2 = [];
          for (const n3 of t3)
            e2.push(Fi2(n3, r3));
          return e2;
        }
        if (typeof t3 == "object") {
          const e2 = t3.constructor, n3 = e2._classRegistryKey;
          if (!n3)
            throw new Error(`can't serialize object of unregistered class ${n3}`);
          const i2 = e2.serialize ? e2.serialize(t3, r3) : {};
          if (!e2.serialize) {
            for (const e3 in t3)
              t3.hasOwnProperty(e3) && (Ci2[n3].omit.indexOf(e3) >= 0 || (i2[e3] = Fi2(t3[e3], r3)));
            t3 instanceof Error && (i2.message = t3.message);
          }
          if (i2.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return n3 !== "Object" && (i2.$name = n3), i2;
        }
        throw new Error("can't serialize object of type " + typeof t3);
      }
      function Li2(t3) {
        if (t3 == null || typeof t3 == "boolean" || typeof t3 == "number" || typeof t3 == "string" || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || Di2(t3) || Vi2(t3) || ArrayBuffer.isView(t3) || t3 instanceof e.ImageData)
          return t3;
        if (Array.isArray(t3))
          return t3.map(Li2);
        if (typeof t3 == "object") {
          const e2 = t3.$name || "Object", { klass: r3 } = Ci2[e2];
          if (!r3)
            throw new Error(`can't deserialize unregistered class ${e2}`);
          if (r3.deserialize)
            return r3.deserialize(t3);
          const n3 = Object.create(r3.prototype);
          for (const e3 of Object.keys(t3))
            e3 !== "$name" && (n3[e3] = Li2(t3[e3]));
          return n3;
        }
        throw new Error("can't deserialize object of type " + typeof t3);
      }
      class Ri2 {
        constructor() {
          this.first = true;
        }
        update(t3, e2) {
          const r3 = Math.floor(t3);
          return this.first ? (this.first = false, this.lastIntegerZoom = r3, this.lastIntegerZoomTime = 0, this.lastZoom = t3, this.lastFloorZoom = r3, true) : (this.lastFloorZoom > r3 ? (this.lastIntegerZoom = r3 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r3 && (this.lastIntegerZoom = r3, this.lastIntegerZoomTime = e2), t3 !== this.lastZoom && (this.lastZoom = t3, this.lastFloorZoom = r3, true));
        }
      }
      const Ui2 = (t3) => t3 >= 1536 && t3 <= 1791, ji2 = (t3) => t3 >= 1872 && t3 <= 1919, $i2 = (t3) => t3 >= 2208 && t3 <= 2303, Oi2 = (t3) => t3 >= 11904 && t3 <= 12031, qi2 = (t3) => t3 >= 12032 && t3 <= 12255, Ni2 = (t3) => t3 >= 12272 && t3 <= 12287, Gi2 = (t3) => t3 >= 12288 && t3 <= 12351, Zi2 = (t3) => t3 >= 12352 && t3 <= 12447, Xi2 = (t3) => t3 >= 12448 && t3 <= 12543, Ki2 = (t3) => t3 >= 12544 && t3 <= 12591, Hi2 = (t3) => t3 >= 12704 && t3 <= 12735, Yi2 = (t3) => t3 >= 12736 && t3 <= 12783, Wi2 = (t3) => t3 >= 12784 && t3 <= 12799, Ji2 = (t3) => t3 >= 12800 && t3 <= 13055, Qi2 = (t3) => t3 >= 13056 && t3 <= 13311, ts = (t3) => t3 >= 13312 && t3 <= 19903, es = (t3) => t3 >= 19968 && t3 <= 40959, rs = (t3) => t3 >= 40960 && t3 <= 42127, ns = (t3) => t3 >= 42128 && t3 <= 42191, is = (t3) => t3 >= 44032 && t3 <= 55215, ss = (t3) => t3 >= 63744 && t3 <= 64255, as2 = (t3) => t3 >= 64336 && t3 <= 65023, os = (t3) => t3 >= 65040 && t3 <= 65055, ls = (t3) => t3 >= 65072 && t3 <= 65103, us = (t3) => t3 >= 65104 && t3 <= 65135, cs = (t3) => t3 >= 65136 && t3 <= 65279, hs = (t3) => t3 >= 65280 && t3 <= 65519;
      function ps(t3) {
        for (const e2 of t3)
          if (ys(e2.charCodeAt(0)))
            return true;
        return false;
      }
      function fs(t3) {
        for (const e2 of t3)
          if (!ds(e2.charCodeAt(0)))
            return false;
        return true;
      }
      function ds(t3) {
        return !(Ui2(t3) || ji2(t3) || $i2(t3) || as2(t3) || cs(t3));
      }
      function ys(t3) {
        return !(t3 !== 746 && t3 !== 747 && (t3 < 4352 || !(Hi2(t3) || Ki2(t3) || ls(t3) && !(t3 >= 65097 && t3 <= 65103) || ss(t3) || Qi2(t3) || Oi2(t3) || Yi2(t3) || !(!Gi2(t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || t3 === 12336) || ts(t3) || es(t3) || Ji2(t3) || ((t4) => t4 >= 12592 && t4 <= 12687)(t3) || ((t4) => t4 >= 43360 && t4 <= 43391)(t3) || ((t4) => t4 >= 55216 && t4 <= 55295)(t3) || ((t4) => t4 >= 4352 && t4 <= 4607)(t3) || is(t3) || Zi2(t3) || Ni2(t3) || ((t4) => t4 >= 12688 && t4 <= 12703)(t3) || qi2(t3) || Wi2(t3) || Xi2(t3) && t3 !== 12540 || !(!hs(t3) || t3 === 65288 || t3 === 65289 || t3 === 65293 || t3 >= 65306 && t3 <= 65310 || t3 === 65339 || t3 === 65341 || t3 === 65343 || t3 >= 65371 && t3 <= 65503 || t3 === 65507 || t3 >= 65512 && t3 <= 65519) || !(!us(t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || ((t4) => t4 >= 5120 && t4 <= 5759)(t3) || ((t4) => t4 >= 6320 && t4 <= 6399)(t3) || os(t3) || ((t4) => t4 >= 19904 && t4 <= 19967)(t3) || rs(t3) || ns(t3))));
      }
      function ms(t3) {
        return !(ys(t3) || function(t4) {
          return !!(((t5) => t5 >= 128 && t5 <= 255)(t4) && (t4 === 167 || t4 === 169 || t4 === 174 || t4 === 177 || t4 === 188 || t4 === 189 || t4 === 190 || t4 === 215 || t4 === 247) || ((t5) => t5 >= 8192 && t5 <= 8303)(t4) && (t4 === 8214 || t4 === 8224 || t4 === 8225 || t4 === 8240 || t4 === 8241 || t4 === 8251 || t4 === 8252 || t4 === 8258 || t4 === 8263 || t4 === 8264 || t4 === 8265 || t4 === 8273) || ((t5) => t5 >= 8448 && t5 <= 8527)(t4) || ((t5) => t5 >= 8528 && t5 <= 8591)(t4) || ((t5) => t5 >= 8960 && t5 <= 9215)(t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || t4 === 9003 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || t4 === 9167 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || ((t5) => t5 >= 9216 && t5 <= 9279)(t4) && t4 !== 9251 || ((t5) => t5 >= 9280 && t5 <= 9311)(t4) || ((t5) => t5 >= 9312 && t5 <= 9471)(t4) || ((t5) => t5 >= 9632 && t5 <= 9727)(t4) || ((t5) => t5 >= 9728 && t5 <= 9983)(t4) && !(t4 >= 9754 && t4 <= 9759) || ((t5) => t5 >= 11008 && t5 <= 11263)(t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || Gi2(t4) || Xi2(t4) || ((t5) => t5 >= 57344 && t5 <= 63743)(t4) || ls(t4) || us(t4) || hs(t4) || t4 === 8734 || t4 === 8756 || t4 === 8757 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || t4 === 65532 || t4 === 65533);
        }(t3));
      }
      function gs(t3) {
        return t3 >= 1424 && t3 <= 2303 || as2(t3) || cs(t3);
      }
      function xs(t3, e2) {
        return !(!e2 && gs(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || ((t4) => t4 >= 6016 && t4 <= 6143)(t3));
      }
      function vs(t3) {
        for (const e2 of t3)
          if (gs(e2.charCodeAt(0)))
            return true;
        return false;
      }
      const bs = "deferred", _s = "loading", ws = "loaded";
      let As = null, Ss = "unavailable", ks = null;
      const Is = function(t3) {
        t3 && typeof t3 == "string" && t3.indexOf("NetworkError") > -1 && (Ss = "error"), As && As(t3);
      };
      function Ms() {
        zs.fire(new Ot("pluginStateChange", { pluginStatus: Ss, pluginURL: ks }));
      }
      const zs = new Nt(), Ts = function() {
        return Ss;
      }, Bs = function() {
        if (Ss !== bs || !ks)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Ss = _s, Ms(), ks && Ct({ url: ks }, (t3) => {
          t3 ? Is(t3) : (Ss = ws, Ms());
        });
      }, Es = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Ss === ws || Es.applyArabicShaping != null, isLoading: () => Ss === _s, setState(t3) {
        Ss = t3.pluginStatus, ks = t3.pluginURL;
      }, isParsed: () => Es.applyArabicShaping != null && Es.processBidirectionalText != null && Es.processStyledBidirectionalText != null, getPluginURL: () => ks };
      class Cs {
        constructor(t3, e2) {
          this.zoom = t3, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition, this.pitch = e2.pitch) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ri2(), this.transition = {}, this.pitch = 0);
        }
        isSupportedScript(t3) {
          return function(t4, e2) {
            for (const r3 of t4)
              if (!xs(r3.charCodeAt(0), e2))
                return false;
            return true;
          }(t3, Es.isLoaded());
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t3 = this.zoom, e2 = t3 - Math.floor(t3), r3 = this.crossFadingFactor();
          return t3 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r3 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r3) * e2 };
        }
      }
      class Ps {
        constructor(t3, e2) {
          this.property = t3, this.value = e2, this.expression = function(t4, e3) {
            if (Mn(t4))
              return new $n(t4, e3);
            if (Fn(t4)) {
              const r3 = jn(t4, e3);
              if (r3.result === "error")
                throw new Error(r3.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
              return r3.value;
            }
            {
              let r3 = t4;
              return typeof t4 == "string" && e3.type === "color" && (r3 = xe.parse(t4)), { kind: "constant", evaluate: () => r3 };
            }
          }(e2 === void 0 ? t3.specification.default : e2, t3.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t3, e2, r3) {
          return this.property.possiblyEvaluate(this, t3, e2, r3);
        }
      }
      class Ds {
        constructor(t3) {
          this.property = t3, this.value = new Ps(t3, void 0);
        }
        transitioned(t3, e2) {
          return new Fs(this.property, this.value, e2, v2({}, t3.transition, this.transition), t3.now);
        }
        untransitioned() {
          return new Fs(this.property, this.value, null, {}, 0);
        }
      }
      class Vs {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues);
        }
        getValue(t3) {
          return T2(this._values[t3].value.value);
        }
        setValue(t3, e2) {
          this._values.hasOwnProperty(t3) || (this._values[t3] = new Ds(this._values[t3].property)), this._values[t3].value = new Ps(this._values[t3].property, e2 === null ? void 0 : T2(e2));
        }
        getTransition(t3) {
          return T2(this._values[t3].transition);
        }
        setTransition(t3, e2) {
          this._values.hasOwnProperty(t3) || (this._values[t3] = new Ds(this._values[t3].property)), this._values[t3].transition = T2(e2) || void 0;
        }
        serialize() {
          const t3 = {};
          for (const e2 of Object.keys(this._values)) {
            const r3 = this.getValue(e2);
            r3 !== void 0 && (t3[e2] = r3);
            const n3 = this.getTransition(e2);
            n3 !== void 0 && (t3[`${e2}-transition`] = n3);
          }
          return t3;
        }
        transitioned(t3, e2) {
          const r3 = new Ls(this._properties);
          for (const n3 of Object.keys(this._values))
            r3._values[n3] = this._values[n3].transitioned(t3, e2._values[n3]);
          return r3;
        }
        untransitioned() {
          const t3 = new Ls(this._properties);
          for (const e2 of Object.keys(this._values))
            t3._values[e2] = this._values[e2].untransitioned();
          return t3;
        }
      }
      class Fs {
        constructor(t3, e2, r3, n3, i2) {
          const s2 = n3.delay || 0, a2 = n3.duration || 0;
          i2 = i2 || 0, this.property = t3, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t3.specification.transition && (n3.delay || n3.duration) && (this.prior = r3);
        }
        possiblyEvaluate(t3, e2, r3) {
          const n3 = t3.now || 0, i2 = this.value.possiblyEvaluate(t3, e2, r3), s2 = this.prior;
          if (s2) {
            if (n3 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n3 < this.begin)
              return s2.possiblyEvaluate(t3, e2, r3);
            {
              const a2 = (n3 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t3, e2, r3), i2, h(a2));
            }
          }
          return i2;
        }
      }
      class Ls {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t3, e2, r3) {
          const n3 = new js(this._properties);
          for (const i2 of Object.keys(this._values))
            n3._values[i2] = this._values[i2].possiblyEvaluate(t3, e2, r3);
          return n3;
        }
        hasTransition() {
          for (const t3 of Object.keys(this._values))
            if (this._values[t3].prior)
              return true;
          return false;
        }
      }
      class Rs {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultPropertyValues);
        }
        getValue(t3) {
          return T2(this._values[t3].value);
        }
        setValue(t3, e2) {
          this._values[t3] = new Ps(this._values[t3].property, e2 === null ? void 0 : T2(e2));
        }
        serialize() {
          const t3 = {};
          for (const e2 of Object.keys(this._values)) {
            const r3 = this.getValue(e2);
            r3 !== void 0 && (t3[e2] = r3);
          }
          return t3;
        }
        possiblyEvaluate(t3, e2, r3) {
          const n3 = new js(this._properties);
          for (const i2 of Object.keys(this._values))
            n3._values[i2] = this._values[i2].possiblyEvaluate(t3, e2, r3);
          return n3;
        }
      }
      class Us {
        constructor(t3, e2, r3) {
          this.property = t3, this.value = e2, this.parameters = r3;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t3) {
          return this.value.kind === "constant" ? this.value.value : t3;
        }
        evaluate(t3, e2, r3, n3) {
          return this.property.evaluate(this.value, this.parameters, t3, e2, r3, n3);
        }
      }
      class js {
        constructor(t3) {
          this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
        }
        get(t3) {
          return this._values[t3];
        }
      }
      class $s {
        constructor(t3) {
          this.specification = t3;
        }
        possiblyEvaluate(t3, e2) {
          return t3.expression.evaluate(e2);
        }
        interpolate(t3, e2, r3) {
          const n3 = br[this.specification.type];
          return n3 ? n3(t3, e2, r3) : t3;
        }
      }
      class Os {
        constructor(t3, e2) {
          this.specification = t3, this.overrides = e2;
        }
        possiblyEvaluate(t3, e2, r3, n3) {
          return new Us(this, t3.expression.kind === "constant" || t3.expression.kind === "camera" ? { kind: "constant", value: t3.expression.evaluate(e2, null, {}, r3, n3) } : t3.expression, e2);
        }
        interpolate(t3, e2, r3) {
          if (t3.value.kind !== "constant" || e2.value.kind !== "constant")
            return t3;
          if (t3.value.value === void 0 || e2.value.value === void 0)
            return new Us(this, { kind: "constant", value: void 0 }, t3.parameters);
          const n3 = br[this.specification.type];
          return n3 ? new Us(this, { kind: "constant", value: n3(t3.value.value, e2.value.value, r3) }, t3.parameters) : t3;
        }
        evaluate(t3, e2, r3, n3, i2, s2) {
          return t3.kind === "constant" ? t3.value : t3.evaluate(e2, r3, n3, i2, s2);
        }
      }
      class qs extends Os {
        possiblyEvaluate(t3, e2, r3, n3) {
          if (t3.value === void 0)
            return new Us(this, { kind: "constant", value: void 0 }, e2);
          if (t3.expression.kind === "constant") {
            const i2 = t3.expression.evaluate(e2, null, {}, r3, n3), s2 = t3.property.specification.type === "resolvedImage" && typeof i2 != "string" ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
            return new Us(this, { kind: "constant", value: a2 }, e2);
          }
          if (t3.expression.kind === "camera") {
            const r4 = this._calculate(t3.expression.evaluate({ zoom: e2.zoom - 1 }), t3.expression.evaluate({ zoom: e2.zoom }), t3.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
            return new Us(this, { kind: "constant", value: r4 }, e2);
          }
          return new Us(this, t3.expression, e2);
        }
        evaluate(t3, e2, r3, n3, i2, s2) {
          if (t3.kind === "source") {
            const a2 = t3.evaluate(e2, r3, n3, i2, s2);
            return this._calculate(a2, a2, a2, e2);
          }
          return t3.kind === "composite" ? this._calculate(t3.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r3, n3), t3.evaluate({ zoom: Math.floor(e2.zoom) }, r3, n3), t3.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r3, n3), e2) : t3.value;
        }
        _calculate(t3, e2, r3, n3) {
          return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e2, other: r3 } : { from: r3, to: e2, other: t3 };
        }
        interpolate(t3) {
          return t3;
        }
      }
      class Ns {
        constructor(t3) {
          this.specification = t3;
        }
        possiblyEvaluate(t3, e2, r3, n3) {
          if (t3.value !== void 0) {
            if (t3.expression.kind === "constant") {
              const i2 = t3.expression.evaluate(e2, null, {}, r3, n3);
              return this._calculate(i2, i2, i2, e2);
            }
            return this._calculate(t3.expression.evaluate(new Cs(Math.floor(e2.zoom - 1), e2)), t3.expression.evaluate(new Cs(Math.floor(e2.zoom), e2)), t3.expression.evaluate(new Cs(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }
        _calculate(t3, e2, r3, n3) {
          return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e2 } : { from: r3, to: e2 };
        }
        interpolate(t3) {
          return t3;
        }
      }
      class Gs {
        constructor(t3) {
          this.specification = t3;
        }
        possiblyEvaluate(t3, e2, r3, n3) {
          return !!t3.expression.evaluate(e2, null, {}, r3, n3);
        }
        interpolate() {
          return false;
        }
      }
      class Zs {
        constructor(t3) {
          this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const e2 = new Cs(0, {});
          for (const r3 in t3) {
            const n3 = t3[r3];
            n3.specification.overridable && this.overridableProperties.push(r3);
            const i2 = this.defaultPropertyValues[r3] = new Ps(n3, void 0), s2 = this.defaultTransitionablePropertyValues[r3] = new Ds(n3);
            this.defaultTransitioningPropertyValues[r3] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r3] = i2.possiblyEvaluate(e2);
          }
        }
      }
      function Xs(t3, e2) {
        return 256 * (t3 = d(Math.floor(t3), 0, 255)) + d(Math.floor(e2), 0, 255);
      }
      Pi2(Os, "DataDrivenProperty"), Pi2($s, "DataConstantProperty"), Pi2(qs, "CrossFadedDataDrivenProperty"), Pi2(Ns, "CrossFadedProperty"), Pi2(Gs, "ColorRampProperty");
      const Ks = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Hs {
        constructor(t3, e2) {
          this._structArray = t3, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class Ys {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t3, e2) {
          return t3._trim(), e2 && (t3.isTransferred = true, e2.push(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
        }
        static deserialize(t3) {
          const e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t3.arrayBuffer, e2.length = t3.length, e2.capacity = t3.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t3) {
          this.reserve(t3), this.length = t3;
        }
        reserve(t3) {
          if (t3 > this.capacity) {
            this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function Ws(t3, e2 = 1) {
        let r3 = 0, n3 = 0;
        return { members: t3.map((t4) => {
          const i2 = Ks[t4.type].BYTES_PER_ELEMENT, s2 = r3 = Js(r3, Math.max(e2, i2)), a2 = t4.components || 1;
          return n3 = Math.max(n3, i2), r3 += i2 * a2, { name: t4.name, type: t4.type, components: a2, offset: s2 };
        }), size: Js(r3, Math.max(n3, e2)), alignment: e2 };
      }
      function Js(t3, e2) {
        return Math.ceil(t3 / e2) * e2;
      }
      class Qs extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, t3, e2);
        }
        emplace(t3, e2, r3) {
          const n3 = 2 * t3;
          return this.int16[n3 + 0] = e2, this.int16[n3 + 1] = r3, t3;
        }
      }
      Qs.prototype.bytesPerElement = 4, Pi2(Qs, "StructArrayLayout2i4");
      class ta2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i2 = 3 * t3;
          return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r3, this.int16[i2 + 2] = n3, t3;
        }
      }
      ta2.prototype.bytesPerElement = 6, Pi2(ta2, "StructArrayLayout3i6");
      class ea2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t3, e2, r3, n3);
        }
        emplace(t3, e2, r3, n3, i2) {
          const s2 = 4 * t3;
          return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r3, this.int16[s2 + 2] = n3, this.int16[s2 + 3] = i2, t3;
        }
      }
      ea2.prototype.bytesPerElement = 8, Pi2(ea2, "StructArrayLayout4i8");
      class ra2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t3, e2, r3, n3, i2, s2, a2);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2) {
          const l3 = 6 * t3, u3 = 12 * t3, c2 = 3 * t3;
          return this.int16[l3 + 0] = e2, this.int16[l3 + 1] = r3, this.uint8[u3 + 4] = n3, this.uint8[u3 + 5] = i2, this.uint8[u3 + 6] = s2, this.uint8[u3 + 7] = a2, this.float32[c2 + 2] = o2, t3;
        }
      }
      ra2.prototype.bytesPerElement = 12, Pi2(ra2, "StructArrayLayout2i4ub1f12");
      class na2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t3, e2, r3, n3);
        }
        emplace(t3, e2, r3, n3, i2) {
          const s2 = 4 * t3;
          return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r3, this.float32[s2 + 2] = n3, this.float32[s2 + 3] = i2, t3;
        }
      }
      na2.prototype.bytesPerElement = 16, Pi2(na2, "StructArrayLayout4f16");
      class ia2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3) {
          const c2 = this.length;
          return this.resize(c2 + 1), this.emplace(c2, t3, e2, r3, n3, i2, s2, a2, o2, l3, u3);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2) {
          const h3 = 10 * t3;
          return this.uint16[h3 + 0] = e2, this.uint16[h3 + 1] = r3, this.uint16[h3 + 2] = n3, this.uint16[h3 + 3] = i2, this.uint16[h3 + 4] = s2, this.uint16[h3 + 5] = a2, this.uint16[h3 + 6] = o2, this.uint16[h3 + 7] = l3, this.uint16[h3 + 8] = u3, this.uint16[h3 + 9] = c2, t3;
        }
      }
      ia2.prototype.bytesPerElement = 20, Pi2(ia2, "StructArrayLayout10ui20");
      class sa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2, o2) {
          const l3 = this.length;
          return this.resize(l3 + 1), this.emplace(l3, t3, e2, r3, n3, i2, s2, a2, o2);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
          const u3 = 8 * t3;
          return this.uint16[u3 + 0] = e2, this.uint16[u3 + 1] = r3, this.uint16[u3 + 2] = n3, this.uint16[u3 + 3] = i2, this.uint16[u3 + 4] = s2, this.uint16[u3 + 5] = a2, this.uint16[u3 + 6] = o2, this.uint16[u3 + 7] = l3, t3;
        }
      }
      sa2.prototype.bytesPerElement = 16, Pi2(sa2, "StructArrayLayout8ui16");
      class aa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t3, e2, r3, n3, i2, s2);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2) {
          const o2 = 6 * t3;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r3, this.int16[o2 + 2] = n3, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t3;
        }
      }
      aa2.prototype.bytesPerElement = 12, Pi2(aa2, "StructArrayLayout6i12");
      class oa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3) {
          const p3 = this.length;
          return this.resize(p3 + 1), this.emplace(p3, t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3) {
          const f2 = 12 * t3;
          return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r3, this.int16[f2 + 2] = n3, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l3, this.int16[f2 + 8] = u3, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h3, this.int16[f2 + 11] = p3, t3;
        }
      }
      oa2.prototype.bytesPerElement = 24, Pi2(oa2, "StructArrayLayout4i4ui4i24");
      class la2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t3, e2, r3, n3, i2, s2);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2) {
          const o2 = 10 * t3, l3 = 5 * t3;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r3, this.int16[o2 + 2] = n3, this.float32[l3 + 2] = i2, this.float32[l3 + 3] = s2, this.float32[l3 + 4] = a2, t3;
        }
      }
      la2.prototype.bytesPerElement = 20, Pi2(la2, "StructArrayLayout3i3f20");
      class ua2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t3) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t3);
        }
        emplace(t3, e2) {
          return this.uint32[1 * t3 + 0] = e2, t3;
        }
      }
      ua2.prototype.bytesPerElement = 4, Pi2(ua2, "StructArrayLayout1ul4");
      class ca2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3) {
          const f2 = this.length;
          return this.resize(f2 + 1), this.emplace(f2, t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2) {
          const d2 = 20 * t3, y3 = 10 * t3;
          return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r3, this.int16[d2 + 2] = n3, this.int16[d2 + 3] = i2, this.int16[d2 + 4] = s2, this.float32[y3 + 3] = a2, this.float32[y3 + 4] = o2, this.float32[y3 + 5] = l3, this.float32[y3 + 6] = u3, this.int16[d2 + 14] = c2, this.uint32[y3 + 8] = h3, this.uint16[d2 + 18] = p3, this.uint16[d2 + 19] = f2, t3;
        }
      }
      ca2.prototype.bytesPerElement = 40, Pi2(ca2, "StructArrayLayout5i4f1i1ul2ui40");
      class ha2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t3, e2, r3, n3, i2, s2, a2);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2) {
          const l3 = 8 * t3;
          return this.int16[l3 + 0] = e2, this.int16[l3 + 1] = r3, this.int16[l3 + 2] = n3, this.int16[l3 + 4] = i2, this.int16[l3 + 5] = s2, this.int16[l3 + 6] = a2, this.int16[l3 + 7] = o2, t3;
        }
      }
      ha2.prototype.bytesPerElement = 16, Pi2(ha2, "StructArrayLayout3i2i2i16");
      class pa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t3, e2, r3, n3, i2);
        }
        emplace(t3, e2, r3, n3, i2, s2) {
          const a2 = 4 * t3, o2 = 8 * t3;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r3, this.float32[a2 + 2] = n3, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t3;
        }
      }
      pa2.prototype.bytesPerElement = 16, Pi2(pa2, "StructArrayLayout2f1f2i16");
      class fa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t3, e2, r3, n3);
        }
        emplace(t3, e2, r3, n3, i2) {
          const s2 = 12 * t3, a2 = 3 * t3;
          return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r3, this.float32[a2 + 1] = n3, this.float32[a2 + 2] = i2, t3;
        }
      }
      fa2.prototype.bytesPerElement = 12, Pi2(fa2, "StructArrayLayout2ub2f12");
      class da2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i2 = 3 * t3;
          return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r3, this.float32[i2 + 2] = n3, t3;
        }
      }
      da2.prototype.bytesPerElement = 12, Pi2(da2, "StructArrayLayout3f12");
      class ya2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3) {
          const n3 = this.length;
          return this.resize(n3 + 1), this.emplace(n3, t3, e2, r3);
        }
        emplace(t3, e2, r3, n3) {
          const i2 = 3 * t3;
          return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r3, this.uint16[i2 + 2] = n3, t3;
        }
      }
      ya2.prototype.bytesPerElement = 6, Pi2(ya2, "StructArrayLayout3ui6");
      class ma2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3, m3, g2, x3, v3, b2) {
          const _2 = this.length;
          return this.resize(_2 + 1), this.emplace(_2, t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3, m3, g2, x3, v3, b2);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3, m3, g2, x3, v3, b2, _2) {
          const w2 = 30 * t3, A3 = 15 * t3, S3 = 60 * t3;
          return this.int16[w2 + 0] = e2, this.int16[w2 + 1] = r3, this.int16[w2 + 2] = n3, this.float32[A3 + 2] = i2, this.float32[A3 + 3] = s2, this.uint16[w2 + 8] = a2, this.uint16[w2 + 9] = o2, this.uint32[A3 + 5] = l3, this.uint32[A3 + 6] = u3, this.uint32[A3 + 7] = c2, this.uint16[w2 + 16] = h3, this.uint16[w2 + 17] = p3, this.uint16[w2 + 18] = f2, this.float32[A3 + 10] = d2, this.float32[A3 + 11] = y3, this.uint8[S3 + 48] = m3, this.uint8[S3 + 49] = g2, this.uint8[S3 + 50] = x3, this.uint32[A3 + 13] = v3, this.int16[w2 + 28] = b2, this.uint8[S3 + 58] = _2, t3;
        }
      }
      ma2.prototype.bytesPerElement = 60, Pi2(ma2, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class ga extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3, m3, g2, x3, v3, b2, _2, w2, A3, S3, k2, I3, M3, z3, T3) {
          const B3 = this.length;
          return this.resize(B3 + 1), this.emplace(B3, t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3, m3, g2, x3, v3, b2, _2, w2, A3, S3, k2, I3, M3, z3, T3);
        }
        emplace(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3, m3, g2, x3, v3, b2, _2, w2, A3, S3, k2, I3, M3, z3, T3, B3) {
          const E3 = 38 * t3, C3 = 19 * t3;
          return this.int16[E3 + 0] = e2, this.int16[E3 + 1] = r3, this.int16[E3 + 2] = n3, this.float32[C3 + 2] = i2, this.float32[C3 + 3] = s2, this.int16[E3 + 8] = a2, this.int16[E3 + 9] = o2, this.int16[E3 + 10] = l3, this.int16[E3 + 11] = u3, this.int16[E3 + 12] = c2, this.int16[E3 + 13] = h3, this.uint16[E3 + 14] = p3, this.uint16[E3 + 15] = f2, this.uint16[E3 + 16] = d2, this.uint16[E3 + 17] = y3, this.uint16[E3 + 18] = m3, this.uint16[E3 + 19] = g2, this.uint16[E3 + 20] = x3, this.uint16[E3 + 21] = v3, this.uint16[E3 + 22] = b2, this.uint16[E3 + 23] = _2, this.uint16[E3 + 24] = w2, this.uint16[E3 + 25] = A3, this.uint16[E3 + 26] = S3, this.uint16[E3 + 27] = k2, this.uint16[E3 + 28] = I3, this.uint32[C3 + 15] = M3, this.float32[C3 + 16] = z3, this.float32[C3 + 17] = T3, this.float32[C3 + 18] = B3, t3;
        }
      }
      ga.prototype.bytesPerElement = 76, Pi2(ga, "StructArrayLayout3i2f6i15ui1ul3f76");
      class xa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t3);
        }
        emplace(t3, e2) {
          return this.float32[1 * t3 + 0] = e2, t3;
        }
      }
      xa2.prototype.bytesPerElement = 4, Pi2(xa2, "StructArrayLayout1f4");
      class va extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t3, e2, r3, n3, i2);
        }
        emplace(t3, e2, r3, n3, i2, s2) {
          const a2 = 5 * t3;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r3, this.float32[a2 + 2] = n3, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t3;
        }
      }
      va.prototype.bytesPerElement = 20, Pi2(va, "StructArrayLayout5f20");
      class ba2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2, r3, n3) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t3, e2, r3, n3);
        }
        emplace(t3, e2, r3, n3, i2) {
          const s2 = 6 * t3;
          return this.uint32[3 * t3 + 0] = e2, this.uint16[s2 + 2] = r3, this.uint16[s2 + 3] = n3, this.uint16[s2 + 4] = i2, t3;
        }
      }
      ba2.prototype.bytesPerElement = 12, Pi2(ba2, "StructArrayLayout1ul3ui12");
      class _a extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, t3, e2);
        }
        emplace(t3, e2, r3) {
          const n3 = 2 * t3;
          return this.uint16[n3 + 0] = e2, this.uint16[n3 + 1] = r3, t3;
        }
      }
      _a.prototype.bytesPerElement = 4, Pi2(_a, "StructArrayLayout2ui4");
      class wa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t3) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t3);
        }
        emplace(t3, e2) {
          return this.uint16[1 * t3 + 0] = e2, t3;
        }
      }
      wa2.prototype.bytesPerElement = 2, Pi2(wa2, "StructArrayLayout1ui2");
      class Aa2 extends Ys {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t3, e2) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, t3, e2);
        }
        emplace(t3, e2, r3) {
          const n3 = 2 * t3;
          return this.float32[n3 + 0] = e2, this.float32[n3 + 1] = r3, t3;
        }
      }
      Aa2.prototype.bytesPerElement = 8, Pi2(Aa2, "StructArrayLayout2f8");
      class Sa2 extends Hs {
        get a_pos_30() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get a_pos_31() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get a_pos_32() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get a_pos_normal_30() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get a_pos_normal_31() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get a_pos_normal_32() {
          return this._structArray.int16[this._pos2 + 5];
        }
      }
      Sa2.prototype.size = 12;
      class ka2 extends aa2 {
        get(t3) {
          return new Sa2(this, t3);
        }
      }
      Pi2(ka2, "FillExtrusionExtArray");
      class Ia2 extends Hs {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      Ia2.prototype.size = 40;
      class Ma2 extends ca2 {
        get(t3) {
          return new Ia2(this, t3);
        }
      }
      Pi2(Ma2, "CollisionBoxArray");
      class za2 extends Hs {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(t3) {
          this._structArray.uint8[this._pos1 + 49] = t3;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(t3) {
          this._structArray.uint8[this._pos1 + 50] = t3;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(t3) {
          this._structArray.uint32[this._pos4 + 13] = t3;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(t3) {
          this._structArray.uint8[this._pos1 + 58] = t3;
        }
      }
      za2.prototype.size = 60;
      class Ta2 extends ma2 {
        get(t3) {
          return new za2(this, t3);
        }
      }
      Pi2(Ta2, "PlacedSymbolArray");
      class Ba2 extends Hs {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 13];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 28];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 15];
        }
        set crossTileID(t3) {
          this._structArray.uint32[this._pos4 + 15] = t3;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 18];
        }
      }
      Ba2.prototype.size = 76;
      class Ea2 extends ga {
        get(t3) {
          return new Ba2(this, t3);
        }
      }
      Pi2(Ea2, "SymbolInstanceArray");
      class Ca2 extends xa2 {
        getoffsetX(t3) {
          return this.float32[1 * t3 + 0];
        }
      }
      Pi2(Ca2, "GlyphOffsetArray");
      class Pa2 extends ta2 {
        getx(t3) {
          return this.int16[3 * t3 + 0];
        }
        gety(t3) {
          return this.int16[3 * t3 + 1];
        }
        gettileUnitDistanceFromAnchor(t3) {
          return this.int16[3 * t3 + 2];
        }
      }
      Pi2(Pa2, "SymbolLineVertexArray");
      class Da2 extends Hs {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      Da2.prototype.size = 12;
      class Va2 extends ba2 {
        get(t3) {
          return new Da2(this, t3);
        }
      }
      Pi2(Va2, "FeatureIndexArray");
      class Fa2 extends Hs {
        get a_centroid_pos0() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get a_centroid_pos1() {
          return this._structArray.uint16[this._pos2 + 1];
        }
      }
      Fa2.prototype.size = 4;
      class La2 extends _a {
        get(t3) {
          return new Fa2(this, t3);
        }
      }
      Pi2(La2, "FillExtrusionCentroidArray");
      class Ra2 extends Hs {
        get a_pos_30() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get a_pos_31() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get a_pos_32() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get a_pos_normal_30() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get a_pos_normal_31() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get a_pos_normal_32() {
          return this._structArray.int16[this._pos2 + 5];
        }
      }
      Ra2.prototype.size = 12;
      class Ua2 extends aa2 {
        get(t3) {
          return new Ra2(this, t3);
        }
      }
      Pi2(Ua2, "CircleGlobeExtArray");
      const ja2 = Ws([{ name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }]), $a2 = Ws([{ name: "a_dash_to", components: 4, type: "Uint16" }, { name: "a_dash_from", components: 4, type: "Uint16" }]);
      var Oa2 = ye(function(t3) {
        t3.exports = function(t4, e2) {
          var r3, n3, i2, s2, a2, o2, l3, u3;
          for (n3 = t4.length - (r3 = 3 & t4.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u3 = 0; u3 < n3; )
            l3 = 255 & t4.charCodeAt(u3) | (255 & t4.charCodeAt(++u3)) << 8 | (255 & t4.charCodeAt(++u3)) << 16 | (255 & t4.charCodeAt(++u3)) << 24, ++u3, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l3 = 0, r3) {
            case 3:
              l3 ^= (255 & t4.charCodeAt(u3 + 2)) << 16;
            case 2:
              l3 ^= (255 & t4.charCodeAt(u3 + 1)) << 8;
            case 1:
              i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & t4.charCodeAt(u3))) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t4.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
      }), qa2 = ye(function(t3) {
        t3.exports = function(t4, e2) {
          for (var r3, n3 = t4.length, i2 = e2 ^ n3, s2 = 0; n3 >= 4; )
            r3 = 1540483477 * (65535 & (r3 = 255 & t4.charCodeAt(s2) | (255 & t4.charCodeAt(++s2)) << 8 | (255 & t4.charCodeAt(++s2)) << 16 | (255 & t4.charCodeAt(++s2)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), n3 -= 4, ++s2;
          switch (n3) {
            case 3:
              i2 ^= (255 & t4.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t4.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t4.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
      }), Na2 = Oa2, Ga2 = qa2;
      Na2.murmur3 = Oa2, Na2.murmur2 = Ga2;
      class Za2 {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(t3, e2, r3, n3) {
          this.ids.push(Xa2(t3)), this.positions.push(e2, r3, n3);
        }
        getPositions(t3) {
          const e2 = Xa2(t3);
          let r3 = 0, n3 = this.ids.length - 1;
          for (; r3 < n3; ) {
            const t4 = r3 + n3 >> 1;
            this.ids[t4] >= e2 ? n3 = t4 : r3 = t4 + 1;
          }
          const i2 = [];
          for (; this.ids[r3] === e2; )
            i2.push({ index: this.positions[3 * r3], start: this.positions[3 * r3 + 1], end: this.positions[3 * r3 + 2] }), r3++;
          return i2;
        }
        static serialize(t3, e2) {
          const r3 = new Float64Array(t3.ids), n3 = new Uint32Array(t3.positions);
          return Ka2(r3, n3, 0, r3.length - 1), e2 && e2.push(r3.buffer, n3.buffer), { ids: r3, positions: n3 };
        }
        static deserialize(t3) {
          const e2 = new Za2();
          return e2.ids = t3.ids, e2.positions = t3.positions, e2.indexed = true, e2;
        }
      }
      function Xa2(t3) {
        const e2 = +t3;
        return !isNaN(e2) && Number.MIN_SAFE_INTEGER <= e2 && e2 <= Number.MAX_SAFE_INTEGER ? e2 : Na2(String(t3));
      }
      function Ka2(t3, e2, r3, n3) {
        for (; r3 < n3; ) {
          const i2 = t3[r3 + n3 >> 1];
          let s2 = r3 - 1, a2 = n3 + 1;
          for (; ; ) {
            do {
              s2++;
            } while (t3[s2] < i2);
            do {
              a2--;
            } while (t3[a2] > i2);
            if (s2 >= a2)
              break;
            Ha2(t3, s2, a2), Ha2(e2, 3 * s2, 3 * a2), Ha2(e2, 3 * s2 + 1, 3 * a2 + 1), Ha2(e2, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r3 < n3 - a2 ? (Ka2(t3, e2, r3, a2), r3 = a2 + 1) : (Ka2(t3, e2, a2 + 1, n3), n3 = a2);
        }
      }
      function Ha2(t3, e2, r3) {
        const n3 = t3[e2];
        t3[e2] = t3[r3], t3[r3] = n3;
      }
      Pi2(Za2, "FeaturePositionMap");
      class Ya2 {
        constructor(t3) {
          this.gl = t3.gl, this.initialized = false;
        }
        fetchUniformLocation(t3, e2) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t3, e2), this.initialized = true), !!this.location;
        }
      }
      class Wa2 extends Ya2 {
        constructor(t3) {
          super(t3), this.current = 0;
        }
        set(t3, e2, r3) {
          this.fetchUniformLocation(t3, e2) && this.current !== r3 && (this.current = r3, this.gl.uniform1f(this.location, r3));
        }
      }
      class Ja2 extends Ya2 {
        constructor(t3) {
          super(t3), this.current = [0, 0, 0, 0];
        }
        set(t3, e2, r3) {
          this.fetchUniformLocation(t3, e2) && (r3[0] === this.current[0] && r3[1] === this.current[1] && r3[2] === this.current[2] && r3[3] === this.current[3] || (this.current = r3, this.gl.uniform4f(this.location, r3[0], r3[1], r3[2], r3[3])));
        }
      }
      class Qa2 extends Ya2 {
        constructor(t3) {
          super(t3), this.current = xe.transparent;
        }
        set(t3, e2, r3) {
          this.fetchUniformLocation(t3, e2) && (r3.r === this.current.r && r3.g === this.current.g && r3.b === this.current.b && r3.a === this.current.a || (this.current = r3, this.gl.uniform4f(this.location, r3.r, r3.g, r3.b, r3.a)));
        }
      }
      const to2 = new Float32Array(16), eo = new Float32Array(9), ro = new Float32Array(4);
      function no(t3) {
        return [Xs(255 * t3.r, 255 * t3.g), Xs(255 * t3.b, 255 * t3.a)];
      }
      class io {
        constructor(t3, e2, r3) {
          this.value = t3, this.uniformNames = e2.map((t4) => `u_${t4}`), this.type = r3;
        }
        setUniform(t3, e2, r3, n3, i2) {
          e2.set(t3, i2, n3.constantOr(this.value));
        }
        getBinding(t3, e2) {
          return this.type === "color" ? new Qa2(t3) : new Wa2(t3);
        }
      }
      class so {
        constructor(t3, e2) {
          this.uniformNames = e2.map((t4) => `u_${t4}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t3, e2) {
          this.pixelRatioFrom = e2.pixelRatio || 1, this.pixelRatioTo = t3.pixelRatio || 1, this.patternFrom = e2.tl.concat(e2.br), this.patternTo = t3.tl.concat(t3.br);
        }
        setUniform(t3, e2, r3, n3, i2) {
          const s2 = i2 === "u_pattern_to" || i2 === "u_dash_to" ? this.patternTo : i2 === "u_pattern_from" || i2 === "u_dash_from" ? this.patternFrom : i2 === "u_pixel_ratio_to" ? this.pixelRatioTo : i2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          s2 && e2.set(t3, i2, s2);
        }
        getBinding(t3, e2) {
          return e2 === "u_pattern_from" || e2 === "u_pattern_to" || e2 === "u_dash_from" || e2 === "u_dash_to" ? new Ja2(t3) : new Wa2(t3);
        }
      }
      class ao {
        constructor(t3, e2, r3, n3) {
          this.expression = t3, this.type = r3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: r3 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
        }
        populatePaintArray(t3, e2, r3, n3, i2, s2) {
          const a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new Cs(0), e2, {}, i2, n3, s2);
          this.paintVertexArray.resize(t3), this._setPaintValue(a2, t3, o2);
        }
        updatePaintArray(t3, e2, r3, n3, i2) {
          const s2 = this.expression.evaluate({ zoom: 0 }, r3, n3, void 0, i2);
          this._setPaintValue(t3, e2, s2);
        }
        _setPaintValue(t3, e2, r3) {
          if (this.type === "color") {
            const n3 = no(r3);
            for (let r4 = t3; r4 < e2; r4++)
              this.paintVertexArray.emplace(r4, n3[0], n3[1]);
          } else {
            for (let n3 = t3; n3 < e2; n3++)
              this.paintVertexArray.emplace(n3, r3);
            this.maxValue = Math.max(this.maxValue, Math.abs(r3));
          }
        }
        upload(t3) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class oo {
        constructor(t3, e2, r3, n3, i2, s2) {
          this.expression = t3, this.uniformNames = e2.map((t4) => `u_${t4}_t`), this.type = r3, this.useIntegerZoom = n3, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: r3 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
        }
        populatePaintArray(t3, e2, r3, n3, i2, s2) {
          const a2 = this.expression.evaluate(new Cs(this.zoom), e2, {}, i2, n3, s2), o2 = this.expression.evaluate(new Cs(this.zoom + 1), e2, {}, i2, n3, s2), l3 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t3), this._setPaintValue(l3, t3, a2, o2);
        }
        updatePaintArray(t3, e2, r3, n3, i2) {
          const s2 = this.expression.evaluate({ zoom: this.zoom }, r3, n3, void 0, i2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r3, n3, void 0, i2);
          this._setPaintValue(t3, e2, s2, a2);
        }
        _setPaintValue(t3, e2, r3, n3) {
          if (this.type === "color") {
            const i2 = no(r3), s2 = no(n3);
            for (let r4 = t3; r4 < e2; r4++)
              this.paintVertexArray.emplace(r4, i2[0], i2[1], s2[0], s2[1]);
          } else {
            for (let i2 = t3; i2 < e2; i2++)
              this.paintVertexArray.emplace(i2, r3, n3);
            this.maxValue = Math.max(this.maxValue, Math.abs(r3), Math.abs(n3));
          }
        }
        upload(t3) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t3, e2, r3, n3, i2) {
          const s2 = this.useIntegerZoom ? Math.floor(r3.zoom) : r3.zoom, a2 = d(this.expression.interpolationFactor(s2, this.zoom, this.zoom + 1), 0, 1);
          e2.set(t3, i2, a2);
        }
        getBinding(t3, e2) {
          return new Wa2(t3);
        }
      }
      class lo {
        constructor(t3, e2, r3, n3, i2, s2, a2) {
          this.expression = t3, this.type = r3, this.useIntegerZoom = n3, this.zoom = i2, this.layerId = a2, this.paintVertexAttributes = (r3 === "array" ? $a2 : ja2).members;
          for (let t4 = 0; t4 < e2.length; ++t4)
            ;
          this.zoomInPaintVertexArray = new s2(), this.zoomOutPaintVertexArray = new s2();
        }
        populatePaintArray(t3, e2, r3) {
          const n3 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t3), this.zoomOutPaintVertexArray.resize(t3), this._setPaintValues(n3, t3, e2.patterns && e2.patterns[this.layerId], r3);
        }
        updatePaintArray(t3, e2, r3, n3, i2, s2) {
          this._setPaintValues(t3, e2, r3.patterns && r3.patterns[this.layerId], s2);
        }
        _setPaintValues(t3, e2, r3, n3) {
          if (!n3 || !r3)
            return;
          const { min: i2, mid: s2, max: a2 } = r3, o2 = n3[i2], l3 = n3[s2], u3 = n3[a2];
          if (o2 && l3 && u3)
            for (let r4 = t3; r4 < e2; r4++)
              this._setPaintValue(this.zoomInPaintVertexArray, r4, l3, o2), this._setPaintValue(this.zoomOutPaintVertexArray, r4, l3, u3);
        }
        _setPaintValue(t3, e2, r3, n3) {
          t3.emplace(e2, r3.tl[0], r3.tl[1], r3.br[0], r3.br[1], n3.tl[0], n3.tl[1], n3.br[0], n3.br[1], r3.pixelRatio, n3.pixelRatio);
        }
        upload(t3) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t3.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t3.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class uo {
        constructor(t3, e2, r3 = () => true) {
          this.binders = {}, this._buffers = [];
          const n3 = [];
          for (const i2 in t3.paint._values) {
            if (!r3(i2))
              continue;
            const s2 = t3.paint.get(i2);
            if (!(s2 instanceof Us && An(s2.property.specification)))
              continue;
            const a2 = po(i2, t3.type), o2 = s2.value, l3 = s2.property.specification.type, u3 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h3 = c2 === "cross-faded" || c2 === "cross-faded-data-driven", p3 = String(i2) === "line-dasharray" && t3.layout.get("line-cap").value.kind !== "constant";
            if (o2.kind !== "constant" || p3)
              if (o2.kind === "source" || p3 || h3) {
                const r4 = mo(i2, l3, "source");
                this.binders[i2] = h3 ? new lo(o2, a2, l3, u3, e2, r4, t3.id) : new ao(o2, a2, l3, r4), n3.push(`/a_${i2}`);
              } else {
                const t4 = mo(i2, l3, "composite");
                this.binders[i2] = new oo(o2, a2, l3, u3, e2, t4), n3.push(`/z_${i2}`);
              }
            else
              this.binders[i2] = h3 ? new so(o2.value, a2) : new io(o2.value, a2, l3), n3.push(`/u_${i2}`);
          }
          this.cacheKey = n3.sort().join("");
        }
        getMaxValue(t3) {
          const e2 = this.binders[t3];
          return e2 instanceof ao || e2 instanceof oo ? e2.maxValue : 0;
        }
        populatePaintArrays(t3, e2, r3, n3, i2, s2) {
          for (const a2 in this.binders) {
            const o2 = this.binders[a2];
            (o2 instanceof ao || o2 instanceof oo || o2 instanceof lo) && o2.populatePaintArray(t3, e2, r3, n3, i2, s2);
          }
        }
        setConstantPatternPositions(t3, e2) {
          for (const r3 in this.binders) {
            const n3 = this.binders[r3];
            n3 instanceof so && n3.setConstantPatternPositions(t3, e2);
          }
        }
        updatePaintArrays(t3, e2, r3, n3, i2, s2) {
          let a2 = false;
          for (const o2 in t3) {
            const l3 = e2.getPositions(o2);
            for (const e3 of l3) {
              const l4 = r3.feature(e3.index);
              for (const r4 in this.binders) {
                const u3 = this.binders[r4];
                if ((u3 instanceof ao || u3 instanceof oo || u3 instanceof lo) && u3.expression.isStateDependent === true) {
                  const c2 = n3.paint.get(r4);
                  u3.expression = c2.value, u3.updatePaintArray(e3.start, e3.end, l4, t3[o2], i2, s2), a2 = true;
                }
              }
            }
          }
          return a2;
        }
        defines() {
          const t3 = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            (r3 instanceof io || r3 instanceof so) && t3.push(...r3.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
          }
          return t3;
        }
        getBinderAttributes() {
          const t3 = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            if (r3 instanceof ao || r3 instanceof oo || r3 instanceof lo)
              for (let e3 = 0; e3 < r3.paintVertexAttributes.length; e3++)
                t3.push(r3.paintVertexAttributes[e3].name);
          }
          return t3;
        }
        getBinderUniforms() {
          const t3 = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            if (r3 instanceof io || r3 instanceof so || r3 instanceof oo)
              for (const e3 of r3.uniformNames)
                t3.push(e3);
          }
          return t3;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t3) {
          const e2 = [];
          for (const r3 in this.binders) {
            const n3 = this.binders[r3];
            if (n3 instanceof io || n3 instanceof so || n3 instanceof oo)
              for (const i2 of n3.uniformNames)
                e2.push({ name: i2, property: r3, binding: n3.getBinding(t3, i2) });
          }
          return e2;
        }
        setUniforms(t3, e2, r3, n3, i2) {
          for (const { name: e3, property: s2, binding: a2 } of r3)
            this.binders[s2].setUniform(t3, a2, i2, n3.get(s2), e3);
        }
        updatePaintBuffers(t3) {
          this._buffers = [];
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            if (t3 && r3 instanceof lo) {
              const e3 = t3.fromScale === 2 ? r3.zoomInPaintVertexBuffer : r3.zoomOutPaintVertexBuffer;
              e3 && this._buffers.push(e3);
            } else
              (r3 instanceof ao || r3 instanceof oo) && r3.paintVertexBuffer && this._buffers.push(r3.paintVertexBuffer);
          }
        }
        upload(t3) {
          for (const e2 in this.binders) {
            const r3 = this.binders[e2];
            (r3 instanceof ao || r3 instanceof oo || r3 instanceof lo) && r3.upload(t3);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t3 in this.binders) {
            const e2 = this.binders[t3];
            (e2 instanceof ao || e2 instanceof oo || e2 instanceof lo) && e2.destroy();
          }
        }
      }
      class co {
        constructor(t3, e2, r3 = () => true) {
          this.programConfigurations = {};
          for (const n3 of t3)
            this.programConfigurations[n3.id] = new uo(n3, e2, r3);
          this.needsUpload = false, this._featureMap = new Za2(), this._bufferOffset = 0;
        }
        populatePaintArrays(t3, e2, r3, n3, i2, s2, a2) {
          for (const r4 in this.programConfigurations)
            this.programConfigurations[r4].populatePaintArrays(t3, e2, n3, i2, s2, a2);
          e2.id !== void 0 && this._featureMap.add(e2.id, r3, this._bufferOffset, t3), this._bufferOffset = t3, this.needsUpload = true;
        }
        updatePaintArrays(t3, e2, r3, n3, i2) {
          for (const s2 of r3)
            this.needsUpload = this.programConfigurations[s2.id].updatePaintArrays(t3, this._featureMap, e2, s2, n3, i2) || this.needsUpload;
        }
        get(t3) {
          return this.programConfigurations[t3];
        }
        upload(t3) {
          if (this.needsUpload) {
            for (const e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t3);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t3 in this.programConfigurations)
            this.programConfigurations[t3].destroy();
        }
      }
      const ho = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "line-dasharray": ["dash_to", "dash_from"] };
      function po(t3, e2) {
        return ho[t3] || [t3.replace(`${e2}-`, "").replace(/-/g, "_")];
      }
      const fo = { "line-pattern": { source: ia2, composite: ia2 }, "fill-pattern": { source: ia2, composite: ia2 }, "fill-extrusion-pattern": { source: ia2, composite: ia2 }, "line-dasharray": { source: sa2, composite: sa2 } }, yo = { color: { source: Aa2, composite: na2 }, number: { source: xa2, composite: Aa2 } };
      function mo(t3, e2, r3) {
        const n3 = fo[t3];
        return n3 && n3[r3] || yo[e2][r3];
      }
      Pi2(io, "ConstantBinder"), Pi2(so, "CrossFadedConstantBinder"), Pi2(ao, "SourceExpressionBinder"), Pi2(lo, "CrossFadedCompositeBinder"), Pi2(oo, "CompositeExpressionBinder"), Pi2(uo, "ProgramConfiguration", { omit: ["_buffers"] }), Pi2(co, "ProgramConfigurationSet");
      const go = "-transition";
      class xo extends Nt {
        constructor(t3, e2) {
          if (super(), this.id = t3.id, this.type = t3.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, t3.type !== "custom" && (this.metadata = (t3 = t3).metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, t3.type !== "background" && t3.type !== "sky" && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), e2.layout && (this._unevaluatedLayout = new Rs(e2.layout)), e2.paint)) {
            this._transitionablePaint = new Vs(e2.paint);
            for (const e3 in t3.paint)
              this.setPaintProperty(e3, t3.paint[e3], { validate: false });
            for (const e3 in t3.layout)
              this.setLayoutProperty(e3, t3.layout[e3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new js(e2.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t3) {
          return t3 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t3);
        }
        setLayoutProperty(t3, e2, r3 = {}) {
          e2 != null && this._validate(Mi2, `layers.${this.id}.layout.${t3}`, t3, e2, r3) || (t3 !== "visibility" ? this._unevaluatedLayout.setValue(t3, e2) : this.visibility = e2);
        }
        getPaintProperty(t3) {
          return I2(t3, go) ? this._transitionablePaint.getTransition(t3.slice(0, -go.length)) : this._transitionablePaint.getValue(t3);
        }
        setPaintProperty(t3, e2, r3 = {}) {
          if (e2 != null && this._validate(Ii2, `layers.${this.id}.paint.${t3}`, t3, e2, r3))
            return false;
          if (I2(t3, go))
            return this._transitionablePaint.setTransition(t3.slice(0, -go.length), e2 || void 0), false;
          {
            const r4 = this._transitionablePaint._values[t3], n3 = r4.property.specification["property-type"] === "cross-faded-data-driven", i2 = r4.value.isDataDriven(), s2 = r4.value;
            this._transitionablePaint.setValue(t3, e2), this._handleSpecialPaintPropertyUpdate(t3);
            const a2 = this._transitionablePaint._values[t3].value;
            return a2.isDataDriven() || i2 || n3 || this._handleOverridablePaintPropertyUpdate(t3, s2, a2);
          }
        }
        _handleSpecialPaintPropertyUpdate(t3) {
        }
        getProgramIds() {
          return null;
        }
        getProgramConfiguration(t3) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(t3, e2, r3) {
          return false;
        }
        isHidden(t3) {
          return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t3) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t3, e2) {
          t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e2);
        }
        serialize() {
          const t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), z2(t3, (t4, e2) => !(t4 === void 0 || e2 === "layout" && !Object.keys(t4).length || e2 === "paint" && !Object.keys(t4).length));
        }
        _validate(t3, e2, r3, n3, i2 = {}) {
          return (!i2 || i2.validate !== false) && Ti2(this, t3.call(ki2, { key: e2, layerType: this.type, objectKey: r3, value: n3, styleSpec: Gt, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const t3 in this.paint._values) {
            const e2 = this.paint.get(t3);
            if (e2 instanceof Us && An(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
              return true;
          }
          return false;
        }
        compileFilter() {
          this._filterCompiled || (this._featureFilter = Jn(this.filter), this._filterCompiled = true);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = false;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
      }
      const vo = Ws([{ name: "a_pos", components: 2, type: "Int16" }], 4), bo = Ws([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class _o {
        constructor(t3 = []) {
          this.segments = t3;
        }
        prepareSegment(t3, e2, r3, n3) {
          let i2 = this.segments[this.segments.length - 1];
          return t3 > _o.MAX_VERTEX_ARRAY_LENGTH && E2(`Max vertices per segment is ${_o.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i2 || i2.vertexLength + t3 > _o.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n3) && (i2 = { vertexOffset: e2.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0 }, n3 !== void 0 && (i2.sortKey = n3), this.segments.push(i2)), i2;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t3 of this.segments)
            for (const e2 in t3.vaos)
              t3.vaos[e2].destroy();
        }
        static simpleSegment(t3, e2, r3, n3) {
          return new _o([{ vertexOffset: t3, primitiveOffset: e2, vertexLength: r3, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
        }
      }
      _o.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Pi2(_o, "SegmentVector");
      var wo = 8192;
      class Ao {
        constructor(t3, e2) {
          t3 && (e2 ? this.setSouthWest(t3).setNorthEast(e2) : t3.length === 4 ? this.setSouthWest([t3[0], t3[1]]).setNorthEast([t3[2], t3[3]]) : this.setSouthWest(t3[0]).setNorthEast(t3[1]));
        }
        setNorthEast(t3) {
          return this._ne = t3 instanceof ko ? new ko(t3.lng, t3.lat) : ko.convert(t3), this;
        }
        setSouthWest(t3) {
          return this._sw = t3 instanceof ko ? new ko(t3.lng, t3.lat) : ko.convert(t3), this;
        }
        extend(t3) {
          const e2 = this._sw, r3 = this._ne;
          let n3, i2;
          if (t3 instanceof ko)
            n3 = t3, i2 = t3;
          else {
            if (!(t3 instanceof Ao))
              return Array.isArray(t3) ? t3.length === 4 || t3.every(Array.isArray) ? this.extend(Ao.convert(t3)) : this.extend(ko.convert(t3)) : this;
            if (n3 = t3._sw, i2 = t3._ne, !n3 || !i2)
              return this;
          }
          return e2 || r3 ? (e2.lng = Math.min(n3.lng, e2.lng), e2.lat = Math.min(n3.lat, e2.lat), r3.lng = Math.max(i2.lng, r3.lng), r3.lat = Math.max(i2.lat, r3.lat)) : (this._sw = new ko(n3.lng, n3.lat), this._ne = new ko(i2.lng, i2.lat)), this;
        }
        getCenter() {
          return new ko((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new ko(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new ko(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t3) {
          const { lng: e2, lat: r3 } = ko.convert(t3);
          let n3 = this._sw.lng <= e2 && e2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (n3 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r3 && r3 <= this._ne.lat && n3;
        }
        static convert(t3) {
          return !t3 || t3 instanceof Ao ? t3 : new Ao(t3);
        }
      }
      const So = 63710088e-1;
      class ko {
        constructor(t3, e2) {
          if (isNaN(t3) || isNaN(e2))
            throw new Error(`Invalid LngLat object: (${t3}, ${e2})`);
          if (this.lng = +t3, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new ko(m2(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t3) {
          const e2 = Math.PI / 180, r3 = this.lat * e2, n3 = t3.lat * e2, i2 = Math.sin(r3) * Math.sin(n3) + Math.cos(r3) * Math.cos(n3) * Math.cos((t3.lng - this.lng) * e2);
          return So * Math.acos(Math.min(i2, 1));
        }
        toBounds(t3 = 0) {
          const e2 = 360 * t3 / 40075017, r3 = e2 / Math.cos(Math.PI / 180 * this.lat);
          return new Ao(new ko(this.lng - r3, this.lat - e2), new ko(this.lng + r3, this.lat + e2));
        }
        static convert(t3) {
          if (t3 instanceof ko)
            return t3;
          if (Array.isArray(t3) && (t3.length === 2 || t3.length === 3))
            return new ko(Number(t3[0]), Number(t3[1]));
          if (!Array.isArray(t3) && typeof t3 == "object" && t3 !== null)
            return new ko(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Io = 2 * Math.PI * So;
      function Mo(t3) {
        return Io * Math.cos(t3 * Math.PI / 180);
      }
      function zo(t3) {
        return (180 + t3) / 360;
      }
      function To(t3) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
      }
      function Bo(t3, e2) {
        return t3 / Mo(e2);
      }
      function Eo(t3) {
        return 360 * t3 - 180;
      }
      function Co(t3) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
      }
      function Po(t3, e2) {
        return t3 * Mo(Co(e2));
      }
      const Do = 85.051129;
      function Vo(t3) {
        return 1 / Math.cos(t3 * Math.PI / 180);
      }
      class Fo {
        constructor(t3, e2, r3 = 0) {
          this.x = +t3, this.y = +e2, this.z = +r3;
        }
        static fromLngLat(t3, e2 = 0) {
          const r3 = ko.convert(t3);
          return new Fo(zo(r3.lng), To(r3.lat), Bo(e2, r3.lat));
        }
        toLngLat() {
          return new ko(Eo(this.x), Co(this.y));
        }
        toAltitude() {
          return Po(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Io * Vo(Co(this.y));
        }
      }
      function Lo(t3, e2, r3, n3, s2, a2, o2, l3, u3) {
        const c2 = (e2 + n3) / 2, h3 = (r3 + s2) / 2, p3 = new i(c2, h3);
        l3(p3), function(t4, e3, r4, n4, i2, s3) {
          const a3 = r4 - i2, o3 = n4 - s3;
          return Math.abs((n4 - e3) * a3 - (r4 - t4) * o3) / Math.hypot(a3, o3);
        }(p3.x, p3.y, a2.x, a2.y, o2.x, o2.y) >= u3 ? (Lo(t3, e2, r3, c2, h3, a2, p3, l3, u3), Lo(t3, c2, h3, n3, s2, p3, o2, l3, u3)) : t3.push(o2);
      }
      function Ro(t3, e2, r3) {
        let n3 = t3[0], i2 = n3.x, s2 = n3.y;
        e2(n3);
        const a2 = [n3];
        for (let o2 = 1; o2 < t3.length; o2++) {
          const l3 = t3[o2], { x: u3, y: c2 } = l3;
          e2(l3), Lo(a2, i2, s2, u3, c2, n3, l3, e2, r3), i2 = u3, s2 = c2, n3 = l3;
        }
        return a2;
      }
      function Uo(t3, e2, r3, n3, i2) {
        if (i2(e2, r3)) {
          const s2 = e2.add(r3).mult(0.5);
          n3(s2), Uo(t3, e2, s2, n3, i2), Uo(t3, s2, r3, n3, i2);
        } else
          t3.push(r3);
      }
      function jo(t3, e2, r3) {
        let n3 = t3[0];
        e2(n3);
        const i2 = [n3];
        for (let s2 = 1; s2 < t3.length; s2++) {
          const a2 = t3[s2];
          e2(a2), Uo(i2, n3, a2, e2, r3), n3 = a2;
        }
        return i2;
      }
      const $o = Math.pow(2, 14) - 1, Oo = -$o - 1;
      function qo(t3, e2) {
        const r3 = Math.round(t3.x * e2), n3 = Math.round(t3.y * e2);
        return t3.x = d(r3, Oo, $o), t3.y = d(n3, Oo, $o), (r3 < t3.x || r3 > t3.x + 1 || n3 < t3.y || n3 > t3.y + 1) && E2("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t3;
      }
      function No(t3, e2, r3) {
        const n3 = t3.loadGeometry(), i2 = t3.extent, s2 = wo / i2;
        if (e2 && r3 && r3.projection.isReprojectedInTileSpace) {
          const s3 = 1 << e2.z, { scale: a2, x: o2, y: l3, projection: u3 } = r3, c2 = (t4) => {
            const r4 = Eo((e2.x + t4.x / i2) / s3), n4 = Co((e2.y + t4.y / i2) / s3), c3 = u3.project(r4, n4);
            t4.x = (c3.x * a2 - o2) * i2, t4.y = (c3.y * a2 - l3) * i2;
          };
          for (let e3 = 0; e3 < n3.length; e3++)
            if (t3.type !== 1)
              n3[e3] = Ro(n3[e3], c2, 1);
            else {
              const t4 = [];
              for (const r4 of n3[e3])
                r4.x < 0 || r4.x >= i2 || r4.y < 0 || r4.y >= i2 || (c2(r4), t4.push(r4));
              n3[e3] = t4;
            }
        }
        for (const t4 of n3)
          for (const e3 of t4)
            qo(e3, s2);
        return n3;
      }
      function Go(t3, e2) {
        return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e2 ? No(t3) : [] };
      }
      function Zo(t3, e2, r3, n3, i2) {
        t3.emplaceBack(2 * e2 + (n3 + 1) / 2, 2 * r3 + (i2 + 1) / 2);
      }
      function Xo(t3, e2, r3) {
        const n3 = 16384;
        t3.emplaceBack(e2.x, e2.y, e2.z, r3[0] * n3, r3[1] * n3, r3[2] * n3);
      }
      class Ko {
        constructor(t3) {
          this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.projection = t3.projection, this.layoutVertexArray = new Qs(), this.indexArray = new ya2(), this.segments = new _o(), this.programConfigurations = new co(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
        }
        populate(t3, e2, r3, n3) {
          const i2 = this.layers[0], s2 = [];
          let a2 = null;
          i2.type === "circle" && (a2 = i2.layout.get("circle-sort-key"));
          for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l3 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, u3 = Go(e3, t4);
            if (!this.layers[0]._featureFilter.filter(new Cs(this.zoom), u3, r3))
              continue;
            const c2 = a2 ? a2.evaluate(u3, {}, r3) : void 0, h3 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t4 ? u3.geometry : No(e3, r3, n3), patterns: {}, sortKey: c2 };
            s2.push(h3);
          }
          a2 && s2.sort((t4, e3) => t4.sortKey - e3.sortKey);
          let o2 = null;
          n3.projection.name === "globe" && (this.globeExtVertexArray = new Ua2(), o2 = n3.projection);
          for (const n4 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n4, l3 = t3[s3].feature;
            this.addFeature(n4, i3, s3, e2.availableImages, r3, o2), e2.featureIndex.insert(l3, i3, s3, a3, this.index);
          }
        }
        update(t3, e2, r3, n3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3, n3);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, vo.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t3.createVertexBuffer(this.globeExtVertexArray, bo.members))), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(t3, e2, r3, n3, i2, s2) {
          for (const r4 of e2)
            for (const e3 of r4) {
              const r5 = e3.x, n4 = e3.y;
              if (r5 < 0 || r5 >= wo || n4 < 0 || n4 >= wo)
                continue;
              if (s2) {
                const t4 = s2.projectTilePoint(r5, n4, i2), e4 = s2.upVector(i2, r5, n4), a3 = this.globeExtVertexArray;
                Xo(a3, t4, e4), Xo(a3, t4, e4), Xo(a3, t4, e4), Xo(a3, t4, e4);
              }
              const a2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), o2 = a2.vertexLength;
              Zo(this.layoutVertexArray, r5, n4, -1, -1), Zo(this.layoutVertexArray, r5, n4, 1, -1), Zo(this.layoutVertexArray, r5, n4, 1, 1), Zo(this.layoutVertexArray, r5, n4, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a2.vertexLength += 4, a2.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, {}, n3, i2);
        }
      }
      function Ho(t3, e2) {
        for (let r3 = 0; r3 < t3.length; r3++)
          if (il(e2, t3[r3]))
            return true;
        for (let r3 = 0; r3 < e2.length; r3++)
          if (il(t3, e2[r3]))
            return true;
        return !!Qo(t3, e2);
      }
      function Yo(t3, e2, r3) {
        return !!il(t3, e2) || !!el(e2, t3, r3);
      }
      function Wo(t3, e2) {
        if (t3.length === 1)
          return nl(e2, t3[0]);
        for (let r3 = 0; r3 < e2.length; r3++) {
          const n3 = e2[r3];
          for (let e3 = 0; e3 < n3.length; e3++)
            if (il(t3, n3[e3]))
              return true;
        }
        for (let r3 = 0; r3 < t3.length; r3++)
          if (nl(e2, t3[r3]))
            return true;
        for (let r3 = 0; r3 < e2.length; r3++)
          if (Qo(t3, e2[r3]))
            return true;
        return false;
      }
      function Jo(t3, e2, r3) {
        if (t3.length > 1) {
          if (Qo(t3, e2))
            return true;
          for (let n3 = 0; n3 < e2.length; n3++)
            if (el(e2[n3], t3, r3))
              return true;
        }
        for (let n3 = 0; n3 < t3.length; n3++)
          if (el(t3[n3], e2, r3))
            return true;
        return false;
      }
      function Qo(t3, e2) {
        if (t3.length === 0 || e2.length === 0)
          return false;
        for (let r3 = 0; r3 < t3.length - 1; r3++) {
          const n3 = t3[r3], i2 = t3[r3 + 1];
          for (let t4 = 0; t4 < e2.length - 1; t4++)
            if (tl(n3, i2, e2[t4], e2[t4 + 1]))
              return true;
        }
        return false;
      }
      function tl(t3, e2, r3, n3) {
        return C2(t3, r3, n3) !== C2(e2, r3, n3) && C2(t3, e2, r3) !== C2(t3, e2, n3);
      }
      function el(t3, e2, r3) {
        const n3 = r3 * r3;
        if (e2.length === 1)
          return t3.distSqr(e2[0]) < n3;
        for (let r4 = 1; r4 < e2.length; r4++)
          if (rl(t3, e2[r4 - 1], e2[r4]) < n3)
            return true;
        return false;
      }
      function rl(t3, e2, r3) {
        const n3 = e2.distSqr(r3);
        if (n3 === 0)
          return t3.distSqr(e2);
        const i2 = ((t3.x - e2.x) * (r3.x - e2.x) + (t3.y - e2.y) * (r3.y - e2.y)) / n3;
        return t3.distSqr(i2 < 0 ? e2 : i2 > 1 ? r3 : r3.sub(e2)._mult(i2)._add(e2));
      }
      function nl(t3, e2) {
        let r3, n3, i2, s2 = false;
        for (let a2 = 0; a2 < t3.length; a2++) {
          r3 = t3[a2];
          for (let t4 = 0, a3 = r3.length - 1; t4 < r3.length; a3 = t4++)
            n3 = r3[t4], i2 = r3[a3], n3.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n3.x) * (e2.y - n3.y) / (i2.y - n3.y) + n3.x && (s2 = !s2);
        }
        return s2;
      }
      function il(t3, e2) {
        let r3 = false;
        for (let n3 = 0, i2 = t3.length - 1; n3 < t3.length; i2 = n3++) {
          const s2 = t3[n3], a2 = t3[i2];
          s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r3 = !r3);
        }
        return r3;
      }
      function sl(t3, e2, r3, n3, s2) {
        for (const i2 of t3)
          if (e2 <= i2.x && r3 <= i2.y && n3 >= i2.x && s2 >= i2.y)
            return true;
        const a2 = [new i(e2, r3), new i(e2, s2), new i(n3, s2), new i(n3, r3)];
        if (t3.length > 2) {
          for (const e3 of a2)
            if (il(t3, e3))
              return true;
        }
        for (let e3 = 0; e3 < t3.length - 1; e3++)
          if (al(t3[e3], t3[e3 + 1], a2))
            return true;
        return false;
      }
      function al(t3, e2, r3) {
        const n3 = r3[0], i2 = r3[2];
        if (t3.x < n3.x && e2.x < n3.x || t3.x > i2.x && e2.x > i2.x || t3.y < n3.y && e2.y < n3.y || t3.y > i2.y && e2.y > i2.y)
          return false;
        const s2 = C2(t3, e2, r3[0]);
        return s2 !== C2(t3, e2, r3[1]) || s2 !== C2(t3, e2, r3[2]) || s2 !== C2(t3, e2, r3[3]);
      }
      function ol(t3, e2, r3) {
        const n3 = e2.paint.get(t3).value;
        return n3.kind === "constant" ? n3.value : r3.programConfigurations.get(e2.id).getMaxValue(t3);
      }
      function ll(t3) {
        return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
      }
      function ul(t3, e2, r3, n3, s2) {
        if (!e2[0] && !e2[1])
          return t3;
        const a2 = i.convert(e2)._mult(s2);
        r3 === "viewport" && a2._rotate(-n3);
        const o2 = [];
        for (let e3 = 0; e3 < t3.length; e3++)
          o2.push(t3[e3].sub(a2));
        return o2;
      }
      function cl(t3, e2, r3, n3) {
        const s2 = i.convert(t3)._mult(n3);
        return e2 === "viewport" && s2._rotate(-r3), s2;
      }
      Pi2(Ko, "CircleBucket", { omit: ["layers"] });
      const hl = new Zs({ "circle-sort-key": new Os(Gt.layout_circle["circle-sort-key"]) });
      var pl = { paint: new Zs({ "circle-radius": new Os(Gt.paint_circle["circle-radius"]), "circle-color": new Os(Gt.paint_circle["circle-color"]), "circle-blur": new Os(Gt.paint_circle["circle-blur"]), "circle-opacity": new Os(Gt.paint_circle["circle-opacity"]), "circle-translate": new $s(Gt.paint_circle["circle-translate"]), "circle-translate-anchor": new $s(Gt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new $s(Gt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new $s(Gt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Os(Gt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Os(Gt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Os(Gt.paint_circle["circle-stroke-opacity"]) }), layout: hl }, fl = 1e-6, dl = typeof Float32Array != "undefined" ? Float32Array : Array;
      function yl() {
        var t3 = new dl(9);
        return dl != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
      }
      function ml(t3) {
        return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
      }
      function gl(t3, e2) {
        var r3 = e2[0], n3 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l3 = e2[6], u3 = e2[7], c2 = e2[8], h3 = e2[9], p3 = e2[10], f2 = e2[11], d2 = e2[12], y3 = e2[13], m3 = e2[14], g2 = e2[15], x3 = r3 * o2 - n3 * a2, v3 = r3 * l3 - i2 * a2, b2 = r3 * u3 - s2 * a2, _2 = n3 * l3 - i2 * o2, w2 = n3 * u3 - s2 * o2, A3 = i2 * u3 - s2 * l3, S3 = c2 * y3 - h3 * d2, k2 = c2 * m3 - p3 * d2, I3 = c2 * g2 - f2 * d2, M3 = h3 * m3 - p3 * y3, z3 = h3 * g2 - f2 * y3, T3 = p3 * g2 - f2 * m3, B3 = x3 * T3 - v3 * z3 + b2 * M3 + _2 * I3 - w2 * k2 + A3 * S3;
        return B3 ? (t3[0] = (o2 * T3 - l3 * z3 + u3 * M3) * (B3 = 1 / B3), t3[1] = (i2 * z3 - n3 * T3 - s2 * M3) * B3, t3[2] = (y3 * A3 - m3 * w2 + g2 * _2) * B3, t3[3] = (p3 * w2 - h3 * A3 - f2 * _2) * B3, t3[4] = (l3 * I3 - a2 * T3 - u3 * k2) * B3, t3[5] = (r3 * T3 - i2 * I3 + s2 * k2) * B3, t3[6] = (m3 * b2 - d2 * A3 - g2 * v3) * B3, t3[7] = (c2 * A3 - p3 * b2 + f2 * v3) * B3, t3[8] = (a2 * z3 - o2 * I3 + u3 * S3) * B3, t3[9] = (n3 * I3 - r3 * z3 - s2 * S3) * B3, t3[10] = (d2 * w2 - y3 * b2 + g2 * x3) * B3, t3[11] = (h3 * b2 - c2 * w2 - f2 * x3) * B3, t3[12] = (o2 * k2 - a2 * M3 - l3 * S3) * B3, t3[13] = (r3 * M3 - n3 * k2 + i2 * S3) * B3, t3[14] = (y3 * v3 - d2 * _2 - m3 * x3) * B3, t3[15] = (c2 * _2 - h3 * v3 + p3 * x3) * B3, t3) : null;
      }
      function xl(t3, e2, r3) {
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u3 = e2[6], c2 = e2[7], h3 = e2[8], p3 = e2[9], f2 = e2[10], d2 = e2[11], y3 = e2[12], m3 = e2[13], g2 = e2[14], x3 = e2[15], v3 = r3[0], b2 = r3[1], _2 = r3[2], w2 = r3[3];
        return t3[0] = v3 * n3 + b2 * o2 + _2 * h3 + w2 * y3, t3[1] = v3 * i2 + b2 * l3 + _2 * p3 + w2 * m3, t3[2] = v3 * s2 + b2 * u3 + _2 * f2 + w2 * g2, t3[3] = v3 * a2 + b2 * c2 + _2 * d2 + w2 * x3, t3[4] = (v3 = r3[4]) * n3 + (b2 = r3[5]) * o2 + (_2 = r3[6]) * h3 + (w2 = r3[7]) * y3, t3[5] = v3 * i2 + b2 * l3 + _2 * p3 + w2 * m3, t3[6] = v3 * s2 + b2 * u3 + _2 * f2 + w2 * g2, t3[7] = v3 * a2 + b2 * c2 + _2 * d2 + w2 * x3, t3[8] = (v3 = r3[8]) * n3 + (b2 = r3[9]) * o2 + (_2 = r3[10]) * h3 + (w2 = r3[11]) * y3, t3[9] = v3 * i2 + b2 * l3 + _2 * p3 + w2 * m3, t3[10] = v3 * s2 + b2 * u3 + _2 * f2 + w2 * g2, t3[11] = v3 * a2 + b2 * c2 + _2 * d2 + w2 * x3, t3[12] = (v3 = r3[12]) * n3 + (b2 = r3[13]) * o2 + (_2 = r3[14]) * h3 + (w2 = r3[15]) * y3, t3[13] = v3 * i2 + b2 * l3 + _2 * p3 + w2 * m3, t3[14] = v3 * s2 + b2 * u3 + _2 * f2 + w2 * g2, t3[15] = v3 * a2 + b2 * c2 + _2 * d2 + w2 * x3, t3;
      }
      function vl(t3, e2, r3) {
        var n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3 = r3[0], m3 = r3[1], g2 = r3[2];
        return e2 === t3 ? (t3[12] = e2[0] * y3 + e2[4] * m3 + e2[8] * g2 + e2[12], t3[13] = e2[1] * y3 + e2[5] * m3 + e2[9] * g2 + e2[13], t3[14] = e2[2] * y3 + e2[6] * m3 + e2[10] * g2 + e2[14], t3[15] = e2[3] * y3 + e2[7] * m3 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u3 = e2[6], c2 = e2[7], h3 = e2[8], p3 = e2[9], f2 = e2[10], d2 = e2[11], t3[0] = n3 = e2[0], t3[1] = i2, t3[2] = s2, t3[3] = a2, t3[4] = o2, t3[5] = l3, t3[6] = u3, t3[7] = c2, t3[8] = h3, t3[9] = p3, t3[10] = f2, t3[11] = d2, t3[12] = n3 * y3 + o2 * m3 + h3 * g2 + e2[12], t3[13] = i2 * y3 + l3 * m3 + p3 * g2 + e2[13], t3[14] = s2 * y3 + u3 * m3 + f2 * g2 + e2[14], t3[15] = a2 * y3 + c2 * m3 + d2 * g2 + e2[15]), t3;
      }
      function bl(t3, e2, r3) {
        var n3 = r3[0], i2 = r3[1], s2 = r3[2];
        return t3[0] = e2[0] * n3, t3[1] = e2[1] * n3, t3[2] = e2[2] * n3, t3[3] = e2[3] * n3, t3[4] = e2[4] * i2, t3[5] = e2[5] * i2, t3[6] = e2[6] * i2, t3[7] = e2[7] * i2, t3[8] = e2[8] * s2, t3[9] = e2[9] * s2, t3[10] = e2[10] * s2, t3[11] = e2[11] * s2, t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15], t3;
      }
      function _l(t3, e2, r3) {
        var n3 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[4], a2 = e2[5], o2 = e2[6], l3 = e2[7], u3 = e2[8], c2 = e2[9], h3 = e2[10], p3 = e2[11];
        return e2 !== t3 && (t3[0] = e2[0], t3[1] = e2[1], t3[2] = e2[2], t3[3] = e2[3], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15]), t3[4] = s2 * i2 + u3 * n3, t3[5] = a2 * i2 + c2 * n3, t3[6] = o2 * i2 + h3 * n3, t3[7] = l3 * i2 + p3 * n3, t3[8] = u3 * i2 - s2 * n3, t3[9] = c2 * i2 - a2 * n3, t3[10] = h3 * i2 - o2 * n3, t3[11] = p3 * i2 - l3 * n3, t3;
      }
      function wl(t3, e2, r3) {
        var n3 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[0], a2 = e2[1], o2 = e2[2], l3 = e2[3], u3 = e2[8], c2 = e2[9], h3 = e2[10], p3 = e2[11];
        return e2 !== t3 && (t3[4] = e2[4], t3[5] = e2[5], t3[6] = e2[6], t3[7] = e2[7], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15]), t3[0] = s2 * i2 - u3 * n3, t3[1] = a2 * i2 - c2 * n3, t3[2] = o2 * i2 - h3 * n3, t3[3] = l3 * i2 - p3 * n3, t3[8] = s2 * n3 + u3 * i2, t3[9] = a2 * n3 + c2 * i2, t3[10] = o2 * n3 + h3 * i2, t3[11] = l3 * n3 + p3 * i2, t3;
      }
      function Al(t3, e2) {
        return t3[0] = e2[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e2[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e2[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
      }
      function Sl(t3, e2, r3) {
        var n3, i2, s2, a2 = r3[0], o2 = r3[1], l3 = r3[2], u3 = Math.hypot(a2, o2, l3);
        return u3 < fl ? null : (a2 *= u3 = 1 / u3, o2 *= u3, l3 *= u3, n3 = Math.sin(e2), i2 = Math.cos(e2), t3[0] = a2 * a2 * (s2 = 1 - i2) + i2, t3[1] = o2 * a2 * s2 + l3 * n3, t3[2] = l3 * a2 * s2 - o2 * n3, t3[3] = 0, t3[4] = a2 * o2 * s2 - l3 * n3, t3[5] = o2 * o2 * s2 + i2, t3[6] = l3 * o2 * s2 + a2 * n3, t3[7] = 0, t3[8] = a2 * l3 * s2 + o2 * n3, t3[9] = o2 * l3 * s2 - a2 * n3, t3[10] = l3 * l3 * s2 + i2, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3);
      }
      Math.hypot || (Math.hypot = function() {
        for (var t3 = 0, e2 = arguments.length; e2--; )
          t3 += arguments[e2] * arguments[e2];
        return Math.sqrt(t3);
      });
      var kl = xl;
      function Il() {
        var t3 = new dl(3);
        return dl != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3;
      }
      function Ml(t3) {
        var e2 = new dl(3);
        return e2[0] = t3[0], e2[1] = t3[1], e2[2] = t3[2], e2;
      }
      function zl(t3) {
        return Math.hypot(t3[0], t3[1], t3[2]);
      }
      function Tl(t3, e2, r3) {
        var n3 = new dl(3);
        return n3[0] = t3, n3[1] = e2, n3[2] = r3, n3;
      }
      function Bl(t3, e2, r3) {
        return t3[0] = e2[0] + r3[0], t3[1] = e2[1] + r3[1], t3[2] = e2[2] + r3[2], t3;
      }
      function El(t3, e2, r3) {
        return t3[0] = e2[0] - r3[0], t3[1] = e2[1] - r3[1], t3[2] = e2[2] - r3[2], t3;
      }
      function Cl(t3, e2, r3) {
        return t3[0] = e2[0] * r3[0], t3[1] = e2[1] * r3[1], t3[2] = e2[2] * r3[2], t3;
      }
      function Pl(t3, e2, r3) {
        return t3[0] = Math.min(e2[0], r3[0]), t3[1] = Math.min(e2[1], r3[1]), t3[2] = Math.min(e2[2], r3[2]), t3;
      }
      function Dl(t3, e2, r3) {
        return t3[0] = Math.max(e2[0], r3[0]), t3[1] = Math.max(e2[1], r3[1]), t3[2] = Math.max(e2[2], r3[2]), t3;
      }
      function Vl(t3, e2, r3) {
        return t3[0] = e2[0] * r3, t3[1] = e2[1] * r3, t3[2] = e2[2] * r3, t3;
      }
      function Fl(t3, e2, r3, n3) {
        return t3[0] = e2[0] + r3[0] * n3, t3[1] = e2[1] + r3[1] * n3, t3[2] = e2[2] + r3[2] * n3, t3;
      }
      function Ll(t3, e2) {
        var r3 = e2[0], n3 = e2[1], i2 = e2[2], s2 = r3 * r3 + n3 * n3 + i2 * i2;
        return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t3[0] = e2[0] * s2, t3[1] = e2[1] * s2, t3[2] = e2[2] * s2, t3;
      }
      function Rl(t3, e2) {
        return t3[0] * e2[0] + t3[1] * e2[1] + t3[2] * e2[2];
      }
      function Ul(t3, e2, r3) {
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r3[0], o2 = r3[1], l3 = r3[2];
        return t3[0] = i2 * l3 - s2 * o2, t3[1] = s2 * a2 - n3 * l3, t3[2] = n3 * o2 - i2 * a2, t3;
      }
      function jl(t3, e2, r3) {
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r3[3] * n3 + r3[7] * i2 + r3[11] * s2 + r3[15];
        return t3[0] = (r3[0] * n3 + r3[4] * i2 + r3[8] * s2 + r3[12]) / (a2 = a2 || 1), t3[1] = (r3[1] * n3 + r3[5] * i2 + r3[9] * s2 + r3[13]) / a2, t3[2] = (r3[2] * n3 + r3[6] * i2 + r3[10] * s2 + r3[14]) / a2, t3;
      }
      function $l(t3, e2, r3) {
        var n3 = r3[0], i2 = r3[1], s2 = r3[2], a2 = e2[0], o2 = e2[1], l3 = e2[2], u3 = i2 * l3 - s2 * o2, c2 = s2 * a2 - n3 * l3, h3 = n3 * o2 - i2 * a2, p3 = i2 * h3 - s2 * c2, f2 = s2 * u3 - n3 * h3, d2 = n3 * c2 - i2 * u3, y3 = 2 * r3[3];
        return c2 *= y3, h3 *= y3, f2 *= 2, d2 *= 2, t3[0] = a2 + (u3 *= y3) + (p3 *= 2), t3[1] = o2 + c2 + f2, t3[2] = l3 + h3 + d2, t3;
      }
      var Ol, ql = El, Nl = Cl, Gl = zl;
      function Zl(t3, e2, r3) {
        return t3[0] = e2[0] * r3, t3[1] = e2[1] * r3, t3[2] = e2[2] * r3, t3[3] = e2[3] * r3, t3;
      }
      function Xl(t3, e2, r3) {
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
        return t3[0] = r3[0] * n3 + r3[4] * i2 + r3[8] * s2 + r3[12] * a2, t3[1] = r3[1] * n3 + r3[5] * i2 + r3[9] * s2 + r3[13] * a2, t3[2] = r3[2] * n3 + r3[6] * i2 + r3[10] * s2 + r3[14] * a2, t3[3] = r3[3] * n3 + r3[7] * i2 + r3[11] * s2 + r3[15] * a2, t3;
      }
      function Kl() {
        var t3 = new dl(4);
        return dl != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3[3] = 1, t3;
      }
      function Hl(t3) {
        return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
      }
      function Yl(t3, e2, r3) {
        r3 *= 0.5;
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l3 = Math.cos(r3);
        return t3[0] = n3 * l3 + a2 * o2, t3[1] = i2 * l3 + s2 * o2, t3[2] = s2 * l3 - i2 * o2, t3[3] = a2 * l3 - n3 * o2, t3;
      }
      function Wl(t3, e2, r3) {
        r3 *= 0.5;
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l3 = Math.cos(r3);
        return t3[0] = n3 * l3 - s2 * o2, t3[1] = i2 * l3 + a2 * o2, t3[2] = s2 * l3 + n3 * o2, t3[3] = a2 * l3 - i2 * o2, t3;
      }
      Il(), Ol = new dl(4), dl != Float32Array && (Ol[0] = 0, Ol[1] = 0, Ol[2] = 0, Ol[3] = 0), Il(), Tl(1, 0, 0), Tl(0, 1, 0), Kl(), Kl(), yl();
      class Jl {
        constructor(t3, e2) {
          this.pos = t3, this.dir = e2;
        }
        intersectsPlane(t3, e2, r3) {
          const n3 = Rl(e2, this.dir);
          if (Math.abs(n3) < 1e-6)
            return false;
          const i2 = ((t3[0] - this.pos[0]) * e2[0] + (t3[1] - this.pos[1]) * e2[1] + (t3[2] - this.pos[2]) * e2[2]) / n3;
          return r3[0] = this.pos[0] + this.dir[0] * i2, r3[1] = this.pos[1] + this.dir[1] * i2, r3[2] = this.pos[2] + this.dir[2] * i2, true;
        }
        closestPointOnSphere(t3, e2, r3) {
          if (function(t4, e3) {
            var r4 = t4[0], n4 = t4[1], i3 = t4[2], s3 = e3[0], a3 = e3[1], o3 = e3[2];
            return Math.abs(r4 - s3) <= fl * Math.max(1, Math.abs(r4), Math.abs(s3)) && Math.abs(n4 - a3) <= fl * Math.max(1, Math.abs(n4), Math.abs(a3)) && Math.abs(i3 - o3) <= fl * Math.max(1, Math.abs(i3), Math.abs(o3));
          }(this.pos, t3) || e2 === 0)
            return r3[0] = r3[1] = r3[2] = 0, false;
          const [n3, i2, s2] = this.dir, a2 = this.pos[0] - t3[0], o2 = this.pos[1] - t3[1], l3 = this.pos[2] - t3[2], u3 = n3 * n3 + i2 * i2 + s2 * s2, c2 = 2 * (a2 * n3 + o2 * i2 + l3 * s2), h3 = c2 * c2 - 4 * u3 * (a2 * a2 + o2 * o2 + l3 * l3 - e2 * e2);
          if (h3 < 0) {
            const t4 = Math.max(-c2 / 2, 0), u4 = a2 + n3 * t4, h4 = o2 + i2 * t4, p3 = l3 + s2 * t4, f2 = Math.hypot(u4, h4, p3);
            return r3[0] = u4 * e2 / f2, r3[1] = h4 * e2 / f2, r3[2] = p3 * e2 / f2, false;
          }
          {
            const t4 = (-c2 - Math.sqrt(h3)) / (2 * u3);
            if (t4 < 0) {
              const t5 = Math.hypot(a2, o2, l3);
              return r3[0] = a2 * e2 / t5, r3[1] = o2 * e2 / t5, r3[2] = l3 * e2 / t5, false;
            }
            return r3[0] = a2 + n3 * t4, r3[1] = o2 + i2 * t4, r3[2] = l3 + s2 * t4, true;
          }
        }
      }
      class Ql {
        constructor(t3, e2, r3, n3, i2) {
          this.TL = t3, this.TR = e2, this.BR = r3, this.BL = n3, this.horizon = i2;
        }
        static fromInvProjectionMatrix(t3, e2, r3) {
          const n3 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], a2 = [-1, -1, 1], o2 = jl(n3, n3, t3), l3 = jl(i2, i2, t3), u3 = jl(s2, s2, t3), c2 = jl(a2, a2, t3);
          return new Ql(o2, l3, u3, c2, e2 / r3);
        }
      }
      class tu {
        constructor(t3, e2) {
          this.points = t3, this.planes = e2;
        }
        static fromInvProjectionMatrix(t3, e2, r3, n3) {
          const i2 = Math.pow(2, r3), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r4) => {
            const s3 = Xl([], r4, t3), a3 = 1 / s3[3] / e2 * i2;
            return function(t4, e3, r5) {
              return t4[0] = e3[0] * r5[0], t4[1] = e3[1] * r5[1], t4[2] = e3[2] * r5[2], t4[3] = e3[3] * r5[3], t4;
            }(s3, s3, [a3, a3, n3 ? 1 / s3[3] : a3, a3]);
          }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t4) => {
            const e3 = Ll([], Ul([], ql([], s2[t4[0]], s2[t4[1]]), ql([], s2[t4[2]], s2[t4[1]]))), r4 = -Rl(e3, s2[t4[1]]);
            return e3.concat(r4);
          });
          return new tu(s2, a2);
        }
      }
      class eu {
        static fromPoints(t3) {
          const e2 = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], r3 = [Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE];
          for (const n3 of t3)
            e2[0] = Math.min(e2[0], n3[0]), e2[1] = Math.min(e2[1], n3[1]), e2[2] = Math.min(e2[2], n3[2]), r3[0] = Math.max(r3[0], n3[0]), r3[1] = Math.max(r3[1], n3[1]), r3[2] = Math.max(r3[2], n3[2]);
          return new eu(e2, r3);
        }
        constructor(t3, e2) {
          this.min = t3, this.max = e2, this.center = Vl([], Bl([], this.min, this.max), 0.5);
        }
        quadrant(t3) {
          const e2 = [t3 % 2 == 0, t3 < 2], r3 = Ml(this.min), n3 = Ml(this.max);
          for (let t4 = 0; t4 < e2.length; t4++)
            r3[t4] = e2[t4] ? this.min[t4] : this.center[t4], n3[t4] = e2[t4] ? this.center[t4] : this.max[t4];
          return n3[2] = this.max[2], new eu(r3, n3);
        }
        distanceX(t3) {
          return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
        }
        distanceY(t3) {
          return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
        }
        distanceZ(t3) {
          return Math.max(Math.min(this.max[2], t3[2]), this.min[2]) - t3[2];
        }
        getCorners() {
          const t3 = this.min, e2 = this.max;
          return [[t3[0], t3[1], t3[2]], [e2[0], t3[1], t3[2]], [e2[0], e2[1], t3[2]], [t3[0], e2[1], t3[2]], [t3[0], t3[1], e2[2]], [e2[0], t3[1], e2[2]], [e2[0], e2[1], e2[2]], [t3[0], e2[1], e2[2]]];
        }
        intersects(t3) {
          const e2 = this.getCorners();
          let r3 = true;
          for (let n3 = 0; n3 < t3.planes.length; n3++) {
            const i2 = t3.planes[n3];
            let s2 = 0;
            for (let t4 = 0; t4 < e2.length; t4++)
              s2 += Rl(i2, e2[t4]) + i2[3] >= 0;
            if (s2 === 0)
              return 0;
            s2 !== e2.length && (r3 = false);
          }
          if (r3)
            return 2;
          for (let e3 = 0; e3 < 3; e3++) {
            let r4 = Number.MAX_VALUE, n3 = -Number.MAX_VALUE;
            for (let i2 = 0; i2 < t3.points.length; i2++) {
              const s2 = t3.points[i2][e3] - this.min[e3];
              r4 = Math.min(r4, s2), n3 = Math.max(n3, s2);
            }
            if (n3 < 0 || r4 > this.max[e3] - this.min[e3])
              return 0;
          }
          return 1;
        }
      }
      function ru(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
        if (s2 && t3.queryGeometry.isAboveHorizon)
          return false;
        s2 && (l3 *= t3.pixelToTileUnitsFactor);
        const u3 = t3.tileID.canonical, c2 = r3.projection.upVectorScale(u3, r3.center.lat, r3.worldSize).metersToTile;
        for (const h3 of e2)
          for (const e3 of h3) {
            const h4 = e3.add(o2), p3 = i2 && r3.elevation ? r3.elevation.exaggeration() * i2.getElevationAt(h4.x, h4.y, true) : 0, f2 = r3.projection.projectTilePoint(h4.x, h4.y, u3);
            if (p3 > 0) {
              const t4 = r3.projection.upVector(u3, h4.x, h4.y);
              f2.x += t4[0] * c2 * p3, f2.y += t4[1] * c2 * p3, f2.z += t4[2] * c2 * p3;
            }
            const d2 = s2 ? h4 : nu(f2.x, f2.y, f2.z, n3), y3 = s2 ? t3.tilespaceRays.map((t4) => au(t4, p3)) : t3.queryGeometry.screenGeometry, m3 = Xl([], [f2.x, f2.y, f2.z, 1], n3);
            if (!a2 && s2 ? l3 *= m3[3] / r3.cameraToCenterDistance : a2 && !s2 && (l3 *= r3.cameraToCenterDistance / m3[3]), s2) {
              const t4 = Co((e3.y / wo + u3.y) / (1 << u3.z));
              l3 /= r3.projection.pixelsPerMeter(t4, 1) / Bo(1, t4);
            }
            if (Yo(y3, d2, l3))
              return true;
          }
        return false;
      }
      function nu(t3, e2, r3, n3) {
        const s2 = Xl([], [t3, e2, r3, 1], n3);
        return new i(s2[0] / s2[3], s2[1] / s2[3]);
      }
      const iu = Tl(0, 0, 0), su = Tl(0, 0, 1);
      function au(t3, e2) {
        const r3 = Il();
        return iu[2] = e2, t3.intersectsPlane(iu, su, r3), new i(r3[0], r3[1]);
      }
      class ou extends Ko {
      }
      function lu(t3, { width: e2, height: r3 }, n3, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e2 * r3 * n3)
            throw new RangeError("mismatched image size");
        } else
          i2 = new Uint8Array(e2 * r3 * n3);
        return t3.width = e2, t3.height = r3, t3.data = i2, t3;
      }
      function uu(t3, e2, r3) {
        const { width: n3, height: i2 } = e2;
        n3 === t3.width && i2 === t3.height || (cu(t3, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, n3), height: Math.min(t3.height, i2) }, r3), t3.width = n3, t3.height = i2, t3.data = e2.data);
      }
      function cu(t3, e2, r3, n3, i2, s2) {
        if (i2.width === 0 || i2.height === 0)
          return e2;
        if (i2.width > t3.width || i2.height > t3.height || r3.x > t3.width - i2.width || r3.y > t3.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e2.width || i2.height > e2.height || n3.x > e2.width - i2.width || n3.y > e2.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const a2 = t3.data, o2 = e2.data;
        for (let l3 = 0; l3 < i2.height; l3++) {
          const u3 = ((r3.y + l3) * t3.width + r3.x) * s2, c2 = ((n3.y + l3) * e2.width + n3.x) * s2;
          for (let t4 = 0; t4 < i2.width * s2; t4++)
            o2[c2 + t4] = a2[u3 + t4];
        }
        return e2;
      }
      Pi2(ou, "HeatmapBucket", { omit: ["layers"] });
      class hu {
        constructor(t3, e2) {
          lu(this, t3, 1, e2);
        }
        resize(t3) {
          uu(this, new hu(t3), 1);
        }
        clone() {
          return new hu({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t3, e2, r3, n3, i2) {
          cu(t3, e2, r3, n3, i2, 1);
        }
      }
      class pu {
        constructor(t3, e2) {
          lu(this, t3, 4, e2);
        }
        resize(t3) {
          uu(this, new pu(t3), 4);
        }
        replace(t3, e2) {
          e2 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
        }
        clone() {
          return new pu({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t3, e2, r3, n3, i2) {
          cu(t3, e2, r3, n3, i2, 4);
        }
      }
      Pi2(hu, "AlphaImage"), Pi2(pu, "RGBAImage");
      var fu = { paint: new Zs({ "heatmap-radius": new Os(Gt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Os(Gt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new $s(Gt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Gs(Gt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new $s(Gt.paint_heatmap["heatmap-opacity"]) }) };
      function du(t3) {
        const e2 = {}, r3 = t3.resolution || 256, n3 = t3.clips ? t3.clips.length : 1, i2 = t3.image || new pu({ width: r3, height: n3 }), s2 = (r4, n4, s3) => {
          e2[t3.evaluationKey] = s3;
          const a2 = t3.expression.evaluate(e2);
          i2.data[r4 + n4 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r4 + n4 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r4 + n4 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r4 + n4 + 3] = Math.floor(255 * a2.a);
        };
        if (t3.clips)
          for (let e3 = 0, i3 = 0; e3 < n3; ++e3, i3 += 4 * r3)
            for (let n4 = 0, a2 = 0; n4 < r3; n4++, a2 += 4) {
              const o2 = n4 / (r3 - 1), { start: l3, end: u3 } = t3.clips[e3];
              s2(i3, a2, l3 * (1 - o2) + u3 * o2);
            }
        else
          for (let t4 = 0, e3 = 0; t4 < r3; t4++, e3 += 4)
            s2(0, e3, t4 / (r3 - 1));
        return i2;
      }
      var yu = { paint: new Zs({ "hillshade-illumination-direction": new $s(Gt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new $s(Gt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new $s(Gt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new $s(Gt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new $s(Gt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new $s(Gt.paint_hillshade["hillshade-accent-color"]) }) };
      const mu = Ws([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: gu } = mu;
      var xu = bu, vu = bu;
      function bu(t3, e2, r3) {
        r3 = r3 || 2;
        var n3, i2, s2, a2, o2, l3, u3, c2 = e2 && e2.length, h3 = c2 ? e2[0] * r3 : t3.length, p3 = _u(t3, 0, h3, r3, true), f2 = [];
        if (!p3 || p3.next === p3.prev)
          return f2;
        if (c2 && (p3 = function(t4, e3, r4, n4) {
          var i3, s3, a3, o3 = [];
          for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
            (a3 = _u(t4, e3[i3] * n4, i3 < s3 - 1 ? e3[i3 + 1] * n4 : t4.length, n4, false)) === a3.next && (a3.steiner = true), o3.push(Cu(a3));
          for (o3.sort(zu), i3 = 0; i3 < o3.length; i3++)
            r4 = Tu(o3[i3], r4);
          return r4;
        }(t3, e2, p3, r3)), t3.length > 80 * r3) {
          n3 = s2 = t3[0], i2 = a2 = t3[1];
          for (var d2 = r3; d2 < h3; d2 += r3)
            (o2 = t3[d2]) < n3 && (n3 = o2), (l3 = t3[d2 + 1]) < i2 && (i2 = l3), o2 > s2 && (s2 = o2), l3 > a2 && (a2 = l3);
          u3 = (u3 = Math.max(s2 - n3, a2 - i2)) !== 0 ? 32767 / u3 : 0;
        }
        return Au(p3, f2, r3, n3, i2, u3, 0), f2;
      }
      function _u(t3, e2, r3, n3, i2) {
        var s2, a2;
        if (i2 === Gu(t3, e2, r3, n3) > 0)
          for (s2 = e2; s2 < r3; s2 += n3)
            a2 = Ou(s2, t3[s2], t3[s2 + 1], a2);
        else
          for (s2 = r3 - n3; s2 >= e2; s2 -= n3)
            a2 = Ou(s2, t3[s2], t3[s2 + 1], a2);
        return a2 && Fu(a2, a2.next) && (qu(a2), a2 = a2.next), a2;
      }
      function wu(t3, e2) {
        if (!t3)
          return t3;
        e2 || (e2 = t3);
        var r3, n3 = t3;
        do {
          if (r3 = false, n3.steiner || !Fu(n3, n3.next) && Vu(n3.prev, n3, n3.next) !== 0)
            n3 = n3.next;
          else {
            if (qu(n3), (n3 = e2 = n3.prev) === n3.next)
              break;
            r3 = true;
          }
        } while (r3 || n3 !== e2);
        return e2;
      }
      function Au(t3, e2, r3, n3, i2, s2, a2) {
        if (t3) {
          !a2 && s2 && function(t4, e3, r4, n4) {
            var i3 = t4;
            do {
              i3.z === 0 && (i3.z = Eu(i3.x, i3.y, e3, r4, n4)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t4);
            i3.prevZ.nextZ = null, i3.prevZ = null, function(t5) {
              var e4, r5, n5, i4, s3, a3, o3, l4, u4 = 1;
              do {
                for (r5 = t5, t5 = null, s3 = null, a3 = 0; r5; ) {
                  for (a3++, n5 = r5, o3 = 0, e4 = 0; e4 < u4 && (o3++, n5 = n5.nextZ); e4++)
                    ;
                  for (l4 = u4; o3 > 0 || l4 > 0 && n5; )
                    o3 !== 0 && (l4 === 0 || !n5 || r5.z <= n5.z) ? (i4 = r5, r5 = r5.nextZ, o3--) : (i4 = n5, n5 = n5.nextZ, l4--), s3 ? s3.nextZ = i4 : t5 = i4, i4.prevZ = s3, s3 = i4;
                  r5 = n5;
                }
                s3.nextZ = null, u4 *= 2;
              } while (a3 > 1);
            }(i3);
          }(t3, n3, i2, s2);
          for (var o2, l3, u3 = t3; t3.prev !== t3.next; )
            if (o2 = t3.prev, l3 = t3.next, s2 ? ku(t3, n3, i2, s2) : Su(t3))
              e2.push(o2.i / r3 | 0), e2.push(t3.i / r3 | 0), e2.push(l3.i / r3 | 0), qu(t3), t3 = l3.next, u3 = l3.next;
            else if ((t3 = l3) === u3) {
              a2 ? a2 === 1 ? Au(t3 = Iu(wu(t3), e2, r3), e2, r3, n3, i2, s2, 2) : a2 === 2 && Mu(t3, e2, r3, n3, i2, s2) : Au(wu(t3), e2, r3, n3, i2, s2, 1);
              break;
            }
        }
      }
      function Su(t3) {
        var e2 = t3.prev, r3 = t3, n3 = t3.next;
        if (Vu(e2, r3, n3) >= 0)
          return false;
        for (var i2 = e2.x, s2 = r3.x, a2 = n3.x, o2 = e2.y, l3 = r3.y, u3 = n3.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h3 = o2 < l3 ? o2 < u3 ? o2 : u3 : l3 < u3 ? l3 : u3, p3 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l3 ? o2 > u3 ? o2 : u3 : l3 > u3 ? l3 : u3, d2 = n3.next; d2 !== e2; ) {
          if (d2.x >= c2 && d2.x <= p3 && d2.y >= h3 && d2.y <= f2 && Pu(i2, o2, s2, l3, a2, u3, d2.x, d2.y) && Vu(d2.prev, d2, d2.next) >= 0)
            return false;
          d2 = d2.next;
        }
        return true;
      }
      function ku(t3, e2, r3, n3) {
        var i2 = t3.prev, s2 = t3, a2 = t3.next;
        if (Vu(i2, s2, a2) >= 0)
          return false;
        for (var o2 = i2.x, l3 = s2.x, u3 = a2.x, c2 = i2.y, h3 = s2.y, p3 = a2.y, f2 = o2 < l3 ? o2 < u3 ? o2 : u3 : l3 < u3 ? l3 : u3, d2 = c2 < h3 ? c2 < p3 ? c2 : p3 : h3 < p3 ? h3 : p3, y3 = o2 > l3 ? o2 > u3 ? o2 : u3 : l3 > u3 ? l3 : u3, m3 = c2 > h3 ? c2 > p3 ? c2 : p3 : h3 > p3 ? h3 : p3, g2 = Eu(f2, d2, e2, r3, n3), x3 = Eu(y3, m3, e2, r3, n3), v3 = t3.prevZ, b2 = t3.nextZ; v3 && v3.z >= g2 && b2 && b2.z <= x3; ) {
          if (v3.x >= f2 && v3.x <= y3 && v3.y >= d2 && v3.y <= m3 && v3 !== i2 && v3 !== a2 && Pu(o2, c2, l3, h3, u3, p3, v3.x, v3.y) && Vu(v3.prev, v3, v3.next) >= 0)
            return false;
          if (v3 = v3.prevZ, b2.x >= f2 && b2.x <= y3 && b2.y >= d2 && b2.y <= m3 && b2 !== i2 && b2 !== a2 && Pu(o2, c2, l3, h3, u3, p3, b2.x, b2.y) && Vu(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        for (; v3 && v3.z >= g2; ) {
          if (v3.x >= f2 && v3.x <= y3 && v3.y >= d2 && v3.y <= m3 && v3 !== i2 && v3 !== a2 && Pu(o2, c2, l3, h3, u3, p3, v3.x, v3.y) && Vu(v3.prev, v3, v3.next) >= 0)
            return false;
          v3 = v3.prevZ;
        }
        for (; b2 && b2.z <= x3; ) {
          if (b2.x >= f2 && b2.x <= y3 && b2.y >= d2 && b2.y <= m3 && b2 !== i2 && b2 !== a2 && Pu(o2, c2, l3, h3, u3, p3, b2.x, b2.y) && Vu(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        return true;
      }
      function Iu(t3, e2, r3) {
        var n3 = t3;
        do {
          var i2 = n3.prev, s2 = n3.next.next;
          !Fu(i2, s2) && Lu(i2, n3, n3.next, s2) && ju(i2, s2) && ju(s2, i2) && (e2.push(i2.i / r3 | 0), e2.push(n3.i / r3 | 0), e2.push(s2.i / r3 | 0), qu(n3), qu(n3.next), n3 = t3 = s2), n3 = n3.next;
        } while (n3 !== t3);
        return wu(n3);
      }
      function Mu(t3, e2, r3, n3, i2, s2) {
        var a2 = t3;
        do {
          for (var o2 = a2.next.next; o2 !== a2.prev; ) {
            if (a2.i !== o2.i && Du(a2, o2)) {
              var l3 = $u(a2, o2);
              return a2 = wu(a2, a2.next), l3 = wu(l3, l3.next), Au(a2, e2, r3, n3, i2, s2, 0), void Au(l3, e2, r3, n3, i2, s2, 0);
            }
            o2 = o2.next;
          }
          a2 = a2.next;
        } while (a2 !== t3);
      }
      function zu(t3, e2) {
        return t3.x - e2.x;
      }
      function Tu(t3, e2) {
        var r3 = function(t4, e3) {
          var r4, n4 = e3, i2 = t4.x, s2 = t4.y, a2 = -1 / 0;
          do {
            if (s2 <= n4.y && s2 >= n4.next.y && n4.next.y !== n4.y) {
              var o2 = n4.x + (s2 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
              if (o2 <= i2 && o2 > a2 && (a2 = o2, r4 = n4.x < n4.next.x ? n4 : n4.next, o2 === i2))
                return r4;
            }
            n4 = n4.next;
          } while (n4 !== e3);
          if (!r4)
            return null;
          var l3, u3 = r4, c2 = r4.x, h3 = r4.y, p3 = 1 / 0;
          n4 = r4;
          do {
            i2 >= n4.x && n4.x >= c2 && i2 !== n4.x && Pu(s2 < h3 ? i2 : a2, s2, c2, h3, s2 < h3 ? a2 : i2, s2, n4.x, n4.y) && (l3 = Math.abs(s2 - n4.y) / (i2 - n4.x), ju(n4, t4) && (l3 < p3 || l3 === p3 && (n4.x > r4.x || n4.x === r4.x && Bu(r4, n4))) && (r4 = n4, p3 = l3)), n4 = n4.next;
          } while (n4 !== u3);
          return r4;
        }(t3, e2);
        if (!r3)
          return e2;
        var n3 = $u(r3, t3);
        return wu(n3, n3.next), wu(r3, r3.next);
      }
      function Bu(t3, e2) {
        return Vu(t3.prev, t3, e2.prev) < 0 && Vu(e2.next, t3, t3.next) < 0;
      }
      function Eu(t3, e2, r3, n3, i2) {
        return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r3) * i2 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n3) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function Cu(t3) {
        var e2 = t3, r3 = t3;
        do {
          (e2.x < r3.x || e2.x === r3.x && e2.y < r3.y) && (r3 = e2), e2 = e2.next;
        } while (e2 !== t3);
        return r3;
      }
      function Pu(t3, e2, r3, n3, i2, s2, a2, o2) {
        return (i2 - a2) * (e2 - o2) >= (t3 - a2) * (s2 - o2) && (t3 - a2) * (n3 - o2) >= (r3 - a2) * (e2 - o2) && (r3 - a2) * (s2 - o2) >= (i2 - a2) * (n3 - o2);
      }
      function Du(t3, e2) {
        return t3.next.i !== e2.i && t3.prev.i !== e2.i && !function(t4, e3) {
          var r3 = t4;
          do {
            if (r3.i !== t4.i && r3.next.i !== t4.i && r3.i !== e3.i && r3.next.i !== e3.i && Lu(r3, r3.next, t4, e3))
              return true;
            r3 = r3.next;
          } while (r3 !== t4);
          return false;
        }(t3, e2) && (ju(t3, e2) && ju(e2, t3) && function(t4, e3) {
          var r3 = t4, n3 = false, i2 = (t4.x + e3.x) / 2, s2 = (t4.y + e3.y) / 2;
          do {
            r3.y > s2 != r3.next.y > s2 && r3.next.y !== r3.y && i2 < (r3.next.x - r3.x) * (s2 - r3.y) / (r3.next.y - r3.y) + r3.x && (n3 = !n3), r3 = r3.next;
          } while (r3 !== t4);
          return n3;
        }(t3, e2) && (Vu(t3.prev, t3, e2.prev) || Vu(t3, e2.prev, e2)) || Fu(t3, e2) && Vu(t3.prev, t3, t3.next) > 0 && Vu(e2.prev, e2, e2.next) > 0);
      }
      function Vu(t3, e2, r3) {
        return (e2.y - t3.y) * (r3.x - e2.x) - (e2.x - t3.x) * (r3.y - e2.y);
      }
      function Fu(t3, e2) {
        return t3.x === e2.x && t3.y === e2.y;
      }
      function Lu(t3, e2, r3, n3) {
        var i2 = Uu(Vu(t3, e2, r3)), s2 = Uu(Vu(t3, e2, n3)), a2 = Uu(Vu(r3, n3, t3)), o2 = Uu(Vu(r3, n3, e2));
        return i2 !== s2 && a2 !== o2 || !(i2 !== 0 || !Ru(t3, r3, e2)) || !(s2 !== 0 || !Ru(t3, n3, e2)) || !(a2 !== 0 || !Ru(r3, t3, n3)) || !(o2 !== 0 || !Ru(r3, e2, n3));
      }
      function Ru(t3, e2, r3) {
        return e2.x <= Math.max(t3.x, r3.x) && e2.x >= Math.min(t3.x, r3.x) && e2.y <= Math.max(t3.y, r3.y) && e2.y >= Math.min(t3.y, r3.y);
      }
      function Uu(t3) {
        return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
      }
      function ju(t3, e2) {
        return Vu(t3.prev, t3, t3.next) < 0 ? Vu(t3, e2, t3.next) >= 0 && Vu(t3, t3.prev, e2) >= 0 : Vu(t3, e2, t3.prev) < 0 || Vu(t3, t3.next, e2) < 0;
      }
      function $u(t3, e2) {
        var r3 = new Nu(t3.i, t3.x, t3.y), n3 = new Nu(e2.i, e2.x, e2.y), i2 = t3.next, s2 = e2.prev;
        return t3.next = e2, e2.prev = t3, r3.next = i2, i2.prev = r3, n3.next = r3, r3.prev = n3, s2.next = n3, n3.prev = s2, n3;
      }
      function Ou(t3, e2, r3, n3) {
        var i2 = new Nu(t3, e2, r3);
        return n3 ? (i2.next = n3.next, i2.prev = n3, n3.next.prev = i2, n3.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function qu(t3) {
        t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
      }
      function Nu(t3, e2, r3) {
        this.i = t3, this.x = e2, this.y = r3, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function Gu(t3, e2, r3, n3) {
        for (var i2 = 0, s2 = e2, a2 = r3 - n3; s2 < r3; s2 += n3)
          i2 += (t3[a2] - t3[s2]) * (t3[s2 + 1] + t3[a2 + 1]), a2 = s2;
        return i2;
      }
      function Zu(t3, e2, r3, n3, i2) {
        Xu(t3, e2, r3 || 0, n3 || t3.length - 1, i2 || Hu);
      }
      function Xu(t3, e2, r3, n3, i2) {
        for (; n3 > r3; ) {
          if (n3 - r3 > 600) {
            var s2 = n3 - r3 + 1, a2 = e2 - r3 + 1, o2 = Math.log(s2), l3 = 0.5 * Math.exp(2 * o2 / 3), u3 = 0.5 * Math.sqrt(o2 * l3 * (s2 - l3) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
            Xu(t3, e2, Math.max(r3, Math.floor(e2 - a2 * l3 / s2 + u3)), Math.min(n3, Math.floor(e2 + (s2 - a2) * l3 / s2 + u3)), i2);
          }
          var c2 = t3[e2], h3 = r3, p3 = n3;
          for (Ku(t3, r3, e2), i2(t3[n3], c2) > 0 && Ku(t3, r3, n3); h3 < p3; ) {
            for (Ku(t3, h3, p3), h3++, p3--; i2(t3[h3], c2) < 0; )
              h3++;
            for (; i2(t3[p3], c2) > 0; )
              p3--;
          }
          i2(t3[r3], c2) === 0 ? Ku(t3, r3, p3) : Ku(t3, ++p3, n3), p3 <= e2 && (r3 = p3 + 1), e2 <= p3 && (n3 = p3 - 1);
        }
      }
      function Ku(t3, e2, r3) {
        var n3 = t3[e2];
        t3[e2] = t3[r3], t3[r3] = n3;
      }
      function Hu(t3, e2) {
        return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
      }
      function Yu(t3, e2) {
        const r3 = t3.length;
        if (r3 <= 1)
          return [t3];
        const n3 = [];
        let i2, s2;
        for (let e3 = 0; e3 < r3; e3++) {
          const r4 = P2(t3[e3]);
          r4 !== 0 && (t3[e3].area = Math.abs(r4), s2 === void 0 && (s2 = r4 < 0), s2 === r4 < 0 ? (i2 && n3.push(i2), i2 = [t3[e3]]) : i2.push(t3[e3]));
        }
        if (i2 && n3.push(i2), e2 > 1)
          for (let t4 = 0; t4 < n3.length; t4++)
            n3[t4].length <= e2 || (Zu(n3[t4], e2, 1, n3[t4].length - 1, Wu), n3[t4] = n3[t4].slice(0, e2));
        return n3;
      }
      function Wu(t3, e2) {
        return e2.area - t3.area;
      }
      function Ju(t3, e2, r3) {
        const n3 = r3.patternDependencies;
        let i2 = false;
        for (const r4 of e2) {
          const e3 = r4.paint.get(`${t3}-pattern`);
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n3[s2.to] = true, n3[s2.from] = true);
        }
        return i2;
      }
      function Qu(t3, e2, r3, n3, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e2) {
          const e3 = a2.paint.get(`${t3}-pattern`).value;
          if (e3.kind !== "constant") {
            let t4 = e3.evaluate({ zoom: n3 - 1 }, r3, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n3 }, r3, {}, i2.availableImages), l3 = e3.evaluate({ zoom: n3 + 1 }, r3, {}, i2.availableImages);
            t4 = t4 && t4.name ? t4.name : t4, o2 = o2 && o2.name ? o2.name : o2, l3 = l3 && l3.name ? l3.name : l3, s2[t4] = true, s2[o2] = true, s2[l3] = true, r3.patterns[a2.id] = { min: t4, mid: o2, max: l3 };
          }
        }
        return r3;
      }
      bu.deviation = function(t3, e2, r3, n3) {
        var i2 = e2 && e2.length, s2 = Math.abs(Gu(t3, 0, i2 ? e2[0] * r3 : t3.length, r3));
        if (i2)
          for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
            s2 -= Math.abs(Gu(t3, e2[a2] * r3, a2 < o2 - 1 ? e2[a2 + 1] * r3 : t3.length, r3));
        var l3 = 0;
        for (a2 = 0; a2 < n3.length; a2 += 3) {
          var u3 = n3[a2] * r3, c2 = n3[a2 + 1] * r3, h3 = n3[a2 + 2] * r3;
          l3 += Math.abs((t3[u3] - t3[h3]) * (t3[c2 + 1] - t3[u3 + 1]) - (t3[u3] - t3[c2]) * (t3[h3 + 1] - t3[u3 + 1]));
        }
        return s2 === 0 && l3 === 0 ? 0 : Math.abs((l3 - s2) / s2);
      }, bu.flatten = function(t3) {
        for (var e2 = t3[0][0].length, r3 = { vertices: [], holes: [], dimensions: e2 }, n3 = 0, i2 = 0; i2 < t3.length; i2++) {
          for (var s2 = 0; s2 < t3[i2].length; s2++)
            for (var a2 = 0; a2 < e2; a2++)
              r3.vertices.push(t3[i2][s2][a2]);
          i2 > 0 && r3.holes.push(n3 += t3[i2 - 1].length);
        }
        return r3;
      }, xu.default = vu;
      class tc2 {
        constructor(t3) {
          this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Qs(), this.indexArray = new ya2(), this.indexArray2 = new _a(), this.programConfigurations = new co(t3.layers, t3.zoom), this.segments = new _o(), this.segments2 = new _o(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.projection = t3.projection;
        }
        populate(t3, e2, r3, n3) {
          this.hasPattern = Ju("fill", this.layers, e2);
          const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
          for (const { feature: a2, id: o2, index: l3, sourceLayerIndex: u3 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, c2 = Go(a2, t4);
            if (!this.layers[0]._featureFilter.filter(new Cs(this.zoom), c2, r3))
              continue;
            const h3 = i2 ? i2.evaluate(c2, {}, r3, e2.availableImages) : void 0, p3 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u3, index: l3, geometry: t4 ? c2.geometry : No(a2, r3, n3), patterns: {}, sortKey: h3 };
            s2.push(p3);
          }
          i2 && s2.sort((t4, e3) => t4.sortKey - e3.sortKey);
          for (const n4 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n4;
            if (this.hasPattern) {
              const t4 = Qu("fill", this.layers, n4, this.zoom, e2);
              this.patternFeatures.push(t4);
            } else
              this.addFeature(n4, i3, s3, r3, {}, e2.availableImages);
            e2.featureIndex.insert(t3[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t3, e2, r3, n3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3, n3);
        }
        addFeatures(t3, e2, r3, n3, i2) {
          for (const t4 of this.patternFeatures)
            this.addFeature(t4, t4.geometry, t4.index, e2, r3, n3);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, gu), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t3, e2, r3, n3, i2, s2 = []) {
          for (const t4 of Yu(e2, 500)) {
            let e3 = 0;
            for (const r5 of t4)
              e3 += r5.length;
            const r4 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n4 = r4.vertexLength, i3 = [], s3 = [];
            for (const e4 of t4) {
              if (e4.length === 0)
                continue;
              e4 !== t4[0] && s3.push(i3.length / 2);
              const r5 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n5 = r5.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n5 + e4.length - 1, n5), i3.push(e4[0].x), i3.push(e4[0].y);
              for (let t5 = 1; t5 < e4.length; t5++)
                this.layoutVertexArray.emplaceBack(e4[t5].x, e4[t5].y), this.indexArray2.emplaceBack(n5 + t5 - 1, n5 + t5), i3.push(e4[t5].x), i3.push(e4[t5].y);
              r5.vertexLength += e4.length, r5.primitiveLength += e4.length;
            }
            const a2 = xu(i3, s3);
            for (let t5 = 0; t5 < a2.length; t5 += 3)
              this.indexArray.emplaceBack(n4 + a2[t5], n4 + a2[t5 + 1], n4 + a2[t5 + 2]);
            r4.vertexLength += e3, r4.primitiveLength += a2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i2, s2, n3);
        }
      }
      Pi2(tc2, "FillBucket", { omit: ["layers", "patternFeatures"] });
      const ec2 = new Zs({ "fill-sort-key": new Os(Gt.layout_fill["fill-sort-key"]) });
      var rc2 = { paint: new Zs({ "fill-antialias": new $s(Gt.paint_fill["fill-antialias"]), "fill-opacity": new Os(Gt.paint_fill["fill-opacity"]), "fill-color": new Os(Gt.paint_fill["fill-color"]), "fill-outline-color": new Os(Gt.paint_fill["fill-outline-color"]), "fill-translate": new $s(Gt.paint_fill["fill-translate"]), "fill-translate-anchor": new $s(Gt.paint_fill["fill-translate-anchor"]), "fill-pattern": new qs(Gt.paint_fill["fill-pattern"]) }), layout: ec2 };
      const nc2 = Ws([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), ic2 = Ws([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), sc2 = Ws([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: ac2 } = nc2;
      var oc2 = lc2;
      function lc2(t3, e2, r3, n3, i2) {
        this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n3, this._values = i2, t3.readFields(uc2, this, e2);
      }
      function uc2(t3, e2, r3) {
        t3 == 1 ? e2.id = r3.readVarint() : t3 == 2 ? function(t4, e3) {
          for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
            var n3 = e3._keys[t4.readVarint()], i2 = e3._values[t4.readVarint()];
            e3.properties[n3] = i2;
          }
        }(r3, e2) : t3 == 3 ? e2.type = r3.readVarint() : t3 == 4 && (e2._geometry = r3.pos);
      }
      function cc2(t3) {
        for (var e2, r3, n3 = 0, i2 = 0, s2 = t3.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          n3 += ((r3 = t3[a2]).x - (e2 = t3[i2]).x) * (e2.y + r3.y);
        return n3;
      }
      lc2.types = ["Unknown", "Point", "LineString", "Polygon"], lc2.prototype.loadGeometry = function() {
        var t3 = this._pbf;
        t3.pos = this._geometry;
        for (var e2, r3 = t3.readVarint() + t3.pos, n3 = 1, s2 = 0, a2 = 0, o2 = 0, l3 = []; t3.pos < r3; ) {
          if (s2 <= 0) {
            var u3 = t3.readVarint();
            n3 = 7 & u3, s2 = u3 >> 3;
          }
          if (s2--, n3 === 1 || n3 === 2)
            a2 += t3.readSVarint(), o2 += t3.readSVarint(), n3 === 1 && (e2 && l3.push(e2), e2 = []), e2.push(new i(a2, o2));
          else {
            if (n3 !== 7)
              throw new Error("unknown command " + n3);
            e2 && e2.push(e2[0].clone());
          }
        }
        return e2 && l3.push(e2), l3;
      }, lc2.prototype.bbox = function() {
        var t3 = this._pbf;
        t3.pos = this._geometry;
        for (var e2 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l3 = 1 / 0, u3 = -1 / 0; t3.pos < e2; ) {
          if (n3 <= 0) {
            var c2 = t3.readVarint();
            r3 = 7 & c2, n3 = c2 >> 3;
          }
          if (n3--, r3 === 1 || r3 === 2)
            (i2 += t3.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t3.readSVarint()) < l3 && (l3 = s2), s2 > u3 && (u3 = s2);
          else if (r3 !== 7)
            throw new Error("unknown command " + r3);
        }
        return [a2, l3, o2, u3];
      }, lc2.prototype.toGeoJSON = function(t3, e2, r3) {
        var n3, i2, s2 = this.extent * Math.pow(2, r3), a2 = this.extent * t3, o2 = this.extent * e2, l3 = this.loadGeometry(), u3 = lc2.types[this.type];
        function c2(t4) {
          for (var e3 = 0; e3 < t4.length; e3++) {
            var r4 = t4[e3];
            t4[e3] = [360 * (r4.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + o2) / s2) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var h3 = [];
            for (n3 = 0; n3 < l3.length; n3++)
              h3[n3] = l3[n3][0];
            c2(l3 = h3);
            break;
          case 2:
            for (n3 = 0; n3 < l3.length; n3++)
              c2(l3[n3]);
            break;
          case 3:
            for (l3 = function(t4) {
              var e3 = t4.length;
              if (e3 <= 1)
                return [t4];
              for (var r4, n4, i3 = [], s3 = 0; s3 < e3; s3++) {
                var a3 = cc2(t4[s3]);
                a3 !== 0 && (n4 === void 0 && (n4 = a3 < 0), n4 === a3 < 0 ? (r4 && i3.push(r4), r4 = [t4[s3]]) : r4.push(t4[s3]));
              }
              return r4 && i3.push(r4), i3;
            }(l3), n3 = 0; n3 < l3.length; n3++)
              for (i2 = 0; i2 < l3[n3].length; i2++)
                c2(l3[n3][i2]);
        }
        l3.length === 1 ? l3 = l3[0] : u3 = "Multi" + u3;
        var p3 = { type: "Feature", geometry: { type: u3, coordinates: l3 }, properties: this.properties };
        return "id" in this && (p3.id = this.id), p3;
      };
      var hc2 = pc2;
      function pc2(t3, e2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(fc2, this, e2), this.length = this._features.length;
      }
      function fc2(t3, e2, r3) {
        t3 === 15 ? e2.version = r3.readVarint() : t3 === 1 ? e2.name = r3.readString() : t3 === 5 ? e2.extent = r3.readVarint() : t3 === 2 ? e2._features.push(r3.pos) : t3 === 3 ? e2._keys.push(r3.readString()) : t3 === 4 && e2._values.push(function(t4) {
          for (var e3 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
            var n3 = t4.readVarint() >> 3;
            e3 = n3 === 1 ? t4.readString() : n3 === 2 ? t4.readFloat() : n3 === 3 ? t4.readDouble() : n3 === 4 ? t4.readVarint64() : n3 === 5 ? t4.readVarint() : n3 === 6 ? t4.readSVarint() : n3 === 7 ? t4.readBoolean() : null;
          }
          return e3;
        }(r3));
      }
      function dc2(t3, e2, r3) {
        if (t3 === 3) {
          var n3 = new hc2(r3, r3.readVarint() + r3.pos);
          n3.length && (e2[n3.name] = n3);
        }
      }
      pc2.prototype.feature = function(t3) {
        if (t3 < 0 || t3 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t3];
        var e2 = this._pbf.readVarint() + this._pbf.pos;
        return new oc2(this._pbf, e2, this.extent, this._keys, this._values);
      };
      var yc2 = { VectorTile: function(t3, e2) {
        this.layers = t3.readFields(dc2, {}, e2);
      }, VectorTileFeature: oc2, VectorTileLayer: hc2 };
      function mc2(t3, e2, r3, n3) {
        const s2 = [], a2 = n3 === 0 ? (t4, e3, r4, n4, s3, a3) => {
          t4.push(new i(a3, r4 + (a3 - e3) / (n4 - e3) * (s3 - r4)));
        } : (t4, e3, r4, n4, s3, a3) => {
          t4.push(new i(e3 + (a3 - r4) / (s3 - r4) * (n4 - e3), a3));
        };
        for (const i2 of t3) {
          const t4 = [];
          for (const s3 of i2) {
            if (s3.length <= 2)
              continue;
            const i3 = [];
            for (let t5 = 0; t5 < s3.length - 1; t5++) {
              const o3 = s3[t5].x, l4 = s3[t5].y, u3 = s3[t5 + 1].x, c2 = s3[t5 + 1].y, h3 = n3 === 0 ? o3 : l4, p3 = n3 === 0 ? u3 : c2;
              h3 < e2 ? p3 > e2 && a2(i3, o3, l4, u3, c2, e2) : h3 > r3 ? p3 < r3 && a2(i3, o3, l4, u3, c2, r3) : i3.push(s3[t5]), p3 < e2 && h3 >= e2 && a2(i3, o3, l4, u3, c2, e2), p3 > r3 && h3 <= r3 && a2(i3, o3, l4, u3, c2, r3);
            }
            let o2 = s3[s3.length - 1];
            const l3 = n3 === 0 ? o2.x : o2.y;
            l3 >= e2 && l3 <= r3 && i3.push(o2), i3.length && (o2 = i3[i3.length - 1], i3[0].x === o2.x && i3[0].y === o2.y || i3.push(i3[0]), t4.push(i3));
          }
          t4.length && s2.push(t4);
        }
        return s2;
      }
      const gc2 = yc2.VectorTileFeature.types, xc2 = Math.pow(2, 13);
      function vc2(t3, e2, r3, n3, i2, s2, a2, o2) {
        t3.emplaceBack((e2 << 1) + a2, (r3 << 1) + s2, (Math.floor(n3 * xc2) << 1) + i2, Math.round(o2));
      }
      function bc2(t3, e2, r3) {
        const n3 = 16384;
        t3.emplaceBack(e2.x, e2.y, e2.z, r3[0] * n3, r3[1] * n3, r3[2] * n3);
      }
      class _c {
        constructor() {
          this.acc = new i(0, 0), this.polyCount = [];
        }
        startRing(t3) {
          this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new i(t3.x, t3.y), this.max = new i(t3.x, t3.y));
        }
        append(t3, e2) {
          this.currentPolyCount.edges++, this.acc._add(t3);
          const r3 = this.min, n3 = this.max;
          t3.x < r3.x ? r3.x = t3.x : t3.x > n3.x && (n3.x = t3.x), t3.y < r3.y ? r3.y = t3.y : t3.y > n3.y && (n3.y = t3.y), ((t3.x === 0 || t3.x === wo) && t3.x === e2.x) != ((t3.y === 0 || t3.y === wo) && t3.y === e2.y) && this.processBorderOverlap(t3, e2), e2.x < 0 != t3.x < 0 && this.addBorderIntersection(0, xr(e2.y, t3.y, (0 - e2.x) / (t3.x - e2.x))), e2.x > wo != t3.x > wo && this.addBorderIntersection(1, xr(e2.y, t3.y, (wo - e2.x) / (t3.x - e2.x))), e2.y < 0 != t3.y < 0 && this.addBorderIntersection(2, xr(e2.x, t3.x, (0 - e2.y) / (t3.y - e2.y))), e2.y > wo != t3.y > wo && this.addBorderIntersection(3, xr(e2.x, t3.x, (wo - e2.y) / (t3.y - e2.y)));
        }
        addBorderIntersection(t3, e2) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const r3 = this.borders[t3];
          e2 < r3[0] && (r3[0] = e2), e2 > r3[1] && (r3[1] = e2);
        }
        processBorderOverlap(t3, e2) {
          if (t3.x === e2.x) {
            if (t3.y === e2.y)
              return;
            const r3 = t3.x === 0 ? 0 : 1;
            this.addBorderIntersection(r3, e2.y), this.addBorderIntersection(r3, t3.y);
          } else {
            const r3 = t3.y === 0 ? 2 : 3;
            this.addBorderIntersection(r3, e2.x), this.addBorderIntersection(r3, t3.x);
          }
        }
        centroid() {
          const t3 = this.polyCount.reduce((t4, e2) => t4 + e2.edges, 0);
          return t3 !== 0 ? this.acc.div(t3)._round() : new i(0, 0);
        }
        span() {
          return new i(this.max.x - this.min.x, this.max.y - this.min.y);
        }
        intersectsCount() {
          return this.borders.reduce((t3, e2) => t3 + +(e2[0] !== Number.MAX_VALUE), 0);
        }
      }
      class wc2 {
        constructor(t3) {
          this.zoom = t3.zoom, this.canonical = t3.canonical, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t3.projection, this.layoutVertexArray = new ea2(), this.centroidVertexArray = new La2(), this.indexArray = new ya2(), this.programConfigurations = new co(t3.layers, t3.zoom), this.segments = new _o(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.enableTerrain = t3.enableTerrain;
        }
        populate(t3, e2, r3, n3) {
          this.features = [], this.hasPattern = Ju("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(t4) {
            const e3 = Math.exp(Math.PI * (1 - t4.y / (1 << t4.z) * 2));
            return 80150034 * e3 / (e3 * e3 + 1) / wo / (1 << t4.z);
          }(r3), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
          for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, l3 = Go(i2, t4);
            if (!this.layers[0]._featureFilter.filter(new Cs(this.zoom), l3, r3))
              continue;
            const u3 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t4 ? l3.geometry : No(i2, r3, n3), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(Qu("fill-extrusion", this.layers, u3, this.zoom, e2)) : this.addFeature(u3, u3.geometry, a2, r3, {}, e2.availableImages, n3), e2.featureIndex.insert(i2, u3.geometry, a2, o2, this.index, c2);
          }
          this.sortBorders();
        }
        addFeatures(t3, e2, r3, n3, i2) {
          for (const t4 of this.features) {
            const { geometry: s2 } = t4;
            this.addFeature(t4, s2, t4.index, e2, r3, n3, i2);
          }
          this.sortBorders();
        }
        update(t3, e2, r3, n3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3, n3);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, ac2), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t3.createVertexBuffer(this.layoutVertexExtArray, sc2.members, true))), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        uploadCentroid(t3) {
          this.centroidVertexArray.length !== 0 && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, ic2.members, true), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t3, e2, r3, n3, s2, a2, o2) {
          const l3 = [new i(0, 0), new i(wo, wo)], u3 = o2.projection, c2 = u3.name === "globe", h3 = this.enableTerrain && !c2 ? new _c() : null, p3 = gc2[t3.type] === "Polygon";
          c2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new ka2());
          const f2 = Yu(e2, 500);
          for (let t4 = f2.length - 1; t4 >= 0; t4--) {
            const e3 = f2[t4];
            (e3.length === 0 || (d2 = e3[0]).every((t5) => t5.x <= 0) || d2.every((t5) => t5.x >= wo) || d2.every((t5) => t5.y <= 0) || d2.every((t5) => t5.y >= wo)) && f2.splice(t4, 1);
          }
          var d2;
          let y3;
          if (c2)
            y3 = Bc2(f2, l3, n3);
          else {
            y3 = [];
            for (const t4 of f2)
              y3.push({ polygon: t4, bounds: l3 });
          }
          const m3 = p3 ? this.edgeRadius : 0;
          for (const { polygon: t4, bounds: e3 } of y3) {
            let r4 = 0, i2 = 0;
            for (const e4 of t4)
              p3 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i2 += p3 ? e4.length - 1 : e4.length;
            const s3 = this.segments.prepareSegment((p3 ? 5 : 4) * i2, this.layoutVertexArray, this.indexArray);
            if (p3) {
              const e4 = [], i3 = [];
              r4 = s3.vertexLength;
              for (const r5 of t4) {
                let a4, o3;
                r5.length && r5 !== t4[0] && i3.push(e4.length / 2), a4 = r5[1].sub(r5[0])._perp()._unit();
                for (let t5 = 1; t5 < r5.length; t5++) {
                  const i4 = r5[t5], l4 = r5[t5 === r5.length - 1 ? 1 : t5 + 1];
                  let { x: h4, y: p4 } = i4;
                  if (m3) {
                    o3 = l4.sub(i4)._perp()._unit();
                    const t6 = a4.add(o3)._unit(), e5 = m3 * Math.min(4, 1 / (a4.x * t6.x + a4.y * t6.y));
                    h4 += e5 * t6.x, p4 += e5 * t6.y, a4 = o3;
                  }
                  vc2(this.layoutVertexArray, h4, p4, 0, 0, 1, 1, 0), s3.vertexLength++, e4.push(i4.x, i4.y), c2 && bc2(this.layoutVertexExtArray, u3.projectTilePoint(h4, p4, n3), u3.upVector(n3, h4, p4));
                }
              }
              const a3 = xu(e4, i3);
              for (let t5 = 0; t5 < a3.length; t5 += 3)
                this.indexArray.emplaceBack(r4 + a3[t5], r4 + a3[t5 + 2], r4 + a3[t5 + 1]), s3.primitiveLength++;
            }
            for (const i3 of t4) {
              h3 && i3.length && h3.startRing(i3[0]);
              let t5, a3, o3, l4 = i3.length > 4 && Mc2(i3[i3.length - 2], i3[0], i3[1]), f3 = m3 ? Sc2(i3[i3.length - 2], i3[0], i3[1], m3) : 0;
              a3 = i3[1].sub(i3[0])._perp()._unit();
              for (let d3 = 1, y4 = 0; d3 < i3.length; d3++) {
                let g2 = i3[d3 - 1], x3 = i3[d3];
                const v3 = i3[d3 === i3.length - 1 ? 1 : d3 + 1];
                if (h3 && p3 && h3.currentPolyCount.top++, Ic2(x3, g2, e3)) {
                  m3 && (a3 = v3.sub(x3)._perp()._unit());
                  continue;
                }
                h3 && h3.append(x3, g2);
                const b2 = x3.sub(g2)._perp(), _2 = b2.x / (Math.abs(b2.x) + Math.abs(b2.y)), w2 = b2.y > 0 ? 1 : 0, A3 = g2.dist(x3);
                if (y4 + A3 > 32768 && (y4 = 0), m3) {
                  o3 = v3.sub(x3)._perp()._unit();
                  let t6 = kc2(g2, x3, v3, Ac2(a3, o3), m3);
                  isNaN(t6) && (t6 = 0);
                  const e4 = x3.sub(g2)._unit();
                  g2 = g2.add(e4.mult(f3))._round(), x3 = x3.add(e4.mult(-t6))._round(), f3 = t6, a3 = o3;
                }
                const S3 = s3.vertexLength, k2 = i3.length > 4 && Mc2(g2, x3, v3);
                let I3 = zc2(y4, l4, true);
                if (vc2(this.layoutVertexArray, g2.x, g2.y, _2, w2, 0, 0, I3), vc2(this.layoutVertexArray, g2.x, g2.y, _2, w2, 0, 1, I3), y4 += A3, I3 = zc2(y4, k2, false), l4 = k2, vc2(this.layoutVertexArray, x3.x, x3.y, _2, w2, 0, 0, I3), vc2(this.layoutVertexArray, x3.x, x3.y, _2, w2, 0, 1, I3), s3.vertexLength += 4, this.indexArray.emplaceBack(S3 + 0, S3 + 1, S3 + 2), this.indexArray.emplaceBack(S3 + 1, S3 + 3, S3 + 2), s3.primitiveLength += 2, m3) {
                  const n4 = r4 + (d3 === 1 ? i3.length - 2 : d3 - 2), a4 = d3 === 1 ? r4 : n4 + 1;
                  if (this.indexArray.emplaceBack(S3 + 1, n4, S3 + 3), this.indexArray.emplaceBack(n4, a4, S3 + 3), s3.primitiveLength += 2, t5 === void 0 && (t5 = S3), !Ic2(v3, i3[d3], e3)) {
                    const e4 = d3 === i3.length - 1 ? t5 : s3.vertexLength;
                    this.indexArray.emplaceBack(S3 + 2, S3 + 3, e4), this.indexArray.emplaceBack(S3 + 3, e4 + 1, e4), this.indexArray.emplaceBack(S3 + 3, a4, e4 + 1), s3.primitiveLength += 3;
                  }
                }
                if (c2) {
                  const t6 = this.layoutVertexExtArray, e4 = u3.projectTilePoint(g2.x, g2.y, n3), r5 = u3.projectTilePoint(x3.x, x3.y, n3), i4 = u3.upVector(n3, g2.x, g2.y), s4 = u3.upVector(n3, x3.x, x3.y);
                  bc2(t6, e4, i4), bc2(t6, e4, i4), bc2(t6, r5, s4), bc2(t6, r5, s4);
                }
              }
              p3 && (r4 += i3.length - 1);
            }
          }
          if (h3 && h3.polyCount.length > 0) {
            if (h3.borders) {
              h3.vertexArrayOffset = this.centroidVertexArray.length;
              const t4 = h3.borders, e3 = this.featuresOnBorder.push(h3) - 1;
              for (let r4 = 0; r4 < 4; r4++)
                t4[r4][0] !== Number.MAX_VALUE && this.borders[r4].push(e3);
            }
            this.encodeCentroid(h3.borders ? void 0 : h3.centroid(), h3);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, s2, a2, n3);
        }
        sortBorders() {
          for (let t3 = 0; t3 < 4; t3++)
            this.borders[t3].sort((e2, r3) => this.featuresOnBorder[e2].borders[t3][0] - this.featuresOnBorder[r3].borders[t3][0]);
        }
        encodeCentroid(t3, e2, r3 = true) {
          let n3, i2;
          if (t3)
            if (t3.y !== 0) {
              const r4 = e2.span()._mult(this.tileToMeter);
              n3 = (Math.max(t3.x, 1) << 3) + Math.min(7, Math.round(r4.x / 10)), i2 = (Math.max(t3.y, 1) << 3) + Math.min(7, Math.round(r4.y / 10));
            } else
              n3 = Math.ceil(7 * (t3.x + 450)), i2 = 0;
          else
            n3 = 0, i2 = +r3;
          let s2 = r3 ? this.centroidVertexArray.length : e2.vertexArrayOffset;
          for (const t4 of e2.polyCount) {
            r3 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t4.edges + t4.top);
            for (let e3 = 0; e3 < t4.top; e3++)
              this.centroidVertexArray.emplace(s2++, n3, i2);
            for (let e3 = 0; e3 < 2 * t4.edges; e3++)
              this.centroidVertexArray.emplace(s2++, 0, i2), this.centroidVertexArray.emplace(s2++, n3, i2);
          }
        }
      }
      function Ac2(t3, e2) {
        const r3 = t3.add(e2)._unit();
        return t3.x * r3.x + t3.y * r3.y;
      }
      function Sc2(t3, e2, r3, n3) {
        const i2 = e2.sub(t3)._perp()._unit(), s2 = r3.sub(e2)._perp()._unit();
        return kc2(t3, e2, r3, Ac2(i2, s2), n3);
      }
      function kc2(t3, e2, r3, n3, i2) {
        const s2 = Math.sqrt(1 - n3 * n3);
        return Math.min(t3.dist(e2) / 3, e2.dist(r3) / 3, i2 * s2 / n3);
      }
      function Ic2(t3, e2, r3) {
        return t3.x < r3[0].x && e2.x < r3[0].x || t3.x > r3[1].x && e2.x > r3[1].x || t3.y < r3[0].y && e2.y < r3[0].y || t3.y > r3[1].y && e2.y > r3[1].y;
      }
      function Mc2(t3, e2, r3) {
        if (t3.x < 0 || t3.x >= wo || e2.x < 0 || e2.x >= wo || r3.x < 0 || r3.x >= wo)
          return false;
        const n3 = r3.sub(e2), i2 = n3.perp(), s2 = t3.sub(e2);
        return (n3.x * s2.x + n3.y * s2.y) / Math.sqrt((n3.x * n3.x + n3.y * n3.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
      }
      function zc2(t3, e2, r3) {
        const n3 = e2 ? 2 | t3 : -3 & t3;
        return r3 ? 1 | n3 : -2 & n3;
      }
      function Tc2() {
        const t3 = Math.PI / 32, e2 = Math.tan(t3), r3 = So;
        return r3 * Math.sqrt(1 + 2 * e2 * e2) - r3;
      }
      function Bc2(t3, e2, r3) {
        const n3 = 1 << r3.z, s2 = Eo(r3.x / n3), a2 = Eo((r3.x + 1) / n3), o2 = Co(r3.y / n3), l3 = Co((r3.y + 1) / n3);
        return function(t4, e3, r4, n4, s3 = 0, a3) {
          const o3 = [];
          if (!t4.length || !r4 || !n4)
            return o3;
          const l4 = (t5, e4) => {
            for (const r5 of t5)
              o3.push({ polygon: r5, bounds: e4 });
          }, u3 = Math.ceil(Math.log2(r4)), c2 = Math.ceil(Math.log2(n4)), h3 = u3 - c2, p3 = [];
          for (let t5 = 0; t5 < Math.abs(h3); t5++)
            p3.push(h3 > 0 ? 0 : 1);
          for (let t5 = 0; t5 < Math.min(u3, c2); t5++)
            p3.push(0), p3.push(1);
          let f2 = t4;
          if (f2 = mc2(f2, e3[0].y - s3, e3[1].y + s3, 1), f2 = mc2(f2, e3[0].x - s3, e3[1].x + s3, 0), !f2.length)
            return o3;
          const d2 = [];
          for (p3.length ? d2.push({ polygons: f2, bounds: e3, depth: 0 }) : l4(f2, e3); d2.length; ) {
            const t5 = d2.pop(), e4 = t5.depth, r5 = p3[e4], n5 = t5.bounds[0], o4 = t5.bounds[1], u4 = r5 === 0 ? n5.x : n5.y, c3 = r5 === 0 ? o4.x : o4.y, h4 = a3 ? a3(r5, u4, c3) : 0.5 * (u4 + c3), f3 = mc2(t5.polygons, u4 - s3, h4 + s3, r5), y3 = mc2(t5.polygons, h4 - s3, c3 + s3, r5);
            if (f3.length) {
              const t6 = [n5, new i(r5 === 0 ? h4 : o4.x, r5 === 1 ? h4 : o4.y)];
              p3.length > e4 + 1 ? d2.push({ polygons: f3, bounds: t6, depth: e4 + 1 }) : l4(f3, t6);
            }
            if (y3.length) {
              const t6 = [new i(r5 === 0 ? h4 : n5.x, r5 === 1 ? h4 : n5.y), o4];
              p3.length > e4 + 1 ? d2.push({ polygons: y3, bounds: t6, depth: e4 + 1 }) : l4(y3, t6);
            }
          }
          return o3;
        }(t3, e2, Math.ceil((a2 - s2) / 11.25), Math.ceil((o2 - l3) / 11.25), 1, (t4, e3, i2) => {
          if (t4 === 0)
            return 0.5 * (e3 + i2);
          {
            const t5 = Co((r3.y + e3 / wo) / n3);
            return (To(0.5 * (Co((r3.y + i2 / wo) / n3) + t5)) * n3 - r3.y) * wo;
          }
        });
      }
      Pi2(wc2, "FillExtrusionBucket", { omit: ["layers", "features"] }), Pi2(_c, "PartMetadata");
      const Ec2 = new Zs({ "fill-extrusion-edge-radius": new $s(Gt["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
      var Cc2 = { paint: new Zs({ "fill-extrusion-opacity": new $s(Gt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Os(Gt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new $s(Gt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new $s(Gt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new qs(Gt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Os(Gt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Os(Gt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new $s(Gt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new $s(Gt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new $s(Gt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]) }), layout: Ec2 };
      function Pc2(t3, e2, r3) {
        var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
        return [t3 * n3 - 2 * Math.PI * 6378137 / 2, e2 * n3 - 2 * Math.PI * 6378137 / 2];
      }
      class Dc2 {
        constructor(t3, e2, r3) {
          this.z = t3, this.x = e2, this.y = r3, this.key = Lc2(0, t3, t3, e2, r3);
        }
        equals(t3) {
          return this.z === t3.z && this.x === t3.x && this.y === t3.y;
        }
        url(t3, e2) {
          const r3 = function(t4, e3, r4) {
            var n4 = Pc2(256 * t4, 256 * (e3 = Math.pow(2, r4) - e3 - 1), r4), i2 = Pc2(256 * (t4 + 1), 256 * (e3 + 1), r4);
            return n4[0] + "," + n4[1] + "," + i2[0] + "," + i2[1];
          }(this.x, this.y, this.z), n3 = function(t4, e3, r4) {
            let n4, i2 = "";
            for (let s2 = t4; s2 > 0; s2--)
              n4 = 1 << s2 - 1, i2 += (e3 & n4 ? 1 : 0) + (r4 & n4 ? 2 : 0);
            return i2;
          }(this.z, this.x, this.y);
          return t3[(this.x + this.y) % t3.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(e2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n3).replace("{bbox-epsg-3857}", r3);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Vc2 {
        constructor(t3, e2) {
          this.wrap = t3, this.canonical = e2, this.key = Lc2(t3, e2.z, e2.z, e2.x, e2.y);
        }
      }
      class Fc2 {
        constructor(t3, e2, r3, n3, i2) {
          this.overscaledZ = t3, this.wrap = e2, this.canonical = new Dc2(r3, +n3, +i2), this.key = e2 === 0 && t3 === r3 ? this.canonical.key : Lc2(e2, t3, r3, n3, i2);
        }
        equals(t3) {
          return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
        }
        scaledTo(t3) {
          const e2 = this.canonical.z - t3;
          return t3 > this.canonical.z ? new Fc2(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Fc2(t3, this.wrap, t3, this.canonical.x >> e2, this.canonical.y >> e2);
        }
        calculateScaledKey(t3, e2 = true) {
          if (this.overscaledZ === t3 && e2)
            return this.key;
          if (t3 > this.canonical.z)
            return Lc2(this.wrap * +e2, t3, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const r3 = this.canonical.z - t3;
            return Lc2(this.wrap * +e2, t3, t3, this.canonical.x >> r3, this.canonical.y >> r3);
          }
        }
        isChildOf(t3) {
          if (t3.wrap !== this.wrap)
            return false;
          const e2 = this.canonical.z - t3.canonical.z;
          return t3.overscaledZ === 0 || t3.overscaledZ < this.overscaledZ && t3.canonical.x === this.canonical.x >> e2 && t3.canonical.y === this.canonical.y >> e2;
        }
        children(t3) {
          if (this.overscaledZ >= t3)
            return [new Fc2(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e2 = this.canonical.z + 1, r3 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
          return [new Fc2(e2, this.wrap, e2, r3, n3), new Fc2(e2, this.wrap, e2, r3 + 1, n3), new Fc2(e2, this.wrap, e2, r3, n3 + 1), new Fc2(e2, this.wrap, e2, r3 + 1, n3 + 1)];
        }
        isLessThan(t3) {
          return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
        }
        wrapped() {
          return new Fc2(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t3) {
          return new Fc2(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Vc2(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function Lc2(t3, e2, r3, n3, i2) {
        const s2 = 1 << Math.min(r3, 22);
        let a2 = s2 * (i2 % s2) + n3 % s2;
        return t3 && r3 < 22 && (a2 += s2 * s2 * ((t3 < 0 ? -2 * t3 - 1 : 2 * t3) % (1 << 2 * (22 - r3)))), 16 * (32 * a2 + r3) + (e2 - r3);
      }
      function Rc2(t3, e2) {
        return t3.x * e2.x + t3.y * e2.y;
      }
      function Uc2(t3, e2) {
        if (t3.length === 1) {
          let r3 = 0;
          const n3 = e2[r3++];
          let i2;
          for (; !i2 || n3.equals(i2); )
            if (i2 = e2[r3++], !i2)
              return 1 / 0;
          for (; r3 < e2.length; r3++) {
            const s2 = e2[r3], a2 = t3[0], o2 = i2.sub(n3), l3 = s2.sub(n3), u3 = a2.sub(n3), c2 = Rc2(o2, o2), h3 = Rc2(o2, l3), p3 = Rc2(l3, l3), f2 = Rc2(u3, o2), d2 = Rc2(u3, l3), y3 = c2 * p3 - h3 * h3, m3 = (p3 * f2 - h3 * d2) / y3, g2 = (c2 * d2 - h3 * f2) / y3, x3 = n3.z * (1 - m3 - g2) + i2.z * m3 + s2.z * g2;
            if (isFinite(x3))
              return x3;
          }
          return 1 / 0;
        }
        {
          let t4 = 1 / 0;
          for (const r3 of e2)
            t4 = Math.min(t4, r3.z);
          return t4;
        }
      }
      function jc2(t3) {
        const e2 = new i(t3[0], t3[1]);
        return e2.z = t3[2], e2;
      }
      function $c2(t3, e2, r3, n3, i2, s2, a2, o2) {
        const l3 = a2 * i2.getElevationAt(t3, e2, true, true), u3 = s2[0] !== 0, c2 = u3 ? s2[1] === 0 ? a2 * (s2[0] / 7 - 450) : a2 * function(t4, e3, r4) {
          const n4 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n4), a3 = 10 * (e3[1] - 8 * i3), o3 = t4.getElevationAt(n4, i3, true, true), l4 = t4.getMeterToDEM(r4), u4 = Math.floor(0.5 * (s3 * l4 - 1)), c3 = Math.floor(0.5 * (a3 * l4 - 1)), h3 = t4.tileCoordToPixel(n4, i3), p3 = 2 * u4 + 1, f2 = 2 * c3 + 1, d2 = function(t5, e4, r5, n5, i4) {
            return [t5.getElevationAtPixel(e4, r5, true), t5.getElevationAtPixel(e4 + i4, r5, true), t5.getElevationAtPixel(e4, r5 + i4, true), t5.getElevationAtPixel(e4 + n5, r5 + i4, true)];
          }(t4, h3.x - u4, h3.y - c3, p3, f2), y3 = Math.abs(d2[0] - d2[1]), m3 = Math.abs(d2[2] - d2[3]), g2 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x3 = Math.min(0.25, 0.5 * l4 * (y3 + m3) / p3), v3 = Math.min(0.25, 0.5 * l4 * g2 / f2);
          return o3 + Math.max(x3 * s3, v3 * a3);
        }(i2, s2, o2) : l3;
        return { base: l3 + (r3 === 0) ? -1 : r3, top: u3 ? Math.max(c2 + n3, l3 + r3 + 2) : l3 + n3 };
      }
      Pi2(Dc2, "CanonicalTileID"), Pi2(Fc2, "OverscaledTileID", { omit: ["projMatrix"] });
      const Oc2 = Ws([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: qc2 } = Oc2, Nc2 = Ws([{ name: "a_packed", components: 4, type: "Float32" }]), { members: Gc2 } = Nc2, Zc2 = yc2.VectorTileFeature.types, Xc2 = Math.cos(Math.PI / 180 * 37.5);
      class Kc2 {
        constructor(t3) {
          this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.projection = t3.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
            this.gradients[t4.id] = {};
          }), this.layoutVertexArray = new ra2(), this.layoutVertexArray2 = new na2(), this.indexArray = new ya2(), this.programConfigurations = new co(t3.layers, t3.zoom), this.segments = new _o(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
        }
        populate(t3, e2, r3, n3) {
          this.hasPattern = Ju("line", this.layers, e2);
          const i2 = this.layers[0].layout.get("line-sort-key"), s2 = [];
          for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: l4 } of t3) {
            const t4 = this.layers[0]._featureFilter.needGeometry, u3 = Go(e3, t4);
            if (!this.layers[0]._featureFilter.filter(new Cs(this.zoom), u3, r3))
              continue;
            const c2 = i2 ? i2.evaluate(u3, {}, r3) : void 0, h3 = { id: a3, properties: e3.properties, type: e3.type, sourceLayerIndex: l4, index: o3, geometry: t4 ? u3.geometry : No(e3, r3, n3), patterns: {}, sortKey: c2 };
            s2.push(h3);
          }
          i2 && s2.sort((t4, e3) => t4.sortKey - e3.sortKey);
          const { lineAtlas: a2, featureIndex: o2 } = e2, l3 = this.addConstantDashes(a2);
          for (const n4 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: u3 } = n4;
            if (l3 && this.addFeatureDashes(n4, a2), this.hasPattern) {
              const t4 = Qu("line", this.layers, n4, this.zoom, e2);
              this.patternFeatures.push(t4);
            } else
              this.addFeature(n4, i3, s3, r3, a2.positions, e2.availableImages);
            o2.insert(t3[s3].feature, i3, s3, u3, this.index);
          }
        }
        addConstantDashes(t3) {
          let e2 = false;
          for (const r3 of this.layers) {
            const n3 = r3.paint.get("line-dasharray").value, i2 = r3.layout.get("line-cap").value;
            if (n3.kind !== "constant" || i2.kind !== "constant")
              e2 = true;
            else {
              const e3 = i2.value, r4 = n3.value;
              if (!r4)
                continue;
              t3.addDash(r4.from, e3), t3.addDash(r4.to, e3), r4.other && t3.addDash(r4.other, e3);
            }
          }
          return e2;
        }
        addFeatureDashes(t3, e2) {
          const r3 = this.zoom;
          for (const n3 of this.layers) {
            const i2 = n3.paint.get("line-dasharray").value, s2 = n3.layout.get("line-cap").value;
            if (i2.kind === "constant" && s2.kind === "constant")
              continue;
            let a2, o2, l3, u3, c2, h3;
            if (i2.kind === "constant") {
              const t4 = i2.value;
              if (!t4)
                continue;
              a2 = t4.other || t4.to, o2 = t4.to, l3 = t4.from;
            } else
              a2 = i2.evaluate({ zoom: r3 - 1 }, t3), o2 = i2.evaluate({ zoom: r3 }, t3), l3 = i2.evaluate({ zoom: r3 + 1 }, t3);
            s2.kind === "constant" ? u3 = c2 = h3 = s2.value : (u3 = s2.evaluate({ zoom: r3 - 1 }, t3), c2 = s2.evaluate({ zoom: r3 }, t3), h3 = s2.evaluate({ zoom: r3 + 1 }, t3)), e2.addDash(a2, u3), e2.addDash(o2, c2), e2.addDash(l3, h3);
            const p3 = e2.getKey(a2, u3), f2 = e2.getKey(o2, c2), d2 = e2.getKey(l3, h3);
            t3.patterns[n3.id] = { min: p3, mid: f2, max: d2 };
          }
        }
        update(t3, e2, r3, n3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e2, this.stateDependentLayers, r3, n3);
        }
        addFeatures(t3, e2, r3, n3, i2) {
          for (const t4 of this.patternFeatures)
            this.addFeature(t4, t4.geometry, t4.index, e2, r3, n3);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t3) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, Gc2)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, qc2), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t3) {
          if (t3.properties && t3.properties.hasOwnProperty("mapbox_clip_start") && t3.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
        }
        addFeature(t3, e2, r3, n3, i2, s2) {
          const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t3, {}), l3 = a2.get("line-cap").evaluate(t3, {}), u3 = a2.get("line-miter-limit"), c2 = a2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t3);
          for (const r4 of e2)
            this.addLine(r4, t3, o2, l3, u3, c2);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i2, s2, n3);
        }
        addLine(t3, e2, r3, n3, i2, s2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0; e3 < t3.length - 1; e3++)
              this.totalDistance += t3[e3].dist(t3[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const a2 = Zc2[e2.type] === "Polygon";
          let o2 = t3.length;
          for (; o2 >= 2 && t3[o2 - 1].equals(t3[o2 - 2]); )
            o2--;
          let l3 = 0;
          for (; l3 < o2 - 1 && t3[l3].equals(t3[l3 + 1]); )
            l3++;
          if (o2 < (a2 ? 3 : 2))
            return;
          r3 === "bevel" && (i2 = 1.05);
          const u3 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
          let h3, p3, f2, d2, y3;
          this.e1 = this.e2 = -1, a2 && (h3 = t3[o2 - 2], y3 = t3[l3].sub(h3)._unit()._perp());
          for (let e3 = l3; e3 < o2; e3++) {
            if (f2 = e3 === o2 - 1 ? a2 ? t3[l3 + 1] : void 0 : t3[e3 + 1], f2 && t3[e3].equals(f2))
              continue;
            y3 && (d2 = y3), h3 && (p3 = h3), h3 = t3[e3], y3 = f2 ? f2.sub(h3)._unit()._perp() : d2, d2 = d2 || y3;
            let m3 = d2.add(y3);
            m3.x === 0 && m3.y === 0 || m3._unit();
            const g2 = d2.x * y3.x + d2.y * y3.y, x3 = m3.x * y3.x + m3.y * y3.y, v3 = x3 !== 0 ? 1 / x3 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x3), _2 = x3 < Xc2 && p3 && f2, w2 = d2.x * y3.y - d2.y * y3.x > 0;
            if (_2 && e3 > l3) {
              const t4 = h3.dist(p3);
              if (t4 > 2 * u3) {
                const e4 = h3.sub(h3.sub(p3)._mult(u3 / t4)._round());
                this.updateDistance(p3, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p3 = e4;
              }
            }
            const A3 = p3 && f2;
            let S3 = A3 ? r3 : a2 ? "butt" : n3;
            if (A3 && S3 === "round" && (v3 < s2 ? S3 = "miter" : v3 <= 2 && (S3 = "fakeround")), S3 === "miter" && v3 > i2 && (S3 = "bevel"), S3 === "bevel" && (v3 > 2 && (S3 = "flipbevel"), v3 < i2 && (S3 = "miter")), p3 && this.updateDistance(p3, h3), S3 === "miter")
              m3._mult(v3), this.addCurrentVertex(h3, m3, 0, 0, c2);
            else if (S3 === "flipbevel") {
              if (v3 > 100)
                m3 = y3.mult(-1);
              else {
                const t4 = v3 * d2.add(y3).mag() / d2.sub(y3).mag();
                m3._perp()._mult(t4 * (w2 ? -1 : 1));
              }
              this.addCurrentVertex(h3, m3, 0, 0, c2), this.addCurrentVertex(h3, m3.mult(-1), 0, 0, c2);
            } else if (S3 === "bevel" || S3 === "fakeround") {
              const t4 = -Math.sqrt(v3 * v3 - 1), e4 = w2 ? t4 : 0, r4 = w2 ? 0 : t4;
              if (p3 && this.addCurrentVertex(h3, d2, e4, r4, c2), S3 === "fakeround") {
                const t5 = Math.round(180 * b2 / Math.PI / 20);
                for (let e5 = 1; e5 < t5; e5++) {
                  let r5 = e5 / t5;
                  if (r5 !== 0.5) {
                    const t6 = r5 - 0.5;
                    r5 += r5 * t6 * (r5 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t6 * t6 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                  }
                  const n4 = y3.sub(d2)._mult(r5)._add(d2)._unit()._mult(w2 ? -1 : 1);
                  this.addHalfVertex(h3, n4.x, n4.y, false, w2, 0, c2);
                }
              }
              f2 && this.addCurrentVertex(h3, y3, -e4, -r4, c2);
            } else if (S3 === "butt")
              this.addCurrentVertex(h3, m3, 0, 0, c2);
            else if (S3 === "square") {
              const t4 = p3 ? 1 : -1;
              p3 || this.addCurrentVertex(h3, m3, t4, t4, c2), this.addCurrentVertex(h3, m3, 0, 0, c2), p3 && this.addCurrentVertex(h3, m3, t4, t4, c2);
            } else
              S3 === "round" && (p3 && (this.addCurrentVertex(h3, d2, 0, 0, c2), this.addCurrentVertex(h3, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h3, y3, -1, -1, c2, true), this.addCurrentVertex(h3, y3, 0, 0, c2)));
            if (_2 && e3 < o2 - 1) {
              const t4 = h3.dist(f2);
              if (t4 > 2 * u3) {
                const e4 = h3.add(f2.sub(h3)._mult(u3 / t4)._round());
                this.updateDistance(h3, e4), this.addCurrentVertex(e4, y3, 0, 0, c2), h3 = e4;
              }
            }
          }
        }
        addCurrentVertex(t3, e2, r3, n3, i2, s2 = false) {
          const a2 = e2.y * n3 - e2.x, o2 = -e2.y - e2.x * n3;
          this.addHalfVertex(t3, e2.x + e2.y * r3, e2.y - e2.x * r3, s2, false, r3, i2), this.addHalfVertex(t3, a2, o2, s2, true, -n3, i2);
        }
        addHalfVertex({ x: t3, y: e2 }, r3, n3, i2, s2, a2, o2) {
          this.layoutVertexArray.emplaceBack((t3 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r3) + 128, Math.round(63 * n3) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const l3 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l3), o2.primitiveLength++), s2 ? this.e2 = l3 : this.e1 = l3;
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const t3 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t3 * this.lineClips.start + this.distance;
          } else
            this.lineSoFar = this.distance;
        }
        updateDistance(t3, e2) {
          this.distance += t3.dist(e2), this.updateScaledDistance();
        }
      }
      Pi2(Kc2, "LineBucket", { omit: ["layers", "patternFeatures"] });
      const Hc2 = new Zs({ "line-cap": new Os(Gt.layout_line["line-cap"]), "line-join": new Os(Gt.layout_line["line-join"]), "line-miter-limit": new $s(Gt.layout_line["line-miter-limit"]), "line-round-limit": new $s(Gt.layout_line["line-round-limit"]), "line-sort-key": new Os(Gt.layout_line["line-sort-key"]) });
      var Yc2 = { paint: new Zs({ "line-opacity": new Os(Gt.paint_line["line-opacity"]), "line-color": new Os(Gt.paint_line["line-color"]), "line-translate": new $s(Gt.paint_line["line-translate"]), "line-translate-anchor": new $s(Gt.paint_line["line-translate-anchor"]), "line-width": new Os(Gt.paint_line["line-width"]), "line-gap-width": new Os(Gt.paint_line["line-gap-width"]), "line-offset": new Os(Gt.paint_line["line-offset"]), "line-blur": new Os(Gt.paint_line["line-blur"]), "line-dasharray": new qs(Gt.paint_line["line-dasharray"]), "line-pattern": new qs(Gt.paint_line["line-pattern"]), "line-gradient": new Gs(Gt.paint_line["line-gradient"]), "line-trim-offset": new $s(Gt.paint_line["line-trim-offset"]) }), layout: Hc2 };
      const Wc2 = new class extends Os {
        possiblyEvaluate(t3, e2) {
          return e2 = new Cs(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t3, e2);
        }
        evaluate(t3, e2, r3, n3) {
          return e2 = v2({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t3, e2, r3, n3);
        }
      }(Yc2.paint.properties["line-width"].specification);
      function Jc2(t3, e2) {
        return e2 > 0 ? e2 + 2 * t3 : t3;
      }
      Wc2.useIntegerZoom = true;
      const Qc2 = Ws([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), th2 = Ws([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), eh2 = Ws([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      Ws([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const rh2 = Ws([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), nh2 = Ws([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
      Ws([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const ih2 = Ws([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), sh2 = Ws([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      Ws([{ name: "triangle", components: 3, type: "Uint16" }]), Ws([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Ws([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Ws([{ type: "Float32", name: "offsetX" }]), Ws([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      var ah2 = 24;
      const oh2 = 128;
      function lh2(t3, e2) {
        const { expression: r3 } = e2;
        if (r3.kind === "constant")
          return { kind: "constant", layoutSize: r3.evaluate(new Cs(t3 + 1)) };
        if (r3.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n3 } = r3;
          let i2 = 0;
          for (; i2 < e3.length && e3[i2] <= t3; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (; s2 < e3.length && e3[s2] < t3 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return r3.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n3 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r3.evaluate(new Cs(a2)), maxSize: r3.evaluate(new Cs(o2)), interpolationType: n3 };
        }
      }
      function uh2(t3, { uSize: e2, uSizeT: r3 }, { lowerSize: n3, upperSize: i2 }) {
        return t3.kind === "source" ? n3 / oh2 : t3.kind === "composite" ? xr(n3 / oh2, i2 / oh2, r3) : e2;
      }
      function ch2(t3, e2) {
        let r3 = 0, n3 = 0;
        if (t3.kind === "constant")
          n3 = t3.layoutSize;
        else if (t3.kind !== "source") {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t3, o2 = i2 ? d(jr.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
          t3.kind === "camera" ? n3 = xr(t3.minSize, t3.maxSize, o2) : r3 = o2;
        }
        return { uSizeT: r3, uSize: n3 };
      }
      var hh2 = Object.freeze({ __proto__: null, getSizeData: lh2, evaluateSizeForFeature: uh2, evaluateSizeForZoom: ch2, SIZE_PACK_FACTOR: oh2 });
      function ph2(t3, e2, r3) {
        return t3.sections.forEach((t4) => {
          t4.text = function(t5, e3, r4) {
            const n3 = e3.layout.get("text-transform").evaluate(r4, {});
            return n3 === "uppercase" ? t5 = t5.toLocaleUpperCase() : n3 === "lowercase" && (t5 = t5.toLocaleLowerCase()), Es.applyArabicShaping && (t5 = Es.applyArabicShaping(t5)), t5;
          }(t4.text, e2, r3);
        }), t3;
      }
      const fh2 = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
      function dh2(t3) {
        return t3 === "\uFE36" || t3 === "\uFE48" || t3 === "\uFE38" || t3 === "\uFE44" || t3 === "\uFE42" || t3 === "\uFE3E" || t3 === "\uFE3C" || t3 === "\uFE3A" || t3 === "\uFE18" || t3 === "\uFE40" || t3 === "\uFE10" || t3 === "\uFE13" || t3 === "\uFE14" || t3 === "\uFF40" || t3 === "\uFFE3" || t3 === "\uFE11" || t3 === "\uFE12";
      }
      function yh2(t3) {
        return t3 === "\uFE35" || t3 === "\uFE47" || t3 === "\uFE37" || t3 === "\uFE43" || t3 === "\uFE41" || t3 === "\uFE3D" || t3 === "\uFE3B" || t3 === "\uFE39" || t3 === "\uFE17" || t3 === "\uFE3F";
      }
      var mh2 = function(t3, e2, r3, n3, i2) {
        var s2, a2, o2 = 8 * i2 - n3 - 1, l3 = (1 << o2) - 1, u3 = l3 >> 1, c2 = -7, h3 = r3 ? i2 - 1 : 0, p3 = r3 ? -1 : 1, f2 = t3[e2 + h3];
        for (h3 += p3, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t3[e2 + h3], h3 += p3, c2 -= 8)
          ;
        for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n3; c2 > 0; a2 = 256 * a2 + t3[e2 + h3], h3 += p3, c2 -= 8)
          ;
        if (s2 === 0)
          s2 = 1 - u3;
        else {
          if (s2 === l3)
            return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
          a2 += Math.pow(2, n3), s2 -= u3;
        }
        return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n3);
      }, gh2 = function(t3, e2, r3, n3, i2, s2) {
        var a2, o2, l3, u3 = 8 * s2 - i2 - 1, c2 = (1 << u3) - 1, h3 = c2 >> 1, p3 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n3 ? 0 : s2 - 1, d2 = n3 ? 1 : -1, y3 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l3 = Math.pow(2, -a2)) < 1 && (a2--, l3 *= 2), (e2 += a2 + h3 >= 1 ? p3 / l3 : p3 * Math.pow(2, 1 - h3)) * l3 >= 2 && (a2++, l3 /= 2), a2 + h3 >= c2 ? (o2 = 0, a2 = c2) : a2 + h3 >= 1 ? (o2 = (e2 * l3 - 1) * Math.pow(2, i2), a2 += h3) : (o2 = e2 * Math.pow(2, h3 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t3[r3 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
          ;
        for (a2 = a2 << i2 | o2, u3 += i2; u3 > 0; t3[r3 + f2] = 255 & a2, f2 += d2, a2 /= 256, u3 -= 8)
          ;
        t3[r3 + f2 - d2] |= 128 * y3;
      }, xh2 = vh2;
      function vh2(t3) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      vh2.Varint = 0, vh2.Fixed64 = 1, vh2.Bytes = 2, vh2.Fixed32 = 5;
      var bh2 = 4294967296, _h = 1 / bh2, wh2 = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf8");
      function Ah2(t3) {
        return t3.type === vh2.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
      }
      function Sh2(t3, e2, r3) {
        return r3 ? 4294967296 * e2 + (t3 >>> 0) : 4294967296 * (e2 >>> 0) + (t3 >>> 0);
      }
      function kh2(t3, e2, r3) {
        var n3 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        r3.realloc(n3);
        for (var i2 = r3.pos - 1; i2 >= t3; i2--)
          r3.buf[i2 + n3] = r3.buf[i2];
      }
      function Ih2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeVarint(t3[r3]);
      }
      function Mh2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeSVarint(t3[r3]);
      }
      function zh2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeFloat(t3[r3]);
      }
      function Th2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeDouble(t3[r3]);
      }
      function Bh2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeBoolean(t3[r3]);
      }
      function Eh2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeFixed32(t3[r3]);
      }
      function Ch2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeSFixed32(t3[r3]);
      }
      function Ph2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeFixed64(t3[r3]);
      }
      function Dh2(t3, e2) {
        for (var r3 = 0; r3 < t3.length; r3++)
          e2.writeSFixed64(t3[r3]);
      }
      function Vh2(t3, e2) {
        return (t3[e2] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) + 16777216 * t3[e2 + 3];
      }
      function Fh2(t3, e2, r3) {
        t3[r3] = e2, t3[r3 + 1] = e2 >>> 8, t3[r3 + 2] = e2 >>> 16, t3[r3 + 3] = e2 >>> 24;
      }
      function Lh2(t3, e2) {
        return (t3[e2] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) + (t3[e2 + 3] << 24);
      }
      function Rh2(t3, e2, r3) {
        e2.glyphs = [], t3 === 1 && r3.readMessage(Uh2, e2);
      }
      function Uh2(t3, e2, r3) {
        if (t3 === 3) {
          const { id: t4, bitmap: n3, width: i2, height: s2, left: a2, top: o2, advance: l3 } = r3.readMessage(jh2, {});
          e2.glyphs.push({ id: t4, bitmap: new hu({ width: i2 + 6, height: s2 + 6 }, n3), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l3 } });
        } else
          t3 === 4 ? e2.ascender = r3.readSVarint() : t3 === 5 && (e2.descender = r3.readSVarint());
      }
      function jh2(t3, e2, r3) {
        t3 === 1 ? e2.id = r3.readVarint() : t3 === 2 ? e2.bitmap = r3.readBytes() : t3 === 3 ? e2.width = r3.readVarint() : t3 === 4 ? e2.height = r3.readVarint() : t3 === 5 ? e2.left = r3.readSVarint() : t3 === 6 ? e2.top = r3.readSVarint() : t3 === 7 && (e2.advance = r3.readVarint());
      }
      function $h2(t3) {
        let e2 = 0, r3 = 0;
        for (const n4 of t3)
          e2 += n4.w * n4.h, r3 = Math.max(r3, n4.w);
        t3.sort((t4, e3) => e3.h - t4.h);
        const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r3), h: 1 / 0 }];
        let i2 = 0, s2 = 0;
        for (const e3 of t3)
          for (let t4 = n3.length - 1; t4 >= 0; t4--) {
            const r4 = n3[t4];
            if (!(e3.w > r4.w || e3.h > r4.h)) {
              if (e3.x = r4.x, e3.y = r4.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r4.w && e3.h === r4.h) {
                const e4 = n3.pop();
                t4 < n3.length && (n3[t4] = e4);
              } else
                e3.h === r4.h ? (r4.x += e3.w, r4.w -= e3.w) : e3.w === r4.w ? (r4.y += e3.h, r4.h -= e3.h) : (n3.push({ x: r4.x + e3.w, y: r4.y, w: r4.w - e3.w, h: e3.h }), r4.y += e3.h, r4.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
      }
      vh2.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t3, e2, r3) {
        for (r3 = r3 || this.length; this.pos < r3; ) {
          var n3 = this.readVarint(), i2 = n3 >> 3, s2 = this.pos;
          this.type = 7 & n3, t3(i2, e2, this), this.pos === s2 && this.skip(n3);
        }
        return e2;
      }, readMessage: function(t3, e2) {
        return this.readFields(t3, e2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t3 = Vh2(this.buf, this.pos);
        return this.pos += 4, t3;
      }, readSFixed32: function() {
        var t3 = Lh2(this.buf, this.pos);
        return this.pos += 4, t3;
      }, readFixed64: function() {
        var t3 = Vh2(this.buf, this.pos) + Vh2(this.buf, this.pos + 4) * bh2;
        return this.pos += 8, t3;
      }, readSFixed64: function() {
        var t3 = Vh2(this.buf, this.pos) + Lh2(this.buf, this.pos + 4) * bh2;
        return this.pos += 8, t3;
      }, readFloat: function() {
        var t3 = mh2(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t3;
      }, readDouble: function() {
        var t3 = mh2(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t3;
      }, readVarint: function(t3) {
        var e2, r3, n3 = this.buf;
        return e2 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e2 : function(t4, e3, r4) {
          var n4, i2, s2 = r4.buf;
          if (n4 = (112 & (i2 = s2[r4.pos++])) >> 4, i2 < 128)
            return Sh2(t4, n4, e3);
          if (n4 |= (127 & (i2 = s2[r4.pos++])) << 3, i2 < 128)
            return Sh2(t4, n4, e3);
          if (n4 |= (127 & (i2 = s2[r4.pos++])) << 10, i2 < 128)
            return Sh2(t4, n4, e3);
          if (n4 |= (127 & (i2 = s2[r4.pos++])) << 17, i2 < 128)
            return Sh2(t4, n4, e3);
          if (n4 |= (127 & (i2 = s2[r4.pos++])) << 24, i2 < 128)
            return Sh2(t4, n4, e3);
          if (n4 |= (1 & (i2 = s2[r4.pos++])) << 31, i2 < 128)
            return Sh2(t4, n4, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e2 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t3 = this.readVarint();
        return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t3 = this.readVarint() + this.pos, e2 = this.pos;
        return this.pos = t3, t3 - e2 >= 12 && wh2 ? function(t4, e3, r3) {
          return wh2.decode(t4.subarray(e3, r3));
        }(this.buf, e2, t3) : function(t4, e3, r3) {
          for (var n3 = "", i2 = e3; i2 < r3; ) {
            var s2, a2, o2, l3 = t4[i2], u3 = null, c2 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
            if (i2 + c2 > r3)
              break;
            c2 === 1 ? l3 < 128 && (u3 = l3) : c2 === 2 ? (192 & (s2 = t4[i2 + 1])) == 128 && (u3 = (31 & l3) << 6 | 63 & s2) <= 127 && (u3 = null) : c2 === 3 ? (a2 = t4[i2 + 2], (192 & (s2 = t4[i2 + 1])) == 128 && (192 & a2) == 128 && ((u3 = (15 & l3) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : c2 === 4 && (a2 = t4[i2 + 2], o2 = t4[i2 + 3], (192 & (s2 = t4[i2 + 1])) == 128 && (192 & a2) == 128 && (192 & o2) == 128 && ((u3 = (15 & l3) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u3 >= 1114112) && (u3 = null)), u3 === null ? (u3 = 65533, c2 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i2 += c2;
          }
          return n3;
        }(this.buf, e2, t3);
      }, readBytes: function() {
        var t3 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t3);
        return this.pos = t3, e2;
      }, readPackedVarint: function(t3, e2) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readVarint(e2));
        var r3 = Ah2(this);
        for (t3 = t3 || []; this.pos < r3; )
          t3.push(this.readVarint(e2));
        return t3;
      }, readPackedSVarint: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readSVarint());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readSVarint());
        return t3;
      }, readPackedBoolean: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readBoolean());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readBoolean());
        return t3;
      }, readPackedFloat: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readFloat());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readFloat());
        return t3;
      }, readPackedDouble: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readDouble());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readDouble());
        return t3;
      }, readPackedFixed32: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readFixed32());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readFixed32());
        return t3;
      }, readPackedSFixed32: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readSFixed32());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readSFixed32());
        return t3;
      }, readPackedFixed64: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readFixed64());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readFixed64());
        return t3;
      }, readPackedSFixed64: function(t3) {
        if (this.type !== vh2.Bytes)
          return t3.push(this.readSFixed64());
        var e2 = Ah2(this);
        for (t3 = t3 || []; this.pos < e2; )
          t3.push(this.readSFixed64());
        return t3;
      }, skip: function(t3) {
        var e2 = 7 & t3;
        if (e2 === vh2.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (e2 === vh2.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (e2 === vh2.Fixed32)
          this.pos += 4;
        else {
          if (e2 !== vh2.Fixed64)
            throw new Error("Unimplemented type: " + e2);
          this.pos += 8;
        }
      }, writeTag: function(t3, e2) {
        this.writeVarint(t3 << 3 | e2);
      }, realloc: function(t3) {
        for (var e2 = this.length || 16; e2 < this.pos + t3; )
          e2 *= 2;
        if (e2 !== this.length) {
          var r3 = new Uint8Array(e2);
          r3.set(this.buf), this.buf = r3, this.length = e2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t3) {
        this.realloc(4), Fh2(this.buf, t3, this.pos), this.pos += 4;
      }, writeSFixed32: function(t3) {
        this.realloc(4), Fh2(this.buf, t3, this.pos), this.pos += 4;
      }, writeFixed64: function(t3) {
        this.realloc(8), Fh2(this.buf, -1 & t3, this.pos), Fh2(this.buf, Math.floor(t3 * _h), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t3) {
        this.realloc(8), Fh2(this.buf, -1 & t3, this.pos), Fh2(this.buf, Math.floor(t3 * _h), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t3) {
        (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e2) {
          var r3, n3;
          if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e2.realloc(10), function(t5, e3, r4) {
            r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
          }(r3, 0, e2), function(t5, e3) {
            var r4 = (7 & t5) << 4;
            e3.buf[e3.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e3.buf[e3.pos++] = 127 & t5)))));
          }(n3, e2);
        }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
      }, writeSVarint: function(t3) {
        this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
      }, writeBoolean: function(t3) {
        this.writeVarint(Boolean(t3));
      }, writeString: function(t3) {
        t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
        var e2 = this.pos;
        this.pos = function(t4, e3, r4) {
          for (var n3, i2, s2 = 0; s2 < e3.length; s2++) {
            if ((n3 = e3.charCodeAt(s2)) > 55295 && n3 < 57344) {
              if (!i2) {
                n3 > 56319 || s2 + 1 === e3.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i2 = n3;
                continue;
              }
              if (n3 < 56320) {
                t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i2 = n3;
                continue;
              }
              n3 = i2 - 55296 << 10 | n3 - 56320 | 65536, i2 = null;
            } else
              i2 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i2 = null);
            n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
          }
          return r4;
        }(this.buf, t3, this.pos);
        var r3 = this.pos - e2;
        r3 >= 128 && kh2(e2, r3, this), this.pos = e2 - 1, this.writeVarint(r3), this.pos += r3;
      }, writeFloat: function(t3) {
        this.realloc(4), gh2(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t3) {
        this.realloc(8), gh2(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t3) {
        var e2 = t3.length;
        this.writeVarint(e2), this.realloc(e2);
        for (var r3 = 0; r3 < e2; r3++)
          this.buf[this.pos++] = t3[r3];
      }, writeRawMessage: function(t3, e2) {
        this.pos++;
        var r3 = this.pos;
        t3(e2, this);
        var n3 = this.pos - r3;
        n3 >= 128 && kh2(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
      }, writeMessage: function(t3, e2, r3) {
        this.writeTag(t3, vh2.Bytes), this.writeRawMessage(e2, r3);
      }, writePackedVarint: function(t3, e2) {
        e2.length && this.writeMessage(t3, Ih2, e2);
      }, writePackedSVarint: function(t3, e2) {
        e2.length && this.writeMessage(t3, Mh2, e2);
      }, writePackedBoolean: function(t3, e2) {
        e2.length && this.writeMessage(t3, Bh2, e2);
      }, writePackedFloat: function(t3, e2) {
        e2.length && this.writeMessage(t3, zh2, e2);
      }, writePackedDouble: function(t3, e2) {
        e2.length && this.writeMessage(t3, Th2, e2);
      }, writePackedFixed32: function(t3, e2) {
        e2.length && this.writeMessage(t3, Eh2, e2);
      }, writePackedSFixed32: function(t3, e2) {
        e2.length && this.writeMessage(t3, Ch2, e2);
      }, writePackedFixed64: function(t3, e2) {
        e2.length && this.writeMessage(t3, Ph2, e2);
      }, writePackedSFixed64: function(t3, e2) {
        e2.length && this.writeMessage(t3, Dh2, e2);
      }, writeBytesField: function(t3, e2) {
        this.writeTag(t3, vh2.Bytes), this.writeBytes(e2);
      }, writeFixed32Field: function(t3, e2) {
        this.writeTag(t3, vh2.Fixed32), this.writeFixed32(e2);
      }, writeSFixed32Field: function(t3, e2) {
        this.writeTag(t3, vh2.Fixed32), this.writeSFixed32(e2);
      }, writeFixed64Field: function(t3, e2) {
        this.writeTag(t3, vh2.Fixed64), this.writeFixed64(e2);
      }, writeSFixed64Field: function(t3, e2) {
        this.writeTag(t3, vh2.Fixed64), this.writeSFixed64(e2);
      }, writeVarintField: function(t3, e2) {
        this.writeTag(t3, vh2.Varint), this.writeVarint(e2);
      }, writeSVarintField: function(t3, e2) {
        this.writeTag(t3, vh2.Varint), this.writeSVarint(e2);
      }, writeStringField: function(t3, e2) {
        this.writeTag(t3, vh2.Bytes), this.writeString(e2);
      }, writeFloatField: function(t3, e2) {
        this.writeTag(t3, vh2.Fixed32), this.writeFloat(e2);
      }, writeDoubleField: function(t3, e2) {
        this.writeTag(t3, vh2.Fixed64), this.writeDouble(e2);
      }, writeBooleanField: function(t3, e2) {
        this.writeVarintField(t3, Boolean(e2));
      } };
      class Oh2 {
        constructor(t3, { pixelRatio: e2, version: r3, stretchX: n3, stretchY: i2, content: s2 }) {
          this.paddedRect = t3, this.pixelRatio = e2, this.stretchX = n3, this.stretchY = i2, this.content = s2, this.version = r3;
        }
        get tl() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }
      }
      class qh2 {
        constructor(t3, e2) {
          const r3 = {}, n3 = {};
          this.haveRenderCallbacks = [];
          const i2 = [];
          this.addImages(t3, r3, i2), this.addImages(e2, n3, i2);
          const { w: s2, h: a2 } = $h2(i2), o2 = new pu({ width: s2 || 1, height: a2 || 1 });
          for (const e3 in t3) {
            const n4 = t3[e3], i3 = r3[e3].paddedRect;
            pu.copy(n4.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n4.data);
          }
          for (const t4 in e2) {
            const r4 = e2[t4], i3 = n3[t4].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l3 = r4.data.width, u3 = r4.data.height;
            pu.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r4.data), pu.copy(r4.data, o2, { x: 0, y: u3 - 1 }, { x: s3, y: a3 - 1 }, { width: l3, height: 1 }), pu.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u3 }, { width: l3, height: 1 }), pu.copy(r4.data, o2, { x: l3 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u3 }), pu.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3 + l3, y: a3 }, { width: 1, height: u3 });
          }
          this.image = o2, this.iconPositions = r3, this.patternPositions = n3;
        }
        addImages(t3, e2, r3) {
          for (const n3 in t3) {
            const i2 = t3[n3], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
            r3.push(s2), e2[n3] = new Oh2(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n3);
          }
        }
        patchUpdatedImages(t3, e2) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t3.hasImage(e3)), t3.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const r3 in t3.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r3], t3.getImage(r3), e2), this.patchUpdatedImage(this.patternPositions[r3], t3.getImage(r3), e2);
        }
        patchUpdatedImage(t3, e2, r3) {
          if (!t3 || !e2)
            return;
          if (t3.version === e2.version)
            return;
          t3.version = e2.version;
          const [n3, i2] = t3.tl;
          r3.update(e2.data, void 0, { x: n3, y: i2 });
        }
      }
      Pi2(Oh2, "ImagePosition"), Pi2(qh2, "ImageAtlas");
      const Nh2 = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      class Gh2 {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t3, e2) {
          const r3 = new Gh2();
          return r3.scale = t3 || 1, r3.fontStack = e2, r3;
        }
        static forImage(t3) {
          const e2 = new Gh2();
          return e2.imageName = t3, e2;
        }
      }
      class Zh2 {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t3, e2) {
          const r3 = new Zh2();
          for (let n3 = 0; n3 < t3.sections.length; n3++) {
            const i2 = t3.sections[n3];
            i2.image ? r3.addImageSection(i2) : r3.addTextSection(i2, e2);
          }
          return r3;
        }
        length() {
          return this.text.length;
        }
        getSection(t3) {
          return this.sections[this.sectionIndex[t3]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(t3) {
          return this.sectionIndex[t3];
        }
        getCharCode(t3) {
          return this.text.charCodeAt(t3);
        }
        verticalizePunctuation(t3) {
          this.text = function(t4, e2) {
            let r3 = "";
            for (let n3 = 0; n3 < t4.length; n3++) {
              const i2 = t4.charCodeAt(n3 + 1) || null, s2 = t4.charCodeAt(n3 - 1) || null;
              r3 += !e2 && (i2 && ms(i2) && !fh2[t4[n3 + 1]] || s2 && ms(s2) && !fh2[t4[n3 - 1]]) || !fh2[t4[n3]] ? t4[n3] : fh2[t4[n3]];
            }
            return r3;
          }(this.text, t3);
        }
        trim() {
          let t3 = 0;
          for (let e3 = 0; e3 < this.text.length && Kh2[this.text.charCodeAt(e3)]; e3++)
            t3++;
          let e2 = this.text.length;
          for (let r3 = this.text.length - 1; r3 >= 0 && r3 >= t3 && Kh2[this.text.charCodeAt(r3)]; r3--)
            e2--;
          this.text = this.text.substring(t3, e2), this.sectionIndex = this.sectionIndex.slice(t3, e2);
        }
        substring(t3, e2) {
          const r3 = new Zh2();
          return r3.text = this.text.substring(t3, e2), r3.sectionIndex = this.sectionIndex.slice(t3, e2), r3.sections = this.sections, r3;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t3, e2) => Math.max(t3, this.sections[e2].scale), 0);
        }
        addTextSection(t3, e2) {
          this.text += t3.text, this.sections.push(Gh2.forText(t3.scale, t3.fontStack || e2));
          const r3 = this.sections.length - 1;
          for (let e3 = 0; e3 < t3.text.length; ++e3)
            this.sectionIndex.push(r3);
        }
        addImageSection(t3) {
          const e2 = t3.image ? t3.image.name : "";
          if (e2.length === 0)
            return void E2("Can't add FormattedSection with an empty image.");
          const r3 = this.getNextImageSectionCharCode();
          r3 ? (this.text += String.fromCharCode(r3), this.sections.push(Gh2.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : E2("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Xh2(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3) {
        const m3 = Zh2.fromFeature(t3, i2);
        let g2;
        h3 === Nh2.vertical && m3.verticalizePunctuation(p3);
        const { processBidirectionalText: x3, processStyledBidirectionalText: v3 } = Es;
        if (x3 && m3.sections.length === 1) {
          g2 = [];
          const t4 = x3(m3.toString(), ep(m3, u3, s2, e2, n3, f2, d2));
          for (const e3 of t4) {
            const t5 = new Zh2();
            t5.text = e3, t5.sections = m3.sections;
            for (let r4 = 0; r4 < e3.length; r4++)
              t5.sectionIndex.push(0);
            g2.push(t5);
          }
        } else if (v3) {
          g2 = [];
          const t4 = v3(m3.text, m3.sectionIndex, ep(m3, u3, s2, e2, n3, f2, d2));
          for (const e3 of t4) {
            const t5 = new Zh2();
            t5.text = e3[0], t5.sectionIndex = e3[1], t5.sections = m3.sections, g2.push(t5);
          }
        } else
          g2 = function(t4, e3) {
            const r4 = [], n4 = t4.text;
            let i3 = 0;
            for (const n5 of e3)
              r4.push(t4.substring(i3, n5)), i3 = n5;
            return i3 < n4.length && r4.push(t4.substring(i3, n4.length)), r4;
          }(m3, ep(m3, u3, s2, e2, n3, f2, d2));
        const b2 = [], _2 = { positionedLines: b2, text: m3.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h3, iconsInText: false, verticalizable: false, hasBaseline: false };
        return function(t4, e3, r4, n4, i3, s3, a3, o3, l4, u4, c3, h4) {
          let p4 = 0, f3 = 0, d3 = 0;
          const y4 = o3 === "right" ? 1 : o3 === "left" ? 0 : 0.5;
          let m4 = false;
          for (const t5 of i3) {
            const r5 = t5.getSections();
            for (const t6 of r5) {
              if (t6.imageName)
                continue;
              const r6 = e3[t6.fontStack];
              if (r6 && (m4 = r6.ascender !== void 0 && r6.descender !== void 0, !m4))
                break;
            }
            if (!m4)
              break;
          }
          let g3 = 0;
          for (const a4 of i3) {
            a4.trim();
            const i4 = a4.getMaxScale(), o4 = (i4 - 1) * ah2, v5 = { positionedGlyphs: [], lineOffset: 0 };
            t4.positionedLines[g3] = v5;
            const b4 = v5.positionedGlyphs;
            let _4 = 0;
            if (!a4.length()) {
              f3 += s3, ++g3;
              continue;
            }
            let w2 = 0, A3 = 0;
            for (let s4 = 0; s4 < a4.length(); s4++) {
              const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), y5 = a4.getCharCode(s4);
              let g4 = o5.scale, v6 = null, S4 = null, k2 = null, I3 = ah2, M3 = 0;
              const z3 = !(l4 === Nh2.horizontal || !c3 && !ys(y5) || c3 && (Kh2[y5] || (x4 = y5, Ui2(x4) || ji2(x4) || $i2(x4) || as2(x4) || cs(x4))));
              if (o5.imageName) {
                const e4 = n4[o5.imageName];
                if (!e4)
                  continue;
                k2 = o5.imageName, t4.iconsInText = t4.iconsInText || true, S4 = e4.paddedRect;
                const r5 = e4.displaySize;
                g4 = g4 * ah2 / h4, v6 = { width: r5[0], height: r5[1], left: 1, top: -3, advance: z3 ? r5[1] : r5[0], localGlyph: false }, M3 = m4 ? -v6.height * g4 : i4 * ah2 - 17 - r5[1] * g4, I3 = v6.advance;
                const s5 = (z3 ? r5[0] : r5[1]) * g4 - ah2 * i4;
                s5 > 0 && s5 > _4 && (_4 = s5);
              } else {
                const t5 = r4[o5.fontStack];
                if (!t5)
                  continue;
                t5[y5] && (S4 = t5[y5]);
                const n5 = e3[o5.fontStack];
                if (!n5)
                  continue;
                const s5 = n5.glyphs[y5];
                if (!s5)
                  continue;
                if (v6 = s5.metrics, I3 = y5 !== 8203 ? ah2 : 0, m4) {
                  const t6 = n5.ascender !== void 0 ? Math.abs(n5.ascender) : 0, e4 = n5.descender !== void 0 ? Math.abs(n5.descender) : 0, r5 = (t6 + e4) * g4;
                  w2 < r5 && (w2 = r5, A3 = (t6 - e4) / 2 * g4), M3 = -t6 * g4;
                } else
                  M3 = (i4 - g4) * ah2 - 17;
              }
              z3 ? (t4.verticalizable = true, b4.push({ glyph: y5, imageName: k2, x: p4, y: f3 + M3, vertical: z3, scale: g4, localGlyph: v6.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v6, rect: S4 }), p4 += I3 * g4 + u4) : (b4.push({ glyph: y5, imageName: k2, x: p4, y: f3 + M3, vertical: z3, scale: g4, localGlyph: v6.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v6, rect: S4 }), p4 += v6.advance * g4 + u4);
            }
            b4.length !== 0 && (d3 = Math.max(p4 - u4, d3), m4 ? np(b4, y4, _4, A3, s3 * i4 / 2) : np(b4, y4, _4, 0, s3 / 2)), p4 = 0;
            const S3 = s3 * i4 + _4;
            v5.lineOffset = Math.max(_4, o4), f3 += S3, ++g3;
          }
          var x4;
          const v4 = f3, { horizontalAlign: b3, verticalAlign: _3 } = rp(a3);
          (function(t5, e4, r5, n5, i4, s4) {
            const a4 = (e4 - r5) * i4, o4 = -s4 * n5;
            for (const e5 of t5)
              for (const t6 of e5.positionedGlyphs)
                t6.x += a4, t6.y += o4;
          })(t4.positionedLines, y4, b3, _3, d3, v4), t4.top += -_3 * v4, t4.bottom = t4.top + v4, t4.left += -b3 * d3, t4.right = t4.left + d3, t4.hasBaseline = m4;
        }(_2, e2, r3, n3, g2, a2, o2, l3, h3, u3, p3, y3), !function(t4) {
          for (const e3 of t4)
            if (e3.positionedGlyphs.length !== 0)
              return false;
          return true;
        }(b2) && _2;
      }
      const Kh2 = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Hh2 = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function Yh2(t3, e2, r3, n3, i2, s2) {
        if (e2.imageName) {
          const t4 = n3[e2.imageName];
          return t4 ? t4.displaySize[0] * e2.scale * ah2 / s2 + i2 : 0;
        }
        {
          const n4 = r3[e2.fontStack], s3 = n4 && n4.glyphs[t3];
          return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
        }
      }
      function Wh2(t3, e2, r3, n3) {
        const i2 = Math.pow(t3 - e2, 2);
        return n3 ? t3 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r3) * r3;
      }
      function Jh2(t3, e2, r3) {
        let n3 = 0;
        return t3 === 10 && (n3 -= 1e4), r3 && (n3 += 150), t3 !== 40 && t3 !== 65288 || (n3 += 50), e2 !== 41 && e2 !== 65289 || (n3 += 50), n3;
      }
      function Qh2(t3, e2, r3, n3, i2, s2) {
        let a2 = null, o2 = Wh2(e2, r3, i2, s2);
        for (const t4 of n3) {
          const n4 = Wh2(e2 - t4.x, r3, i2, s2) + t4.badness;
          n4 <= o2 && (a2 = t4, o2 = n4);
        }
        return { index: t3, x: e2, priorBreak: a2, badness: o2 };
      }
      function tp(t3) {
        return t3 ? tp(t3.priorBreak).concat(t3.index) : [];
      }
      function ep(t3, e2, r3, n3, i2, s2, a2) {
        if (s2 !== "point")
          return [];
        if (!t3)
          return [];
        const o2 = [], l3 = function(t4, e3, r4, n4, i3, s3) {
          let a3 = 0;
          for (let r5 = 0; r5 < t4.length(); r5++) {
            const o3 = t4.getSection(r5);
            a3 += Yh2(t4.getCharCode(r5), o3, n4, i3, e3, s3);
          }
          return a3 / Math.max(1, Math.ceil(a3 / r4));
        }(t3, e2, r3, n3, i2, a2), u3 = t3.text.indexOf("\u200B") >= 0;
        let c2 = 0;
        for (let r4 = 0; r4 < t3.length(); r4++) {
          const s3 = t3.getSection(r4), p3 = t3.getCharCode(r4);
          if (Kh2[p3] || (c2 += Yh2(p3, s3, n3, i2, e2, a2)), r4 < t3.length() - 1) {
            const e3 = !((h3 = p3) < 11904 || !(Hi2(h3) || Ki2(h3) || ls(h3) || ss(h3) || Qi2(h3) || Oi2(h3) || Yi2(h3) || Gi2(h3) || ts(h3) || es(h3) || Ji2(h3) || hs(h3) || Zi2(h3) || Ni2(h3) || qi2(h3) || Wi2(h3) || Xi2(h3) || os(h3) || ns(h3) || rs(h3)));
            (Hh2[p3] || e3 || s3.imageName) && o2.push(Qh2(r4 + 1, c2, l3, o2, Jh2(p3, t3.getCharCode(r4 + 1), e3 && u3), false));
          }
        }
        var h3;
        return tp(Qh2(t3.length(), c2, l3, o2, 0, true));
      }
      function rp(t3) {
        let e2 = 0.5, r3 = 0.5;
        switch (t3) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t3) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r3 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r3 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r3 };
      }
      function np(t3, e2, r3, n3, i2) {
        if (!(e2 || r3 || n3 || i2))
          return;
        const s2 = t3.length - 1, a2 = t3[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
        for (let e3 = 0; e3 <= s2; e3++)
          t3[e3].x -= o2, t3[e3].y += r3 + n3 + i2;
      }
      function ip(t3, e2, r3) {
        const { horizontalAlign: n3, verticalAlign: i2 } = rp(r3), s2 = e2[0] - t3.displaySize[0] * n3, a2 = e2[1] - t3.displaySize[1] * i2;
        return { image: t3, top: a2, bottom: a2 + t3.displaySize[1], left: s2, right: s2 + t3.displaySize[0] };
      }
      function sp(t3, e2, r3, n3, i2, s2) {
        const a2 = t3.image;
        let o2;
        if (a2.content) {
          const t4 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [t4[0] / e3, t4[1] / e3, a2.displaySize[0] - t4[2] / e3, a2.displaySize[1] - t4[3] / e3];
        }
        const l3 = e2.left * s2, u3 = e2.right * s2;
        let c2, h3, p3, f2;
        r3 === "width" || r3 === "both" ? (f2 = i2[0] + l3 - n3[3], h3 = i2[0] + u3 + n3[1]) : (f2 = i2[0] + (l3 + u3 - a2.displaySize[0]) / 2, h3 = f2 + a2.displaySize[0]);
        const d2 = e2.top * s2, y3 = e2.bottom * s2;
        return r3 === "height" || r3 === "both" ? (c2 = i2[1] + d2 - n3[0], p3 = i2[1] + y3 + n3[2]) : (c2 = i2[1] + (d2 + y3 - a2.displaySize[1]) / 2, p3 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h3, bottom: p3, left: f2, collisionPadding: o2 };
      }
      class ap extends i {
        constructor(t3, e2, r3, n3, i2) {
          super(t3, e2), this.angle = n3, this.z = r3, i2 !== void 0 && (this.segment = i2);
        }
        clone() {
          return new ap(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function op(t3, e2, r3, n3, i2) {
        if (e2.segment === void 0)
          return true;
        let s2 = e2, a2 = e2.segment + 1, o2 = 0;
        for (; o2 > -r3 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t3[a2].dist(s2), s2 = t3[a2];
        }
        o2 += t3[a2].dist(t3[a2 + 1]), a2++;
        const l3 = [];
        let u3 = 0;
        for (; o2 < r3 / 2; ) {
          const e3 = t3[a2], r4 = t3[a2 + 1];
          if (!r4)
            return false;
          let s3 = t3[a2 - 1].angleTo(e3) - e3.angleTo(r4);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: o2, angleDelta: s3 }), u3 += s3; o2 - l3[0].distance > n3; )
            u3 -= l3.shift().angleDelta;
          if (u3 > i2)
            return false;
          a2++, o2 += e3.dist(r4);
        }
        return true;
      }
      function lp(t3) {
        let e2 = 0;
        for (let r3 = 0; r3 < t3.length - 1; r3++)
          e2 += t3[r3].dist(t3[r3 + 1]);
        return e2;
      }
      function up(t3, e2, r3) {
        return t3 ? 0.6 * e2 * r3 : 0;
      }
      function cp(t3, e2) {
        return Math.max(t3 ? t3.right - t3.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function hp(t3, e2, r3, n3, i2, s2) {
        const a2 = up(r3, i2, s2), o2 = cp(r3, n3) * s2;
        let l3 = 0;
        const u3 = lp(t3) / 2;
        for (let r4 = 0; r4 < t3.length - 1; r4++) {
          const n4 = t3[r4], i3 = t3[r4 + 1], s3 = n4.dist(i3);
          if (l3 + s3 > u3) {
            const c2 = (u3 - l3) / s3, h3 = xr(n4.x, i3.x, c2), p3 = xr(n4.y, i3.y, c2), f2 = new ap(h3, p3, 0, i3.angleTo(n4), r4);
            return !a2 || op(t3, f2, o2, a2, e2) ? f2 : void 0;
          }
          l3 += s3;
        }
      }
      function pp(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
        const u3 = up(n3, s2, a2), c2 = cp(n3, i2), h3 = c2 * a2, p3 = t3[0].x === 0 || t3[0].x === l3 || t3[0].y === 0 || t3[0].y === l3;
        return e2 - h3 < e2 / 4 && (e2 = h3 + e2 / 4), fp(t3, p3 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u3, r3, h3, p3, false, l3);
      }
      function fp(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
        const u3 = s2 / 2, c2 = lp(t3);
        let h3 = 0, p3 = e2 - r3, f2 = [];
        for (let e3 = 0; e3 < t3.length - 1; e3++) {
          const a3 = t3[e3], o3 = t3[e3 + 1], d2 = a3.dist(o3), y3 = o3.angleTo(a3);
          for (; p3 + r3 < h3 + d2; ) {
            p3 += r3;
            const m3 = (p3 - h3) / d2, g2 = xr(a3.x, o3.x, m3), x3 = xr(a3.y, o3.y, m3);
            if (g2 >= 0 && g2 < l3 && x3 >= 0 && x3 < l3 && p3 - u3 >= 0 && p3 + u3 <= c2) {
              const r4 = new ap(g2, x3, 0, y3, e3);
              r4._round(), n3 && !op(t3, r4, s2, n3, i2) || f2.push(r4);
            }
          }
          h3 += d2;
        }
        return o2 || f2.length || a2 || (f2 = fp(t3, h3 / 2, r3, n3, i2, s2, a2, true, l3)), f2;
      }
      function dp(t3, e2, r3, n3, s2) {
        const a2 = [];
        for (let o2 = 0; o2 < t3.length; o2++) {
          const l3 = t3[o2];
          let u3;
          for (let t4 = 0; t4 < l3.length - 1; t4++) {
            let o3 = l3[t4], c2 = l3[t4 + 1];
            o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new i(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new i(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r3 && c2.y < r3 || (o3.y < r3 ? o3 = new i(o3.x + (r3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r3)._round() : c2.y < r3 && (c2 = new i(o3.x + (r3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r3)._round()), o3.x >= n3 && c2.x >= n3 || (o3.x >= n3 ? o3 = new i(n3, o3.y + (n3 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n3 && (c2 = new i(n3, o3.y + (n3 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= s2 && c2.y >= s2 || (o3.y >= s2 ? o3 = new i(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round() : c2.y >= s2 && (c2 = new i(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round()), u3 && o3.equals(u3[u3.length - 1]) || (u3 = [o3], a2.push(u3)), u3.push(c2)))));
          }
        }
        return a2;
      }
      Pi2(ap, "Anchor");
      const yp = 1e20;
      function mp(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
        for (let u3 = e2; u3 < e2 + n3; u3++)
          gp(t3, r3 * s2 + u3, s2, i2, a2, o2, l3);
        for (let u3 = r3; u3 < r3 + i2; u3++)
          gp(t3, u3 * s2 + e2, 1, n3, a2, o2, l3);
      }
      function gp(t3, e2, r3, n3, i2, s2, a2) {
        s2[0] = 0, a2[0] = -yp, a2[1] = yp, i2[0] = t3[e2];
        for (let o2 = 1, l3 = 0, u3 = 0; o2 < n3; o2++) {
          i2[o2] = t3[e2 + o2 * r3];
          const n4 = o2 * o2;
          do {
            const t4 = s2[l3];
            u3 = (i2[o2] - i2[t4] + n4 - t4 * t4) / (o2 - t4) / 2;
          } while (u3 <= a2[l3] && --l3 > -1);
          l3++, s2[l3] = o2, a2[l3] = u3, a2[l3 + 1] = yp;
        }
        for (let o2 = 0, l3 = 0; o2 < n3; o2++) {
          for (; a2[l3 + 1] < o2; )
            l3++;
          const n4 = s2[l3], u3 = o2 - n4;
          t3[e2 + o2 * r3] = i2[n4] + u3 * u3;
        }
      }
      const xp = { none: 0, ideographs: 1, all: 2 };
      class vp {
        constructor(t3, e2, r3) {
          this.requestManager = t3, this.localGlyphMode = e2, this.localFontFamily = r3, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(t3) {
          this.url = t3;
        }
        getGlyphs(t3, e2) {
          const r3 = [];
          for (const e3 in t3)
            for (const n3 of t3[e3])
              r3.push({ stack: e3, id: n3 });
          g(r3, ({ stack: t4, id: e3 }, r4) => {
            let n3 = this.entries[t4];
            n3 || (n3 = this.entries[t4] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let i2 = n3.glyphs[e3];
            if (i2 !== void 0)
              return void r4(null, { stack: t4, id: e3, glyph: i2 });
            if (i2 = this._tinySDF(n3, t4, e3), i2)
              return n3.glyphs[e3] = i2, void r4(null, { stack: t4, id: e3, glyph: i2 });
            const s2 = Math.floor(e3 / 256);
            if (256 * s2 > 65535)
              return void r4(new Error("glyphs > 65535 not supported"));
            if (n3.ranges[s2])
              return void r4(null, { stack: t4, id: e3, glyph: i2 });
            let a2 = n3.requests[s2];
            a2 || (a2 = n3.requests[s2] = [], vp.loadGlyphRange(t4, s2, this.url, this.requestManager, (t5, e4) => {
              if (e4) {
                n3.ascender = e4.ascender, n3.descender = e4.descender;
                for (const t6 in e4.glyphs)
                  this._doesCharSupportLocalGlyph(+t6) || (n3.glyphs[+t6] = e4.glyphs[+t6]);
                n3.ranges[s2] = true;
              }
              for (const r5 of a2)
                r5(t5, e4);
              delete n3.requests[s2];
            })), a2.push((n4, i3) => {
              n4 ? r4(n4) : i3 && r4(null, { stack: t4, id: e3, glyph: i3.glyphs[e3] || null });
            });
          }, (t4, r4) => {
            if (t4)
              e2(t4);
            else if (r4) {
              const t5 = {};
              for (const { stack: e3, id: n3, glyph: i2 } of r4)
                t5[e3] === void 0 && (t5[e3] = {}), t5[e3].glyphs === void 0 && (t5[e3].glyphs = {}), t5[e3].glyphs[n3] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t5[e3].ascender = this.entries[e3].ascender, t5[e3].descender = this.entries[e3].descender;
              e2(null, t5);
            }
          });
        }
        _doesCharSupportLocalGlyph(t3) {
          return this.localGlyphMode !== xp.none && (this.localGlyphMode === xp.all ? !!this.localFontFamily : !!this.localFontFamily && (es(t3) || is(t3) || Zi2(t3) || Xi2(t3) || Gi2(t3)));
        }
        _tinySDF(t3, e2, r3) {
          const n3 = this.localFontFamily;
          if (!n3 || !this._doesCharSupportLocalGlyph(r3))
            return;
          let i2 = t3.tinySDF;
          if (!i2) {
            let r4 = "400";
            /bold/i.test(e2) ? r4 = "900" : /medium/i.test(e2) ? r4 = "500" : /light/i.test(e2) && (r4 = "200"), i2 = t3.tinySDF = new vp.TinySDF({ fontFamily: n3, fontWeight: r4, fontSize: 48, buffer: 6, radius: 16 }), i2.fontWeight = r4;
          }
          if (this.localGlyphs[i2.fontWeight][r3])
            return this.localGlyphs[i2.fontWeight][r3];
          const s2 = String.fromCharCode(r3), { data: a2, width: o2, height: l3, glyphWidth: u3, glyphHeight: c2, glyphLeft: h3, glyphTop: p3, glyphAdvance: f2 } = i2.draw(s2);
          return this.localGlyphs[i2.fontWeight][r3] = { id: r3, bitmap: new hu({ width: o2, height: l3 }, a2), metrics: { width: u3 / 2, height: c2 / 2, left: h3 / 2, top: p3 / 2 - 27, advance: f2 / 2, localGlyph: true } };
        }
      }
      function bp(t3, e2, r3, n3) {
        const s2 = [], a2 = t3.image, o2 = a2.pixelRatio, l3 = a2.paddedRect.w - 2, u3 = a2.paddedRect.h - 2, c2 = t3.right - t3.left, h3 = t3.bottom - t3.top, p3 = a2.stretchX || [[0, l3]], f2 = a2.stretchY || [[0, u3]], d2 = (t4, e3) => t4 + e3[1] - e3[0], y3 = p3.reduce(d2, 0), m3 = f2.reduce(d2, 0), g2 = l3 - y3, x3 = u3 - m3;
        let v3 = 0, b2 = y3, _2 = 0, w2 = m3, A3 = 0, S3 = g2, k2 = 0, I3 = x3;
        if (a2.content && n3) {
          const t4 = a2.content;
          v3 = _p(p3, 0, t4[0]), _2 = _p(f2, 0, t4[1]), b2 = _p(p3, t4[0], t4[2]), w2 = _p(f2, t4[1], t4[3]), A3 = t4[0] - v3, k2 = t4[1] - _2, S3 = t4[2] - t4[0] - b2, I3 = t4[3] - t4[1] - w2;
        }
        const M3 = (n4, s3, l4, u4) => {
          const p4 = Ap(n4.stretch - v3, b2, c2, t3.left), f3 = Sp(n4.fixed - A3, S3, n4.stretch, y3), d3 = Ap(s3.stretch - _2, w2, h3, t3.top), g3 = Sp(s3.fixed - k2, I3, s3.stretch, m3), x4 = Ap(l4.stretch - v3, b2, c2, t3.left), M4 = Sp(l4.fixed - A3, S3, l4.stretch, y3), z3 = Ap(u4.stretch - _2, w2, h3, t3.top), T3 = Sp(u4.fixed - k2, I3, u4.stretch, m3), B3 = new i(p4, d3), E3 = new i(x4, d3), C3 = new i(x4, z3), P3 = new i(p4, z3), D3 = new i(f3 / o2, g3 / o2), V3 = new i(M4 / o2, T3 / o2), F3 = e2 * Math.PI / 180;
          if (F3) {
            const t4 = Math.sin(F3), e3 = Math.cos(F3), r4 = [e3, -t4, t4, e3];
            B3._matMult(r4), E3._matMult(r4), P3._matMult(r4), C3._matMult(r4);
          }
          const L3 = n4.stretch + n4.fixed, R3 = s3.stretch + s3.fixed;
          return { tl: B3, tr: E3, bl: P3, br: C3, tex: { x: a2.paddedRect.x + 1 + L3, y: a2.paddedRect.y + 1 + R3, w: l4.stretch + l4.fixed - L3, h: u4.stretch + u4.fixed - R3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D3, pixelOffsetBR: V3, minFontScaleX: S3 / o2 / c2, minFontScaleY: I3 / o2 / h3, isSDF: r3 };
        };
        if (n3 && (a2.stretchX || a2.stretchY)) {
          const t4 = wp(p3, g2, y3), e3 = wp(f2, x3, m3);
          for (let r4 = 0; r4 < t4.length - 1; r4++) {
            const n4 = t4[r4], i2 = t4[r4 + 1];
            for (let t5 = 0; t5 < e3.length - 1; t5++)
              s2.push(M3(n4, e3[t5], i2, e3[t5 + 1]));
          }
        } else
          s2.push(M3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l3 + 1 }, { fixed: 0, stretch: u3 + 1 }));
        return s2;
      }
      function _p(t3, e2, r3) {
        let n3 = 0;
        for (const i2 of t3)
          n3 += Math.max(e2, Math.min(r3, i2[1])) - Math.max(e2, Math.min(r3, i2[0]));
        return n3;
      }
      function wp(t3, e2, r3) {
        const n3 = [{ fixed: -1, stretch: 0 }];
        for (const [e3, r4] of t3) {
          const t4 = n3[n3.length - 1];
          n3.push({ fixed: e3 - t4.stretch, stretch: t4.stretch }), n3.push({ fixed: e3 - t4.stretch, stretch: t4.stretch + (r4 - e3) });
        }
        return n3.push({ fixed: e2 + 1, stretch: r3 }), n3;
      }
      function Ap(t3, e2, r3, n3) {
        return t3 / e2 * r3 + n3;
      }
      function Sp(t3, e2, r3, n3) {
        return t3 - e2 * r3 / n3;
      }
      function kp(t3, e2, r3, n3) {
        const i2 = e2 + t3.positionedLines[n3].lineOffset;
        return n3 === 0 ? r3 + i2 / 2 : r3 + (i2 + (e2 + t3.positionedLines[n3 - 1].lineOffset)) / 2;
      }
      vp.loadGlyphRange = function(t3, e2, r3, n3, i2) {
        const s2 = 256 * e2, a2 = s2 + 255, o2 = n3.transformRequest(n3.normalizeGlyphsURL(r3).replace("{fontstack}", t3).replace("{range}", `${s2}-${a2}`), zt.Glyphs);
        Ct(o2, (t4, e3) => {
          if (t4)
            i2(t4);
          else if (e3) {
            const t5 = {}, r4 = function(t6) {
              return new xh2(t6).readFields(Rh2, {});
            }(e3);
            for (const e4 of r4.glyphs)
              t5[e4.id] = e4;
            i2(null, { glyphs: t5, ascender: r4.ascender, descender: r4.descender });
          }
        });
      }, vp.TinySDF = class {
        constructor({ fontSize: t3 = 24, buffer: e2 = 3, radius: r3 = 8, cutoff: n3 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" } = {}) {
          this.buffer = e2, this.cutoff = n3, this.radius = r3;
          const o2 = this.size = t3 + 4 * e2, l3 = this._createCanvas(o2), u3 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
          u3.font = `${a2} ${s2} ${t3}px ${i2}`, u3.textBaseline = "alphabetic", u3.textAlign = "left", u3.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
        }
        _createCanvas(t3) {
          const e2 = document.createElement("canvas");
          return e2.width = e2.height = t3, e2;
        }
        draw(t3) {
          const { width: e2, actualBoundingBoxAscent: r3, actualBoundingBoxDescent: n3, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t3), a2 = Math.ceil(r3), o2 = Math.min(this.size - this.buffer, Math.ceil(s2 - i2)), l3 = Math.min(this.size - this.buffer, a2 + Math.ceil(n3)), u3 = o2 + 2 * this.buffer, c2 = l3 + 2 * this.buffer, h3 = Math.max(u3 * c2, 0), p3 = new Uint8ClampedArray(h3), f2 = { data: p3, width: u3, height: c2, glyphWidth: o2, glyphHeight: l3, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
          if (o2 === 0 || l3 === 0)
            return f2;
          const { ctx: d2, buffer: y3, gridInner: m3, gridOuter: g2 } = this;
          d2.clearRect(y3, y3, o2, l3), d2.fillText(t3, y3, y3 + a2);
          const x3 = d2.getImageData(y3, y3, o2, l3);
          g2.fill(yp, 0, h3), m3.fill(0, 0, h3);
          for (let t4 = 0; t4 < l3; t4++)
            for (let e3 = 0; e3 < o2; e3++) {
              const r4 = x3.data[4 * (t4 * o2 + e3) + 3] / 255;
              if (r4 === 0)
                continue;
              const n4 = (t4 + y3) * u3 + e3 + y3;
              if (r4 === 1)
                g2[n4] = 0, m3[n4] = yp;
              else {
                const t5 = 0.5 - r4;
                g2[n4] = t5 > 0 ? t5 * t5 : 0, m3[n4] = t5 < 0 ? t5 * t5 : 0;
              }
            }
          mp(g2, 0, 0, u3, c2, u3, this.f, this.v, this.z), mp(m3, y3, y3, o2, l3, u3, this.f, this.v, this.z);
          for (let t4 = 0; t4 < h3; t4++) {
            const e3 = Math.sqrt(g2[t4]) - Math.sqrt(m3[t4]);
            p3[t4] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return f2;
        }
      };
      class Ip {
        constructor(t3 = [], e2 = Mp) {
          if (this.data = t3, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t4 = (this.length >> 1) - 1; t4 >= 0; t4--)
              this._down(t4);
        }
        push(t3) {
          this.data.push(t3), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0)
            return;
          const t3 = this.data[0], e2 = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t3;
        }
        peek() {
          return this.data[0];
        }
        _up(t3) {
          const { data: e2, compare: r3 } = this, n3 = e2[t3];
          for (; t3 > 0; ) {
            const i2 = t3 - 1 >> 1, s2 = e2[i2];
            if (r3(n3, s2) >= 0)
              break;
            e2[t3] = s2, t3 = i2;
          }
          e2[t3] = n3;
        }
        _down(t3) {
          const { data: e2, compare: r3 } = this, n3 = this.length >> 1, i2 = e2[t3];
          for (; t3 < n3; ) {
            let n4 = 1 + (t3 << 1), s2 = e2[n4];
            const a2 = n4 + 1;
            if (a2 < this.length && r3(e2[a2], s2) < 0 && (n4 = a2, s2 = e2[a2]), r3(s2, i2) >= 0)
              break;
            e2[t3] = s2, t3 = n4;
          }
          e2[t3] = i2;
        }
      }
      function Mp(t3, e2) {
        return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
      }
      function zp(t3, e2 = 1, r3 = false) {
        let n3 = 1 / 0, s2 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
        const l3 = t3[0];
        for (let t4 = 0; t4 < l3.length; t4++) {
          const e3 = l3[t4];
          (!t4 || e3.x < n3) && (n3 = e3.x), (!t4 || e3.y < s2) && (s2 = e3.y), (!t4 || e3.x > a2) && (a2 = e3.x), (!t4 || e3.y > o2) && (o2 = e3.y);
        }
        const u3 = Math.min(a2 - n3, o2 - s2);
        let c2 = u3 / 2;
        const h3 = new Ip([], Tp);
        if (u3 === 0)
          return new i(n3, s2);
        for (let e3 = n3; e3 < a2; e3 += u3)
          for (let r4 = s2; r4 < o2; r4 += u3)
            h3.push(new Bp(e3 + c2, r4 + c2, c2, t3));
        let p3 = function(t4) {
          let e3 = 0, r4 = 0, n4 = 0;
          const i2 = t4[0];
          for (let t5 = 0, s3 = i2.length, a3 = s3 - 1; t5 < s3; a3 = t5++) {
            const s4 = i2[t5], o3 = i2[a3], l4 = s4.x * o3.y - o3.x * s4.y;
            r4 += (s4.x + o3.x) * l4, n4 += (s4.y + o3.y) * l4, e3 += 3 * l4;
          }
          return new Bp(r4 / e3, n4 / e3, 0, t4);
        }(t3), f2 = h3.length;
        for (; h3.length; ) {
          const n4 = h3.pop();
          (n4.d > p3.d || !p3.d) && (p3 = n4, r3 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, f2)), n4.max - p3.d <= e2 || (c2 = n4.h / 2, h3.push(new Bp(n4.p.x - c2, n4.p.y - c2, c2, t3)), h3.push(new Bp(n4.p.x + c2, n4.p.y - c2, c2, t3)), h3.push(new Bp(n4.p.x - c2, n4.p.y + c2, c2, t3)), h3.push(new Bp(n4.p.x + c2, n4.p.y + c2, c2, t3)), f2 += 4);
        }
        return r3 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p3.d}`)), p3.p;
      }
      function Tp(t3, e2) {
        return e2.max - t3.max;
      }
      function Bp(t3, e2, r3, n3) {
        this.p = new i(t3, e2), this.h = r3, this.d = function(t4, e3) {
          let r4 = false, n4 = 1 / 0;
          for (let i2 = 0; i2 < e3.length; i2++) {
            const s2 = e3[i2];
            for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
              const i4 = s2[e4], o2 = s2[a2];
              i4.y > t4.y != o2.y > t4.y && t4.x < (o2.x - i4.x) * (t4.y - i4.y) / (o2.y - i4.y) + i4.x && (r4 = !r4), n4 = Math.min(n4, rl(t4, i4, o2));
            }
          }
          return (r4 ? 1 : -1) * Math.sqrt(n4);
        }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
      }
      const Ep = Number.POSITIVE_INFINITY, Cp = Math.sqrt(2);
      function Pp(t3, e2) {
        return e2[1] !== Ep ? function(t4, e3, r3) {
          let n3 = 0, i2 = 0;
          switch (e3 = Math.abs(e3), r3 = Math.abs(r3), t4) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r3 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = 7 - r3;
          }
          switch (t4) {
            case "top-right":
            case "bottom-right":
            case "right":
              n3 = -e3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n3 = e3;
          }
          return [n3, i2];
        }(t3, e2[0], e2[1]) : function(t4, e3) {
          let r3 = 0, n3 = 0;
          e3 < 0 && (e3 = 0);
          const i2 = e3 / Cp;
          switch (t4) {
            case "top-right":
            case "top-left":
              n3 = i2 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              n3 = 7 - i2;
              break;
            case "bottom":
              n3 = 7 - e3;
              break;
            case "top":
              n3 = e3 - 7;
          }
          switch (t4) {
            case "top-right":
            case "bottom-right":
              r3 = -i2;
              break;
            case "top-left":
            case "bottom-left":
              r3 = i2;
              break;
            case "left":
              r3 = e3;
              break;
            case "right":
              r3 = -e3;
          }
          return [r3, n3];
        }(t3, e2[0]);
      }
      function Dp(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3) {
        t3.createArrays(), t3.tilePixelRatio = wo / (512 * t3.overscaling), t3.compareText = {}, t3.iconsNeedLinear = false;
        const c2 = t3.layers[0].layout, h3 = t3.layers[0]._unevaluatedLayout._values, p3 = {};
        if (t3.textSizeData.kind === "composite") {
          const { minZoom: e3, maxZoom: r4 } = t3.textSizeData;
          p3.compositeTextSizes = [h3["text-size"].possiblyEvaluate(new Cs(e3), o2), h3["text-size"].possiblyEvaluate(new Cs(r4), o2)];
        }
        if (t3.iconSizeData.kind === "composite") {
          const { minZoom: e3, maxZoom: r4 } = t3.iconSizeData;
          p3.compositeIconSizes = [h3["icon-size"].possiblyEvaluate(new Cs(e3), o2), h3["icon-size"].possiblyEvaluate(new Cs(r4), o2)];
        }
        p3.layoutTextSize = h3["text-size"].possiblyEvaluate(new Cs(l3 + 1), o2), p3.layoutIconSize = h3["icon-size"].possiblyEvaluate(new Cs(l3 + 1), o2), p3.textMaxSize = h3["text-size"].possiblyEvaluate(new Cs(18), o2);
        const f2 = c2.get("text-rotation-alignment") === "map" && c2.get("symbol-placement") !== "point", d2 = c2.get("text-size");
        for (const s3 of t3.features) {
          const l4 = c2.get("text-font").evaluate(s3, {}, o2).join(","), h4 = d2.evaluate(s3, {}, o2), y3 = p3.layoutTextSize.evaluate(s3, {}, o2), m3 = (p3.layoutIconSize.evaluate(s3, {}, o2), { horizontal: {}, vertical: void 0 }), g2 = s3.text;
          let x3, v3 = [0, 0];
          if (g2) {
            const n4 = g2.toString(), a3 = c2.get("text-letter-spacing").evaluate(s3, {}, o2) * ah2, u4 = c2.get("text-line-height").evaluate(s3, {}, o2) * ah2, p4 = fs(n4) ? a3 : 0, d3 = c2.get("text-anchor").evaluate(s3, {}, o2), x4 = c2.get("text-variable-anchor");
            if (!x4) {
              const t4 = c2.get("text-radial-offset").evaluate(s3, {}, o2);
              v3 = t4 ? Pp(d3, [t4 * ah2, Ep]) : c2.get("text-offset").evaluate(s3, {}, o2).map((t5) => t5 * ah2);
            }
            let b3 = f2 ? "center" : c2.get("text-justify").evaluate(s3, {}, o2);
            const _3 = c2.get("symbol-placement"), w2 = _3 === "point", A3 = _3 === "point" ? c2.get("text-max-width").evaluate(s3, {}, o2) * ah2 : 0, S3 = (s4) => {
              t3.allowVerticalPlacement && ps(n4) && (m3.vertical = Xh2(g2, e2, r3, i2, l4, A3, u4, d3, s4, p4, v3, Nh2.vertical, true, _3, y3, h4));
            };
            if (!f2 && x4) {
              const t4 = b3 === "auto" ? x4.map((t5) => Vp(t5)) : [b3];
              let n5 = false;
              for (let s4 = 0; s4 < t4.length; s4++) {
                const a4 = t4[s4];
                if (!m3.horizontal[a4])
                  if (n5)
                    m3.horizontal[a4] = m3.horizontal[0];
                  else {
                    const t5 = Xh2(g2, e2, r3, i2, l4, A3, u4, "center", a4, p4, v3, Nh2.horizontal, false, _3, y3, h4);
                    t5 && (m3.horizontal[a4] = t5, n5 = t5.positionedLines.length === 1);
                  }
              }
              S3("left");
            } else {
              if (b3 === "auto" && (b3 = Vp(d3)), w2 || c2.get("text-writing-mode").indexOf("horizontal") >= 0 || !ps(n4)) {
                const t4 = Xh2(g2, e2, r3, i2, l4, A3, u4, d3, b3, p4, v3, Nh2.horizontal, false, _3, y3, h4);
                t4 && (m3.horizontal[b3] = t4);
              }
              S3(_3 === "point" ? "left" : b3);
            }
          }
          let b2 = false;
          if (s3.icon && s3.icon.name) {
            const e3 = n3[s3.icon.name];
            e3 && (x3 = ip(i2[s3.icon.name], c2.get("icon-offset").evaluate(s3, {}, o2), c2.get("icon-anchor").evaluate(s3, {}, o2)), b2 = e3.sdf, t3.sdfIcons === void 0 ? t3.sdfIcons = e3.sdf : t3.sdfIcons !== e3.sdf && E2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t3.pixelRatio || c2.get("icon-rotate").constantOr(1) !== 0) && (t3.iconsNeedLinear = true));
          }
          const _2 = Up(m3.horizontal) || m3.vertical;
          t3.iconsInText || (t3.iconsInText = !!_2 && _2.iconsInText), (_2 || x3) && Fp(t3, s3, m3, x3, n3, p3, y3, 0, v3, b2, a2, o2, u3);
        }
        s2 && t3.generateCollisionDebugBuffers(l3, t3.collisionBoxArray);
      }
      function Vp(t3) {
        switch (t3) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Fp(t3, e2, r3, n3, i2, s2, a2, o2, u3, c2, h3, p3, f2) {
        let d2 = s2.textMaxSize.evaluate(e2, {}, p3);
        d2 === void 0 && (d2 = a2);
        const y3 = t3.layers[0].layout, m3 = y3.get("icon-offset").evaluate(e2, {}, p3), g2 = Up(r3.horizontal) || r3.vertical, x3 = f2.name === "globe", v3 = a2 / 24, b2 = t3.tilePixelRatio * d2 / 24, _2 = (T3 = t3.overscaling, t3.zoom > 18 && T3 > 2 && (T3 >>= 1), Math.max(wo / (512 * T3), 1) * y3.get("symbol-spacing")), w2 = y3.get("text-padding") * t3.tilePixelRatio, A3 = y3.get("icon-padding") * t3.tilePixelRatio, S3 = l2(y3.get("text-max-angle")), k2 = y3.get("text-rotation-alignment") === "map" && y3.get("symbol-placement") !== "point", I3 = y3.get("icon-rotation-alignment") === "map" && y3.get("symbol-placement") !== "point", M3 = y3.get("symbol-placement"), z3 = _2 / 2;
        var T3;
        const B3 = y3.get("icon-text-fit");
        let C3;
        n3 && B3 !== "none" && (t3.allowVerticalPlacement && r3.vertical && (C3 = sp(n3, r3.vertical, B3, y3.get("icon-text-fit-padding"), m3, v3)), g2 && (n3 = sp(n3, g2, B3, y3.get("icon-text-fit-padding"), m3, v3)));
        const P3 = (a3, o3, l3) => {
          if (o3.x < 0 || o3.x >= wo || o3.y < 0 || o3.y >= wo)
            return;
          let d3 = null;
          if (x3) {
            const { x: t4, y: e3, z: r4 } = f2.projectTilePoint(o3.x, o3.y, l3);
            d3 = { anchor: new ap(t4, e3, r4, 0, void 0), up: f2.upVector(l3, o3.x, o3.y) };
          }
          !function(t4, e3, r4, n4, i3, s3, a4, o4, l4, u4, c3, h4, p4, f3, d4, y4, m4, g3, x4, v4, b3, _3, w3, A4, S4) {
            const k3 = t4.addToLineVertexArray(e3, n4);
            let I4, M4, z4, T4, B4, C4, P4, D3 = 0, V3 = 0, F3 = 0, L3 = 0, R3 = -1, U3 = -1;
            const j2 = {};
            let $2 = Na2("");
            const O3 = r4 ? r4.anchor : e3;
            let q3 = 0, N3 = 0;
            if (l4._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [q3, N3] = l4.layout.get("text-offset").evaluate(b3, {}, S4).map((t5) => t5 * ah2) : (q3 = l4.layout.get("text-radial-offset").evaluate(b3, {}, S4) * ah2, N3 = Ep), t4.allowVerticalPlacement && i3.vertical) {
              const t5 = i3.vertical;
              if (d4)
                C4 = $p(t5), o4 && (P4 = $p(o4));
              else {
                const r5 = l4.layout.get("text-rotate").evaluate(b3, {}, S4) + 90;
                z4 = jp(u4, O3, e3, c3, h4, p4, t5, f3, r5, y4), o4 && (T4 = jp(u4, O3, e3, c3, h4, p4, o4, g3, r5));
              }
            }
            if (s3) {
              const n5 = l4.layout.get("icon-rotate").evaluate(b3, {}, S4), i4 = l4.layout.get("icon-text-fit") !== "none", a5 = bp(s3, n5, w3, i4), f4 = o4 ? bp(o4, n5, w3, i4) : void 0;
              M4 = jp(u4, O3, e3, c3, h4, p4, s3, g3, n5), D3 = 4 * a5.length;
              const d5 = t4.iconSizeData;
              let y5 = null;
              d5.kind === "source" ? (y5 = [oh2 * l4.layout.get("icon-size").evaluate(b3, {}, S4)], y5[0] > Lp && E2(`${t4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : d5.kind === "composite" && (y5 = [oh2 * _3.compositeIconSizes[0].evaluate(b3, {}, S4), oh2 * _3.compositeIconSizes[1].evaluate(b3, {}, S4)], (y5[0] > Lp || y5[1] > Lp) && E2(`${t4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t4.addSymbols(t4.icon, a5, y5, v4, x4, b3, false, r4, e3, k3.lineStartIndex, k3.lineLength, -1, A4, S4), R3 = t4.icon.placedSymbolArray.length - 1, f4 && (V3 = 4 * f4.length, t4.addSymbols(t4.icon, f4, y5, v4, x4, b3, Nh2.vertical, r4, e3, k3.lineStartIndex, k3.lineLength, -1, A4, S4), U3 = t4.icon.placedSymbolArray.length - 1);
            }
            for (const n5 in i3.horizontal) {
              const s4 = i3.horizontal[n5];
              I4 || ($2 = Na2(s4.text), d4 ? B4 = $p(s4) : I4 = jp(u4, O3, e3, c3, h4, p4, s4, f3, l4.layout.get("text-rotate").evaluate(b3, {}, S4), y4));
              const o5 = s4.positionedLines.length === 1;
              if (F3 += Rp(t4, r4, e3, s4, a4, l4, d4, b3, y4, k3, i3.vertical ? Nh2.horizontal : Nh2.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n5], j2, R3, _3, A4, S4), o5)
                break;
            }
            i3.vertical && (L3 += Rp(t4, r4, e3, i3.vertical, a4, l4, d4, b3, y4, k3, Nh2.vertical, ["vertical"], j2, U3, _3, A4, S4));
            let G3 = -1;
            const Z3 = (t5, e4) => t5 ? Math.max(t5, e4) : e4;
            G3 = Z3(B4, G3), G3 = Z3(C4, G3), G3 = Z3(P4, G3);
            const X3 = G3 > -1 ? 1 : 0;
            t4.glyphOffsetArray.length >= Qf2.MAX_GLYPHS && E2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), b3.sortKey !== void 0 && t4.addToSortKeyRanges(t4.symbolInstances.length, b3.sortKey), t4.symbolInstances.emplaceBack(O3.x, O3.y, O3.z, e3.x, e3.y, j2.right >= 0 ? j2.right : -1, j2.center >= 0 ? j2.center : -1, j2.left >= 0 ? j2.left : -1, j2.vertical >= 0 ? j2.vertical : -1, R3, U3, $2, I4 !== void 0 ? I4 : t4.collisionBoxArray.length, I4 !== void 0 ? I4 + 1 : t4.collisionBoxArray.length, z4 !== void 0 ? z4 : t4.collisionBoxArray.length, z4 !== void 0 ? z4 + 1 : t4.collisionBoxArray.length, M4 !== void 0 ? M4 : t4.collisionBoxArray.length, M4 !== void 0 ? M4 + 1 : t4.collisionBoxArray.length, T4 || t4.collisionBoxArray.length, T4 ? T4 + 1 : t4.collisionBoxArray.length, c3, F3, L3, D3, V3, X3, 0, q3, N3, G3);
          }(t3, o3, d3, a3, r3, n3, i2, C3, t3.layers[0], t3.collisionBoxArray, e2.index, e2.sourceLayerIndex, t3.index, w2, k2, u3, 0, A3, I3, m3, e2, s2, c2, h3, p3);
        };
        if (M3 === "line")
          for (const i3 of dp(e2.geometry, 0, 0, wo, wo)) {
            const e3 = pp(i3, _2, S3, r3.vertical || g2, n3, 24, b2, t3.overscaling, wo);
            for (const r4 of e3) {
              const e4 = g2;
              e4 && Op(t3, e4.text, z3, r4) || P3(i3, r4, p3);
            }
          }
        else if (M3 === "line-center") {
          for (const t4 of e2.geometry)
            if (t4.length > 1) {
              const e3 = hp(t4, S3, r3.vertical || g2, n3, 24, b2);
              e3 && P3(t4, e3, p3);
            }
        } else if (e2.type === "Polygon")
          for (const t4 of Yu(e2.geometry, 0)) {
            const e3 = zp(t4, 16);
            P3(t4[0], new ap(e3.x, e3.y, 0, 0, void 0), p3);
          }
        else if (e2.type === "LineString")
          for (const t4 of e2.geometry)
            P3(t4, new ap(t4[0].x, t4[0].y, 0, 0, void 0), p3);
        else if (e2.type === "Point")
          for (const t4 of e2.geometry)
            for (const e3 of t4)
              P3([e3], new ap(e3.x, e3.y, 0, 0, void 0), p3);
      }
      const Lp = 32640;
      function Rp(t3, e2, r3, n3, s2, a2, o2, l3, u3, c2, h3, p3, f2, d2, y3, m3, g2) {
        const x3 = function(t4, e3, r4, n4, s3, a3, o3, l4) {
          const u4 = [];
          if (e3.positionedLines.length === 0)
            return u4;
          const c3 = n4.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, h4 = function(t5) {
            const e4 = t5[0], r5 = t5[1], n5 = e4 * r5;
            return n5 > 0 ? [e4, -r5] : n5 < 0 ? [-e4, r5] : e4 === 0 ? [r5, e4] : [r5, -e4];
          }(r4);
          let p4 = Math.abs(e3.top - e3.bottom);
          for (const t5 of e3.positionedLines)
            p4 -= t5.lineOffset;
          const f3 = e3.positionedLines.length, d3 = p4 / f3;
          let y4 = e3.top - r4[1];
          for (let t5 = 0; t5 < f3; ++t5) {
            const n5 = e3.positionedLines[t5];
            y4 = kp(e3, d3, y4, t5);
            for (const t6 of n5.positionedGlyphs) {
              if (!t6.rect)
                continue;
              const n6 = t6.rect || {};
              let a4 = 4, p5 = true, f4 = 1, d4 = 0;
              if (t6.imageName) {
                const e4 = o3[t6.imageName];
                if (!e4)
                  continue;
                if (e4.sdf) {
                  E2("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                p5 = false, f4 = e4.pixelRatio, a4 = 1 / f4;
              }
              const m4 = (s3 || l4) && t6.vertical, g3 = t6.metrics.advance * t6.scale / 2, x4 = t6.metrics, v4 = t6.rect;
              if (v4 === null)
                continue;
              l4 && e3.verticalizable && (d4 = t6.imageName ? g3 - t6.metrics.width * t6.scale / 2 : 0);
              const b3 = s3 ? [t6.x + g3, t6.y] : [0, 0];
              let _2 = [0, 0], w2 = [0, 0], A3 = false;
              s3 || (m4 ? (w2 = [t6.x + g3 + h4[0], t6.y + h4[1] - d4], A3 = true) : _2 = [t6.x + g3 + r4[0], t6.y + r4[1] - d4]);
              const S3 = v4.w * t6.scale / (f4 * (t6.localGlyph ? 2 : 1)), k2 = v4.h * t6.scale / (f4 * (t6.localGlyph ? 2 : 1));
              let I3, M3, z3, T3;
              if (m4) {
                const e4 = t6.y - y4, r5 = new i(-g3, g3 - e4), n7 = -Math.PI / 2, s4 = new i(...w2);
                I3 = new i(-g3 + _2[0], _2[1]), I3._rotateAround(n7, r5)._add(s4), I3.x += -e4 + g3, I3.y -= (x4.left - a4) * t6.scale;
                const o4 = t6.imageName ? x4.advance * t6.scale : ah2 * t6.scale, l5 = String.fromCharCode(t6.glyph);
                dh2(l5) ? I3.x += (1 - a4) * t6.scale : yh2(l5) ? I3.x += o4 - x4.height * t6.scale + (-a4 - 1) * t6.scale : I3.x += t6.imageName || x4.width + 2 * a4 === v4.w && x4.height + 2 * a4 === v4.h ? (o4 - k2) / 2 : (o4 - (x4.height + 2 * a4) * t6.scale) / 2, M3 = new i(I3.x, I3.y - S3), z3 = new i(I3.x + k2, I3.y), T3 = new i(I3.x + k2, I3.y - S3);
              } else {
                const e4 = (x4.left - a4) * t6.scale - g3 + _2[0], r5 = (-x4.top - a4) * t6.scale + _2[1], n7 = e4 + S3, s4 = r5 + k2;
                I3 = new i(e4, r5), M3 = new i(n7, r5), z3 = new i(e4, s4), T3 = new i(n7, s4);
              }
              if (c3) {
                let t7;
                t7 = s3 ? new i(0, 0) : A3 ? new i(h4[0], h4[1]) : new i(r4[0], r4[1]), I3._rotateAround(c3, t7), M3._rotateAround(c3, t7), z3._rotateAround(c3, t7), T3._rotateAround(c3, t7);
              }
              const B3 = new i(0, 0), C3 = new i(0, 0);
              u4.push({ tl: I3, tr: M3, bl: z3, br: T3, tex: n6, writingMode: e3.writingMode, glyphOffset: b3, sectionIndex: t6.sectionIndex, isSDF: p5, pixelOffsetTL: B3, pixelOffsetBR: C3, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return u4;
        }(0, n3, u3, a2, o2, l3, s2, t3.allowVerticalPlacement), v3 = t3.textSizeData;
        let b2 = null;
        v3.kind === "source" ? (b2 = [oh2 * a2.layout.get("text-size").evaluate(l3, {}, g2)], b2[0] > Lp && E2(`${t3.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : v3.kind === "composite" && (b2 = [oh2 * y3.compositeTextSizes[0].evaluate(l3, {}, g2), oh2 * y3.compositeTextSizes[1].evaluate(l3, {}, g2)], (b2[0] > Lp || b2[1] > Lp) && E2(`${t3.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t3.addSymbols(t3.text, x3, b2, u3, o2, l3, h3, e2, r3, c2.lineStartIndex, c2.lineLength, d2, m3, g2);
        for (const e3 of p3)
          f2[e3] = t3.text.placedSymbolArray.length - 1;
        return 4 * x3.length;
      }
      function Up(t3) {
        for (const e2 in t3)
          return t3[e2];
        return null;
      }
      function jp(t3, e2, r3, n3, s2, a2, o2, u3, c2, h3) {
        let p3 = o2.top, f2 = o2.bottom, d2 = o2.left, y3 = o2.right;
        const m3 = o2.collisionPadding;
        if (m3 && (d2 -= m3[0], p3 -= m3[1], y3 += m3[2], f2 += m3[3]), c2) {
          const t4 = new i(d2, p3), e3 = new i(y3, p3), r4 = new i(d2, f2), n4 = new i(y3, f2), s3 = l2(c2);
          let a3 = new i(0, 0);
          h3 && (a3 = new i(h3[0], h3[1])), t4._rotateAround(s3, a3), e3._rotateAround(s3, a3), r4._rotateAround(s3, a3), n4._rotateAround(s3, a3), d2 = Math.min(t4.x, e3.x, r4.x, n4.x), y3 = Math.max(t4.x, e3.x, r4.x, n4.x), p3 = Math.min(t4.y, e3.y, r4.y, n4.y), f2 = Math.max(t4.y, e3.y, r4.y, n4.y);
        }
        return t3.emplaceBack(e2.x, e2.y, e2.z, r3.x, r3.y, d2, p3, y3, f2, u3, n3, s2, a2), t3.length - 1;
      }
      function $p(t3) {
        t3.collisionPadding && (t3.top -= t3.collisionPadding[1], t3.bottom += t3.collisionPadding[3]);
        const e2 = t3.bottom - t3.top;
        return e2 > 0 ? Math.max(10, e2) : null;
      }
      function Op(t3, e2, r3, n3) {
        const i2 = t3.compareText;
        if (e2 in i2) {
          const t4 = i2[e2];
          for (let e3 = t4.length - 1; e3 >= 0; e3--)
            if (n3.dist(t4[e3]) < r3)
              return true;
        } else
          i2[e2] = [];
        return i2[e2].push(n3), false;
      }
      const qp = Ws([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Np } = qp, Gp = Ws([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var Zp = Ws([{ name: "a_pos", type: "Int16", components: 2 }]);
      const Xp = wo / Math.PI / 2, Kp = 2 * Bo(1, 0) * Xp * Math.PI, Hp = [64, 32, 16], Yp = -Xp, Wp = Xp, Jp = [new eu([Yp, Yp, Yp], [Wp, Wp, Wp]), new eu([Yp, Yp, Yp], [0, 0, Wp]), new eu([0, Yp, Yp], [Wp, 0, Wp]), new eu([Yp, 0, Yp], [0, Wp, Wp]), new eu([0, 0, Yp], [Wp, Wp, Wp])];
      function Qp(t3, e2, r3, n3 = true) {
        const i2 = Vl([], t3._camera.position, t3.worldSize), s2 = [e2, r3, 1, 1];
        Xl(s2, s2, t3.pixelMatrixInverse), Zl(s2, s2, 1 / s2[3]);
        const a2 = Ll([], ql([], s2, i2)), o2 = t3.globeMatrix, l3 = [o2[12], o2[13], o2[14]], c2 = ql([], l3, i2), h3 = zl(c2), p3 = Ll([], c2), f2 = t3.worldSize / (2 * Math.PI), y3 = Rl(p3, a2), m3 = Math.asin(f2 / h3);
        if (m3 < Math.acos(y3)) {
          if (!n3)
            return null;
          const t4 = [], e3 = [];
          Vl(t4, a2, h3 / y3), Ll(e3, ql(e3, t4, c2)), Ll(a2, Bl(a2, c2, Vl(a2, e3, Math.tan(m3) * h3)));
        }
        const g2 = [];
        new Jl(i2, a2).closestPointOnSphere(l3, f2, g2);
        const x3 = Ll([], U2(o2, 0)), v3 = Ll([], U2(o2, 1)), b2 = Ll([], U2(o2, 2)), _2 = Rl(x3, g2), w2 = Rl(v3, g2), A3 = Rl(b2, g2), S3 = u2(Math.asin(-w2 / f2));
        let k2 = u2(Math.atan2(_2, A3));
        k2 = t3.center.lng + function(t4, e3) {
          const r4 = (e3 - t4 + 180) % 360 - 180;
          return r4 < -180 ? r4 + 360 : r4;
        }(t3.center.lng, k2);
        const I3 = zo(k2), M3 = d(To(S3), 0, 1);
        return new Fo(I3, M3);
      }
      class tf2 {
        constructor(t3, e2, r3) {
          this.a = ql([], t3, r3), this.b = ql([], e2, r3), this.center = r3;
          const n3 = Ll([], this.a), i2 = Ll([], this.b);
          this.angle = Math.acos(Rl(n3, i2));
        }
      }
      function ef2(t3, e2) {
        if (t3.angle === 0)
          return null;
        let r3;
        return r3 = t3.a[e2] === 0 ? 1 / t3.angle * 0.5 * Math.PI : 1 / t3.angle * Math.atan(t3.b[e2] / t3.a[e2] / Math.sin(t3.angle) - 1 / Math.tan(t3.angle)), r3 < 0 || r3 > 1 ? null : function(t4, e3, r4, n3) {
          const i2 = Math.sin(r4);
          return t4 * (Math.sin((1 - n3) * r4) / i2) + e3 * (Math.sin(n3 * r4) / i2);
        }(t3.a[e2], t3.b[e2], t3.angle, d(r3, 0, 1)) + t3.center[e2];
      }
      function rf2(t3) {
        if (t3.z <= 1)
          return Jp[t3.z + 2 * t3.y + t3.x];
        const e2 = lf2(of2(t3));
        return eu.fromPoints(e2);
      }
      function nf2(t3, e2) {
        const r3 = gf2(e2.zoom);
        if (r3 === 0)
          return rf2(t3);
        const n3 = of2(t3), i2 = lf2(n3), s2 = zo(n3.getWest()) * e2.worldSize, a2 = zo(n3.getEast()) * e2.worldSize, o2 = To(n3.getNorth()) * e2.worldSize, l3 = To(n3.getSouth()) * e2.worldSize, u3 = [s2, o2, 0], c2 = [a2, o2, 0], h3 = [s2, l3, 0], p3 = [a2, l3, 0], f2 = gl([], e2.globeMatrix);
        return jl(u3, u3, f2), jl(c2, c2, f2), jl(h3, h3, f2), jl(p3, p3, f2), i2[0] = vr(i2[0], h3, r3), i2[1] = vr(i2[1], p3, r3), i2[2] = vr(i2[2], c2, r3), i2[3] = vr(i2[3], u3, r3), eu.fromPoints(i2);
      }
      function sf2(t3, e2, r3, n3, i2) {
        for (const s2 of r3)
          jl(s2, s2, n3), Vl(s2, s2, i2), Pl(t3, t3, s2), Dl(e2, e2, s2);
      }
      function af2(t3, e2, r3) {
        const n3 = e2 / t3.worldSize, i2 = Number.MAX_VALUE, s2 = [-i2, -i2, -i2], a2 = [i2, i2, i2], o2 = t3.globeMatrix;
        if (r3.z <= 1)
          return sf2(a2, s2, rf2(r3).getCorners(), o2, n3), new eu(a2, s2);
        const u3 = of2(r3), c2 = lf2(u3);
        if (sf2(a2, s2, c2, o2, n3), u3.contains(t3.center)) {
          s2[2] = 0;
          const e3 = t3.point, r4 = [e3.x * n3, e3.y * n3, 0];
          return Pl(a2, a2, r4), Dl(s2, s2, r4), new eu(a2, s2);
        }
        const h3 = [o2[12] * n3, o2[13] * n3, o2[14] * n3], p3 = u3.getCenter(), f2 = d(t3.center.lat, -85.051129, Do), y3 = d(p3.lat, -85.051129, Do), m3 = zo(t3.center.lng), g2 = To(f2);
        let x3 = m3 - zo(p3.lng);
        const v3 = g2 - To(y3);
        x3 > 0.5 ? x3 -= 1 : x3 < -0.5 && (x3 += 1);
        let b2 = 0;
        Math.abs(x3) > Math.abs(v3) ? b2 = x3 >= 0 ? 1 : 3 : (b2 = v3 >= 0 ? 0 : 2, Fl(h3, h3, [o2[4] * n3, o2[5] * n3, o2[6] * n3], -Math.sin(l2(v3 >= 0 ? u3.getSouth() : u3.getNorth())) * Xp));
        const _2 = c2[b2], w2 = c2[(b2 + 1) % 4], A3 = new tf2(_2, w2, h3), S3 = [ef2(A3, 0) || _2[0], ef2(A3, 1) || _2[1], ef2(A3, 2) || _2[2]];
        return a2[2] = Math.min(_2[2], w2[2]), Pl(a2, a2, S3), Dl(s2, s2, S3), new eu(a2, s2);
      }
      function of2({ x: t3, y: e2, z: r3 }) {
        const n3 = 1 / (1 << r3), i2 = new ko(Eo(t3 * n3), Co((e2 + 1) * n3)), s2 = new ko(Eo((t3 + 1) * n3), Co(e2 * n3));
        return new Ao(i2, s2);
      }
      function lf2(t3) {
        const e2 = l2(t3.getNorth()), r3 = l2(t3.getSouth()), n3 = Math.cos(e2), i2 = Math.cos(r3), s2 = Math.sin(e2), a2 = Math.sin(r3), o2 = t3.getWest(), u3 = t3.getEast();
        return [uf2(i2, a2, o2), uf2(i2, a2, u3), uf2(n3, s2, u3), uf2(n3, s2, o2)];
      }
      function uf2(t3, e2, r3, n3 = Xp) {
        return r3 = l2(r3), [t3 * Math.sin(r3) * n3, -e2 * n3, t3 * Math.cos(r3) * n3];
      }
      function cf2(t3, e2, r3) {
        return uf2(Math.cos(l2(t3)), Math.sin(l2(t3)), e2, r3);
      }
      function hf2(t3, e2, r3, n3) {
        const i2 = 1 << r3.z, s2 = (t3 / wo + r3.x) / i2;
        return cf2(Co((e2 / wo + r3.y) / i2), Eo(s2), n3);
      }
      function pf2({ min: t3, max: e2 }) {
        return 16383 / Math.max(e2[0] - t3[0], e2[1] - t3[1], e2[2] - t3[2]);
      }
      const ff2 = new Float64Array(16);
      function df2(t3) {
        const e2 = pf2(t3), r3 = Al(ff2, [e2, e2, e2]);
        return vl(r3, r3, ((n3 = [])[0] = -(i2 = t3.min)[0], n3[1] = -i2[1], n3[2] = -i2[2], n3));
        var n3, i2;
      }
      function yf2(t3) {
        const e2 = (n3 = t3.min, (r3 = ff2)[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = 1, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = 1, r3[11] = 0, r3[12] = n3[0], r3[13] = n3[1], r3[14] = n3[2], r3[15] = 1, r3);
        var r3, n3;
        const i2 = 1 / pf2(t3);
        return bl(e2, e2, [i2, i2, i2]);
      }
      function mf2(t3, e2, r3, n3, i2) {
        const s2 = function(t4) {
          const e3 = wo / (2 * Math.PI);
          return t4 / (2 * Math.PI) / e3;
        }(r3), a2 = [t3, e2, -r3 / (2 * Math.PI)], o2 = ml(new Float64Array(16));
        return vl(o2, o2, a2), bl(o2, o2, [s2, s2, s2]), _l(o2, o2, l2(-i2)), wl(o2, o2, l2(-n3)), o2;
      }
      function gf2(t3) {
        return y2(5, 6, t3);
      }
      function xf2(t3, e2) {
        const r3 = cf2(e2.lat, e2.lng);
        return s2 = (n3 = El([], function(t4) {
          const e3 = cf2(t4._center.lat, t4._center.lng);
          let r4 = Ul([], Tl(0, 1, 0), e3);
          const n4 = Sl([], -t4.angle, e3);
          r4 = jl(r4, r4, n4), Sl(n4, -t4._pitch, r4);
          const i3 = Ll([], e3);
          return Vl(i3, i3, t4.cameraToCenterDistance / t4.pixelsPerMeter * Kp), jl(i3, i3, n4), Bl([], e3, i3);
        }(t3), r3))[0], a2 = n3[1], o2 = n3[2], l3 = (i2 = r3)[0], u3 = i2[1], c2 = i2[2], p3 = (h3 = Math.sqrt(s2 * s2 + a2 * a2 + o2 * o2) * Math.sqrt(l3 * l3 + u3 * u3 + c2 * c2)) && Rl(n3, i2) / h3, Math.acos(Math.min(Math.max(p3, -1), 1));
        var n3, i2, s2, a2, o2, l3, u3, c2, h3, p3;
      }
      const vf2 = l2(85), bf2 = Math.cos(vf2), _f = Math.sin(vf2);
      function wf2(t3, e2) {
        const r3 = t3.fovAboveCenter, n3 = t3.elevation ? t3.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t3._camera.position[2] * t3.worldSize - n3) / Math.cos(t3._pitch), s2 = Math.sin(r3) * i2 / Math.sin(Math.max(Math.PI / 2 - t3._pitch - r3, 0.01)), a2 = Math.sin(t3._pitch) * s2 + i2;
        return Math.min(1.01 * a2, i2 * (1 / t3._horizonShift));
      }
      function Af2(t3, e2) {
        if (!e2.isReprojectedInTileSpace)
          return { scale: 1 << t3.z, x: t3.x, y: t3.y, x2: t3.x + 1, y2: t3.y + 1, projection: e2 };
        const r3 = Math.pow(2, -t3.z), n3 = t3.x * r3, i2 = (t3.x + 1) * r3, s2 = t3.y * r3, a2 = (t3.y + 1) * r3, o2 = Eo(n3), l3 = Eo(i2), u3 = Co(s2), c2 = Co(a2), h3 = e2.project(o2, u3), p3 = e2.project(l3, u3), f2 = e2.project(l3, c2), d2 = e2.project(o2, c2);
        let y3 = Math.min(h3.x, p3.x, f2.x, d2.x), m3 = Math.min(h3.y, p3.y, f2.y, d2.y), g2 = Math.max(h3.x, p3.x, f2.x, d2.x), x3 = Math.max(h3.y, p3.y, f2.y, d2.y);
        const v3 = r3 / 16;
        function b2(t4, r4, n4, i3, s3, a3) {
          const o3 = (n4 + s3) / 2, l4 = (i3 + a3) / 2, u4 = e2.project(Eo(o3), Co(l4)), c3 = Math.max(0, y3 - u4.x, m3 - u4.y, u4.x - g2, u4.y - x3);
          y3 = Math.min(y3, u4.x), g2 = Math.max(g2, u4.x), m3 = Math.min(m3, u4.y), x3 = Math.max(x3, u4.y), c3 > v3 && (b2(t4, u4, n4, i3, o3, l4), b2(u4, r4, o3, l4, s3, a3));
        }
        b2(h3, p3, n3, s2, i2, s2), b2(p3, f2, i2, s2, i2, a2), b2(f2, d2, i2, a2, n3, a2), b2(d2, h3, n3, a2, n3, s2), y3 -= v3, m3 -= v3, g2 += v3, x3 += v3;
        const _2 = 1 / Math.max(g2 - y3, x3 - m3);
        return { scale: _2, x: y3 * _2, y: m3 * _2, x2: g2 * _2, y2: x3 * _2, projection: e2 };
      }
      const Sf2 = ml(new Float32Array(16));
      class kf2 {
        constructor(t3) {
          this.spec = t3, this.name = t3.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(t3, e2) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(t3, e2) {
          return new ko(0, 0);
        }
        projectTilePoint(t3, e2, r3) {
          return { x: t3, y: e2, z: 0 };
        }
        locationPoint(t3, e2, r3 = true) {
          return t3._coordinatePoint(t3.locationCoordinate(e2), r3);
        }
        pixelsPerMeter(t3, e2) {
          return Bo(1, t3) * e2;
        }
        pixelSpaceConversion(t3, e2, r3) {
          return 1;
        }
        farthestPixelDistance(t3) {
          return wf2(t3, t3.pixelsPerMeter);
        }
        pointCoordinate(t3, e2, r3, n3) {
          const s2 = t3.horizonLineFromTop(false), a2 = new i(e2, Math.max(s2, r3));
          return t3.rayIntersectionCoordinate(t3.pointRayIntersection(a2, n3));
        }
        pointCoordinate3D(t3, e2, r3) {
          const n3 = new i(e2, r3);
          if (t3.elevation)
            return t3.elevation.pointCoordinate(n3);
          {
            const e3 = this.pointCoordinate(t3, n3.x, n3.y, 0);
            return [e3.x, e3.y, e3.z];
          }
        }
        isPointAboveHorizon(t3, e2) {
          if (t3.elevation)
            return !this.pointCoordinate3D(t3, e2.x, e2.y);
          const r3 = t3.horizonLineFromTop();
          return e2.y < r3;
        }
        createInversionMatrix(t3, e2) {
          return Sf2;
        }
        createTileMatrix(t3, e2, r3) {
          let n3, i2, s2;
          const a2 = r3.canonical, o2 = ml(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const l3 = Af2(a2, this);
            n3 = 1, i2 = l3.x + r3.wrap * l3.scale, s2 = l3.y, bl(o2, o2, [n3 / l3.scale, n3 / l3.scale, t3.pixelsPerMeter / e2]);
          } else
            n3 = e2 / t3.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r3.wrap) * n3, s2 = a2.y * n3;
          return vl(o2, o2, [i2, s2, 0]), bl(o2, o2, [n3 / wo, n3 / wo, 1]), o2;
        }
        upVector(t3, e2, r3) {
          return [0, 0, 1];
        }
        upVectorScale(t3, e2, r3) {
          return { metersToTile: 1 };
        }
      }
      class If2 extends kf2 {
        constructor(t3) {
          super(t3), this.range = [4, 7], this.center = t3.center || [-96, 37.5];
          const [e2, r3] = this.parallels = t3.parallels || [29.5, 45.5], n3 = Math.sin(l2(e2));
          this.n = (n3 + Math.sin(l2(r3))) / 2, this.c = 1 + n3 * (2 * this.n - n3), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(t3, e2) {
          const { n: r3, c: n3, r0: i2 } = this, s2 = l2(t3 - this.center[0]), a2 = l2(e2), o2 = Math.sqrt(n3 - 2 * r3 * Math.sin(a2)) / r3;
          return { x: o2 * Math.sin(s2 * r3), y: o2 * Math.cos(s2 * r3) - i2, z: 0 };
        }
        unproject(t3, e2) {
          const { n: r3, c: n3, r0: i2 } = this, s2 = i2 + e2;
          let a2 = Math.atan2(t3, Math.abs(s2)) * Math.sign(s2);
          s2 * r3 < 0 && (a2 -= Math.PI * Math.sign(t3) * Math.sign(s2));
          const o2 = l2(this.center[0]) * r3;
          a2 = m2(a2, -Math.PI - o2, Math.PI - o2);
          const c2 = u2(a2 / r3) + this.center[0], h3 = Math.asin(d((n3 - (t3 * t3 + s2 * s2) * r3 * r3) / (2 * r3), -1, 1)), p3 = d(u2(h3), -85.051129, Do);
          return new ko(c2, p3);
        }
      }
      const Mf2 = 1.340264, zf2 = -0.081106, Tf2 = 893e-6, Bf2 = 3796e-6, Ef2 = Math.sqrt(3) / 2;
      class Cf2 extends kf2 {
        project(t3, e2) {
          e2 = e2 / 180 * Math.PI, t3 = t3 / 180 * Math.PI;
          const r3 = Math.asin(Ef2 * Math.sin(e2)), n3 = r3 * r3, i2 = n3 * n3 * n3;
          return { x: 0.5 * (t3 * Math.cos(r3) / (Ef2 * (Mf2 + 3 * zf2 * n3 + i2 * (7 * Tf2 + 9 * Bf2 * n3))) / Math.PI + 0.5), y: 1 - 0.5 * (r3 * (Mf2 + zf2 * n3 + i2 * (Tf2 + Bf2 * n3)) / Math.PI + 1), z: 0 };
        }
        unproject(t3, e2) {
          t3 = (2 * t3 - 0.5) * Math.PI;
          let r3 = e2 = (2 * (1 - e2) - 1) * Math.PI, n3 = r3 * r3, i2 = n3 * n3 * n3;
          for (let t4, s3, a3, o3 = 0; o3 < 12 && (s3 = r3 * (Mf2 + zf2 * n3 + i2 * (Tf2 + Bf2 * n3)) - e2, a3 = Mf2 + 3 * zf2 * n3 + i2 * (7 * Tf2 + 9 * Bf2 * n3), t4 = s3 / a3, r3 = d(r3 - t4, -Math.PI / 3, Math.PI / 3), n3 = r3 * r3, i2 = n3 * n3 * n3, !(Math.abs(t4) < 1e-12)); ++o3)
            ;
          const s2 = Ef2 * t3 * (Mf2 + 3 * zf2 * n3 + i2 * (7 * Tf2 + 9 * Bf2 * n3)) / Math.cos(r3), a2 = Math.asin(Math.sin(r3) / Ef2), o2 = d(180 * s2 / Math.PI, -180, 180), l3 = d(180 * a2 / Math.PI, -85.051129, Do);
          return new ko(o2, l3);
        }
      }
      class Pf2 extends kf2 {
        constructor(t3) {
          super(t3), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t3, e2) {
          return { x: 0.5 + t3 / 360, y: 0.5 - e2 / 360, z: 0 };
        }
        unproject(t3, e2) {
          const r3 = 360 * (t3 - 0.5), n3 = d(360 * (0.5 - e2), -85.051129, Do);
          return new ko(r3, n3);
        }
      }
      const Df2 = Math.PI / 2;
      function Vf2(t3) {
        return Math.tan((Df2 + t3) / 2);
      }
      class Ff2 extends kf2 {
        constructor(t3) {
          super(t3), this.center = t3.center || [0, 30];
          const [e2, r3] = this.parallels = t3.parallels || [30, 30], n3 = l2(e2), i2 = l2(r3), s2 = Math.cos(n3);
          this.n = n3 === i2 ? Math.sin(n3) : Math.log(s2 / Math.cos(i2)) / Math.log(Vf2(i2) / Vf2(n3)), this.f = s2 * Math.pow(Vf2(n3), this.n) / this.n;
        }
        project(t3, e2) {
          e2 = l2(e2), t3 = l2(t3 - this.center[0]);
          const r3 = 1e-6, { n: n3, f: i2 } = this;
          i2 > 0 ? e2 < -Df2 + r3 && (e2 = -Df2 + r3) : e2 > Df2 - r3 && (e2 = Df2 - r3);
          const s2 = i2 / Math.pow(Vf2(e2), n3), a2 = s2 * Math.sin(n3 * t3), o2 = i2 - s2 * Math.cos(n3 * t3);
          return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 0.5), z: 0 };
        }
        unproject(t3, e2) {
          t3 = (2 * t3 - 0.5) * Math.PI, e2 = (2 * (1 - e2) - 0.5) * Math.PI;
          const { n: r3, f: n3 } = this, i2 = n3 - e2, s2 = Math.sign(i2), a2 = Math.sign(r3) * Math.sqrt(t3 * t3 + i2 * i2);
          let o2 = Math.atan2(t3, Math.abs(i2)) * s2;
          i2 * r3 < 0 && (o2 -= Math.PI * Math.sign(t3) * s2);
          const l3 = d(u2(o2 / r3) + this.center[0], -180, 180), c2 = d(u2(2 * Math.atan(Math.pow(n3 / a2, 1 / r3)) - Df2), -85.051129, Do);
          return new ko(l3, c2);
        }
      }
      class Lf2 extends kf2 {
        constructor(t3) {
          super(t3), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
        }
        project(t3, e2) {
          return { x: zo(t3), y: To(e2), z: 0 };
        }
        unproject(t3, e2) {
          const r3 = Eo(t3), n3 = Co(e2);
          return new ko(r3, n3);
        }
      }
      const Rf2 = l2(Do);
      class Uf2 extends kf2 {
        project(t3, e2) {
          const r3 = (e2 = l2(e2)) * e2, n3 = r3 * r3;
          return { x: 0.5 * ((t3 = l2(t3)) * (0.8707 - 0.131979 * r3 + n3 * (n3 * (3971e-6 * r3 - 1529e-6 * n3) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r3 * (0.015085 + n3 * (0.028874 * r3 - 0.044475 - 5916e-6 * n3))) / Math.PI + 1), z: 0 };
        }
        unproject(t3, e2) {
          t3 = (2 * t3 - 0.5) * Math.PI;
          let r3 = e2 = (2 * (1 - e2) - 1) * Math.PI, n3 = 25, i2 = 0, s2 = r3 * r3;
          do {
            s2 = r3 * r3;
            const t4 = s2 * s2;
            i2 = (r3 * (1.007226 + s2 * (0.015085 + t4 * (0.028874 * s2 - 0.044475 - 5916e-6 * t4))) - e2) / (1.007226 + s2 * (0.045255 + t4 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t4))), r3 = d(r3 - i2, -Rf2, Rf2);
          } while (Math.abs(i2) > 1e-6 && --n3 > 0);
          s2 = r3 * r3;
          const a2 = d(u2(t3 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = u2(r3);
          return new ko(a2, o2);
        }
      }
      const jf2 = l2(Do);
      class $f2 extends kf2 {
        project(t3, e2) {
          e2 = l2(e2), t3 = l2(t3);
          const r3 = Math.cos(e2), n3 = 2 / Math.PI, i2 = Math.acos(r3 * Math.cos(t3 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t3 * n3 + 2 * r3 * Math.sin(t3 / 2) / s2) || 0, o2 = 0.5 * (e2 + Math.sin(e2) / s2) || 0;
          return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
        }
        unproject(t3, e2) {
          let r3 = t3 = (2 * t3 - 0.5) * Math.PI, n3 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
          const s2 = 1e-6;
          let a2 = 0, o2 = 0;
          do {
            const i3 = Math.cos(n3), s3 = Math.sin(n3), l3 = 2 * s3 * i3, u3 = s3 * s3, c2 = i3 * i3, h3 = Math.cos(r3 / 2), p3 = Math.sin(r3 / 2), f2 = 2 * h3 * p3, y3 = p3 * p3, m3 = 1 - c2 * h3 * h3, g2 = m3 ? 1 / m3 : 0, x3 = m3 ? Math.acos(i3 * h3) * Math.sqrt(1 / m3) : 0, v3 = 0.5 * (2 * x3 * i3 * p3 + 2 * r3 / Math.PI) - t3, b2 = 0.5 * (x3 * s3 + n3) - e2, _2 = 0.5 * g2 * (c2 * y3 + x3 * i3 * h3 * u3) + 1 / Math.PI, w2 = g2 * (f2 * l3 / 4 - x3 * s3 * p3), A3 = 0.125 * g2 * (l3 * p3 - x3 * s3 * c2 * f2), S3 = 0.5 * g2 * (u3 * h3 + x3 * y3 * i3) + 0.5, k2 = w2 * A3 - S3 * _2;
            a2 = (b2 * w2 - v3 * S3) / k2, o2 = (v3 * A3 - b2 * _2) / k2, r3 = d(r3 - a2, -Math.PI, Math.PI), n3 = d(n3 - o2, -jf2, jf2);
          } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
          return new ko(u2(r3), u2(n3));
        }
      }
      class Of2 extends kf2 {
        constructor(t3) {
          super(t3), this.center = t3.center || [0, 0], this.parallels = t3.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(l2(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t3, e2) {
          const { scale: r3, cosPhi: n3 } = this;
          return { x: l2(t3) * n3 * r3 + 0.5, y: -Math.sin(l2(e2)) / n3 * r3 + 0.5, z: 0 };
        }
        unproject(t3, e2) {
          const { scale: r3, cosPhi: n3 } = this, i2 = -(e2 - 0.5) / r3, s2 = d(u2((t3 - 0.5) / r3) / n3, -180, 180), a2 = Math.asin(d(i2 * n3, -1, 1)), o2 = d(u2(a2), -85.051129, Do);
          return new ko(s2, o2);
        }
      }
      class qf2 extends Lf2 {
        constructor(t3) {
          super(t3), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug", "custom"], this.range = [3, 5];
        }
        projectTilePoint(t3, e2, r3) {
          const n3 = hf2(t3, e2, r3);
          return jl(n3, n3, df2(rf2(r3))), { x: n3[0], y: n3[1], z: n3[2] };
        }
        locationPoint(t3, e2) {
          const r3 = cf2(e2.lat, e2.lng), n3 = Ll([], r3), s2 = t3.elevation ? t3.elevation.getAtPointOrZero(t3.locationCoordinate(e2), t3._centerAltitude) : t3._centerAltitude;
          Fl(r3, r3, n3, Bo(1, 0) * wo * s2);
          const a2 = ml(new Float64Array(16));
          return xl(a2, t3.pixelMatrix, t3.globeMatrix), jl(r3, r3, a2), new i(r3[0], r3[1]);
        }
        pixelsPerMeter(t3, e2) {
          return Bo(1, 0) * e2;
        }
        pixelSpaceConversion(t3, e2, r3) {
          const n3 = xr(Bo(1, 45) * e2, Bo(1, t3) * e2, r3);
          return this.pixelsPerMeter(t3, e2) / n3;
        }
        createTileMatrix(t3, e2, r3) {
          const n3 = yf2(rf2(r3.canonical));
          return xl(new Float64Array(16), t3.globeMatrix, n3);
        }
        createInversionMatrix(t3, e2) {
          const { center: r3 } = t3, n3 = df2(rf2(e2));
          return wl(n3, n3, l2(r3.lng)), _l(n3, n3, l2(r3.lat)), bl(n3, n3, [t3._pixelsPerMercatorPixel, t3._pixelsPerMercatorPixel, 1]), Float32Array.from(n3);
        }
        pointCoordinate(t3, e2, r3, n3) {
          return Qp(t3, e2, r3, true) || new Fo(0, 0);
        }
        pointCoordinate3D(t3, e2, r3) {
          const n3 = this.pointCoordinate(t3, e2, r3, 0);
          return [n3.x, n3.y, n3.z];
        }
        isPointAboveHorizon(t3, e2) {
          return !Qp(t3, e2.x, e2.y, false);
        }
        farthestPixelDistance(t3) {
          const e2 = function(t4, e3) {
            const r4 = t4.cameraToCenterDistance, n3 = t4._centerAltitude * e3, i2 = t4._camera, s2 = t4._camera.forward(), a2 = Bl([], Vl([], s2, -r4), [0, 0, n3]), o2 = t4.worldSize / (2 * Math.PI), l3 = [0, 0, -o2], u3 = t4.width / t4.height, c2 = Math.tan(t4.fovAboveCenter), h3 = Vl([], i2.up(), c2), p3 = Vl([], i2.right(), c2 * u3), f2 = Ll([], Bl([], Bl([], s2, h3), p3)), d2 = [];
            let y3;
            if (new Jl(a2, f2).closestPointOnSphere(l3, o2, d2)) {
              const e4 = Bl([], d2, l3), r5 = ql([], e4, a2);
              y3 = Math.cos(t4.fovAboveCenter) * zl(r5);
            } else {
              const t5 = ql([], a2, l3), e4 = ql([], l3, a2);
              Ll(e4, e4);
              const r5 = zl(t5) - o2;
              y3 = Math.sqrt(r5 * (r5 + 2 * o2));
              const n4 = Math.acos(y3 / (o2 + r5)) - Math.acos(Rl(s2, e4));
              y3 *= Math.cos(n4);
            }
            return 1.01 * y3;
          }(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize)), r3 = gf2(t3.zoom);
          if (r3 > 0) {
            const n3 = wf2(t3, Bo(1, t3.center.lat) * t3.worldSize), i2 = t3.worldSize / (2 * Math.PI), s2 = Math.max(t3.width, t3.height) / t3.worldSize * Math.PI;
            return xr(e2, n3 + i2 * (1 - Math.cos(s2)), Math.pow(r3, 10));
          }
          return e2;
        }
        upVector(t3, e2, r3) {
          return hf2(e2, r3, t3, 1);
        }
        upVectorScale(t3) {
          return { metersToTile: Kp * pf2(rf2(t3)) };
        }
      }
      function Nf2(t3) {
        const e2 = t3.parallels, r3 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
        switch (t3.name) {
          case "mercator":
            return new Lf2(t3);
          case "equirectangular":
            return new Pf2(t3);
          case "naturalEarth":
            return new Uf2(t3);
          case "equalEarth":
            return new Cf2(t3);
          case "winkelTripel":
            return new $f2(t3);
          case "albers":
            return r3 ? new Of2(t3) : new If2(t3);
          case "lambertConformalConic":
            return r3 ? new Of2(t3) : new Ff2(t3);
          case "globe":
            return new qf2(t3);
        }
        throw new Error(`Invalid projection name: ${t3.name}`);
      }
      const Gf2 = yc2.VectorTileFeature.types, Zf2 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Xf2(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3) {
        const f2 = o2 ? Math.min(Lp, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Lp, Math.round(o2[1])) : 0;
        t3.emplaceBack(e2, r3, Math.round(32 * n3), Math.round(32 * i2), s2, a2, (f2 << 1) + (l3 ? 1 : 0), d2, 16 * u3, 16 * c2, 256 * h3, 256 * p3);
      }
      function Kf2(t3, e2, r3, n3, i2, s2, a2) {
        t3.emplaceBack(e2, r3, n3, i2, s2, a2);
      }
      function Hf2(t3, e2, r3, n3, i2) {
        t3.emplaceBack(e2, r3, n3, i2), t3.emplaceBack(e2, r3, n3, i2), t3.emplaceBack(e2, r3, n3, i2), t3.emplaceBack(e2, r3, n3, i2);
      }
      function Yf2(t3) {
        for (const e2 of t3.sections)
          if (vs(e2.text))
            return true;
        return false;
      }
      class Wf2 {
        constructor(t3) {
          this.layoutVertexArray = new oa2(), this.indexArray = new ya2(), this.programConfigurations = t3, this.segments = new _o(), this.dynamicLayoutVertexArray = new na2(), this.opacityVertexArray = new ua2(), this.placedSymbolArray = new Ta2(), this.globeExtVertexArray = new la2();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t3, e2, r3, n3) {
          this.isEmpty() || (r3 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Qc2.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, eh2.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, Zf2, true), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t3.createVertexBuffer(this.globeExtVertexArray, th2.members, true)), this.opacityVertexBuffer.itemSize = 1), (r3 || n3) && this.programConfigurations.upload(t3));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
      }
      Pi2(Wf2, "SymbolBuffers");
      class Jf2 {
        constructor(t3, e2, r3) {
          this.layoutVertexArray = new t3(), this.layoutAttributes = e2, this.indexArray = new r3(), this.segments = new _o(), this.collisionVertexArray = new fa2(), this.collisionVertexArrayExt = new da2();
        }
        upload(t3) {
          this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, rh2.members, true), this.collisionVertexBufferExt = t3.createVertexBuffer(this.collisionVertexArrayExt, nh2.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      Pi2(Jf2, "CollisionBuffers");
      class Qf2 {
        constructor(t3) {
          this.collisionBoxArray = t3.collisionBoxArray, this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.pixelRatio = t3.pixelRatio, this.sourceLayerIndex = t3.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ml([]), this.placementViewportMatrix = ml([]);
          const e2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = lh2(this.zoom, e2["text-size"]), this.iconSizeData = lh2(this.zoom, e2["icon-size"]);
          const r3 = this.layers[0].layout, n3 = r3.get("symbol-sort-key"), i2 = r3.get("symbol-z-order");
          this.canOverlap = r3.get("text-allow-overlap") || r3.get("icon-allow-overlap") || r3.get("text-ignore-placement") || r3.get("icon-ignore-placement"), this.sortFeaturesByKey = i2 !== "viewport-y" && n3.constantOr(1) !== void 0, this.sortFeaturesByY = (i2 === "viewport-y" || i2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r3.get("text-writing-mode").map((t4) => Nh2[t4]), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.sourceID = t3.sourceID, this.projection = t3.projection;
        }
        createArrays() {
          this.text = new Wf2(new co(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new Wf2(new co(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new Ca2(), this.lineVertexArray = new Pa2(), this.symbolInstances = new Ea2();
        }
        calculateGlyphDependencies(t3, e2, r3, n3, i2) {
          for (let r4 = 0; r4 < t3.length; r4++)
            if (e2[t3.charCodeAt(r4)] = true, n3 && i2) {
              const n4 = fh2[t3.charAt(r4)];
              n4 && (e2[n4.charCodeAt(0)] = true);
            }
        }
        populate(t3, e2, r3, n3) {
          const i2 = this.layers[0], s2 = i2.layout, a2 = this.projection.name === "globe", o2 = s2.get("text-font"), l3 = s2.get("text-field"), u3 = s2.get("icon-image"), c2 = (l3.value.kind !== "constant" || l3.value.value instanceof _e && !l3.value.value.isEmpty() || l3.value.value.toString().length > 0) && (o2.value.kind !== "constant" || o2.value.value.length > 0), h3 = u3.value.kind !== "constant" || !!u3.value.value || Object.keys(u3.parameters).length > 0, p3 = s2.get("symbol-sort-key");
          if (this.features = [], !c2 && !h3)
            return;
          const f2 = e2.iconDependencies, d2 = e2.glyphDependencies, y3 = e2.availableImages, m3 = new Cs(this.zoom);
          for (const { feature: e3, id: l4, index: u4, sourceLayerIndex: g2 } of t3) {
            const t4 = i2._featureFilter.needGeometry, x3 = Go(e3, t4);
            if (!i2._featureFilter.filter(m3, x3, r3))
              continue;
            if (t4 || (x3.geometry = No(e3, r3, n3)), a2 && e3.type !== 1 && r3.z <= 5) {
              const t5 = x3.geometry, e4 = 0.98078528056;
              for (let n4 = 0; n4 < t5.length; n4++)
                t5[n4] = jo(t5[n4], (t6) => t6, (t6, n5) => Rl(hf2(t6.x, t6.y, r3, 1), hf2(n5.x, n5.y, r3, 1)) < e4);
            }
            let v3, b2;
            if (c2) {
              const t5 = i2.getValueAndResolveTokens("text-field", x3, r3, y3), e4 = _e.factory(t5);
              Yf2(e4) && (this.hasRTLText = true), (!this.hasRTLText || Ts() === "unavailable" || this.hasRTLText && Es.isParsed()) && (v3 = ph2(e4, i2, x3));
            }
            if (h3) {
              const t5 = i2.getValueAndResolveTokens("icon-image", x3, r3, y3);
              b2 = t5 instanceof we2 ? t5 : we2.fromString(t5);
            }
            if (!v3 && !b2)
              continue;
            const _2 = this.sortFeaturesByKey ? p3.evaluate(x3, {}, r3) : void 0;
            if (this.features.push({ id: l4, text: v3, icon: b2, index: u4, sourceLayerIndex: g2, geometry: x3.geometry, properties: e3.properties, type: Gf2[e3.type], sortKey: _2 }), b2 && (f2[b2.name] = true), v3) {
              const t5 = o2.evaluate(x3, {}, r3).join(","), e4 = s2.get("text-rotation-alignment") === "map" && s2.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Nh2.vertical) >= 0;
              for (const r4 of v3.sections)
                if (r4.image)
                  f2[r4.image.name] = true;
                else {
                  const n4 = ps(v3.toString()), i3 = r4.fontStack || t5, s3 = d2[i3] = d2[i3] || {};
                  this.calculateGlyphDependencies(r4.text, s3, e4, this.allowVerticalPlacement, n4);
                }
            }
          }
          s2.get("symbol-placement") === "line" && (this.features = function(t4) {
            const e3 = {}, r4 = {}, n4 = [];
            let i3 = 0;
            function s3(e4) {
              n4.push(t4[e4]), i3++;
            }
            function a3(t5, e4, i4) {
              const s4 = r4[t5];
              return delete r4[t5], r4[e4] = s4, n4[s4].geometry[0].pop(), n4[s4].geometry[0] = n4[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t5, r5, i4) {
              const s4 = e3[r5];
              return delete e3[r5], e3[t5] = s4, n4[s4].geometry[0].shift(), n4[s4].geometry[0] = i4[0].concat(n4[s4].geometry[0]), s4;
            }
            function l4(t5, e4, r5) {
              const n5 = r5 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t5}:${n5.x}:${n5.y}`;
            }
            for (let u4 = 0; u4 < t4.length; u4++) {
              const c3 = t4[u4], h4 = c3.geometry, p4 = c3.text ? c3.text.toString() : null;
              if (!p4) {
                s3(u4);
                continue;
              }
              const f3 = l4(p4, h4), d3 = l4(p4, h4, true);
              if (f3 in r4 && d3 in e3 && r4[f3] !== e3[d3]) {
                const t5 = o3(f3, d3, h4), i4 = a3(f3, d3, n4[t5].geometry);
                delete e3[f3], delete r4[d3], r4[l4(p4, n4[i4].geometry, true)] = i4, n4[t5].geometry = null;
              } else
                f3 in r4 ? a3(f3, d3, h4) : d3 in e3 ? o3(f3, d3, h4) : (s3(u4), e3[f3] = i3 - 1, r4[d3] = i3 - 1);
            }
            return n4.filter((t5) => t5.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t4, e3) => t4.sortKey - e3.sortKey);
        }
        update(t3, e2, r3, n3) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t3, e2, this.layers, r3, n3), this.icon.programConfigurations.updatePaintArrays(t3, e2, this.layers, r3, n3));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t3) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = Nf2(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t3, e2) {
          const r3 = this.lineVertexArray.length, n3 = t3.segment;
          if (n3 !== void 0) {
            let r4 = t3.dist(e2[n3 + 1]), i2 = t3.dist(e2[n3]);
            const s2 = {};
            for (let t4 = n3 + 1; t4 < e2.length; t4++)
              s2[t4] = { x: e2[t4].x, y: e2[t4].y, tileUnitDistanceFromAnchor: r4 }, t4 < e2.length - 1 && (r4 += e2[t4 + 1].dist(e2[t4]));
            for (let t4 = n3 || 0; t4 >= 0; t4--)
              s2[t4] = { x: e2[t4].x, y: e2[t4].y, tileUnitDistanceFromAnchor: i2 }, t4 > 0 && (i2 += e2[t4 - 1].dist(e2[t4]));
            for (let t4 = 0; t4 < e2.length; t4++) {
              const e3 = s2[t4];
              this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r3, lineLength: this.lineVertexArray.length - r3 };
        }
        addSymbols(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2, h3, p3, f2) {
          const d2 = t3.indexArray, y3 = t3.layoutVertexArray, m3 = t3.globeExtVertexArray, g2 = t3.segments.prepareSegment(4 * e2.length, y3, d2, this.canOverlap ? s2.sortKey : void 0), x3 = this.glyphOffsetArray.length, v3 = g2.vertexLength, b2 = this.allowVerticalPlacement && a2 === Nh2.vertical ? Math.PI / 2 : 0, _2 = s2.text && s2.text.sections;
          for (let n4 = 0; n4 < e2.length; n4++) {
            const { tl: i3, tr: a3, bl: u4, br: c3, tex: h4, pixelOffsetTL: x4, pixelOffsetBR: v4, minFontScaleX: w3, minFontScaleY: A3, glyphOffset: S3, isSDF: k2, sectionIndex: I3 } = e2[n4], M3 = g2.vertexLength, z3 = S3[1];
            if (Xf2(y3, l3.x, l3.y, i3.x, z3 + i3.y, h4.x, h4.y, r3, k2, x4.x, x4.y, w3, A3), Xf2(y3, l3.x, l3.y, a3.x, z3 + a3.y, h4.x + h4.w, h4.y, r3, k2, v4.x, x4.y, w3, A3), Xf2(y3, l3.x, l3.y, u4.x, z3 + u4.y, h4.x, h4.y + h4.h, r3, k2, x4.x, v4.y, w3, A3), Xf2(y3, l3.x, l3.y, c3.x, z3 + c3.y, h4.x + h4.w, h4.y + h4.h, r3, k2, v4.x, v4.y, w3, A3), o2) {
              const e3 = o2.anchor, r4 = o2.up;
              Kf2(m3, e3.x, e3.y, e3.z, r4[0], r4[1], r4[2]), Kf2(m3, e3.x, e3.y, e3.z, r4[0], r4[1], r4[2]), Kf2(m3, e3.x, e3.y, e3.z, r4[0], r4[1], r4[2]), Kf2(m3, e3.x, e3.y, e3.z, r4[0], r4[1], r4[2]), Hf2(t3.dynamicLayoutVertexArray, e3.x, e3.y, e3.z, b2);
            } else
              Hf2(t3.dynamicLayoutVertexArray, l3.x, l3.y, l3.z, b2);
            d2.emplaceBack(M3, M3 + 1, M3 + 2), d2.emplaceBack(M3 + 1, M3 + 2, M3 + 3), g2.vertexLength += 4, g2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S3[0]), n4 !== e2.length - 1 && I3 === e2[n4 + 1].sectionIndex || t3.programConfigurations.populatePaintArrays(y3.length, s2, s2.index, {}, p3, f2, _2 && _2[I3]);
          }
          const w2 = o2 ? o2.anchor : l3;
          t3.placedSymbolArray.emplaceBack(w2.x, w2.y, w2.z, l3.x, l3.y, x3, this.glyphOffsetArray.length - x3, v3, u3, c2, l3.segment, r3 ? r3[0] : 0, r3 ? r3[1] : 0, n3[0], n3[1], a2, 0, false, 0, h3, 0);
        }
        _commitLayoutVertex(t3, e2, r3, n3, i2, s2, a2) {
          t3.emplaceBack(e2, r3, n3, i2, s2, Math.round(a2.x), Math.round(a2.y));
        }
        _addCollisionDebugVertices(t3, e2, r3, n3, s2, a2, o2) {
          const l3 = r3.segments.prepareSegment(4, r3.layoutVertexArray, r3.indexArray), u3 = l3.vertexLength, c2 = o2.tileAnchorX, h3 = o2.tileAnchorY;
          for (let t4 = 0; t4 < 4; t4++)
            r3.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          r3.collisionVertexArrayExt.emplaceBack(e2, -t3.padding, -t3.padding), r3.collisionVertexArrayExt.emplaceBack(e2, t3.padding, -t3.padding), r3.collisionVertexArrayExt.emplaceBack(e2, t3.padding, t3.padding), r3.collisionVertexArrayExt.emplaceBack(e2, -t3.padding, t3.padding), this._commitLayoutVertex(r3.layoutVertexArray, n3, s2, a2, c2, h3, new i(t3.x1, t3.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n3, s2, a2, c2, h3, new i(t3.x2, t3.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n3, s2, a2, c2, h3, new i(t3.x2, t3.y2)), this._commitLayoutVertex(r3.layoutVertexArray, n3, s2, a2, c2, h3, new i(t3.x1, t3.y2)), l3.vertexLength += 4;
          const p3 = r3.indexArray;
          p3.emplaceBack(u3, u3 + 1), p3.emplaceBack(u3 + 1, u3 + 2), p3.emplaceBack(u3 + 2, u3 + 3), p3.emplaceBack(u3 + 3, u3), l3.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(t3, e2, r3, n3, i2, s2) {
          for (let a2 = n3; a2 < i2; a2++) {
            const n4 = r3.get(a2), i3 = this.getSymbolInstanceTextSize(t3, s2, e2, a2);
            this._addCollisionDebugVertices(n4, i3, this.textCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s2);
          }
        }
        _addIconDebugCollisionBoxes(t3, e2, r3, n3, i2, s2) {
          for (let a2 = n3; a2 < i2; a2++) {
            const n4 = r3.get(a2), i3 = this.getSymbolInstanceIconSize(t3, e2, a2);
            this._addCollisionDebugVertices(n4, i3, this.iconCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s2);
          }
        }
        generateCollisionDebugBuffers(t3, e2) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Jf2(ha2, ih2.members, _a), this.iconCollisionBox = new Jf2(ha2, ih2.members, _a);
          const r3 = ch2(this.iconSizeData, t3), n3 = ch2(this.textSizeData, t3);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._addTextDebugCollisionBoxes(n3, t3, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n3, t3, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r3, t3, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r3, t3, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
        }
        getSymbolInstanceTextSize(t3, e2, r3, n3) {
          const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n3), s2 = uh2(this.textSizeData, t3, i2) / ah2;
          return this.tilePixelRatio * s2;
        }
        getSymbolInstanceIconSize(t3, e2, r3) {
          const n3 = this.icon.placedSymbolArray.get(r3), i2 = uh2(this.iconSizeData, t3, n3);
          return this.tilePixelRatio * i2;
        }
        _commitDebugCollisionVertexUpdate(t3, e2, r3) {
          t3.emplaceBack(e2, -r3, -r3), t3.emplaceBack(e2, r3, -r3), t3.emplaceBack(e2, r3, r3), t3.emplaceBack(e2, -r3, r3);
        }
        _updateTextDebugCollisionBoxes(t3, e2, r3, n3, i2, s2) {
          for (let a2 = n3; a2 < i2; a2++) {
            const n4 = r3.get(a2), i3 = this.getSymbolInstanceTextSize(t3, s2, e2, a2);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n4.padding);
          }
        }
        _updateIconDebugCollisionBoxes(t3, e2, r3, n3, i2) {
          for (let s2 = n3; s2 < i2; s2++) {
            const n4 = r3.get(s2), i3 = this.getSymbolInstanceIconSize(t3, e2, s2);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n4.padding);
          }
        }
        updateCollisionDebugBuffers(t3, e2) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const r3 = ch2(this.iconSizeData, t3), n3 = ch2(this.textSizeData, t3);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._updateTextDebugCollisionBoxes(n3, t3, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n3, t3, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r3, t3, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(r3, t3, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
          const u3 = {};
          for (let n4 = e2; n4 < r3; n4++) {
            const e3 = t3.get(n4);
            u3.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, padding: e3.padding, projectedAnchorX: e3.projectedAnchorX, projectedAnchorY: e3.projectedAnchorY, projectedAnchorZ: e3.projectedAnchorZ, tileAnchorX: e3.tileAnchorX, tileAnchorY: e3.tileAnchorY }, u3.textFeatureIndex = e3.featureIndex;
            break;
          }
          for (let e3 = n3; e3 < i2; e3++) {
            const r4 = t3.get(e3);
            u3.verticalTextBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, projectedAnchorX: r4.projectedAnchorX, projectedAnchorY: r4.projectedAnchorY, projectedAnchorZ: r4.projectedAnchorZ, tileAnchorX: r4.tileAnchorX, tileAnchorY: r4.tileAnchorY }, u3.verticalTextFeatureIndex = r4.featureIndex;
            break;
          }
          for (let e3 = s2; e3 < a2; e3++) {
            const r4 = t3.get(e3);
            u3.iconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, projectedAnchorX: r4.projectedAnchorX, projectedAnchorY: r4.projectedAnchorY, projectedAnchorZ: r4.projectedAnchorZ, tileAnchorX: r4.tileAnchorX, tileAnchorY: r4.tileAnchorY }, u3.iconFeatureIndex = r4.featureIndex;
            break;
          }
          for (let e3 = o2; e3 < l3; e3++) {
            const r4 = t3.get(e3);
            u3.verticalIconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, projectedAnchorX: r4.projectedAnchorX, projectedAnchorY: r4.projectedAnchorY, projectedAnchorZ: r4.projectedAnchorZ, tileAnchorX: r4.tileAnchorX, tileAnchorY: r4.tileAnchorY }, u3.verticalIconFeatureIndex = r4.featureIndex;
            break;
          }
          return u3;
        }
        deserializeCollisionBoxes(t3) {
          this.collisionArrays = [];
          for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
            const r3 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r3.textBoxStartIndex, r3.textBoxEndIndex, r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t3, e2) {
          const r3 = t3.placedSymbolArray.get(e2), n3 = r3.vertexStartIndex + 4 * r3.numGlyphs;
          for (let e3 = r3.vertexStartIndex; e3 < n3; e3 += 4)
            t3.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t3.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t3) {
          if (this.sortedAngle === t3 && this.symbolInstanceIndexes !== void 0)
            return this.symbolInstanceIndexes;
          const e2 = Math.sin(t3), r3 = Math.cos(t3), n3 = [], i2 = [], s2 = [];
          for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
            s2.push(t4);
            const a2 = this.symbolInstances.get(t4);
            n3.push(0 | Math.round(e2 * a2.tileAnchorX + r3 * a2.tileAnchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t4, e3) => n3[t4] - n3[e3] || i2[e3] - i2[t4]), s2;
        }
        addToSortKeyRanges(t3, e2) {
          const r3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r3 && r3.sortKey === e2 ? r3.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
        }
        sortFeatures(t3) {
          if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t4 of this.symbolInstanceIndexes) {
              const e2 = this.symbolInstances.get(t4);
              this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t5, e3, r3) => {
                t5 >= 0 && r3.indexOf(t5) === e3 && this.addIndicesForPlacedSymbol(this.text, t5);
              }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      Pi2(Qf2, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Qf2.MAX_GLYPHS = 65535, Qf2.addDynamicAttributes = Hf2;
      const td2 = new Zs({ "symbol-placement": new $s(Gt.layout_symbol["symbol-placement"]), "symbol-spacing": new $s(Gt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new $s(Gt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Os(Gt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new $s(Gt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new $s(Gt.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new $s(Gt.layout_symbol["icon-ignore-placement"]), "icon-optional": new $s(Gt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new $s(Gt.layout_symbol["icon-rotation-alignment"]), "icon-size": new Os(Gt.layout_symbol["icon-size"]), "icon-text-fit": new $s(Gt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new $s(Gt.layout_symbol["icon-text-fit-padding"]), "icon-image": new Os(Gt.layout_symbol["icon-image"]), "icon-rotate": new Os(Gt.layout_symbol["icon-rotate"]), "icon-padding": new $s(Gt.layout_symbol["icon-padding"]), "icon-keep-upright": new $s(Gt.layout_symbol["icon-keep-upright"]), "icon-offset": new Os(Gt.layout_symbol["icon-offset"]), "icon-anchor": new Os(Gt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new $s(Gt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new $s(Gt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new $s(Gt.layout_symbol["text-rotation-alignment"]), "text-field": new Os(Gt.layout_symbol["text-field"]), "text-font": new Os(Gt.layout_symbol["text-font"]), "text-size": new Os(Gt.layout_symbol["text-size"]), "text-max-width": new Os(Gt.layout_symbol["text-max-width"]), "text-line-height": new Os(Gt.layout_symbol["text-line-height"]), "text-letter-spacing": new Os(Gt.layout_symbol["text-letter-spacing"]), "text-justify": new Os(Gt.layout_symbol["text-justify"]), "text-radial-offset": new Os(Gt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new $s(Gt.layout_symbol["text-variable-anchor"]), "text-anchor": new Os(Gt.layout_symbol["text-anchor"]), "text-max-angle": new $s(Gt.layout_symbol["text-max-angle"]), "text-writing-mode": new $s(Gt.layout_symbol["text-writing-mode"]), "text-rotate": new Os(Gt.layout_symbol["text-rotate"]), "text-padding": new $s(Gt.layout_symbol["text-padding"]), "text-keep-upright": new $s(Gt.layout_symbol["text-keep-upright"]), "text-transform": new Os(Gt.layout_symbol["text-transform"]), "text-offset": new Os(Gt.layout_symbol["text-offset"]), "text-allow-overlap": new $s(Gt.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new $s(Gt.layout_symbol["text-ignore-placement"]), "text-optional": new $s(Gt.layout_symbol["text-optional"]) });
      var ed2 = { paint: new Zs({ "icon-opacity": new Os(Gt.paint_symbol["icon-opacity"]), "icon-color": new Os(Gt.paint_symbol["icon-color"]), "icon-halo-color": new Os(Gt.paint_symbol["icon-halo-color"]), "icon-halo-width": new Os(Gt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Os(Gt.paint_symbol["icon-halo-blur"]), "icon-translate": new $s(Gt.paint_symbol["icon-translate"]), "icon-translate-anchor": new $s(Gt.paint_symbol["icon-translate-anchor"]), "text-opacity": new Os(Gt.paint_symbol["text-opacity"]), "text-color": new Os(Gt.paint_symbol["text-color"], { runtimeType: ne2, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new Os(Gt.paint_symbol["text-halo-color"]), "text-halo-width": new Os(Gt.paint_symbol["text-halo-width"]), "text-halo-blur": new Os(Gt.paint_symbol["text-halo-blur"]), "text-translate": new $s(Gt.paint_symbol["text-translate"]), "text-translate-anchor": new $s(Gt.paint_symbol["text-translate-anchor"]) }), layout: td2 };
      class rd2 {
        constructor(t3) {
          this.type = t3.property.overrides ? t3.property.overrides.runtimeType : Qt, this.defaultValue = t3;
        }
        evaluate(t3) {
          if (t3.formattedSection) {
            const e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t3.formattedSection))
              return e2.getOverride(t3.formattedSection);
          }
          return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t3) {
          this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      Pi2(rd2, "FormatSectionOverride", { omit: ["defaultValue"] });
      class nd2 extends xo {
        constructor(t3) {
          super(t3, ed2);
        }
        recalculate(t3, e2) {
          super.recalculate(t3, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const r3 = this.layout.get("text-writing-mode");
          if (r3) {
            const t4 = [];
            for (const e3 of r3)
              t4.indexOf(e3) < 0 && t4.push(e3);
            this.layout._values["text-writing-mode"] = t4;
          } else
            this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t3, e2, r3, n3) {
          const i2 = this.layout.get(t3).evaluate(e2, {}, r3, n3), s2 = this._unevaluatedLayout._values[t3];
          return s2.isDataDriven() || Fn(s2.value) || !i2 ? i2 : function(t4, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r4) => r4 in t4 ? String(t4[r4]) : "");
          }(e2.properties, i2);
        }
        createBucket(t3) {
          return new Qf2(t3);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const t3 of ed2.paint.overridableProperties) {
            if (!nd2.hasPaintOverride(this.layout, t3))
              continue;
            const e2 = this.paint.get(t3), r3 = new rd2(e2), n3 = new Vn(r3, e2.property.specification);
            let i2 = null;
            i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new Rn("source", n3) : new Un("composite", n3, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t3] = new Us(e2.property, i2, e2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t3, e2, r3) {
          return !(!this.layout || e2.isDataDriven() || r3.isDataDriven()) && nd2.hasPaintOverride(this.layout, t3);
        }
        static hasPaintOverride(t3, e2) {
          const r3 = t3.get("text-field"), n3 = ed2.paint.properties[e2];
          let i2 = false;
          const s2 = (t4) => {
            for (const e3 of t4)
              if (n3.overrides && n3.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if (r3.value.kind === "constant" && r3.value.value instanceof _e)
            s2(r3.value.value.sections);
          else if (r3.value.kind === "source") {
            const t4 = (e4) => {
              i2 || (e4 instanceof ze && ke2(e4.value) === oe2 ? s2(e4.value.sections) : e4 instanceof Pe2 ? s2(e4.sections) : e4.eachChild(t4));
            }, e3 = r3.value;
            e3._styleExpression && t4(e3._styleExpression.expression);
          }
          return i2;
        }
        getProgramConfiguration(t3) {
          return new uo(this, t3);
        }
      }
      var id2 = { paint: new Zs({ "background-color": new $s(Gt.paint_background["background-color"]), "background-pattern": new Ns(Gt.paint_background["background-pattern"]), "background-opacity": new $s(Gt.paint_background["background-opacity"]) }) }, sd2 = { paint: new Zs({ "raster-opacity": new $s(Gt.paint_raster["raster-opacity"]), "raster-hue-rotate": new $s(Gt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new $s(Gt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new $s(Gt.paint_raster["raster-brightness-max"]), "raster-saturation": new $s(Gt.paint_raster["raster-saturation"]), "raster-contrast": new $s(Gt.paint_raster["raster-contrast"]), "raster-resampling": new $s(Gt.paint_raster["raster-resampling"]), "raster-fade-duration": new $s(Gt.paint_raster["raster-fade-duration"]) }) };
      class ad2 extends xo {
        constructor(t3) {
          super(t3, {}), this.implementation = t3;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
        }
        onAdd(t3) {
          this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
        }
        onRemove(t3) {
          this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
        }
      }
      var od2 = { paint: new Zs({ "sky-type": new $s(Gt.paint_sky["sky-type"]), "sky-atmosphere-sun": new $s(Gt.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new $s(Gt.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new $s(Gt.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new $s(Gt.paint_sky["sky-gradient-radius"]), "sky-gradient": new Gs(Gt.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new $s(Gt.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new $s(Gt.paint_sky["sky-atmosphere-color"]), "sky-opacity": new $s(Gt.paint_sky["sky-opacity"]) }) };
      function ld2(t3, e2, r3) {
        const n3 = [0, 0, 1], i2 = Hl([]);
        return Wl(i2, i2, r3 ? -l2(t3) + Math.PI : l2(t3)), Yl(i2, i2, -l2(e2)), $l(n3, n3, i2), Ll(n3, n3);
      }
      const ud2 = { circle: class extends xo {
        constructor(t3) {
          super(t3, pl);
        }
        createBucket(t3) {
          return new Ko(t3);
        }
        queryRadius(t3) {
          const e2 = t3;
          return ol("circle-radius", this, e2) + ol("circle-stroke-width", this, e2) + ll(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t3, e2, r3, n3, i2, s2, a2, o2) {
          const l3 = cl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t3.pixelToTileUnitsFactor), u3 = this.paint.get("circle-radius").evaluate(e2, r3) + this.paint.get("circle-stroke-width").evaluate(e2, r3);
          return ru(t3, n3, s2, a2, o2, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", l3, u3);
        }
        getProgramIds() {
          return ["circle"];
        }
        getProgramConfiguration(t3) {
          return new uo(this, t3);
        }
      }, heatmap: class extends xo {
        createBucket(t3) {
          return new ou(t3);
        }
        constructor(t3) {
          super(t3, fu), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t3) {
          t3 === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = du({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t3) {
          return ol("heatmap-radius", this, t3);
        }
        queryIntersectsFeature(t3, e2, r3, n3, s2, a2, o2, l3) {
          const u3 = this.paint.get("heatmap-radius").evaluate(e2, r3);
          return ru(t3, n3, a2, o2, l3, true, true, new i(0, 0), u3);
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getProgramConfiguration(t3) {
          return new uo(this, t3);
        }
      }, hillshade: class extends xo {
        constructor(t3) {
          super(t3, yu);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
      }, fill: class extends xo {
        constructor(t3) {
          super(t3, rc2);
        }
        getProgramIds() {
          const t3 = this.paint.get("fill-pattern"), e2 = t3 && t3.constantOr(1), r3 = [e2 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r3.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r3;
        }
        getProgramConfiguration(t3) {
          return new uo(this, t3);
        }
        recalculate(t3, e2) {
          super.recalculate(t3, e2);
          const r3 = this.paint._values["fill-outline-color"];
          r3.value.kind === "constant" && r3.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t3) {
          return new tc2(t3);
        }
        queryRadius() {
          return ll(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t3, e2, r3, n3, i2, s2) {
          return !t3.queryGeometry.isAboveHorizon && Wo(ul(t3.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t3.pixelToTileUnitsFactor), n3);
        }
        isTileClipped() {
          return true;
        }
      }, "fill-extrusion": class extends xo {
        constructor(t3) {
          super(t3, Cc2);
        }
        createBucket(t3) {
          return new wc2(t3);
        }
        queryRadius() {
          return ll(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        getProgramConfiguration(t3) {
          return new uo(this, t3);
        }
        queryIntersectsFeature(t3, e2, r3, n3, s2, a2, o2, l3, u3) {
          const c2 = cl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, t3.pixelToTileUnitsFactor), h3 = this.paint.get("fill-extrusion-height").evaluate(e2, r3), p3 = this.paint.get("fill-extrusion-base").evaluate(e2, r3), f2 = [0, 0], d2 = l3 && a2.elevation, y3 = a2.elevation ? a2.elevation.exaggeration() : 1, m3 = t3.tile.getBucket(this);
          if (d2 && m3 instanceof wc2) {
            const t4 = m3.centroidVertexArray, e3 = u3 + 1;
            if (e3 < t4.length) {
              const r4 = t4.get(e3);
              f2[0] = r4.a_centroid_pos0, f2[1] = r4.a_centroid_pos1;
            }
          }
          if (f2[0] === 0 && f2[1] === 1)
            return false;
          a2.projection.name === "globe" && (n3 = Bc2([n3], [new i(0, 0), new i(wo, wo)], t3.tileID.canonical).map((t4) => t4.polygon).flat());
          const g2 = function(t4, e3, r4, n4, s3, a3, o3, l4, u4, c3, h4) {
            return t4.projection.name === "globe" ? function(t5, e4, r5, n5, i2, s4, a4, o4, l5, u5, c4) {
              const h5 = [], p4 = [], f3 = t5.projection.upVectorScale(c4, t5.center.lat, t5.worldSize).metersToTile, d3 = [0, 0, 0, 1], y4 = [0, 0, 0, 1], m4 = (t6, e5, r6, n6) => {
                t6[0] = e5, t6[1] = r6, t6[2] = n6, t6[3] = 1;
              }, g3 = Tc2();
              r5 > 0 && (r5 += g3), n5 += g3;
              for (const g4 of e4) {
                const e5 = [], x4 = [];
                for (const h6 of g4) {
                  const p5 = h6.x + i2.x, g5 = h6.y + i2.y, v3 = t5.projection.projectTilePoint(p5, g5, c4), b2 = t5.projection.upVector(c4, h6.x, h6.y);
                  let _2 = r5, w2 = n5;
                  if (a4) {
                    const t6 = $c2(p5, g5, r5, n5, a4, o4, l5, u5);
                    _2 += t6.base, w2 += t6.top;
                  }
                  r5 !== 0 ? m4(d3, v3.x + b2[0] * f3 * _2, v3.y + b2[1] * f3 * _2, v3.z + b2[2] * f3 * _2) : m4(d3, v3.x, v3.y, v3.z), m4(y4, v3.x + b2[0] * f3 * w2, v3.y + b2[1] * f3 * w2, v3.z + b2[2] * f3 * w2), jl(d3, d3, s4), jl(y4, y4, s4), e5.push(jc2(d3)), x4.push(jc2(y4));
                }
                h5.push(e5), p4.push(x4);
              }
              return [h5, p4];
            }(t4, e3, r4, n4, s3, a3, o3, l4, u4, c3, h4) : o3 ? function(t5, e4, r5, n5, i2, s4, a4, o4, l5) {
              const u5 = [], c4 = [], h5 = [0, 0, 0, 1];
              for (const p4 of t5) {
                const t6 = [], f3 = [];
                for (const u6 of p4) {
                  const c5 = u6.x + n5.x, p5 = u6.y + n5.y, d3 = $c2(c5, p5, e4, r5, s4, a4, o4, l5);
                  h5[0] = c5, h5[1] = p5, h5[2] = d3.base, h5[3] = 1, Xl(h5, h5, i2), h5[3] = Math.max(h5[3], 1e-5);
                  const y4 = jc2([h5[0] / h5[3], h5[1] / h5[3], h5[2] / h5[3]]);
                  h5[0] = c5, h5[1] = p5, h5[2] = d3.top, h5[3] = 1, Xl(h5, h5, i2), h5[3] = Math.max(h5[3], 1e-5);
                  const m4 = jc2([h5[0] / h5[3], h5[1] / h5[3], h5[2] / h5[3]]);
                  t6.push(y4), f3.push(m4);
                }
                u5.push(t6), c4.push(f3);
              }
              return [u5, c4];
            }(e3, r4, n4, s3, a3, o3, l4, u4, c3) : function(t5, e4, r5, n5, s4) {
              const a4 = [], o4 = [], l5 = s4[8] * e4, u5 = s4[9] * e4, c4 = s4[10] * e4, h5 = s4[11] * e4, p4 = s4[8] * r5, f3 = s4[9] * r5, d3 = s4[10] * r5, y4 = s4[11] * r5;
              for (const e5 of t5) {
                const t6 = [], r6 = [];
                for (const a5 of e5) {
                  const e6 = a5.x + n5.x, o5 = a5.y + n5.y, m4 = s4[0] * e6 + s4[4] * o5 + s4[12], g3 = s4[1] * e6 + s4[5] * o5 + s4[13], x4 = s4[2] * e6 + s4[6] * o5 + s4[14], v3 = s4[3] * e6 + s4[7] * o5 + s4[15], b2 = m4 + l5, _2 = g3 + u5, w2 = x4 + c4, A3 = Math.max(v3 + h5, 1e-5), S3 = m4 + p4, k2 = g3 + f3, I3 = x4 + d3, M3 = Math.max(v3 + y4, 1e-5), z3 = new i(b2 / A3, _2 / A3);
                  z3.z = w2 / A3, t6.push(z3);
                  const T3 = new i(S3 / M3, k2 / M3);
                  T3.z = I3 / M3, r6.push(T3);
                }
                a4.push(t6), o4.push(r6);
              }
              return [a4, o4];
            }(e3, r4, n4, s3, a3);
          }(a2, n3, p3, h3, c2, o2, d2 ? l3 : null, f2, y3, a2.center.lat, t3.tileID.canonical), x3 = t3.queryGeometry;
          return function(t4, e3, r4) {
            let n4 = 1 / 0;
            Wo(r4, e3) && (n4 = Uc2(r4, e3[0]));
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s3 = e3[i2], a3 = t4[i2];
              for (let t5 = 0; t5 < s3.length - 1; t5++) {
                const e4 = s3[t5], i3 = [e4, s3[t5 + 1], a3[t5 + 1], a3[t5], e4];
                Ho(r4, i3) && (n4 = Math.min(n4, Uc2(r4, i3)));
              }
            }
            return n4 !== 1 / 0 && n4;
          }(g2[0], g2[1], x3.isPointQuery() ? x3.screenBounds : x3.screenGeometry);
        }
      }, line: class extends xo {
        constructor(t3) {
          super(t3, Yc2), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(t3) {
          if (t3 === "line-gradient") {
            const t4 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t4._styleExpression && t4._styleExpression.expression instanceof gr, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t3, e2) {
          super.recalculate(t3, e2), this.paint._values["line-floorwidth"] = Wc2.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
        }
        createBucket(t3) {
          return new Kc2(t3);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getProgramConfiguration(t3) {
          return new uo(this, t3);
        }
        queryRadius(t3) {
          const e2 = t3, r3 = Jc2(ol("line-width", this, e2), ol("line-gap-width", this, e2)), n3 = ol("line-offset", this, e2);
          return r3 / 2 + Math.abs(n3) + ll(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t3, e2, r3, n3, s2, a2) {
          if (t3.queryGeometry.isAboveHorizon)
            return false;
          const o2 = ul(t3.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, t3.pixelToTileUnitsFactor), l3 = t3.pixelToTileUnitsFactor / 2 * Jc2(this.paint.get("line-width").evaluate(e2, r3), this.paint.get("line-gap-width").evaluate(e2, r3)), u3 = this.paint.get("line-offset").evaluate(e2, r3);
          return u3 && (n3 = function(t4, e3) {
            const r4 = [], n4 = new i(0, 0);
            for (let i2 = 0; i2 < t4.length; i2++) {
              const s3 = t4[i2], a3 = [];
              for (let t5 = 0; t5 < s3.length; t5++) {
                const r5 = s3[t5 - 1], i3 = s3[t5], o3 = s3[t5 + 1], l4 = t5 === 0 ? n4 : i3.sub(r5)._unit()._perp(), u4 = t5 === s3.length - 1 ? n4 : o3.sub(i3)._unit()._perp(), c2 = l4._add(u4)._unit();
                c2._mult(1 / (c2.x * u4.x + c2.y * u4.y)), a3.push(c2._mult(e3)._add(i3));
              }
              r4.push(a3);
            }
            return r4;
          }(n3, u3 * t3.pixelToTileUnitsFactor)), function(t4, e3, r4) {
            for (let n4 = 0; n4 < e3.length; n4++) {
              const i2 = e3[n4];
              if (t4.length >= 3) {
                for (let e4 = 0; e4 < i2.length; e4++)
                  if (il(t4, i2[e4]))
                    return true;
              }
              if (Jo(t4, i2, r4))
                return true;
            }
            return false;
          }(o2, n3, l3);
        }
        isTileClipped() {
          return true;
        }
      }, symbol: nd2, background: class extends xo {
        constructor(t3) {
          super(t3, id2);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
      }, raster: class extends xo {
        constructor(t3) {
          super(t3, sd2);
        }
        getProgramIds() {
          return ["raster"];
        }
      }, sky: class extends xo {
        constructor(t3) {
          super(t3, od2), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t3) {
          t3 === "sky-gradient" ? this._updateColorRamp() : t3 !== "sky-atmosphere-sun" && t3 !== "sky-atmosphere-halo-color" && t3 !== "sky-atmosphere-color" && t3 !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = du({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t3) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e2 = t3.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
          }
          return false;
        }
        getCenter(t3, e2) {
          if (this.paint.get("sky-type") === "atmosphere") {
            const r4 = this.paint.get("sky-atmosphere-sun"), n3 = !r4, i2 = t3.style.light, s2 = i2.properties.get("position");
            return n3 && i2.properties.get("anchor") === "viewport" && E2("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n3 ? ld2(s2.azimuthal, 90 - s2.polar, e2) : ld2(r4[0], 90 - r4[1], e2);
          }
          const r3 = this.paint.get("sky-gradient-center");
          return ld2(r3[0], 90 - r3[1], e2);
        }
        is3D() {
          return false;
        }
        isSky() {
          return true;
        }
        markSkyboxValid(t3) {
          this._skyboxInvalidated = false, this._lightPosition = t3.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const t3 = this.paint.get("sky-type");
          return t3 === "atmosphere" ? ["skyboxCapture", "skybox"] : t3 === "gradient" ? ["skyboxGradient"] : null;
        }
      } };
      class cd2 {
        constructor(t3, e2, r3, n3) {
          this.context = t3, this.format = r3, this.texture = t3.gl.createTexture(), this.update(e2, n3);
        }
        update(t3, r3, n3) {
          const { width: i2, height: s2 } = t3, { context: a2 } = this, { gl: o2 } = a2, { HTMLImageElement: l3, HTMLCanvasElement: u3, HTMLVideoElement: c2, ImageData: h3, ImageBitmap: p3 } = e;
          if (o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!r3 || r3.premultiply !== false)), n3 || this.size && this.size[0] === i2 && this.size[1] === s2) {
            const { x: e2, y: r4 } = n3 || { x: 0, y: 0 };
            t3 instanceof l3 || t3 instanceof u3 || t3 instanceof c2 || t3 instanceof h3 || p3 && t3 instanceof p3 ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r4, o2.RGBA, o2.UNSIGNED_BYTE, t3) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r4, i2, s2, o2.RGBA, o2.UNSIGNED_BYTE, t3.data);
          } else
            this.size = [i2, s2], t3 instanceof l3 || t3 instanceof u3 || t3 instanceof c2 || t3 instanceof h3 || p3 && t3 instanceof p3 ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t3) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, i2, s2, 0, this.format, o2.UNSIGNED_BYTE, t3.data);
          this.useMipmap = Boolean(r3 && r3.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o2.generateMipmap(o2.TEXTURE_2D);
        }
        bind(t3, e2) {
          const { context: r3 } = this, { gl: n3 } = r3;
          n3.bindTexture(n3.TEXTURE_2D, this.texture), t3 !== this.filter && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MAG_FILTER, t3), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MIN_FILTER, this.useMipmap ? t3 === n3.NEAREST ? n3.NEAREST_MIPMAP_NEAREST : n3.LINEAR_MIPMAP_NEAREST : t3), this.filter = t3), e2 !== this.wrap && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_S, e2), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t3 } = this.context;
          t3.deleteTexture(this.texture), this.texture = null;
        }
      }
      class hd2 {
        constructor(t3, e2) {
          this.width = t3, this.height = e2, this.nextRow = 0, this.image = new hu({ width: t3, height: e2 }), this.positions = {}, this.uploaded = false;
        }
        getDash(t3, e2) {
          const r3 = this.getKey(t3, e2);
          return this.positions[r3];
        }
        trim() {
          const t3 = this.width, e2 = this.height = A2(this.nextRow);
          this.image.resize({ width: t3, height: e2 });
        }
        getKey(t3, e2) {
          return t3.join(",") + e2;
        }
        getDashRanges(t3, e2, r3) {
          const n3 = [];
          let i2 = t3.length % 2 == 1 ? -t3[t3.length - 1] * r3 : 0, s2 = t3[0] * r3, a2 = true;
          n3.push({ left: i2, right: s2, isDash: a2, zeroLength: t3[0] === 0 });
          let o2 = t3[0];
          for (let e3 = 1; e3 < t3.length; e3++) {
            a2 = !a2;
            const l3 = t3[e3];
            i2 = o2 * r3, o2 += l3, s2 = o2 * r3, n3.push({ left: i2, right: s2, isDash: a2, zeroLength: l3 === 0 });
          }
          return n3;
        }
        addRoundDash(t3, e2, r3) {
          const n3 = e2 / 2;
          for (let e3 = -r3; e3 <= r3; e3++) {
            const i2 = this.width * (this.nextRow + r3 + e3);
            let s2 = 0, a2 = t3[s2];
            for (let o2 = 0; o2 < this.width; o2++) {
              o2 / a2.right > 1 && (a2 = t3[++s2]);
              const l3 = Math.abs(o2 - a2.left), u3 = Math.abs(o2 - a2.right), c2 = Math.min(l3, u3);
              let h3;
              const p3 = e3 / r3 * (n3 + 1);
              if (a2.isDash) {
                const t4 = n3 - Math.abs(p3);
                h3 = Math.sqrt(c2 * c2 + t4 * t4);
              } else
                h3 = n3 - Math.sqrt(c2 * c2 + p3 * p3);
              this.image.data[i2 + o2] = Math.max(0, Math.min(255, h3 + 128));
            }
          }
        }
        addRegularDash(t3, e2) {
          for (let e3 = t3.length - 1; e3 >= 0; --e3) {
            const r4 = t3[e3], n4 = t3[e3 + 1];
            r4.zeroLength ? t3.splice(e3, 1) : n4 && n4.isDash === r4.isDash && (n4.left = r4.left, t3.splice(e3, 1));
          }
          const r3 = t3[0], n3 = t3[t3.length - 1];
          r3.isDash === n3.isDash && (r3.left = n3.left - this.width, n3.right = r3.right + this.width);
          const i2 = this.width * this.nextRow;
          let s2 = 0, a2 = t3[s2];
          for (let r4 = 0; r4 < this.width; r4++) {
            r4 / a2.right > 1 && (a2 = t3[++s2]);
            const n4 = Math.abs(r4 - a2.left), o2 = Math.abs(r4 - a2.right), l3 = Math.min(n4, o2);
            this.image.data[i2 + r4] = Math.max(0, Math.min(255, (a2.isDash ? l3 : -l3) + e2 + 128));
          }
        }
        addDash(t3, e2) {
          const r3 = this.getKey(t3, e2);
          if (this.positions[r3])
            return this.positions[r3];
          const n3 = e2 === "round", i2 = n3 ? 7 : 0, s2 = 2 * i2 + 1;
          if (this.nextRow + s2 > this.height)
            return E2("LineAtlas out of space"), null;
          t3.length === 0 && t3.push(1);
          let a2 = 0;
          for (let e3 = 0; e3 < t3.length; e3++)
            t3[e3] < 0 && (E2("Negative value is found in line dasharray, replacing values with 0"), t3[e3] = 0), a2 += t3[e3];
          if (a2 !== 0) {
            const r4 = this.width / a2, s3 = this.getDashRanges(t3, this.width, r4);
            n3 ? this.addRoundDash(s3, r4, i2) : this.addRegularDash(s3, e2 === "square" ? 0.5 * r4 : 0);
          }
          const o2 = this.nextRow + i2;
          this.nextRow += s2;
          const l3 = { tl: [o2, i2], br: [a2, 0] };
          return this.positions[r3] = l3, l3;
        }
      }
      Pi2(hd2, "LineAtlas");
      class pd2 {
        constructor(t3) {
          this._callback = t3, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class fd2 {
        constructor() {
          this.tasks = {}, this.taskQueue = [], k(["process"], this), this.invoker = new pd2(this.process), this.nextId = 0;
        }
        add(t3, e2) {
          const r3 = this.nextId++, n3 = function({ type: t4, isSymbolTile: e3, zoom: r4 }) {
            return r4 = r4 || 0, t4 === "message" ? 0 : t4 !== "maybePrepare" || e3 ? t4 !== "parseTile" || e3 ? t4 === "parseTile" && e3 ? 300 - r4 : t4 === "maybePrepare" && e3 ? 400 - r4 : 500 : 200 - r4 : 100 - r4;
          }(e2);
          if (n3 === 0) {
            D2();
            try {
              t3();
            } finally {
            }
            return { cancel: () => {
            } };
          }
          return this.tasks[r3] = { fn: t3, metadata: e2, priority: n3, id: r3 }, this.taskQueue.push(r3), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[r3];
          } };
        }
        process() {
          D2();
          try {
            if (this.taskQueue = this.taskQueue.filter((t4) => !!this.tasks[t4]), !this.taskQueue.length)
              return;
            const t3 = this.pick();
            if (t3 === null)
              return;
            const e2 = this.tasks[t3];
            if (delete this.tasks[t3], this.taskQueue.length && this.invoker.trigger(), !e2)
              return;
            e2.fn();
          } finally {
          }
        }
        pick() {
          let t3 = null, e2 = 1 / 0;
          for (let r4 = 0; r4 < this.taskQueue.length; r4++) {
            const n3 = this.tasks[this.taskQueue[r4]];
            n3.priority < e2 && (e2 = n3.priority, t3 = r4);
          }
          if (t3 === null)
            return null;
          const r3 = this.taskQueue[t3];
          return this.taskQueue.splice(t3, 1), r3;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class dd2 {
        constructor(t3) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e2 = 0; e2 < t3.length; e2++) {
            const r3 = t3[e2];
            this._stringToNumber[r3] = e2, this._numberToString[e2] = r3;
          }
        }
        encode(t3) {
          return this._stringToNumber[t3];
        }
        decode(t3) {
          return this._numberToString[t3];
        }
      }
      const yd2 = ["tile", "layer", "source", "sourceLayer", "state"];
      class md2 {
        constructor(t3, e2, r3, n3, i2) {
          this.type = "Feature", this._vectorTileFeature = t3, this._z = e2, this._x = r3, this._y = n3, this.properties = t3.properties, this.id = i2;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(t3) {
          this._geometry = t3;
        }
        toJSON() {
          const t3 = { type: "Feature", geometry: this.geometry, properties: this.properties };
          this.id !== void 0 && (t3.id = this.id);
          for (const e2 of yd2)
            this[e2] !== void 0 && (t3[e2] = this[e2]);
          return t3;
        }
      }
      const gd2 = 32, xd2 = 33, vd2 = new Uint16Array(8184);
      for (let t3 = 0; t3 < 2046; t3++) {
        let e2 = t3 + 2, r3 = 0, n3 = 0, i2 = 0, s2 = 0, a2 = 0, o2 = 0;
        for (1 & e2 ? i2 = s2 = a2 = gd2 : r3 = n3 = o2 = gd2; (e2 >>= 1) > 1; ) {
          const t4 = r3 + i2 >> 1, l4 = n3 + s2 >> 1;
          1 & e2 ? (i2 = r3, s2 = n3, r3 = a2, n3 = o2) : (r3 = i2, n3 = s2, i2 = a2, s2 = o2), a2 = t4, o2 = l4;
        }
        const l3 = 4 * t3;
        vd2[l3 + 0] = r3, vd2[l3 + 1] = n3, vd2[l3 + 2] = i2, vd2[l3 + 3] = s2;
      }
      const bd2 = new Uint16Array(2178), _d = new Uint8Array(1089), wd2 = new Uint16Array(1089);
      function Ad2(t3) {
        return t3 === 0 ? -0.03125 : t3 === 32 ? 0.03125 : 0;
      }
      var Sd2 = Ws([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      const kd2 = { type: 2, extent: wo, loadGeometry: () => [[new i(0, 0), new i(8193, 0), new i(8193, 8193), new i(0, 8193), new i(0, 0)]] };
      class Id2 {
        constructor(t3, e2, r3, n3, i2) {
          this.tileID = t3, this.uid = _(), this.uses = 0, this.tileSize = e2, this.tileZoom = r3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i2, this.expiredRequestCount = 0, this.state = "loading", n3 && n3.transform && (this.projection = n3.transform.projection);
        }
        registerFadeDuration(t3) {
          const e2 = t3 + this.timeAdded;
          e2 < X2.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = Af2(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t3, e2, r3) {
          if (this.unloadVectorData(), this.state = "loaded", t3) {
            t3.featureIndex && (this.latestFeatureIndex = t3.featureIndex, t3.rawTileData ? (this.latestRawTileData = t3.rawTileData, this.latestFeatureIndex.rawTileData = t3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t3.collisionBoxArray, this.buckets = function(t4, e3) {
              const r4 = {};
              if (!e3)
                return r4;
              for (const n3 of t4) {
                const t5 = n3.layerIds.map((t6) => e3.getLayer(t6)).filter(Boolean);
                if (t5.length !== 0) {
                  n3.layers = t5, n3.stateDependentLayerIds && (n3.stateDependentLayers = n3.stateDependentLayerIds.map((e4) => t5.filter((t6) => t6.id === e4)[0]));
                  for (const e4 of t5)
                    r4[e4.id] = n3;
                }
              }
              return r4;
            }(t3.buckets, e2.style), this.hasSymbolBuckets = false;
            for (const t4 in this.buckets) {
              const e3 = this.buckets[t4];
              if (e3 instanceof Qf2) {
                if (this.hasSymbolBuckets = true, !r3)
                  break;
                e3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const t4 in this.buckets) {
                const e3 = this.buckets[t4];
                if (e3 instanceof Qf2 && e3.hasRTLText) {
                  this.hasRTLText = true, Es.isLoading() || Es.isLoaded() || Ts() !== "deferred" || Bs();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const t4 in this.buckets) {
              const r4 = this.buckets[t4];
              this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(t4).queryRadius(r4));
            }
            t3.imageAtlas && (this.imageAtlas = t3.imageAtlas), t3.glyphAtlasImage && (this.glyphAtlasImage = t3.glyphAtlasImage), t3.lineAtlas && (this.lineAtlas = t3.lineAtlas);
          } else
            this.collisionBoxArray = new Ma2();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const t3 in this.buckets)
              this.buckets[t3].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        getBucket(t3) {
          return this.buckets[t3.id];
        }
        upload(t3) {
          for (const e3 in this.buckets) {
            const r3 = this.buckets[e3];
            r3.uploadPending() && r3.upload(t3);
          }
          const e2 = t3.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new cd2(t3, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new cd2(t3, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new cd2(t3, this.lineAtlas.image, e2.ALPHA), this.lineAtlas.uploaded = true);
        }
        prepare(t3) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t3, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t3, e2, r3, n3, i2, s2, a2, o2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n3, pixelPosMatrix: a2, transform: s2, params: i2, tileTransform: this.tileTransform }, t3, e2, r3) : {};
        }
        querySourceFeatures(t3, e2) {
          const r3 = this.latestFeatureIndex;
          if (!r3 || !r3.rawTileData)
            return;
          const n3 = r3.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", s2 = n3._geojsonTileLayer || n3[i2];
          if (!s2)
            return;
          const a2 = Jn(e2 && e2.filter), { z: o2, x: l3, y: u3 } = this.tileID.canonical, c2 = { z: o2, x: l3, y: u3 };
          for (let e3 = 0; e3 < s2.length; e3++) {
            const n4 = s2.feature(e3);
            if (a2.needGeometry) {
              const t4 = Go(n4, true);
              if (!a2.filter(new Cs(this.tileID.overscaledZ), t4, this.tileID.canonical))
                continue;
            } else if (!a2.filter(new Cs(this.tileID.overscaledZ), n4))
              continue;
            const h3 = r3.getId(n4, i2), p3 = new md2(n4, o2, l3, u3, h3);
            p3.tile = c2, t3.push(p3);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t3) {
          const e2 = this.expirationTime;
          if (t3.cacheControl) {
            const e3 = V2(t3.cacheControl);
            e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
          } else
            t3.expires && (this.expirationTime = new Date(t3.expires).getTime());
          if (this.expirationTime) {
            const t4 = Date.now();
            let r3 = false;
            if (this.expirationTime > t4)
              r3 = false;
            else if (e2)
              if (this.expirationTime < e2)
                r3 = true;
              else {
                const n3 = this.expirationTime - e2;
                n3 ? this.expirationTime = t4 + Math.max(n3, 3e4) : r3 = true;
              }
            else
              r3 = true;
            r3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t3, e2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t3).length === 0 || !e2)
            return;
          const r3 = this.latestFeatureIndex.loadVTLayers(), n3 = e2.style.listImages();
          for (const i2 in this.buckets) {
            if (!e2.style.hasLayer(i2))
              continue;
            const s2 = this.buckets[i2], a2 = s2.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r3[a2], l3 = t3[a2];
            if (!o2 || !l3 || Object.keys(l3).length === 0)
              continue;
            if (s2.update(l3, o2, n3, this.imageAtlas && this.imageAtlas.patternPositions || {}), s2 instanceof Kc2 || s2 instanceof tc2) {
              const t4 = e2.style._getSourceCache(s2.layers[0].source);
              e2._terrain && e2._terrain.enabled && t4 && s2.programConfigurations.needsUpload && e2._terrain._clearRenderCacheForTile(t4.id, this.tileID);
            }
            const u3 = e2 && e2.style && e2.style.getLayer(i2);
            u3 && (this.queryPadding = Math.max(this.queryPadding, u3.queryRadius(s2)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < X2.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t3) {
          this.symbolFadeHoldUntil = X2.now() + t3;
        }
        setTexture(t3, e2) {
          const r3 = e2.context, n3 = r3.gl;
          this.texture = e2.getTileTexture(t3.width), this.texture ? this.texture.update(t3, { useMipmap: true }) : (this.texture = new cd2(r3, t3, n3.RGBA, { useMipmap: true }), this.texture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), r3.extTextureFilterAnisotropic && n3.texParameterf(n3.TEXTURE_2D, r3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r3.extTextureFilterAnisotropicMax));
        }
        setDependencies(t3, e2) {
          const r3 = {};
          for (const t4 of e2)
            r3[t4] = true;
          this.dependencies[t3] = r3;
        }
        hasDependency(t3, e2) {
          for (const r3 of t3) {
            const t4 = this.dependencies[r3];
            if (t4) {
              for (const r4 of e2)
                if (t4[r4])
                  return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(t3, e2) {
          if (!e2 || e2.name === "mercator" || this._tileDebugBuffer)
            return;
          const r3 = No(kd2, this.tileID.canonical, this.tileTransform)[0], n3 = new Qs(), i2 = new wa2();
          for (let t4 = 0; t4 < r3.length; t4++) {
            const { x: e3, y: s2 } = r3[t4];
            n3.emplaceBack(e3, s2), i2.emplaceBack(t4);
          }
          i2.emplaceBack(0), this._tileDebugIndexBuffer = t3.createIndexBuffer(i2), this._tileDebugBuffer = t3.createVertexBuffer(n3, Zp.members), this._tileDebugSegments = _o.simpleSegment(0, 0, n3.length, i2.length);
        }
        _makeTileBoundsBuffers(t3, e2) {
          if (this._tileBoundsBuffer || !e2 || e2.name === "mercator")
            return;
          const r3 = No(kd2, this.tileID.canonical, this.tileTransform)[0];
          let n3, i2;
          if (this.isRaster) {
            const t4 = function(t5, e3) {
              const r4 = Af2(t5, e3), n4 = Math.pow(2, t5.z);
              for (let i4 = 0; i4 < xd2; i4++)
                for (let s3 = 0; s3 < xd2; s3++) {
                  const a3 = Eo((t5.x + (s3 + Ad2(s3)) / gd2) / n4), o3 = Co((t5.y + (i4 + Ad2(i4)) / gd2) / n4), l4 = e3.project(a3, o3), u3 = i4 * xd2 + s3;
                  bd2[2 * u3 + 0] = Math.round((l4.x * r4.scale - r4.x) * wo), bd2[2 * u3 + 1] = Math.round((l4.y * r4.scale - r4.y) * wo);
                }
              _d.fill(0), wd2.fill(0);
              for (let t6 = 2045; t6 >= 0; t6--) {
                const e4 = 4 * t6, r5 = vd2[e4 + 0], n5 = vd2[e4 + 1], i4 = vd2[e4 + 2], s3 = vd2[e4 + 3], a3 = r5 + i4 >> 1, o3 = n5 + s3 >> 1, l4 = a3 + o3 - n5, u3 = o3 + r5 - a3, c2 = n5 * xd2 + r5, h3 = s3 * xd2 + i4, p3 = o3 * xd2 + a3, f2 = Math.hypot((bd2[2 * c2 + 0] + bd2[2 * h3 + 0]) / 2 - bd2[2 * p3 + 0], (bd2[2 * c2 + 1] + bd2[2 * h3 + 1]) / 2 - bd2[2 * p3 + 1]) >= 16;
                if (_d[p3] = _d[p3] || (f2 ? 1 : 0), t6 < 1022) {
                  const t7 = (n5 + u3 >> 1) * xd2 + (r5 + l4 >> 1), e5 = (s3 + u3 >> 1) * xd2 + (i4 + l4 >> 1);
                  _d[p3] = _d[p3] || _d[t7] || _d[e5];
                }
              }
              const i3 = new ea2(), s2 = new ya2();
              let a2 = 0;
              function o2(t6, e4) {
                const r5 = e4 * xd2 + t6;
                return wd2[r5] === 0 && (i3.emplaceBack(bd2[2 * r5 + 0], bd2[2 * r5 + 1], t6 * wo / gd2, e4 * wo / gd2), wd2[r5] = ++a2), wd2[r5] - 1;
              }
              function l3(t6, e4, r5, n5, i4, a3) {
                const u3 = t6 + r5 >> 1, c2 = e4 + n5 >> 1;
                if (Math.abs(t6 - i4) + Math.abs(e4 - a3) > 1 && _d[c2 * xd2 + u3])
                  l3(i4, a3, t6, e4, u3, c2), l3(r5, n5, i4, a3, u3, c2);
                else {
                  const l4 = o2(t6, e4), u4 = o2(r5, n5), c3 = o2(i4, a3);
                  s2.emplaceBack(l4, u4, c3);
                }
              }
              return l3(0, 0, gd2, gd2, gd2, 0), l3(gd2, gd2, 0, 0, 0, gd2), { vertices: i3, indices: s2 };
            }(this.tileID.canonical, e2);
            n3 = t4.vertices, i2 = t4.indices;
          } else {
            n3 = new ea2(), i2 = new ya2();
            for (const { x: t5, y: e3 } of r3)
              n3.emplaceBack(t5, e3, 0, 0);
            const t4 = xu(n3.int16, void 0, 4);
            for (let e3 = 0; e3 < t4.length; e3 += 3)
              i2.emplaceBack(t4[e3], t4[e3 + 1], t4[e3 + 2]);
          }
          this._tileBoundsBuffer = t3.createVertexBuffer(n3, Sd2.members), this._tileBoundsIndexBuffer = t3.createIndexBuffer(i2), this._tileBoundsSegments = _o.simpleSegment(0, 0, n3.length, i2.length);
        }
        _makeGlobeTileDebugBuffers(t3, e2) {
          const r3 = e2.projection;
          if (!r3 || r3.name !== "globe" || e2.freezeTileCoverage)
            return;
          const n3 = this.tileID.canonical, i2 = df2(nf2(n3, e2)), s2 = gf2(e2.zoom);
          let a2;
          s2 > 0 && (a2 = gl(new Float64Array(16), e2.globeMatrix));
          const o2 = (n3.x + 0.5) / (1 << n3.z) - zo(e2.center.lng);
          let l3 = 0;
          o2 > 0.5 ? l3 = -1 : o2 < -0.5 && (l3 = 1), this._makeGlobeTileDebugBorderBuffer(t3, n3, e2, i2, a2, s2, l3), this._makeGlobeTileDebugTextBuffer(t3, n3, e2, i2, a2, s2, l3);
        }
        _globePoint(t3, e2, r3, n3, i2, s2, a2, o2) {
          let l3 = hf2(t3, e2, r3);
          if (s2) {
            const i3 = 1 << r3.z, u3 = [((t3 / wo + r3.x) / i3 + o2) * n3, (e2 / wo + r3.y) / i3 * n3, 0];
            jl(u3, u3, s2), l3 = vr(l3, u3, a2);
          }
          return jl(l3, l3, i2);
        }
        _makeGlobeTileDebugBorderBuffer(t3, e2, r3, n3, i2, s2, a2) {
          const o2 = new Qs(), l3 = new wa2(), u3 = new ta2(), c2 = (t4, c3, h4, p3, f2) => {
            const d2 = (h4 - t4) / (f2 - 1), y3 = (p3 - c3) / (f2 - 1), m3 = o2.length;
            for (let h5 = 0; h5 < f2; h5++) {
              const p4 = t4 + h5 * d2, f3 = c3 + h5 * y3;
              o2.emplaceBack(p4, f3);
              const g2 = this._globePoint(p4, f3, e2, r3.worldSize, n3, i2, s2, a2);
              u3.emplaceBack(g2[0], g2[1], g2[2]), l3.emplaceBack(m3 + h5);
            }
          }, h3 = wo;
          c2(0, 0, h3, 0, 16), c2(h3, 0, h3, h3, 16), c2(h3, h3, 0, h3, 16), c2(0, h3, 0, 0, 16), this._tileDebugIndexBuffer = t3.createIndexBuffer(l3), this._tileDebugBuffer = t3.createVertexBuffer(o2, Zp.members), this._globeTileDebugBorderBuffer = t3.createVertexBuffer(u3, Gp.members), this._tileDebugSegments = _o.simpleSegment(0, 0, o2.length, l3.length);
        }
        _makeGlobeTileDebugTextBuffer(t3, e2, r3, n3, i2, s2, a2) {
          const o2 = new Qs(), l3 = new ya2(), u3 = new ta2(), c2 = 25;
          l3.reserve(32), o2.reserve(c2), u3.reserve(c2);
          const h3 = (t4, e3) => c2 * t4 + e3;
          for (let t4 = 0; t4 < c2; t4++) {
            const l4 = 2048 * t4;
            for (let t5 = 0; t5 < c2; t5++) {
              const c3 = 2048 * t5;
              o2.emplaceBack(c3, l4);
              const h4 = this._globePoint(c3, l4, e2, r3.worldSize, n3, i2, s2, a2);
              u3.emplaceBack(h4[0], h4[1], h4[2]);
            }
          }
          for (let t4 = 0; t4 < 4; t4++)
            for (let e3 = 0; e3 < 4; e3++) {
              const r4 = h3(t4, e3), n4 = h3(t4, e3 + 1), i3 = h3(t4 + 1, e3), s3 = h3(t4 + 1, e3 + 1);
              l3.emplaceBack(r4, n4, i3), l3.emplaceBack(i3, n4, s3);
            }
          this._tileDebugTextIndexBuffer = t3.createIndexBuffer(l3), this._tileDebugTextBuffer = t3.createVertexBuffer(o2, Zp.members), this._globeTileDebugTextBuffer = t3.createVertexBuffer(u3, Gp.members), this._tileDebugTextSegments = _o.simpleSegment(0, 0, c2, 32);
        }
      }
      class Md2 {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t3, e2, r3) {
          const n3 = String(e2);
          if (this.stateChanges[t3] = this.stateChanges[t3] || {}, this.stateChanges[t3][n3] = this.stateChanges[t3][n3] || {}, v2(this.stateChanges[t3][n3], r3), this.deletedStates[t3] === null) {
            this.deletedStates[t3] = {};
            for (const e3 in this.state[t3])
              e3 !== n3 && (this.deletedStates[t3][e3] = null);
          } else if (this.deletedStates[t3] && this.deletedStates[t3][n3] === null) {
            this.deletedStates[t3][n3] = {};
            for (const e3 in this.state[t3][n3])
              r3[e3] || (this.deletedStates[t3][n3][e3] = null);
          } else
            for (const e3 in r3)
              this.deletedStates[t3] && this.deletedStates[t3][n3] && this.deletedStates[t3][n3][e3] === null && delete this.deletedStates[t3][n3][e3];
        }
        removeFeatureState(t3, e2, r3) {
          if (this.deletedStates[t3] === null)
            return;
          const n3 = String(e2);
          if (this.deletedStates[t3] = this.deletedStates[t3] || {}, r3 && e2 !== void 0)
            this.deletedStates[t3][n3] !== null && (this.deletedStates[t3][n3] = this.deletedStates[t3][n3] || {}, this.deletedStates[t3][n3][r3] = null);
          else if (e2 !== void 0)
            if (this.stateChanges[t3] && this.stateChanges[t3][n3])
              for (r3 in this.deletedStates[t3][n3] = {}, this.stateChanges[t3][n3])
                this.deletedStates[t3][n3][r3] = null;
            else
              this.deletedStates[t3][n3] = null;
          else
            this.deletedStates[t3] = null;
        }
        getState(t3, e2) {
          const r3 = String(e2), n3 = v2({}, (this.state[t3] || {})[r3], (this.stateChanges[t3] || {})[r3]);
          if (this.deletedStates[t3] === null)
            return {};
          if (this.deletedStates[t3]) {
            const r4 = this.deletedStates[t3][e2];
            if (r4 === null)
              return {};
            for (const t4 in r4)
              delete n3[t4];
          }
          return n3;
        }
        initializeTileState(t3, e2) {
          t3.setFeatureState(this.state, e2);
        }
        coalesceChanges(t3, e2) {
          const r3 = {};
          for (const t4 in this.stateChanges) {
            this.state[t4] = this.state[t4] || {};
            const e3 = {};
            for (const r4 in this.stateChanges[t4])
              this.state[t4][r4] || (this.state[t4][r4] = {}), v2(this.state[t4][r4], this.stateChanges[t4][r4]), e3[r4] = this.state[t4][r4];
            r3[t4] = e3;
          }
          for (const t4 in this.deletedStates) {
            this.state[t4] = this.state[t4] || {};
            const e3 = {};
            if (this.deletedStates[t4] === null)
              for (const r4 in this.state[t4])
                e3[r4] = {}, this.state[t4][r4] = {};
            else
              for (const r4 in this.deletedStates[t4]) {
                if (this.deletedStates[t4][r4] === null)
                  this.state[t4][r4] = {};
                else
                  for (const e4 of Object.keys(this.deletedStates[t4][r4]))
                    delete this.state[t4][r4][e4];
                e3[r4] = this.state[t4][r4];
              }
            r3[t4] = r3[t4] || {}, v2(r3[t4], e3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(r3).length !== 0)
            for (const n3 in t3)
              t3[n3].setFeatureState(r3, e2);
        }
      }
      class zd2 {
        constructor(t3) {
          this.size = t3, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(t3, e2) {
          const r3 = this.toIdx(t3, e2);
          return { min: this.minimums[r3], max: this.maximums[r3] };
        }
        isLeaf(t3, e2) {
          return this.leaves[this.toIdx(t3, e2)];
        }
        toIdx(t3, e2) {
          return e2 * this.size + t3;
        }
      }
      function Td2(t3, e2, r3, n3) {
        let i2 = 0, s2 = Number.MAX_VALUE;
        for (let a2 = 0; a2 < 3; a2++)
          if (Math.abs(n3[a2]) < 1e-15) {
            if (r3[a2] < t3[a2] || r3[a2] > e2[a2])
              return null;
          } else {
            const o2 = 1 / n3[a2];
            let l3 = (t3[a2] - r3[a2]) * o2, u3 = (e2[a2] - r3[a2]) * o2;
            if (l3 > u3) {
              const t4 = l3;
              l3 = u3, u3 = t4;
            }
            if (l3 > i2 && (i2 = l3), u3 < s2 && (s2 = u3), i2 > s2)
              return null;
          }
        return i2;
      }
      function Bd2(t3, e2, r3, n3, i2, s2, a2, o2, l3, u3, c2) {
        const h3 = n3 - t3, p3 = i2 - e2, f2 = s2 - r3, d2 = a2 - t3, y3 = o2 - e2, m3 = l3 - r3, g2 = c2[1] * m3 - c2[2] * y3, x3 = c2[2] * d2 - c2[0] * m3, v3 = c2[0] * y3 - c2[1] * d2, b2 = h3 * g2 + p3 * x3 + f2 * v3;
        if (Math.abs(b2) < 1e-15)
          return null;
        const _2 = 1 / b2, w2 = u3[0] - t3, A3 = u3[1] - e2, S3 = u3[2] - r3, k2 = (w2 * g2 + A3 * x3 + S3 * v3) * _2;
        if (k2 < 0 || k2 > 1)
          return null;
        const I3 = A3 * f2 - S3 * p3, M3 = S3 * h3 - w2 * f2, z3 = w2 * p3 - A3 * h3, T3 = (c2[0] * I3 + c2[1] * M3 + c2[2] * z3) * _2;
        return T3 < 0 || k2 + T3 > 1 ? null : (d2 * I3 + y3 * M3 + m3 * z3) * _2;
      }
      function Ed2(t3, e2, r3) {
        return (t3 - e2) / (r3 - e2);
      }
      function Cd2(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
        const u3 = 1 << r3, c2 = s2 - n3, h3 = a2 - i2, p3 = (t3 + 1) / u3 * c2 + n3, f2 = (e2 + 0) / u3 * h3 + i2, d2 = (e2 + 1) / u3 * h3 + i2;
        o2[0] = (t3 + 0) / u3 * c2 + n3, o2[1] = f2, l3[0] = p3, l3[1] = d2;
      }
      class Pd2 {
        constructor(t3) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t3, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const e2 = function(t4) {
            const e3 = Math.ceil(Math.log2(t4.dim / 8)), r4 = [];
            let n4 = Math.ceil(Math.pow(2, e3));
            const i2 = 1 / n4, s2 = (t5, e4, r5, n5, i3) => {
              const s3 = n5 ? 1 : 0, a3 = (t5 + 1) * r5 - s3, o3 = e4 * r5, l3 = (e4 + 1) * r5 - s3;
              i3[0] = t5 * r5, i3[1] = o3, i3[2] = a3, i3[3] = l3;
            };
            let a2 = new zd2(n4);
            const o2 = [];
            for (let e4 = 0; e4 < n4 * n4; e4++) {
              s2(e4 % n4, Math.floor(e4 / n4), i2, false, o2);
              const r5 = Vd2(o2[0], o2[1], t4), l3 = Vd2(o2[2], o2[1], t4), u3 = Vd2(o2[2], o2[3], t4), c2 = Vd2(o2[0], o2[3], t4);
              a2.minimums.push(Math.min(r5, l3, u3, c2)), a2.maximums.push(Math.max(r5, l3, u3, c2)), a2.leaves.push(1);
            }
            for (r4.push(a2), n4 /= 2; n4 >= 1; n4 /= 2) {
              const t5 = r4[r4.length - 1];
              a2 = new zd2(n4);
              for (let e4 = 0; e4 < n4 * n4; e4++) {
                s2(e4 % n4, Math.floor(e4 / n4), 2, true, o2);
                const r5 = t5.getElevation(o2[0], o2[1]), i3 = t5.getElevation(o2[2], o2[1]), l3 = t5.getElevation(o2[2], o2[3]), u3 = t5.getElevation(o2[0], o2[3]), c2 = t5.isLeaf(o2[0], o2[1]), h3 = t5.isLeaf(o2[2], o2[1]), p3 = t5.isLeaf(o2[2], o2[3]), f2 = t5.isLeaf(o2[0], o2[3]), d2 = Math.min(r5.min, i3.min, l3.min, u3.min), y3 = Math.max(r5.max, i3.max, l3.max, u3.max), m3 = c2 && h3 && p3 && f2;
                a2.maximums.push(y3), a2.minimums.push(d2), a2.leaves.push(y3 - d2 <= 5 && m3 ? 1 : 0);
              }
              r4.push(a2);
            }
            return r4;
          }(this.dem), r3 = e2.length - 1, n3 = e2[r3];
          this._addNode(n3.minimums[0], n3.maximums[0], n3.leaves[0]), this._construct(e2, 0, 0, r3, 0);
        }
        raycastRoot(t3, e2, r3, n3, i2, s2, a2 = 1) {
          return Td2([t3, e2, -100], [r3, n3, this.maximums[0] * a2], i2, s2);
        }
        raycast(t3, e2, r3, n3, i2, s2, a2 = 1) {
          if (!this.nodeCount)
            return null;
          const o2 = this.raycastRoot(t3, e2, r3, n3, i2, s2, a2);
          if (o2 == null)
            return null;
          const l3 = [], u3 = [], c2 = [], h3 = [], p3 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
          for (; p3.length > 0; ) {
            const { idx: o3, t: f2, nodex: d2, nodey: y3, depth: m3 } = p3.pop();
            if (this.leaves[o3]) {
              Cd2(d2, y3, m3, t3, e2, r3, n3, c2, h3);
              const o4 = 1 << m3, l4 = (d2 + 0) / o4, u4 = (d2 + 1) / o4, p4 = (y3 + 0) / o4, g3 = (y3 + 1) / o4, x3 = Vd2(l4, p4, this.dem) * a2, v3 = Vd2(u4, p4, this.dem) * a2, b2 = Vd2(u4, g3, this.dem) * a2, _2 = Vd2(l4, g3, this.dem) * a2, w2 = Bd2(c2[0], c2[1], x3, h3[0], c2[1], v3, h3[0], h3[1], b2, i2, s2), A3 = Bd2(h3[0], h3[1], b2, c2[0], h3[1], _2, c2[0], c2[1], x3, i2, s2), S3 = Math.min(w2 !== null ? w2 : Number.MAX_VALUE, A3 !== null ? A3 : Number.MAX_VALUE);
              if (S3 !== Number.MAX_VALUE)
                return S3;
              {
                const t4 = Fl([], i2, s2, f2);
                if (Dd2(x3, v3, _2, b2, Ed2(t4[0], c2[0], h3[0]), Ed2(t4[1], c2[1], h3[1])) >= t4[2])
                  return f2;
              }
              continue;
            }
            let g2 = 0;
            for (let p4 = 0; p4 < this._siblingOffset.length; p4++) {
              Cd2((d2 << 1) + this._siblingOffset[p4][0], (y3 << 1) + this._siblingOffset[p4][1], m3 + 1, t3, e2, r3, n3, c2, h3), c2[2] = -100, h3[2] = this.maximums[this.childOffsets[o3] + p4] * a2;
              const f3 = Td2(c2, h3, i2, s2);
              if (f3 != null) {
                const t4 = f3;
                l3[p4] = t4;
                let e3 = false;
                for (let r4 = 0; r4 < g2 && !e3; r4++)
                  t4 >= l3[u3[r4]] && (u3.splice(r4, 0, p4), e3 = true);
                e3 || (u3[g2] = p4), g2++;
              }
            }
            for (let t4 = 0; t4 < g2; t4++) {
              const e3 = u3[t4];
              p3.push({ idx: this.childOffsets[o3] + e3, t: l3[e3], nodex: (d2 << 1) + this._siblingOffset[e3][0], nodey: (y3 << 1) + this._siblingOffset[e3][1], depth: m3 + 1 });
            }
          }
          return null;
        }
        _addNode(t3, e2, r3) {
          return this.minimums.push(t3), this.maximums.push(e2), this.leaves.push(r3), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(t3, e2, r3, n3, i2) {
          if (t3[n3].isLeaf(e2, r3) === 1)
            return;
          this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
          const s2 = n3 - 1, a2 = t3[s2];
          let o2 = 0, l3 = 0;
          for (let t4 = 0; t4 < this._siblingOffset.length; t4++) {
            const n4 = 2 * e2 + this._siblingOffset[t4][0], i3 = 2 * r3 + this._siblingOffset[t4][1], s3 = a2.getElevation(n4, i3), u3 = a2.isLeaf(n4, i3), c2 = this._addNode(s3.min, s3.max, u3);
            u3 && (o2 |= 1 << t4), l3 || (l3 = c2);
          }
          for (let n4 = 0; n4 < this._siblingOffset.length; n4++)
            o2 & 1 << n4 || this._construct(t3, 2 * e2 + this._siblingOffset[n4][0], 2 * r3 + this._siblingOffset[n4][1], s2, l3 + n4);
        }
      }
      function Dd2(t3, e2, r3, n3, i2, s2) {
        return xr(xr(t3, r3, s2), xr(e2, n3, s2), i2);
      }
      function Vd2(t3, e2, r3) {
        const n3 = r3.dim, i2 = d(t3 * n3 - 0.5, 0, n3 - 1), s2 = d(e2 * n3 - 0.5, 0, n3 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l3 = Math.min(a2 + 1, n3 - 1), u3 = Math.min(o2 + 1, n3 - 1);
        return Dd2(r3.get(a2, o2), r3.get(l3, o2), r3.get(a2, u3), r3.get(l3, u3), i2 - a2, s2 - o2);
      }
      const Fd2 = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      class Ld2 {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(t3, e2, r3, n3 = false, i2 = false) {
          if (this.uid = t3, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r3 && r3 !== "mapbox" && r3 !== "terrarium")
            return E2(`"${r3}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = e2.height;
          const s2 = this.dim = e2.height - 2, a2 = new Uint32Array(e2.data.buffer);
          if (this.pixels = new Uint8Array(e2.data.buffer), this.encoding = r3 || "mapbox", this.borderReady = n3, !n3) {
            for (let t4 = 0; t4 < s2; t4++)
              a2[this._idx(-1, t4)] = a2[this._idx(0, t4)], a2[this._idx(s2, t4)] = a2[this._idx(s2 - 1, t4)], a2[this._idx(t4, -1)] = a2[this._idx(t4, 0)], a2[this._idx(t4, s2)] = a2[this._idx(t4, s2 - 1)];
            a2[this._idx(-1, -1)] = a2[this._idx(0, 0)], a2[this._idx(s2, -1)] = a2[this._idx(s2 - 1, 0)], a2[this._idx(-1, s2)] = a2[this._idx(0, s2 - 1)], a2[this._idx(s2, s2)] = a2[this._idx(s2 - 1, s2 - 1)], i2 && this._buildQuadTree();
          }
        }
        _buildQuadTree() {
          this._tree = new Pd2(this);
        }
        get(t3, e2, r3 = false) {
          r3 && (t3 = d(t3, -1, this.dim), e2 = d(e2, -1, this.dim));
          const n3 = 4 * this._idx(t3, e2);
          return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n3], this.pixels[n3 + 1], this.pixels[n3 + 2]);
        }
        static getUnpackVector(t3) {
          return Fd2[t3];
        }
        get unpackVector() {
          return Fd2[this.encoding];
        }
        _idx(t3, e2) {
          if (t3 < -1 || t3 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t3 + 1);
        }
        _unpackMapbox(t3, e2, r3) {
          return (256 * t3 * 256 + 256 * e2 + r3) / 10 - 1e4;
        }
        _unpackTerrarium(t3, e2, r3) {
          return 256 * t3 + e2 + r3 / 256 - 32768;
        }
        static pack(t3, e2) {
          const r3 = [0, 0, 0, 0], n3 = Ld2.getUnpackVector(e2);
          let i2 = Math.floor((t3 + n3[3]) / n3[2]);
          return r3[2] = i2 % 256, i2 = Math.floor(i2 / 256), r3[1] = i2 % 256, i2 = Math.floor(i2 / 256), r3[0] = i2, r3;
        }
        getPixels() {
          return new pu({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(t3, e2, r3) {
          if (this.dim !== t3.dim)
            throw new Error("dem dimension mismatch");
          let n3 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r3 * this.dim, a2 = r3 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n3 = i2 - 1;
              break;
            case 1:
              i2 = n3 + 1;
          }
          switch (r3) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e2 * this.dim, l3 = -r3 * this.dim;
          for (let e3 = s2; e3 < a2; e3++)
            for (let r4 = n3; r4 < i2; r4++) {
              const n4 = 4 * this._idx(r4, e3), i3 = 4 * this._idx(r4 + o2, e3 + l3);
              this.pixels[n4 + 0] = t3.pixels[i3 + 0], this.pixels[n4 + 1] = t3.pixels[i3 + 1], this.pixels[n4 + 2] = t3.pixels[i3 + 2], this.pixels[n4 + 3] = t3.pixels[i3 + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      Pi2(Ld2, "DEMData"), Pi2(Pd2, "DemMinMaxQuadTree", { omit: ["dem"] });
      class Rd2 {
        constructor(t3, e2) {
          this.max = t3, this.onRemove = e2, this.reset();
        }
        reset() {
          for (const t3 in this.data)
            for (const e2 of this.data[t3])
              e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
          return this.data = {}, this.order = [], this;
        }
        add(t3, e2, r3) {
          const n3 = t3.wrapped().key;
          this.data[n3] === void 0 && (this.data[n3] = []);
          const i2 = { value: e2, timeout: void 0 };
          if (r3 !== void 0 && (i2.timeout = setTimeout(() => {
            this.remove(t3, i2);
          }, r3)), this.data[n3].push(i2), this.order.push(n3), this.order.length > this.max) {
            const t4 = this._getAndRemoveByKey(this.order[0]);
            t4 && this.onRemove(t4);
          }
          return this;
        }
        has(t3) {
          return t3.wrapped().key in this.data;
        }
        getAndRemove(t3) {
          return this.has(t3) ? this._getAndRemoveByKey(t3.wrapped().key) : null;
        }
        _getAndRemoveByKey(t3) {
          const e2 = this.data[t3].shift();
          return e2.timeout && clearTimeout(e2.timeout), this.data[t3].length === 0 && delete this.data[t3], this.order.splice(this.order.indexOf(t3), 1), e2.value;
        }
        getByKey(t3) {
          const e2 = this.data[t3];
          return e2 ? e2[0].value : null;
        }
        get(t3) {
          return this.has(t3) ? this.data[t3.wrapped().key][0].value : null;
        }
        remove(t3, e2) {
          if (!this.has(t3))
            return this;
          const r3 = t3.wrapped().key, n3 = e2 === void 0 ? 0 : this.data[r3].indexOf(e2), i2 = this.data[r3][n3];
          return this.data[r3].splice(n3, 1), i2.timeout && clearTimeout(i2.timeout), this.data[r3].length === 0 && delete this.data[r3], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r3), 1), this;
        }
        setMaxSize(t3) {
          for (this.max = t3; this.order.length > this.max; ) {
            const t4 = this._getAndRemoveByKey(this.order[0]);
            t4 && this.onRemove(t4);
          }
          return this;
        }
        filter(t3) {
          const e2 = [];
          for (const r3 in this.data)
            for (const n3 of this.data[r3])
              t3(n3.value) || e2.push(n3);
          for (const t4 of e2)
            this.remove(t4.value.tileID, t4);
        }
      }
      class Ud2 {
        constructor(t3, e2, r3) {
          this.func = t3, this.mask = e2, this.range = r3;
        }
      }
      Ud2.ReadOnly = false, Ud2.ReadWrite = true, Ud2.disabled = new Ud2(519, Ud2.ReadOnly, [0, 1]);
      const jd2 = 7680;
      class $d2 {
        constructor(t3, e2, r3, n3, i2, s2) {
          this.test = t3, this.ref = e2, this.mask = r3, this.fail = n3, this.depthFail = i2, this.pass = s2;
        }
      }
      $d2.disabled = new $d2({ func: 519, mask: 0 }, 0, 0, jd2, jd2, jd2);
      class Od2 {
        constructor(t3, e2, r3) {
          this.blendFunction = t3, this.blendColor = e2, this.mask = r3;
        }
      }
      Od2.Replace = [1, 0], Od2.disabled = new Od2(Od2.Replace, xe.transparent, [false, false, false, false]), Od2.unblended = new Od2(Od2.Replace, xe.transparent, [true, true, true, true]), Od2.alphaBlended = new Od2([1, 771], xe.transparent, [true, true, true, true]);
      const qd2 = 1029, Nd2 = 2305;
      class Gd2 {
        constructor(t3, e2, r3) {
          this.enable = t3, this.mode = e2, this.frontFace = r3;
        }
      }
      Gd2.disabled = new Gd2(false, qd2, Nd2), Gd2.backCCW = new Gd2(true, qd2, Nd2), Gd2.backCW = new Gd2(true, qd2, 2304), Gd2.frontCW = new Gd2(true, 1028, 2304), Gd2.frontCCW = new Gd2(true, 1028, Nd2);
      class Zd2 extends Nt {
        constructor(t3, e2, r3) {
          super(), this.id = t3, this._onlySymbols = r3, e2.on("data", (t4) => {
            t4.dataType === "source" && t4.sourceDataType === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && t4.dataType === "source" && t4.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
          }), e2.on("error", () => {
            this._sourceErrored = true;
          }), this._source = e2, this._tiles = {}, this._cache = new Rd2(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e2.minTileCacheSize, this._maxTileCacheSize = e2.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Md2(), this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "custom" && this._source._dataType === "raster";
        }
        onAdd(t3) {
          this.map = t3, this._minTileCacheSize = this._minTileCacheSize === void 0 && t3 ? t3._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t3 ? t3._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (const t3 in this._tiles) {
            const e2 = this._tiles[t3];
            if (e2.state !== "loaded" && e2.state !== "errored")
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const t3 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, t3 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(t3, e2) {
          return t3.isSymbolTile = this._onlySymbols, this._source.loadTile(t3, e2);
        }
        _unloadTile(t3) {
          if (this._source.unloadTile)
            return this._source.unloadTile(t3, () => {
            });
        }
        _abortTile(t3) {
          if (this._source.abortTile)
            return this._source.abortTile(t3, () => {
            });
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t3) {
          if (this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._source.prepareTile)
            for (const e2 in this._tiles) {
              const r3 = this._tiles[e2];
              this._source.prepareTile(r3) && this.map.painter.terrain && this.map.painter.terrain._clearRenderCacheForTile(this.id, r3.tileID), r3.upload(t3), r3.prepare(this.map.style.imageManager);
            }
          else
            for (const e2 in this._tiles) {
              const r3 = this._tiles[e2];
              r3.upload(t3), r3.prepare(this.map.style.imageManager);
            }
        }
        getIds() {
          return x2(this._tiles).map((t3) => t3.tileID).sort(Xd2).map((t3) => t3.key);
        }
        getRenderableIds(t3) {
          const e2 = [];
          for (const r3 in this._tiles)
            this._isIdRenderable(+r3, t3) && e2.push(this._tiles[r3]);
          return t3 ? e2.sort((t4, e3) => {
            const r3 = t4.tileID, n3 = e3.tileID, s2 = new i(r3.canonical.x, r3.canonical.y)._rotate(this.transform.angle), a2 = new i(n3.canonical.x, n3.canonical.y)._rotate(this.transform.angle);
            return r3.overscaledZ - n3.overscaledZ || a2.y - s2.y || a2.x - s2.x;
          }).map((t4) => t4.tileID.key) : e2.map((t4) => t4.tileID).sort(Xd2).map((t4) => t4.key);
        }
        hasRenderableParent(t3) {
          const e2 = this.findLoadedParent(t3, 0);
          return !!e2 && this._isIdRenderable(e2.tileID.key);
        }
        _isIdRenderable(t3, e2) {
          return this._tiles[t3] && this._tiles[t3].hasData() && !this._coveredTiles[t3] && (e2 || !this._tiles[t3].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t3 in this._tiles)
              this._tiles[t3].state !== "errored" && this._reloadTile(+t3, "reloading");
          }
        }
        _reloadTile(t3, e2) {
          const r3 = this._tiles[t3];
          r3 && (r3.state !== "loading" && (r3.state = e2), this._loadTile(r3, this._tileLoaded.bind(this, r3, t3, e2)));
        }
        _tileLoaded(t3, e2, r3, n3) {
          if (n3)
            if (t3.state = "errored", n3.status !== 404)
              this._source.fire(new qt(n3, { tile: t3 }));
            else if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
              const t4 = this.map.painter.terrain;
              this.update(this.transform, t4.getScaledDemTileSize(), true), t4.resetTileLookupCache(this.id);
            } else
              this.update(this.transform);
          else
            t3.timeAdded = X2.now(), r3 === "expired" && (t3.refreshedUponExpiration = true), this._setTileReloadTimer(e2, t3), this._source.type === "raster-dem" && t3.dem && this._backfillDEM(t3), this._state.initializeTileState(t3, this.map ? this.map.painter : null), this._source.fire(new Ot("data", { dataType: "source", tile: t3, coord: t3.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(t3) {
          const e2 = this.getRenderableIds();
          for (let n3 = 0; n3 < e2.length; n3++) {
            const i2 = e2[n3];
            if (t3.neighboringTiles && t3.neighboringTiles[i2]) {
              const e3 = this.getTileByID(i2);
              r3(t3, e3), r3(e3, t3);
            }
          }
          function r3(t4, e3) {
            if (!t4.dem || t4.dem.borderReady)
              return;
            t4.needsHillshadePrepare = true, t4.needsDEMTextureUpload = true;
            let r4 = e3.tileID.canonical.x - t4.tileID.canonical.x;
            const n3 = e3.tileID.canonical.y - t4.tileID.canonical.y, i2 = Math.pow(2, t4.tileID.canonical.z), s2 = e3.tileID.key;
            r4 === 0 && n3 === 0 || Math.abs(n3) > 1 || (Math.abs(r4) > 1 && (Math.abs(r4 + i2) === 1 ? r4 += i2 : Math.abs(r4 - i2) === 1 && (r4 -= i2)), e3.dem && t4.dem && (t4.dem.backfillBorder(e3.dem, r4, n3), t4.neighboringTiles && t4.neighboringTiles[s2] && (t4.neighboringTiles[s2].backfilled = true)));
          }
        }
        getTile(t3) {
          return this.getTileByID(t3.key);
        }
        getTileByID(t3) {
          return this._tiles[t3];
        }
        _retainLoadedChildren(t3, e2, r3, n3) {
          for (const i2 in this._tiles) {
            let s2 = this._tiles[i2];
            if (n3[i2] || !s2.hasData() || s2.tileID.overscaledZ <= e2 || s2.tileID.overscaledZ > r3)
              continue;
            let a2 = s2.tileID;
            for (; s2 && s2.tileID.overscaledZ > e2 + 1; ) {
              const t4 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
              s2 = this._tiles[t4.key], s2 && s2.hasData() && (a2 = t4);
            }
            let o2 = a2;
            for (; o2.overscaledZ > e2; )
              if (o2 = o2.scaledTo(o2.overscaledZ - 1), t3[o2.key]) {
                n3[a2.key] = a2;
                break;
              }
          }
        }
        findLoadedParent(t3, e2) {
          if (t3.key in this._loadedParentTiles) {
            const r3 = this._loadedParentTiles[t3.key];
            return r3 && r3.tileID.overscaledZ >= e2 ? r3 : null;
          }
          for (let r3 = t3.overscaledZ - 1; r3 >= e2; r3--) {
            const e3 = t3.scaledTo(r3), n3 = this._getLoadedTile(e3);
            if (n3)
              return n3;
          }
        }
        _getLoadedTile(t3) {
          const e2 = this._tiles[t3.key];
          return e2 && e2.hasData() ? e2 : this._cache.getByKey(this._source.reparseOverscaled ? t3.wrapped().key : t3.canonical.key);
        }
        updateCacheSize(t3, e2) {
          e2 = e2 || this._source.tileSize;
          const r3 = Math.ceil(t3.width / e2) + 1, n3 = Math.ceil(t3.height / e2) + 1, i2 = Math.floor(r3 * n3 * 5), s2 = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, i2) : i2, a2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, s2) : s2;
          this._cache.setMaxSize(a2);
        }
        handleWrapJump(t3) {
          const e2 = Math.round((t3 - (this._prevLng === void 0 ? t3 : this._prevLng)) / 360);
          if (this._prevLng = t3, e2) {
            const t4 = {};
            for (const r3 in this._tiles) {
              const n3 = this._tiles[r3];
              n3.tileID = n3.tileID.unwrapTo(n3.tileID.wrap + e2), t4[n3.tileID.key] = n3;
            }
            this._tiles = t4;
            for (const t5 in this._timers)
              clearTimeout(this._timers[t5]), delete this._timers[t5];
            for (const t5 in this._tiles)
              this._setTileReloadTimer(+t5, this._tiles[t5]);
          }
        }
        update(t3, e2, r3) {
          if (this.transform = t3, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
            return;
          if (this.usedForTerrain && !r3)
            return;
          let n3;
          this.updateCacheSize(t3, e2), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n3 = t3.getVisibleUnwrappedCoordinates(this._source.tileID).map((t4) => new Fc2(t4.canonical.z, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y)) : (n3 = t3.coveringTiles({ tileSize: e2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n3 = n3.filter((t4) => this._source.hasTile(t4)))) : n3 = [];
          const i2 = this._updateRetainedTiles(n3);
          if (Kd2(this._source.type) && n3.length !== 0) {
            const t4 = {}, e3 = {}, r4 = Object.keys(i2);
            for (const n4 of r4) {
              const r5 = i2[n4], s4 = this._tiles[n4];
              if (!s4 || s4.fadeEndTime && s4.fadeEndTime <= X2.now())
                continue;
              const a2 = this.findLoadedParent(r5, Math.max(r5.overscaledZ - Zd2.maxOverzooming, this._source.minzoom));
              a2 && (this._addTile(a2.tileID), t4[a2.tileID.key] = a2.tileID), e3[n4] = r5;
            }
            const s3 = n3[n3.length - 1].overscaledZ;
            for (const t5 in this._tiles) {
              const r5 = this._tiles[t5];
              if (i2[t5] || !r5.hasData())
                continue;
              let n4 = r5.tileID;
              for (; n4.overscaledZ > s3; ) {
                n4 = n4.scaledTo(n4.overscaledZ - 1);
                const s4 = this._tiles[n4.key];
                if (s4 && s4.hasData() && e3[n4.key]) {
                  i2[t5] = r5.tileID;
                  break;
                }
              }
            }
            for (const e4 in t4)
              i2[e4] || (this._coveredTiles[e4] = true, i2[e4] = t4[e4]);
          }
          for (const t4 in i2)
            this._tiles[t4].clearFadeHold();
          const s2 = function(t4, e3) {
            const r4 = [];
            for (const n4 in t4)
              n4 in e3 || r4.push(n4);
            return r4;
          }(this._tiles, i2);
          for (const t4 of s2) {
            const e3 = this._tiles[t4];
            e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t4);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const t3 in this._tiles)
            this._tiles[t3].holdingForFade() && this._removeTile(+t3);
        }
        _updateRetainedTiles(t3) {
          const e2 = {};
          if (t3.length === 0)
            return e2;
          const r3 = {}, n3 = t3.reduce((t4, e3) => Math.min(t4, e3.overscaledZ), 1 / 0), i2 = t3[0].overscaledZ, s2 = Math.max(i2 - Zd2.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + Zd2.maxUnderzooming, this._source.minzoom), o2 = {};
          for (const r4 of t3) {
            const t4 = this._addTile(r4);
            e2[r4.key] = r4, t4.hasData() || n3 < this._source.maxzoom && (o2[r4.key] = r4);
          }
          this._retainLoadedChildren(o2, n3, a2, e2);
          for (const n4 of t3) {
            let t4 = this._tiles[n4.key];
            if (t4.hasData())
              continue;
            if (n4.canonical.z >= this._source.maxzoom) {
              const t5 = n4.children(this._source.maxzoom)[0], r4 = this.getTile(t5);
              if (r4 && r4.hasData()) {
                e2[t5.key] = t5;
                continue;
              }
            } else {
              const t5 = n4.children(this._source.maxzoom);
              if (e2[t5[0].key] && e2[t5[1].key] && e2[t5[2].key] && e2[t5[3].key])
                continue;
            }
            let i3 = t4.wasRequested();
            for (let a3 = n4.overscaledZ - 1; a3 >= s2; --a3) {
              const s3 = n4.scaledTo(a3);
              if (r3[s3.key])
                break;
              if (r3[s3.key] = true, t4 = this.getTile(s3), !t4 && i3 && (t4 = this._addTile(s3)), t4 && (e2[s3.key] = s3, i3 = t4.wasRequested(), t4.hasData()))
                break;
            }
          }
          return e2;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t3 in this._tiles) {
            const e2 = [];
            let r3, n3 = this._tiles[t3].tileID;
            for (; n3.overscaledZ > 0; ) {
              if (n3.key in this._loadedParentTiles) {
                r3 = this._loadedParentTiles[n3.key];
                break;
              }
              e2.push(n3.key);
              const t4 = n3.scaledTo(n3.overscaledZ - 1);
              if (r3 = this._getLoadedTile(t4), r3)
                break;
              n3 = t4;
            }
            for (const t4 of e2)
              this._loadedParentTiles[t4] = r3;
          }
        }
        _addTile(t3) {
          let e2 = this._tiles[t3.key];
          if (e2)
            return this._source.prepareTile && this._source.prepareTile(e2), e2;
          e2 = this._cache.getAndRemove(t3), e2 && (this._setTileReloadTimer(t3.key, e2), e2.tileID = t3, this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._cacheTimers[t3.key] && (clearTimeout(this._cacheTimers[t3.key]), delete this._cacheTimers[t3.key], this._setTileReloadTimer(t3.key, e2)));
          const r3 = Boolean(e2);
          if (!r3) {
            const r4 = this.map ? this.map.painter : null;
            e2 = new Id2(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, r4, this._isRaster), this._source.prepareTile && this._source.prepareTile(e2) || this._loadTile(e2, this._tileLoaded.bind(this, e2, t3.key, e2.state));
          }
          return e2 ? (e2.uses++, this._tiles[t3.key] = e2, r3 || this._source.fire(new Ot("dataloading", { tile: e2, coord: e2.tileID, dataType: "source" })), e2) : null;
        }
        _setTileReloadTimer(t3, e2) {
          t3 in this._timers && (clearTimeout(this._timers[t3]), delete this._timers[t3]);
          const r3 = e2.getExpiryTimeout();
          r3 && (this._timers[t3] = setTimeout(() => {
            this._reloadTile(t3, "expired"), delete this._timers[t3];
          }, r3));
        }
        _removeTile(t3) {
          const e2 = this._tiles[t3];
          e2 && (e2.uses--, delete this._tiles[t3], this._timers[t3] && (clearTimeout(this._timers[t3]), delete this._timers[t3]), e2.uses > 0 || (e2.hasData() && e2.state !== "reloading" ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const t3 in this._tiles)
            this._removeTile(+t3);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t3, e2, r3) {
          const n3 = [], i2 = this.transform;
          if (!i2)
            return n3;
          const s2 = i2.projection.name === "globe", a2 = zo(i2.center.lng);
          for (const o2 in this._tiles) {
            const l3 = this._tiles[o2];
            if (r3 && l3.clearQueryDebugViz(), l3.holdingForFade())
              continue;
            let u3;
            if (s2) {
              const t4 = l3.tileID.canonical;
              if (t4.z === 0) {
                const e3 = [Math.abs(d(a2, ...Hd2(t4, -1)) - a2), Math.abs(d(a2, ...Hd2(t4, 1)) - a2)];
                u3 = [0, 2 * e3.indexOf(Math.min(...e3)) - 1];
              } else {
                const e3 = [Math.abs(d(a2, ...Hd2(t4, -1)) - a2), Math.abs(d(a2, ...Hd2(t4, 0)) - a2), Math.abs(d(a2, ...Hd2(t4, 1)) - a2)];
                u3 = [e3.indexOf(Math.min(...e3)) - 1];
              }
            } else
              u3 = [0];
            for (const r4 of u3) {
              const s3 = t3.containsTile(l3, i2, e2, r4);
              s3 && n3.push(s3);
            }
          }
          return n3;
        }
        getVisibleCoordinates(t3) {
          const e2 = this.getRenderableIds(t3).map((t4) => this._tiles[t4].tileID);
          for (const t4 of e2)
            t4.projMatrix = this.transform.calculateProjMatrix(t4.toUnwrapped());
          return e2;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (Kd2(this._source.type))
            for (const t3 in this._tiles) {
              const e2 = this._tiles[t3];
              if (e2.fadeEndTime !== void 0 && e2.fadeEndTime >= X2.now())
                return true;
            }
          return false;
        }
        setFeatureState(t3, e2, r3) {
          this._state.updateState(t3 = t3 || "_geojsonTileLayer", e2, r3);
        }
        removeFeatureState(t3, e2, r3) {
          this._state.removeFeatureState(t3 = t3 || "_geojsonTileLayer", e2, r3);
        }
        getFeatureState(t3, e2) {
          return this._state.getState(t3 = t3 || "_geojsonTileLayer", e2);
        }
        setDependencies(t3, e2, r3) {
          const n3 = this._tiles[t3];
          n3 && n3.setDependencies(e2, r3);
        }
        reloadTilesForDependencies(t3, e2) {
          for (const r3 in this._tiles)
            this._tiles[r3].hasDependency(t3, e2) && this._reloadTile(+r3, "reloading");
          this._cache.filter((r3) => !r3.hasDependency(t3, e2));
        }
        _preloadTiles(t3, e2) {
          const r3 = new Map(), n3 = Array.isArray(t3) ? t3 : [t3], i2 = this.map.painter.terrain, s2 = this.usedForTerrain && i2 ? i2.getScaledDemTileSize() : this._source.tileSize;
          for (const t4 of n3) {
            const e3 = t4.coveringTiles({ tileSize: s2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const t5 of e3)
              r3.set(t5.key, t5);
            this.usedForTerrain && t4.updateElevation(false);
          }
          g(Array.from(r3.values()), (t4, e3) => {
            const r4 = new Id2(t4, this._source.tileSize * t4.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(r4, (t5) => {
              this._source.type === "raster-dem" && r4.dem && this._backfillDEM(r4), e3(t5, r4);
            });
          }, e2);
        }
      }
      function Xd2(t3, e2) {
        const r3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0), n3 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
        return t3.overscaledZ - e2.overscaledZ || n3 - r3 || e2.canonical.y - t3.canonical.y || e2.canonical.x - t3.canonical.x;
      }
      function Kd2(t3) {
        return t3 === "raster" || t3 === "image" || t3 === "video";
      }
      function Hd2(t3, e2) {
        const r3 = 1 << t3.z;
        return [t3.x / r3 + e2, (t3.x + 1) / r3 + e2];
      }
      Zd2.maxOverzooming = 10, Zd2.maxUnderzooming = 3;
      class Yd2 {
        constructor(t3, e2, r3) {
          this._demTile = t3, this._dem = this._demTile.dem, this._scale = e2, this._offset = r3;
        }
        static create(t3, e2, r3) {
          const n3 = r3 || t3.findDEMTileFor(e2);
          if (!n3 || !n3.dem)
            return;
          const i2 = n3.dem, s2 = n3.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
          return new Yd2(n3, n3.tileSize / wo / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
        }
        tileCoordToPixel(t3, e2) {
          const r3 = e2 * this._scale + this._offset[1], n3 = Math.floor(t3 * this._scale + this._offset[0]), s2 = Math.floor(r3);
          return new i(n3, s2);
        }
        getElevationAt(t3, e2, r3, n3) {
          const i2 = t3 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l3 = this._dem;
          return n3 = !!n3, r3 ? xr(xr(l3.get(a2, o2, n3), l3.get(a2, o2 + 1, n3), s2 - o2), xr(l3.get(a2 + 1, o2, n3), l3.get(a2 + 1, o2 + 1, n3), s2 - o2), i2 - a2) : l3.get(a2, o2, n3);
        }
        getElevationAtPixel(t3, e2, r3) {
          return this._dem.get(t3, e2, !!r3);
        }
        getMeterToDEM(t3) {
          return (1 << this._demTile.tileID.canonical.z) * Bo(1, t3) * this._dem.stride;
        }
      }
      class Wd2 {
        constructor(t3, e2) {
          this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new Bi2(wo, 16, 0), this.featureIndexArray = new Va2(), this.promoteId = e2;
        }
        insert(t3, e2, r3, n3, i2, s2 = 0) {
          const a2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r3, n3, i2, s2);
          const o2 = this.grid;
          for (let t4 = 0; t4 < e2.length; t4++) {
            const r4 = e2[t4], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t5 = 0; t5 < r4.length; t5++) {
              const e3 = r4[t5];
              n4[0] = Math.min(n4[0], e3.x), n4[1] = Math.min(n4[1], e3.y), n4[2] = Math.max(n4[2], e3.x), n4[3] = Math.max(n4[3], e3.y);
            }
            n4[0] < wo && n4[1] < wo && n4[2] >= 0 && n4[3] >= 0 && o2.insert(a2, n4[0], n4[1], n4[2], n4[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new yc2.VectorTile(new xh2(this.rawTileData)).layers, this.sourceLayerCoder = new dd2(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const t3 in this.vtLayers)
              this.vtFeatures[t3] = [];
          }
          return this.vtLayers;
        }
        query(t3, e2, r3, n3) {
          this.loadVTLayers();
          const i2 = t3.params || {}, s2 = Jn(i2.filter), a2 = t3.tileResult, o2 = t3.transform, l3 = a2.bufferedTilespaceBounds, u3 = this.grid.query(l3.min.x, l3.min.y, l3.max.x, l3.max.y, (t4, e3, r4, n4) => sl(a2.bufferedTilespaceGeometry, t4, e3, r4, n4));
          u3.sort(Qd2);
          let c2 = null;
          o2.elevation && u3.length > 0 && (c2 = Yd2.create(o2.elevation, this.tileID));
          const h3 = {};
          let p3;
          for (let o3 = 0; o3 < u3.length; o3++) {
            const l4 = u3[o3];
            if (l4 === p3)
              continue;
            p3 = l4;
            const f2 = this.featureIndexArray.get(l4);
            let d2 = null;
            this.loadMatchingFeature(h3, f2, s2, i2.layers, i2.availableImages, e2, r3, n3, (e3, r4, n4, i3 = 0) => (d2 || (d2 = No(e3, this.tileID.canonical, t3.tileTransform)), r4.queryIntersectsFeature(a2, e3, n4, d2, this.z, t3.transform, t3.pixelPosMatrix, c2, i3)));
          }
          return h3;
        }
        loadMatchingFeature(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
          const { featureIndex: u3, bucketIndex: c2, sourceLayerIndex: h3, layoutVertexArrayOffset: p3 } = e2, f2 = this.bucketLayerIDs[c2];
          if (n3 && !function(t4, e3) {
            for (let r4 = 0; r4 < t4.length; r4++)
              if (e3.indexOf(t4[r4]) >= 0)
                return true;
            return false;
          }(n3, f2))
            return;
          const d2 = this.sourceLayerCoder.decode(h3), y3 = this.vtLayers[d2].feature(u3);
          if (r3.needGeometry) {
            const t4 = Go(y3, true);
            if (!r3.filter(new Cs(this.tileID.overscaledZ), t4, this.tileID.canonical))
              return;
          } else if (!r3.filter(new Cs(this.tileID.overscaledZ), y3))
            return;
          const m3 = this.getId(y3, d2);
          for (let e3 = 0; e3 < f2.length; e3++) {
            const r4 = f2[e3];
            if (n3 && n3.indexOf(r4) < 0)
              continue;
            const c3 = s2[r4];
            if (!c3)
              continue;
            let h4 = {};
            m3 !== void 0 && o2 && (h4 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", m3));
            const d3 = v2({}, a2[r4]);
            d3.paint = Jd2(d3.paint, c3.paint, y3, h4, i2), d3.layout = Jd2(d3.layout, c3.layout, y3, h4, i2);
            const g2 = !l3 || l3(y3, c3, h4, p3);
            if (!g2)
              continue;
            const x3 = new md2(y3, this.z, this.x, this.y, m3);
            x3.layer = d3;
            let b2 = t3[r4];
            b2 === void 0 && (b2 = t3[r4] = []), b2.push({ featureIndex: u3, feature: x3, intersectionZ: g2 });
          }
        }
        lookupSymbolFeatures(t3, e2, r3, n3, i2, s2, a2, o2) {
          const l3 = {};
          this.loadVTLayers();
          const u3 = Jn(i2);
          for (const i3 of t3)
            this.loadMatchingFeature(l3, { bucketIndex: r3, sourceLayerIndex: n3, featureIndex: i3, layoutVertexArrayOffset: 0 }, u3, s2, a2, o2, e2);
          return l3;
        }
        loadFeature(t3) {
          const { featureIndex: e2, sourceLayerIndex: r3 } = t3;
          this.loadVTLayers();
          const n3 = this.sourceLayerCoder.decode(r3), i2 = this.vtFeatures[n3];
          if (i2[e2])
            return i2[e2];
          const s2 = this.vtLayers[n3].feature(e2);
          return i2[e2] = s2, s2;
        }
        hasLayer(t3) {
          for (const e2 of this.bucketLayerIDs)
            for (const r3 of e2)
              if (t3 === r3)
                return true;
          return false;
        }
        getId(t3, e2) {
          let r3 = t3.id;
          return this.promoteId && (r3 = t3.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2]], typeof r3 == "boolean" && (r3 = Number(r3))), r3;
        }
      }
      function Jd2(t3, e2, r3, n3, i2) {
        return M2(t3, (t4, s2) => {
          const a2 = e2 instanceof js ? e2.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r3, n3, i2) : a2;
        });
      }
      function Qd2(t3, e2) {
        return e2 - t3;
      }
      Pi2(Wd2, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      class ty {
        constructor(t3) {
          const e2 = {}, r3 = [];
          for (const n4 in t3) {
            const i3 = t3[n4], s3 = e2[n4] = {};
            for (const t4 in i3.glyphs) {
              const e3 = i3.glyphs[+t4];
              if (!e3 || e3.bitmap.width === 0 || e3.bitmap.height === 0)
                continue;
              const n5 = e3.metrics.localGlyph ? 2 : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n5, h: e3.bitmap.height + 2 * n5 };
              r3.push(a2), s3[t4] = a2;
            }
          }
          const { w: n3, h: i2 } = $h2(r3), s2 = new hu({ width: n3 || 1, height: i2 || 1 });
          for (const r4 in t3) {
            const n4 = t3[r4];
            for (const t4 in n4.glyphs) {
              const i3 = n4.glyphs[+t4];
              if (!i3 || i3.bitmap.width === 0 || i3.bitmap.height === 0)
                continue;
              const a2 = e2[r4][t4], o2 = i3.metrics.localGlyph ? 2 : 1;
              hu.copy(i3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
            }
          }
          this.image = s2, this.positions = e2;
        }
      }
      Pi2(ty, "GlyphAtlas");
      class ey {
        constructor(t3) {
          this.tileID = new Fc2(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.tileZoom = t3.tileZoom, this.uid = t3.uid, this.zoom = t3.zoom, this.canonical = t3.tileID.canonical, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.returnDependencies = !!t3.returnDependencies, this.promoteId = t3.promoteId, this.enableTerrain = !!t3.enableTerrain, this.isSymbolTile = t3.isSymbolTile, this.tileTransform = Af2(t3.tileID.canonical, t3.projection), this.projection = t3.projection;
        }
        parse(t3, e2, r3, n3, i2) {
          this.status = "parsing", this.data = t3, this.collisionBoxArray = new Ma2();
          const s2 = new dd2(Object.keys(t3.layers).sort()), a2 = new Wd2(this.tileID, this.promoteId);
          a2.bucketLayerIDs = [];
          const o2 = {}, l3 = new hd2(256, 256), u3 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l3, availableImages: r3 }, c2 = e2.familiesBySource[this.source];
          for (const e3 in c2) {
            const n4 = t3.layers[e3];
            if (!n4)
              continue;
            let i3 = false, l4 = false;
            for (const t4 of c2[e3])
              t4[0].type === "symbol" ? i3 = true : l4 = true;
            if (this.isSymbolTile === true && !i3)
              continue;
            if (this.isSymbolTile === false && !l4)
              continue;
            n4.version === 1 && E2(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const h4 = s2.encode(e3), p4 = [];
            for (let t4 = 0; t4 < n4.length; t4++) {
              const r4 = n4.feature(t4), i4 = a2.getId(r4, e3);
              p4.push({ feature: r4, id: i4, index: t4, sourceLayerIndex: h4 });
            }
            for (const t4 of c2[e3]) {
              const e4 = t4[0];
              this.isSymbolTile !== void 0 && e4.type === "symbol" !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || e4.visibility !== "none" && (ry(t4, this.zoom, r3), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t4, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h4, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r3 })).populate(p4, u3, this.tileID.canonical, this.tileTransform), a2.bucketLayerIDs.push(t4.map((t5) => t5.id)));
            }
          }
          let h3, p3, f2, d2;
          l3.trim();
          const y3 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m3 = M2(u3.glyphDependencies, (t4) => Object.keys(t4).map(Number));
          Object.keys(m3).length ? n3.send("getGlyphs", { uid: this.uid, stacks: m3 }, (t4, e3) => {
            h3 || (h3 = t4, p3 = e3, b2.call(this));
          }, void 0, false, y3) : p3 = {};
          const g2 = Object.keys(u3.iconDependencies);
          g2.length ? n3.send("getImages", { icons: g2, source: this.source, tileID: this.tileID, type: "icons" }, (t4, e3) => {
            h3 || (h3 = t4, f2 = e3, b2.call(this));
          }, void 0, false, y3) : f2 = {};
          const v3 = Object.keys(u3.patternDependencies);
          function b2() {
            if (h3)
              return i2(h3);
            if (p3 && f2 && d2) {
              const t4 = new ty(p3), e3 = new qh2(f2, d2);
              for (const n4 in o2) {
                const i3 = o2[n4];
                i3 instanceof Qf2 ? (ry(i3.layers, this.zoom, r3), Dp(i3, p3, t4.positions, f2, e3.iconPositions, this.showCollisionBoxes, r3, this.tileID.canonical, this.tileZoom, this.projection)) : i3.hasPattern && (i3 instanceof Kc2 || i3 instanceof tc2 || i3 instanceof wc2) && (ry(i3.layers, this.zoom, r3), i3.addFeatures(u3, this.tileID.canonical, e3.patternPositions, r3, this.tileTransform));
              }
              this.status = "done", i2(null, { buckets: x2(o2).filter((t5) => !t5.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t4.image, lineAtlas: l3, imageAtlas: e3, glyphMap: this.returnDependencies ? p3 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t4.positions : null });
            }
          }
          v3.length ? n3.send("getImages", { icons: v3, source: this.source, tileID: this.tileID, type: "patterns" }, (t4, e3) => {
            h3 || (h3 = t4, d2 = e3, b2.call(this));
          }, void 0, false, y3) : d2 = {}, b2.call(this);
        }
      }
      function ry(t3, e2, r3) {
        const n3 = new Cs(e2);
        for (const e3 of t3)
          e3.recalculate(n3, r3);
      }
      class ny {
        constructor(t3) {
          this.entries = {}, this.scheduler = t3;
        }
        request(t3, e2, r3, n3) {
          const i2 = this.entries[t3] = this.entries[t3] || { callbacks: [] };
          if (i2.result) {
            const [t4, r4] = i2.result;
            return this.scheduler ? this.scheduler.add(() => {
              n3(t4, r4);
            }, e2) : n3(t4, r4), () => {
            };
          }
          return i2.callbacks.push(n3), i2.cancel || (i2.cancel = r3((r4, n4) => {
            i2.result = [r4, n4];
            for (const t4 of i2.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                t4(r4, n4);
              }, e2) : t4(r4, n4);
            setTimeout(() => delete this.entries[t3], 3e3);
          })), () => {
            i2.result || (i2.callbacks = i2.callbacks.filter((t4) => t4 !== n3), i2.callbacks.length || (i2.cancel(), delete this.entries[t3]));
          };
        }
      }
      function iy(t3, e2, r3) {
        const n3 = JSON.stringify(t3.request);
        return t3.data && (this.deduped.entries[n3] = { result: [null, t3.data] }), this.deduped.request(n3, { type: "parseTile", isSymbolTile: t3.isSymbolTile, zoom: t3.tileZoom }, (e3) => {
          const n4 = Ct(t3.request, (t4, n5, i2, s2) => {
            t4 ? e3(t4) : n5 && e3(null, { vectorTile: r3 ? void 0 : new yc2.VectorTile(new xh2(n5)), rawData: n5, cacheControl: i2, expires: s2 });
          });
          return () => {
            n4.cancel(), e3();
          };
        }, e2);
      }
      t2.ARRAY_TYPE = dl, t2.AUTH_ERR_MSG = nt, t2.Aabb = eu, t2.Actor = class {
        constructor(t3, r3, n3) {
          this.target = t3, this.parent = r3, this.mapId = n3, this.callbacks = {}, this.cancelCallbacks = {}, k(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = D2() ? t3 : e, this.scheduler = new fd2();
        }
        send(t3, e2, r3, n3, i2 = false, s2) {
          const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r3 && (r3.metadata = s2, this.callbacks[a2] = r3);
          const o2 = L2(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: a2, type: t3, hasCallback: !!r3, targetMapId: n3, mustQueue: i2, sourceMapId: this.mapId, data: Fi2(e2, o2) }, o2), { cancel: () => {
            r3 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
          } };
        }
        receive(t3) {
          const e2 = t3.data, r3 = e2.id;
          if (r3 && (!e2.targetMapId || this.mapId === e2.targetMapId))
            if (e2.type === "<cancel>") {
              const t4 = this.cancelCallbacks[r3];
              delete this.cancelCallbacks[r3], t4 && t4.cancel();
            } else if (e2.mustQueue || D2()) {
              const t4 = this.callbacks[r3];
              this.cancelCallbacks[r3] = this.scheduler.add(() => this.processTask(r3, e2), t4 && t4.metadata || { type: "message" });
            } else
              this.processTask(r3, e2);
        }
        processTask(t3, e2) {
          if (e2.type === "<response>") {
            const r3 = this.callbacks[t3];
            delete this.callbacks[t3], r3 && (e2.error ? r3(Li2(e2.error)) : r3(null, Li2(e2.data)));
          } else {
            const r3 = L2(this.globalScope) ? void 0 : [], n3 = e2.hasCallback ? (e3, n4) => {
              delete this.cancelCallbacks[t3], this.target.postMessage({ id: t3, type: "<response>", sourceMapId: this.mapId, error: e3 ? Fi2(e3) : null, data: Fi2(n4, r3) }, r3);
            } : (t4) => {
            }, i2 = Li2(e2.data);
            if (this.parent[e2.type])
              this.parent[e2.type](e2.sourceMapId, i2, n3);
            else if (this.parent.getWorkerSource) {
              const t4 = e2.type.split(".");
              this.parent.getWorkerSource(e2.sourceMapId, t4[0], i2.source)[t4[1]](i2, n3);
            } else
              n3(new Error(`Could not find function ${e2.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }, t2.CanonicalTileID = Dc2, t2.Color = xe, t2.ColorMode = Od2, t2.CullFaceMode = Gd2, t2.DEMData = Ld2, t2.DataConstantProperty = $s, t2.DedupedRequest = ny, t2.DepthMode = Ud2, t2.EXTENT = wo, t2.Elevation = class {
        isDataAvailableAtPoint(t3) {
          const e2 = this._source();
          if (!e2 || t3.y < 0 || t3.y > 1)
            return false;
          const r3 = e2.getSource().maxzoom, n3 = 1 << r3, i2 = Math.floor(t3.x), s2 = Math.floor((t3.x - i2) * n3), a2 = Math.floor(t3.y * n3), o2 = this.findDEMTileFor(new Fc2(r3, i2, r3, s2, a2));
          return !(!o2 || !o2.dem);
        }
        getAtPointOrZero(t3, e2 = 0) {
          return this.getAtPoint(t3, e2) || 0;
        }
        getAtPoint(t3, e2, r3 = true) {
          e2 == null && (e2 = null);
          const n3 = this._source();
          if (!n3)
            return e2;
          if (t3.y < 0 || t3.y > 1)
            return e2;
          const i2 = n3.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t3.x), o2 = t3.x - a2, l3 = new Fc2(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t3.y * s2)), u3 = this.findDEMTileFor(l3);
          if (!u3 || !u3.dem)
            return e2;
          const c2 = u3.dem, h3 = 1 << u3.tileID.canonical.z, p3 = (o2 * h3 - u3.tileID.canonical.x) * c2.dim, f2 = (t3.y * h3 - u3.tileID.canonical.y) * c2.dim, d2 = Math.floor(p3), y3 = Math.floor(f2);
          return (r3 ? this.exaggeration() : 1) * xr(xr(c2.get(d2, y3), c2.get(d2, y3 + 1), f2 - y3), xr(c2.get(d2 + 1, y3), c2.get(d2 + 1, y3 + 1), f2 - y3), p3 - d2);
        }
        getAtTileOffset(t3, e2, r3) {
          const n3 = 1 << t3.canonical.z;
          return this.getAtPointOrZero(new Fo(t3.wrap + (t3.canonical.x + e2 / wo) / n3, (t3.canonical.y + r3 / wo) / n3));
        }
        getAtTileOffsetFunc(t3, e2, r3, n3) {
          return (i2) => {
            const s2 = this.getAtTileOffset(t3, i2.x, i2.y), a2 = n3.upVector(t3.canonical, i2.x, i2.y);
            return Vl(a2, a2, s2 * n3.upVectorScale(t3.canonical, e2, r3).metersToTile), a2;
          };
        }
        getForTilePoints(t3, e2, r3, n3) {
          const i2 = Yd2.create(this, t3, n3);
          return !!i2 && (e2.forEach((t4) => {
            t4[2] = this.exaggeration() * i2.getElevationAt(t4[0], t4[1], r3);
          }), true);
        }
        getMinMaxForTile(t3) {
          const e2 = this.findDEMTileFor(t3);
          if (!e2 || !e2.dem)
            return null;
          const r3 = e2.dem.tree, n3 = e2.tileID, i2 = 1 << t3.canonical.z - n3.canonical.z;
          let s2 = t3.canonical.x / i2 - n3.canonical.x, a2 = t3.canonical.y / i2 - n3.canonical.y, o2 = 0;
          for (let e3 = 0; e3 < t3.canonical.z - n3.canonical.z && !r3.leaves[o2]; e3++) {
            s2 *= 2, a2 *= 2;
            const t4 = 2 * Math.floor(a2) + Math.floor(s2);
            o2 = r3.childOffsets[o2] + t4, s2 %= 1, a2 %= 1;
          }
          return { min: this.exaggeration() * r3.minimums[o2], max: this.exaggeration() * r3.maximums[o2] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(t3, e2, r3) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(t3) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(t3) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
      }, t2.ErrorEvent = qt, t2.EvaluationParameters = Cs, t2.Event = Ot, t2.Evented = Nt, t2.FillExtrusionBucket = wc2, t2.Frustum = tu, t2.FrustumCorners = Ql, t2.GLOBE_METERS_TO_ECEF = Kp, t2.GLOBE_RADIUS = Xp, t2.GLOBE_SCALE_MATCH_LATITUDE = 45, t2.GLOBE_ZOOM_THRESHOLD_MAX = 6, t2.GLOBE_ZOOM_THRESHOLD_MIN = 5, t2.GlobeSharedBuffers = class {
        constructor(t3) {
          this._createGrid(t3), this._createPoles(t3);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const t3 of this._poleSegments)
            t3.destroy();
          for (const t3 of this._gridSegments)
            t3.destroy();
          if (this._wireframeIndexBuffer) {
            this._wireframeIndexBuffer.destroy();
            for (const t3 of this._wireframeSegments)
              t3.destroy();
          }
        }
        _createGrid(t3) {
          const e2 = new Qs(), r3 = new ya2(), n3 = 65;
          for (let t4 = 0; t4 < n3; t4++)
            for (let r4 = 0; r4 < n3; r4++)
              e2.emplaceBack(r4, t4);
          this._gridSegments = [];
          for (let t4 = 0, e3 = 0; t4 < Hp.length; t4++) {
            const i2 = Hp[t4];
            for (let t5 = 0; t5 < i2; t5++)
              for (let e4 = 0; e4 < 64; e4++) {
                const i3 = t5 * n3 + e4;
                r3.emplaceBack(i3 + 1, i3, i3 + n3), r3.emplaceBack(i3 + n3, i3 + n3 + 1, i3 + 1);
              }
            const s2 = 64 * i2 * 2;
            this._gridSegments.push(_o.simpleSegment(0, e3, (i2 + 1) * n3, s2)), e3 += s2;
          }
          this._gridBuffer = t3.createVertexBuffer(e2, Zp.members), this._gridIndexBuffer = t3.createIndexBuffer(r3, true);
        }
        _createPoles(t3) {
          const e2 = new ya2();
          for (let t4 = 0; t4 <= 64; t4++)
            e2.emplaceBack(0, t4 + 1, t4 + 2);
          this._poleIndexBuffer = t3.createIndexBuffer(e2, true);
          const r3 = new va(), n3 = new va();
          this._poleSegments = [];
          for (let t4 = 0, e3 = 0; t4 < 5; t4++) {
            const i2 = 360 / (1 << t4);
            r3.emplaceBack(0, -Xp, 0, 0.5, 0), n3.emplaceBack(0, -Xp, 0, 0.5, 1);
            for (let t5 = 0; t5 <= 64; t5++) {
              const e4 = t5 / 64, s2 = xr(0, i2, e4), [a2, o2, l3] = uf2(bf2, _f, s2, Xp);
              r3.emplaceBack(a2, o2, l3, e4, 0), n3.emplaceBack(a2, o2, l3, e4, 1);
            }
            this._poleSegments.push(_o.simpleSegment(e3, 0, 66, 64)), e3 += 66;
          }
          this._poleNorthVertexBuffer = t3.createVertexBuffer(r3, Np, false), this._poleSouthVertexBuffer = t3.createVertexBuffer(n3, Np, false);
        }
        getGridBuffers(t3) {
          return [this._gridBuffer, this._gridIndexBuffer, this._gridSegments[t3]];
        }
        getPoleBuffers(t3) {
          return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t3]];
        }
        getWirefameBuffers(t3, e2) {
          if (!this._wireframeSegments) {
            const e3 = new _a(), r3 = 64, n3 = r3 + 1;
            this._wireframeSegments = [];
            for (let t4 = 0, i2 = 0; t4 < Hp.length; t4++) {
              const s2 = Hp[t4];
              for (let t5 = 0; t5 < s2; t5++)
                for (let i3 = 0; i3 < r3; i3++) {
                  const r4 = t5 * n3 + i3;
                  e3.emplaceBack(r4, r4 + 1), e3.emplaceBack(r4, r4 + n3), e3.emplaceBack(r4, r4 + n3 + 1);
                }
              const a2 = s2 * r3 * 3;
              this._wireframeSegments.push(_o.simpleSegment(0, i2, (s2 + 1) * n3, a2)), i2 += a2;
            }
            this._wireframeIndexBuffer = t3.createIndexBuffer(e3);
          }
          return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e2]];
        }
      }, t2.GlyphManager = vp, t2.ImagePosition = Oh2, t2.LineAtlas = hd2, t2.LngLat = ko, t2.LngLatBounds = Ao, t2.LocalGlyphMode = xp, t2.MAX_MERCATOR_LATITUDE = Do, t2.MercatorCoordinate = Fo, t2.ONE_EM = ah2, t2.OverscaledTileID = Fc2, t2.Properties = Zs, t2.RGBAImage = pu, t2.Ray = Jl, t2.RequestManager = class {
        constructor(t3, e2, r3) {
          this._transformRequestFn = t3, this._customAccessToken = e2, this._silenceAuthErrors = !!r3, this._createSkuToken();
        }
        _createSkuToken() {
          const t3 = function() {
            let t4 = "";
            for (let e2 = 0; e2 < 10; e2++)
              t4 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", rt, t4].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t3.token, this._skuTokenExpiresAt = t3.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t3, e2) {
          return this._transformRequestFn && this._transformRequestFn(t3, e2) || { url: t3 };
        }
        normalizeStyleURL(t3, e2) {
          if (!it(t3))
            return t3;
          const r3 = ot(t3);
          return r3.path = `/styles/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e2);
        }
        normalizeGlyphsURL(t3, e2) {
          if (!it(t3))
            return t3;
          const r3 = ot(t3);
          return r3.path = `/fonts/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e2);
        }
        normalizeSourceURL(t3, e2, r3, n3) {
          if (!it(t3))
            return t3;
          const i2 = ot(t3);
          return i2.path = `/v4/${i2.authority}.json`, i2.params.push("secure"), r3 && i2.params.push(`language=${r3}`), n3 && i2.params.push(`worldview=${n3}`), this._makeAPIURL(i2, this._customAccessToken || e2);
        }
        normalizeSpriteURL(t3, e2, r3, n3) {
          const i2 = ot(t3);
          return it(t3) ? (i2.path = `/styles/v1${i2.path}/sprite${e2}${r3}`, this._makeAPIURL(i2, this._customAccessToken || n3)) : (i2.path += `${e2}${r3}`, lt(i2));
        }
        normalizeTileURL(t3, e2, r3) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t3 && !it(t3))
            return t3;
          const n3 = ot(t3);
          n3.path = n3.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e2 || r3 && n3.authority !== "raster" && r3 === 512 ? "@2x" : ""}${Y2.supported ? ".webp" : "$1"}`), n3.authority === "raster" ? n3.path = `/${H2.RASTER_URL_PREFIX}${n3.path}` : (n3.path = n3.path.replace(/^.+\/v4\//, "/"), n3.path = `/${H2.TILE_URL_VERSION}${n3.path}`);
          const i2 = this._customAccessToken || function(t4) {
            for (const e3 of t4) {
              const t5 = e3.match(/^access_token=(.*)$/);
              if (t5)
                return t5[1];
            }
            return null;
          }(n3.params) || H2.ACCESS_TOKEN;
          return H2.REQUIRE_ACCESS_TOKEN && i2 && this._skuToken && n3.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n3, i2);
        }
        canonicalizeTileURL(t3, e2) {
          const r3 = ot(t3);
          if (!r3.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r3.path.match(/\.[\w]+$/))
            return t3;
          let n3 = "mapbox://";
          r3.path.match(/^\/raster\/v1\//) ? n3 += `raster/${r3.path.replace(`/${H2.RASTER_URL_PREFIX}/`, "")}` : n3 += `tiles/${r3.path.replace(`/${H2.TILE_URL_VERSION}/`, "")}`;
          let i2 = r3.params;
          return e2 && (i2 = i2.filter((t4) => !t4.match(/^access_token=/))), i2.length && (n3 += `?${i2.join("&")}`), n3;
        }
        canonicalizeTileset(t3, e2) {
          const r3 = !!e2 && it(e2), n3 = [];
          for (const e3 of t3.tiles || [])
            st(e3) ? n3.push(this.canonicalizeTileURL(e3, r3)) : n3.push(e3);
          return n3;
        }
        _makeAPIURL(t3, e2) {
          const r3 = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", n3 = ot(H2.API_URL);
          if (t3.protocol = n3.protocol, t3.authority = n3.authority, t3.protocol === "http") {
            const e3 = t3.params.indexOf("secure");
            e3 >= 0 && t3.params.splice(e3, 1);
          }
          if (n3.path !== "/" && (t3.path = `${n3.path}${t3.path}`), !H2.REQUIRE_ACCESS_TOKEN)
            return lt(t3);
          if (e2 = e2 || H2.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!e2)
              throw new Error(`An API access token is required to use Mapbox GL. ${r3}`);
            if (e2[0] === "s")
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r3}`);
          }
          return t3.params = t3.params.filter((t4) => t4.indexOf("access_token") === -1), t3.params.push(`access_token=${e2 || ""}`), lt(t3);
        }
      }, t2.ResourceType = zt, t2.SegmentVector = _o, t2.SourceCache = Zd2, t2.StencilMode = $d2, t2.StructArrayLayout1ui2 = wa2, t2.StructArrayLayout2f1f2i16 = pa2, t2.StructArrayLayout2i4 = Qs, t2.StructArrayLayout2ui4 = _a, t2.StructArrayLayout3f12 = da2, t2.StructArrayLayout3ui6 = ya2, t2.StructArrayLayout4i8 = ea2, t2.StructArrayLayout5f20 = va, t2.Texture = cd2, t2.Tile = Id2, t2.Transitionable = Vs, t2.Uniform1f = Wa2, t2.Uniform1i = class extends Ya2 {
        constructor(t3) {
          super(t3), this.current = 0;
        }
        set(t3, e2, r3) {
          this.fetchUniformLocation(t3, e2) && this.current !== r3 && (this.current = r3, this.gl.uniform1i(this.location, r3));
        }
      }, t2.Uniform2f = class extends Ya2 {
        constructor(t3) {
          super(t3), this.current = [0, 0];
        }
        set(t3, e2, r3) {
          this.fetchUniformLocation(t3, e2) && (r3[0] === this.current[0] && r3[1] === this.current[1] || (this.current = r3, this.gl.uniform2f(this.location, r3[0], r3[1])));
        }
      }, t2.Uniform3f = class extends Ya2 {
        constructor(t3) {
          super(t3), this.current = [0, 0, 0];
        }
        set(t3, e2, r3) {
          this.fetchUniformLocation(t3, e2) && (r3[0] === this.current[0] && r3[1] === this.current[1] && r3[2] === this.current[2] || (this.current = r3, this.gl.uniform3f(this.location, r3[0], r3[1], r3[2])));
        }
      }, t2.Uniform4f = Ja2, t2.UniformColor = Qa2, t2.UniformMatrix2f = class extends Ya2 {
        constructor(t3) {
          super(t3), this.current = ro;
        }
        set(t3, e2, r3) {
          if (this.fetchUniformLocation(t3, e2)) {
            for (let t4 = 0; t4 < 4; t4++)
              if (r3[t4] !== this.current[t4]) {
                this.current = r3, this.gl.uniformMatrix2fv(this.location, false, r3);
                break;
              }
          }
        }
      }, t2.UniformMatrix3f = class extends Ya2 {
        constructor(t3) {
          super(t3), this.current = eo;
        }
        set(t3, e2, r3) {
          if (this.fetchUniformLocation(t3, e2)) {
            for (let t4 = 0; t4 < 9; t4++)
              if (r3[t4] !== this.current[t4]) {
                this.current = r3, this.gl.uniformMatrix3fv(this.location, false, r3);
                break;
              }
          }
        }
      }, t2.UniformMatrix4f = class extends Ya2 {
        constructor(t3) {
          super(t3), this.current = to2;
        }
        set(t3, e2, r3) {
          if (this.fetchUniformLocation(t3, e2)) {
            if (r3[12] !== this.current[12] || r3[0] !== this.current[0])
              return this.current = r3, void this.gl.uniformMatrix4fv(this.location, false, r3);
            for (let t4 = 1; t4 < 16; t4++)
              if (r3[t4] !== this.current[t4]) {
                this.current = r3, this.gl.uniformMatrix4fv(this.location, false, r3);
                break;
              }
          }
        }
      }, t2.UnwrappedTileID = Vc2, t2.ValidationError = qn, t2.VectorTileWorkerSource = class extends Nt {
        constructor(t3, e2, r3, n3, i2) {
          super(), this.actor = t3, this.layerIndex = e2, this.availableImages = r3, this.loadVectorData = i2 || iy, this.loading = {}, this.loaded = {}, this.deduped = new ny(t3.scheduler), this.isSpriteLoaded = n3, this.scheduler = t3.scheduler;
        }
        loadTile(t3, e2) {
          const r3 = t3.uid, n3 = t3 && t3.request, i2 = n3 && n3.collectResourceTiming, s2 = this.loading[r3] = new ey(t3);
          s2.abort = this.loadVectorData(t3, (a2, o2) => {
            const l3 = !this.loading[r3];
            if (delete this.loading[r3], l3 || a2 || !o2)
              return s2.status = "done", l3 || (this.loaded[r3] = s2), e2(a2);
            const u3 = o2.rawData, c2 = {};
            o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s2.vectorTile = o2.vectorTile || new yc2.VectorTile(new xh2(u3));
            const h3 = () => {
              s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, r4) => {
                if (t4 || !r4)
                  return e2(t4);
                const s3 = {};
                if (i2) {
                  const t5 = $(n3);
                  t5.length > 0 && (s3.resourceTiming = JSON.parse(JSON.stringify(t5)));
                }
                e2(null, v2({ rawTileData: u3.slice(0) }, r4, c2, s3));
              });
            };
            this.isSpriteLoaded ? h3() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(h3, { type: "parseTile", isSymbolTile: t3.isSymbolTile, zoom: t3.tileZoom }) : h3();
            }), this.loaded = this.loaded || {}, this.loaded[r3] = s2;
          });
        }
        reloadTile(t3, e2) {
          const r3 = this.loaded, n3 = t3.uid, i2 = this;
          if (r3 && r3[n3]) {
            const s2 = r3[n3];
            s2.showCollisionBoxes = t3.showCollisionBoxes, s2.enableTerrain = !!t3.enableTerrain, s2.projection = t3.projection, s2.tileTransform = Af2(t3.tileID.canonical, t3.projection);
            const a2 = (t4, r4) => {
              const n4 = s2.reloadCallback;
              n4 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n4)), e2(t4, r4);
            };
            s2.status === "parsing" ? s2.reloadCallback = a2 : s2.status === "done" && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
          }
        }
        abortTile(t3, e2) {
          const r3 = t3.uid, n3 = this.loading[r3];
          n3 && (n3.abort && n3.abort(), delete this.loading[r3]), e2();
        }
        removeTile(t3, e2) {
          const r3 = this.loaded, n3 = t3.uid;
          r3 && r3[n3] && delete r3[n3], e2();
        }
      }, t2.WritingMode = Nh2, t2.ZoomHistory = Ri2, t2.add = Bl, t2.addDynamicAttributes = Hf2, t2.adjoint = function(t3, e2) {
        var r3 = e2[0], n3 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l3 = e2[6], u3 = e2[7], c2 = e2[8];
        return t3[0] = a2 * c2 - o2 * u3, t3[1] = i2 * u3 - n3 * c2, t3[2] = n3 * o2 - i2 * a2, t3[3] = o2 * l3 - s2 * c2, t3[4] = r3 * c2 - i2 * l3, t3[5] = i2 * s2 - r3 * o2, t3[6] = s2 * u3 - a2 * l3, t3[7] = n3 * l3 - r3 * u3, t3[8] = r3 * a2 - n3 * s2, t3;
      }, t2.asyncAll = g, t2.bezier = p2, t2.bindAll = k, t2.boundsAttributes = Sd2, t2.bufferConvexPolygon = function(t3, e2) {
        const r3 = [];
        for (let n3 = 0; n3 < t3.length; n3++) {
          const i2 = m2(n3 - 1, -1, t3.length - 1), s2 = m2(n3 + 1, -1, t3.length - 1), a2 = t3[n3], o2 = t3[s2], l3 = t3[i2].sub(a2).unit(), u3 = o2.sub(a2).unit(), c2 = u3.angleWithSep(l3.x, l3.y), h3 = l3.add(u3).unit().mult(-1 * e2 / Math.sin(c2 / 2));
          r3.push(a2.add(h3));
        }
        return r3;
      }, t2.cacheEntryPossiblyAdded = function(t3) {
        Mt++, Mt > bt && (t3.getActor().send("enforceCacheSizeLimit", vt), Mt = 0);
      }, t2.calculateGlobeLabelMatrix = function(t3, e2) {
        const { x: r3, y: n3 } = t3.point, i2 = mf2(r3, n3, t3.worldSize / t3._pixelsPerMercatorPixel, 0, 0);
        return xl(i2, i2, yf2(rf2(e2)));
      }, t2.calculateGlobeMatrix = function(t3) {
        const { x: e2, y: r3 } = t3.point, { lng: n3, lat: i2 } = t3._center;
        return mf2(e2, r3, t3.worldSize, n3, i2);
      }, t2.calculateGlobeMercatorMatrix = function(t3) {
        const e2 = t3.pixelsPerMeter, r3 = e2 / Bo(1, t3.center.lat), n3 = ml(new Float64Array(16));
        return vl(n3, n3, [t3.point.x, t3.point.y, 0]), bl(n3, n3, [r3, r3, e2]), Float32Array.from(n3);
      }, t2.circumferenceAtLatitude = Mo, t2.clamp = d, t2.clearTileCache = function(t3) {
        const e2 = At(), r3 = [];
        for (const t4 in _t)
          e2 && r3.push(e2.delete(t4)), delete _t[t4];
        t3 && Promise.all(r3).catch(t3).then(() => t3());
      }, t2.clipLine = dp, t2.clone = function(t3) {
        var e2 = new dl(16);
        return e2[0] = t3[0], e2[1] = t3[1], e2[2] = t3[2], e2[3] = t3[3], e2[4] = t3[4], e2[5] = t3[5], e2[6] = t3[6], e2[7] = t3[7], e2[8] = t3[8], e2[9] = t3[9], e2[10] = t3[10], e2[11] = t3[11], e2[12] = t3[12], e2[13] = t3[13], e2[14] = t3[14], e2[15] = t3[15], e2;
      }, t2.clone$1 = T2, t2.collisionCircleLayout = sh2, t2.config = H2, t2.conjugate = function(t3, e2) {
        return t3[0] = -e2[0], t3[1] = -e2[1], t3[2] = -e2[2], t3[3] = e2[3], t3;
      }, t2.create = function() {
        var t3 = new dl(16);
        return dl != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
      }, t2.create$1 = yl, t2.createExpression = Ln, t2.createLayout = Ws, t2.createStyleLayer = function(t3) {
        return t3.type === "custom" ? new ad2(t3) : new ud2[t3.type](t3);
      }, t2.cross = Ul, t2.degToRad = l2, t2.distance = function(t3, e2) {
        return Math.hypot(e2[0] - t3[0], e2[1] - t3[1], e2[2] - t3[2]);
      }, t2.div = function(t3, e2, r3) {
        return t3[0] = e2[0] / r3[0], t3[1] = e2[1] / r3[1], t3[2] = e2[2] / r3[2], t3;
      }, t2.dot = Rl, t2.ease = f, t2.easeCubicInOut = h, t2.emitValidationErrors = Ti2, t2.endsWith = I2, t2.enforceCacheSizeLimit = function(t3) {
        for (const e2 in _t)
          St(e2), _t[e2].then((e3) => {
            e3.keys().then((r3) => {
              for (let n3 = 0; n3 < r3.length - t3; n3++)
                e3.delete(r3[n3]);
            });
          });
      }, t2.evaluateSizeForFeature = uh2, t2.evaluateSizeForZoom = ch2, t2.evaluateVariableOffset = Pp, t2.evented = zs, t2.exactEquals = function(t3, e2) {
        return t3[0] === e2[0] && t3[1] === e2[1] && t3[2] === e2[2] && t3[3] === e2[3];
      }, t2.exactEquals$1 = function(t3, e2) {
        return t3[0] === e2[0] && t3[1] === e2[1] && t3[2] === e2[2];
      }, t2.exported = X2, t2.exported$1 = Y2, t2.extend = v2, t2.extend$1 = Zt, t2.fillExtrusionHeightLift = Tc2, t2.filterObject = z2, t2.fromMat4 = function(t3, e2) {
        return t3[0] = e2[0], t3[1] = e2[1], t3[2] = e2[2], t3[3] = e2[4], t3[4] = e2[5], t3[5] = e2[6], t3[6] = e2[8], t3[7] = e2[9], t3[8] = e2[10], t3;
      }, t2.fromQuat = function(t3, e2) {
        var r3 = e2[0], n3 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r3 + r3, o2 = n3 + n3, l3 = i2 + i2, u3 = r3 * a2, c2 = n3 * a2, h3 = n3 * o2, p3 = i2 * a2, f2 = i2 * o2, d2 = i2 * l3, y3 = s2 * a2, m3 = s2 * o2, g2 = s2 * l3;
        return t3[0] = 1 - h3 - d2, t3[1] = c2 + g2, t3[2] = p3 - m3, t3[3] = 0, t3[4] = c2 - g2, t3[5] = 1 - u3 - d2, t3[6] = f2 + y3, t3[7] = 0, t3[8] = p3 + m3, t3[9] = f2 - y3, t3[10] = 1 - u3 - h3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
      }, t2.fromRotation = function(t3, e2) {
        var r3 = Math.sin(e2), n3 = Math.cos(e2);
        return t3[0] = n3, t3[1] = r3, t3[2] = 0, t3[3] = -r3, t3[4] = n3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
      }, t2.fromScaling = Al, t2.furthestTileCorner = function(t3) {
        const e2 = Math.round((t3 + 45 + 360) % 360 / 90) % 4;
        return c[e2];
      }, t2.getAABBPointSquareDist = function(t3, e2, r3) {
        let n3 = 0;
        for (let i2 = 0; i2 < 2; ++i2) {
          const s2 = r3 ? r3[i2] : 0;
          t3[i2] > s2 && (n3 += (t3[i2] - s2) * (t3[i2] - s2)), e2[i2] < s2 && (n3 += (s2 - e2[i2]) * (s2 - e2[i2]));
        }
        return n3;
      }, t2.getAnchorAlignment = rp, t2.getAnchorJustification = Vp, t2.getBounds = function(t3) {
        let e2 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, s2 = -1 / 0;
        for (const i2 of t3)
          e2 = Math.min(e2, i2.x), r3 = Math.min(r3, i2.y), n3 = Math.max(n3, i2.x), s2 = Math.max(s2, i2.y);
        return { min: new i(e2, r3), max: new i(n3, s2) };
      }, t2.getColumn = U2, t2.getGridMatrix = function(t3, e2, r3) {
        const n3 = e2.getNorth(), i2 = e2.getSouth(), s2 = e2.getWest(), a2 = 0.015625;
        return [0, (e2.getEast() - s2) * a2, 1 << t3.z, (i2 - n3) / Hp[r3], 0, t3.y, n3, s2, a2];
      }, t2.getImage = Ut, t2.getJSON = function(t3, e2) {
        return Et(v2(t3, { type: "json" }), e2);
      }, t2.getLatitudinalLod = function(t3) {
        const e2 = 80.051129;
        t3 = d(t3, -80.051129, e2) / e2 * 90;
        const r3 = Math.pow(Math.abs(Math.sin(l2(t3))), 3);
        return Math.round(r3 * (Hp.length - 1));
      }, t2.getMapSessionAPI = mt, t2.getPerformanceMeasurement = $, t2.getProjection = Nf2, t2.getRTLTextPluginStatus = Ts, t2.getReferrer = Bt, t2.getTilePoint = function(t3, { x: e2, y: r3 }, n3 = 0) {
        return new i(((e2 - n3) * t3.scale - t3.x) * wo, (r3 * t3.scale - t3.y) * wo);
      }, t2.getTileVec3 = function(t3, e2, r3 = 0) {
        return Tl(((e2.x - r3) * t3.scale - t3.x) * wo, (e2.y * t3.scale - t3.y) * wo, Po(e2.z, e2.y));
      }, t2.getVideo = function(t3, r3) {
        const n3 = e.document.createElement("video");
        n3.muted = true, n3.onloadstart = function() {
          r3(null, n3);
        };
        for (let r4 = 0; r4 < t3.length; r4++) {
          const i2 = e.document.createElement("source");
          Vt(t3[r4]) || (n3.crossOrigin = "Anonymous"), i2.src = t3[r4], n3.appendChild(i2);
        }
        return { cancel: () => {
        } };
      }, t2.globeCenterToScreenPoint = function(t3) {
        const e2 = [0, 0, 0], r3 = ml(new Float64Array(16));
        return xl(r3, t3.pixelMatrix, t3.globeMatrix), jl(e2, e2, r3), new i(e2[0], e2[1]);
      }, t2.globeDenormalizeECEF = yf2, t2.globeECEFOrigin = function(t3, e2) {
        const r3 = [0, 0, 0];
        return jl(r3, r3, df2(rf2(e2.canonical))), jl(r3, r3, t3), r3;
      }, t2.globeNormalizeECEF = df2, t2.globePixelsToTileUnits = function(t3, e2) {
        return wo / (512 * Math.pow(2, t3)) * pf2(rf2(e2));
      }, t2.globePoleMatrixForTile = function(t3, e2, r3) {
        const n3 = ml(new Float64Array(16)), i2 = (e2 / (1 << t3) - 0.5) * Math.PI * 2;
        return wl(n3, r3.globeMatrix, i2), Float32Array.from(n3);
      }, t2.globeTileBounds = rf2, t2.globeTiltAtLngLat = xf2, t2.globeToMercatorTransition = gf2, t2.globeUseCustomAntiAliasing = function(t3, e2, r3) {
        const n3 = gf2(r3.zoom), i2 = t3.style.map._antialias, s2 = !!e2.extStandardDerivatives, a2 = e2.extStandardDerivativesForceOff || t3.terrain && t3.terrain.exaggeration() > 0;
        return n3 === 0 && !i2 && !a2 && s2;
      }, t2.identity = ml, t2.identity$1 = Hl, t2.invert = gl, t2.isFullscreen = function() {
        return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
      }, t2.isLngLatBehindGlobe = function(t3, e2) {
        return xf2(t3, e2) > Math.PI / 2 * 1.01;
      }, t2.isMapAuthenticated = function(t3) {
        return gt.has(t3);
      }, t2.isMapboxURL = it, t2.isSafariWithAntialiasingBug = function(t3) {
        const e2 = t3.navigator ? t3.navigator.userAgent : null;
        return !!L2(t3) && e2 && (e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
      }, t2.latFromMercatorY = Co, t2.len = Gl, t2.length = zl, t2.length$1 = function(t3) {
        return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
      }, t2.loadVectorTile = iy, t2.makeRequest = Et, t2.mapValue = function(t3, e2, r3, n3, i2) {
        return d((t3 - e2) / (r3 - e2) * (i2 - n3) + n3, n3, i2);
      }, t2.mercatorScale = Vo, t2.mercatorXfromLng = zo, t2.mercatorYfromLat = To, t2.mercatorZfromAltitude = Bo, t2.mul = kl, t2.mul$1 = Nl, t2.multiply = xl, t2.multiply$1 = function(t3, e2, r3) {
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u3 = e2[6], c2 = e2[7], h3 = e2[8], p3 = r3[0], f2 = r3[1], d2 = r3[2], y3 = r3[3], m3 = r3[4], g2 = r3[5], x3 = r3[6], v3 = r3[7], b2 = r3[8];
        return t3[0] = p3 * n3 + f2 * a2 + d2 * u3, t3[1] = p3 * i2 + f2 * o2 + d2 * c2, t3[2] = p3 * s2 + f2 * l3 + d2 * h3, t3[3] = y3 * n3 + m3 * a2 + g2 * u3, t3[4] = y3 * i2 + m3 * o2 + g2 * c2, t3[5] = y3 * s2 + m3 * l3 + g2 * h3, t3[6] = x3 * n3 + v3 * a2 + b2 * u3, t3[7] = x3 * i2 + v3 * o2 + b2 * c2, t3[8] = x3 * s2 + v3 * l3 + b2 * h3, t3;
      }, t2.multiply$2 = Cl, t2.nextPowerOfTwo = A2, t2.normalize = Ll, t2.normalize$1 = function(t3, e2) {
        var r3 = e2[0], n3 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r3 * r3 + n3 * n3 + i2 * i2 + s2 * s2;
        return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t3[0] = r3 * a2, t3[1] = n3 * a2, t3[2] = i2 * a2, t3[3] = s2 * a2, t3;
      }, t2.number = xr, t2.ortho = function(t3, e2, r3, n3, i2, s2, a2) {
        var o2 = 1 / (e2 - r3), l3 = 1 / (n3 - i2), u3 = 1 / (s2 - a2);
        return t3[0] = -2 * o2, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e2 + r3) * o2, t3[13] = (i2 + n3) * l3, t3[14] = (a2 + s2) * u3, t3[15] = 1, t3;
      }, t2.pbf = xh2, t2.perspective = function(t3, e2, r3, n3, i2) {
        var s2, a2 = 1 / Math.tan(e2 / 2);
        return t3[0] = a2 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, i2 != null && i2 !== 1 / 0 ? (t3[10] = (i2 + n3) * (s2 = 1 / (n3 - i2)), t3[14] = 2 * i2 * n3 * s2) : (t3[10] = -1, t3[14] = -2 * n3), t3;
      }, t2.pick = function(t3, e2) {
        const r3 = {};
        for (let n3 = 0; n3 < e2.length; n3++) {
          const i2 = e2[n3];
          i2 in t3 && (r3[i2] = t3[i2]);
        }
        return r3;
      }, t2.plugin = Es, t2.pointGeometry = i, t2.polygonContainsPoint = il, t2.polygonIntersectsBox = sl, t2.polygonIntersectsPolygon = Ho, t2.polygonizeBounds = function(t3, e2, r3 = 0, n3 = true) {
        const s2 = new i(r3, r3), a2 = t3.sub(s2), o2 = e2.add(s2), l3 = [a2, new i(o2.x, a2.y), o2, new i(a2.x, o2.y)];
        return n3 && l3.push(a2.clone()), l3;
      }, t2.posAttributes = Zp, t2.postMapLoadEvent = dt, t2.postTurnstileEvent = pt, t2.potpack = $h2, t2.prevPowerOfTwo = function(t3) {
        return t3 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t3) / Math.LN2));
      }, t2.radToDeg = u2, t2.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t2.registerForPluginStateChange = function(t3) {
        return t3({ pluginStatus: Ss, pluginURL: ks }), zs.on("pluginStateChange", t3), t3;
      }, t2.removeAuthState = function(t3) {
        gt.delete(t3);
      }, t2.renderColorRamp = du, t2.resample = Ro, t2.rotateX = _l, t2.rotateX$1 = Yl, t2.rotateY = wl, t2.rotateY$1 = Wl, t2.rotateZ = function(t3, e2, r3) {
        var n3 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[0], a2 = e2[1], o2 = e2[2], l3 = e2[3], u3 = e2[4], c2 = e2[5], h3 = e2[6], p3 = e2[7];
        return e2 !== t3 && (t3[8] = e2[8], t3[9] = e2[9], t3[10] = e2[10], t3[11] = e2[11], t3[12] = e2[12], t3[13] = e2[13], t3[14] = e2[14], t3[15] = e2[15]), t3[0] = s2 * i2 + u3 * n3, t3[1] = a2 * i2 + c2 * n3, t3[2] = o2 * i2 + h3 * n3, t3[3] = l3 * i2 + p3 * n3, t3[4] = u3 * i2 - s2 * n3, t3[5] = c2 * i2 - a2 * n3, t3[6] = h3 * i2 - o2 * n3, t3[7] = p3 * i2 - l3 * n3, t3;
      }, t2.rotateZ$1 = function(t3, e2, r3) {
        r3 *= 0.5;
        var n3 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l3 = Math.cos(r3);
        return t3[0] = n3 * l3 + i2 * o2, t3[1] = i2 * l3 - n3 * o2, t3[2] = s2 * l3 + a2 * o2, t3[3] = a2 * l3 - s2 * o2, t3;
      }, t2.scale = bl, t2.scale$1 = Zl, t2.scale$2 = Vl, t2.scaleAndAdd = Fl, t2.setCacheLimits = function(t3, e2) {
        vt = t3, bt = e2;
      }, t2.setColumn = function(t3, e2, r3) {
        t3[4 * e2 + 0] = r3[0], t3[4 * e2 + 1] = r3[1], t3[4 * e2 + 2] = r3[2], t3[4 * e2 + 3] = r3[3];
      }, t2.setRTLTextPlugin = function(t3, e2, r3 = false) {
        if (Ss === bs || Ss === _s || Ss === ws)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        ks = X2.resolveURL(t3), Ss = bs, As = e2, Ms(), r3 || Bs();
      }, t2.smoothstep = y2, t2.spec = Gt, t2.storeAuthState = function(t3, e2) {
        e2 ? gt.add(t3) : gt.delete(t3);
      }, t2.sub = ql, t2.subtract = El, t2.symbolSize = hh2, t2.tileAABB = function(t3, e2, r3, n3, i2, s2, a2, o2, l3) {
        if (l3.name === "globe")
          return af2(t3, e2, new Dc2(r3, n3, i2));
        const u3 = Af2({ z: r3, x: n3, y: i2 }, l3);
        return new eu([(s2 + u3.x / u3.scale) * e2, e2 * (u3.y / u3.scale), a2], [(s2 + u3.x2 / u3.scale) * e2, e2 * (u3.y2 / u3.scale), o2]);
      }, t2.tileCornersToBounds = of2, t2.tileTransform = Af2, t2.transformMat3 = function(t3, e2, r3) {
        var n3 = e2[0], i2 = e2[1], s2 = e2[2];
        return t3[0] = n3 * r3[0] + i2 * r3[3] + s2 * r3[6], t3[1] = n3 * r3[1] + i2 * r3[4] + s2 * r3[7], t3[2] = n3 * r3[2] + i2 * r3[5] + s2 * r3[8], t3;
      }, t2.transformMat4 = jl, t2.transformMat4$1 = Xl, t2.transformQuat = $l, t2.transitionTileAABBinECEF = nf2, t2.translate = vl, t2.transpose = function(t3, e2) {
        if (t3 === e2) {
          var r3 = e2[1], n3 = e2[2], i2 = e2[5];
          t3[1] = e2[3], t3[2] = e2[6], t3[3] = r3, t3[5] = e2[7], t3[6] = n3, t3[7] = i2;
        } else
          t3[0] = e2[0], t3[1] = e2[3], t3[2] = e2[6], t3[3] = e2[1], t3[4] = e2[4], t3[5] = e2[7], t3[6] = e2[2], t3[7] = e2[5], t3[8] = e2[8];
        return t3;
      }, t2.triggerPluginCompletionEvent = Is, t2.uniqueId = _, t2.updateGlobeVertexNormal = function(t3, e2, r3, n3, i2) {
        const s2 = 5 * e2 + 2;
        t3.float32[s2 + 0] = r3, t3.float32[s2 + 1] = n3, t3.float32[s2 + 2] = i2;
      }, t2.validateCustomStyleLayer = function(t3) {
        const e2 = [], r3 = t3.id;
        return r3 === void 0 && e2.push({ message: `layers.${r3}: missing required property "id"` }), t3.render === void 0 && e2.push({ message: `layers.${r3}: missing required method "render"` }), t3.renderingMode && t3.renderingMode !== "2d" && t3.renderingMode !== "3d" && e2.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e2;
      }, t2.validateFilter = (t3) => zi2(ci2(t3)), t2.validateFog = (t3) => zi2(_i(t3)), t2.validateLayer = (t3) => zi2(yi2(t3)), t2.validateLight = (t3) => zi2(vi2(t3)), t2.validateSource = (t3) => zi2(xi2(t3)), t2.validateStyle = ki2, t2.validateTerrain = (t3) => zi2(bi2(t3)), t2.values = x2, t2.vectorTile = yc2, t2.version = O2, t2.warnOnce = E2, t2.window = e, t2.wrap = m2;
    });
    define(["./shared"], function(e) {
      function t2(e2) {
        if (typeof e2 == "number" || typeof e2 == "boolean" || typeof e2 == "string" || e2 == null)
          return JSON.stringify(e2);
        if (Array.isArray(e2)) {
          let r4 = "[";
          for (const o2 of e2)
            r4 += `${t2(o2)},`;
          return `${r4}]`;
        }
        let r3 = "{";
        for (const o2 of Object.keys(e2).sort())
          r3 += `${o2}:${t2(e2[o2])},`;
        return `${r3}}`;
      }
      function r2(r3) {
        let o2 = "";
        for (const n3 of e.refProperties)
          o2 += `/${t2(r3[n3])}`;
        return o2;
      }
      class o {
        constructor(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        }
        replace(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }
        update(t3, o2) {
          for (const r3 of t3)
            this._layerConfigs[r3.id] = r3, (this._layers[r3.id] = e.createStyleLayer(r3)).compileFilter(), this.keyCache[r3.id] && delete this.keyCache[r3.id];
          for (const e2 of o2)
            delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
          this.familiesBySource = {};
          const n3 = function(e2, t4) {
            const o3 = {};
            for (let n5 = 0; n5 < e2.length; n5++) {
              const i2 = t4 && t4[e2[n5].id] || r2(e2[n5]);
              t4 && (t4[e2[n5].id] = i2);
              let s2 = o3[i2];
              s2 || (s2 = o3[i2] = []), s2.push(e2[n5]);
            }
            const n4 = [];
            for (const e3 in o3)
              n4.push(o3[e3]);
            return n4;
          }(e.values(this._layerConfigs), this.keyCache);
          for (const e2 of n3) {
            const t4 = e2.map((e3) => this._layers[e3.id]), r3 = t4[0];
            if (r3.visibility === "none")
              continue;
            const o3 = r3.source || "";
            let n4 = this.familiesBySource[o3];
            n4 || (n4 = this.familiesBySource[o3] = {});
            const i2 = r3.sourceLayer || "_geojsonTileLayer";
            let s2 = n4[i2];
            s2 || (s2 = n4[i2] = []), s2.push(t4);
          }
        }
      }
      class n2 {
        loadTile(t3, r3) {
          const { uid: o2, encoding: n3, rawImageData: i2, padding: s2, buildQuadTree: a2 } = t3, l3 = e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? this.getImageData(i2, s2) : i2;
          r3(null, new e.DEMData(o2, l3, n3, s2 < 1, a2));
        }
        getImageData(e2, t3) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
          const r3 = this.offscreenCanvasContext.getImageData(-t3, -t3, e2.width + 2 * t3, e2.height + 2 * t3);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r3;
        }
      }
      var i = function e2(t3, r3) {
        var o2, n3 = t3 && t3.type;
        if (n3 === "FeatureCollection")
          for (o2 = 0; o2 < t3.features.length; o2++)
            e2(t3.features[o2], r3);
        else if (n3 === "GeometryCollection")
          for (o2 = 0; o2 < t3.geometries.length; o2++)
            e2(t3.geometries[o2], r3);
        else if (n3 === "Feature")
          e2(t3.geometry, r3);
        else if (n3 === "Polygon")
          s(t3.coordinates, r3);
        else if (n3 === "MultiPolygon")
          for (o2 = 0; o2 < t3.coordinates.length; o2++)
            s(t3.coordinates[o2], r3);
        return t3;
      };
      function s(e2, t3) {
        if (e2.length !== 0) {
          a(e2[0], t3);
          for (var r3 = 1; r3 < e2.length; r3++)
            a(e2[r3], !t3);
        }
      }
      function a(e2, t3) {
        for (var r3 = 0, o2 = 0, n3 = 0, i2 = e2.length, s2 = i2 - 1; n3 < i2; s2 = n3++) {
          var a2 = (e2[n3][0] - e2[s2][0]) * (e2[s2][1] + e2[n3][1]), l3 = r3 + a2;
          o2 += Math.abs(r3) >= Math.abs(a2) ? r3 - l3 + a2 : a2 - l3 + r3, r3 = l3;
        }
        r3 + o2 >= 0 != !!t3 && e2.reverse();
      }
      const l2 = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;
      class u2 {
        constructor(t3) {
          this._feature = t3, this.extent = e.EXTENT, this.type = t3.type, this.properties = t3.tags, "id" in t3 && !isNaN(t3.id) && (this.id = parseInt(t3.id, 10));
        }
        loadGeometry() {
          if (this._feature.type === 1) {
            const t3 = [];
            for (const r3 of this._feature.geometry)
              t3.push([new e.pointGeometry(r3[0], r3[1])]);
            return t3;
          }
          {
            const t3 = [];
            for (const r3 of this._feature.geometry) {
              const o2 = [];
              for (const t4 of r3)
                o2.push(new e.pointGeometry(t4[0], t4[1]));
              t3.push(o2);
            }
            return t3;
          }
        }
        toGeoJSON(e2, t3, r3) {
          return l2.call(this, e2, t3, r3);
        }
      }
      class h {
        constructor(t3) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t3.length, this._features = t3;
        }
        feature(e2) {
          return new u2(this._features[e2]);
        }
      }
      var c = e.vectorTile.VectorTileFeature, f = p2;
      function p2(e2, t3) {
        this.options = t3 || {}, this.features = e2, this.length = e2.length;
      }
      function g(e2, t3) {
        this.id = typeof e2.id == "number" ? e2.id : void 0, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t3 || 4096;
      }
      p2.prototype.feature = function(e2) {
        return new g(this.features[e2], this.options.extent);
      }, g.prototype.loadGeometry = function() {
        var t3 = this.rawGeometry;
        this.geometry = [];
        for (var r3 = 0; r3 < t3.length; r3++) {
          for (var o2 = t3[r3], n3 = [], i2 = 0; i2 < o2.length; i2++)
            n3.push(new e.pointGeometry(o2[i2][0], o2[i2][1]));
          this.geometry.push(n3);
        }
        return this.geometry;
      }, g.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e2 = this.geometry, t3 = 1 / 0, r3 = -1 / 0, o2 = 1 / 0, n3 = -1 / 0, i2 = 0; i2 < e2.length; i2++)
          for (var s2 = e2[i2], a2 = 0; a2 < s2.length; a2++) {
            var l3 = s2[a2];
            t3 = Math.min(t3, l3.x), r3 = Math.max(r3, l3.x), o2 = Math.min(o2, l3.y), n3 = Math.max(n3, l3.y);
          }
        return [t3, o2, r3, n3];
      }, g.prototype.toGeoJSON = c.prototype.toGeoJSON;
      var d = y2, m2 = f;
      function y2(t3) {
        var r3 = new e.pbf();
        return function(e2, t4) {
          for (var r4 in e2.layers)
            t4.writeMessage(3, v2, e2.layers[r4]);
        }(t3, r3), r3.finish();
      }
      function v2(e2, t3) {
        var r3;
        t3.writeVarintField(15, e2.version || 1), t3.writeStringField(1, e2.name || ""), t3.writeVarintField(5, e2.extent || 4096);
        var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (r3 = 0; r3 < e2.length; r3++)
          o2.feature = e2.feature(r3), t3.writeMessage(2, x2, o2);
        var n3 = o2.keys;
        for (r3 = 0; r3 < n3.length; r3++)
          t3.writeStringField(3, n3[r3]);
        var i2 = o2.values;
        for (r3 = 0; r3 < i2.length; r3++)
          t3.writeMessage(4, b, i2[r3]);
      }
      function x2(e2, t3) {
        var r3 = e2.feature;
        r3.id !== void 0 && t3.writeVarintField(1, r3.id), t3.writeMessage(2, w, e2), t3.writeVarintField(3, r3.type), t3.writeMessage(4, P2, r3);
      }
      function w(e2, t3) {
        var r3 = e2.feature, o2 = e2.keys, n3 = e2.values, i2 = e2.keycache, s2 = e2.valuecache;
        for (var a2 in r3.properties) {
          var l3 = r3.properties[a2], u3 = i2[a2];
          if (l3 !== null) {
            u3 === void 0 && (o2.push(a2), i2[a2] = u3 = o2.length - 1), t3.writeVarint(u3);
            var h3 = typeof l3;
            h3 !== "string" && h3 !== "boolean" && h3 !== "number" && (l3 = JSON.stringify(l3));
            var c2 = h3 + ":" + l3, f2 = s2[c2];
            f2 === void 0 && (n3.push(l3), s2[c2] = f2 = n3.length - 1), t3.writeVarint(f2);
          }
        }
      }
      function S2(e2, t3) {
        return (t3 << 3) + (7 & e2);
      }
      function M2(e2) {
        return e2 << 1 ^ e2 >> 31;
      }
      function P2(e2, t3) {
        for (var r3 = e2.loadGeometry(), o2 = e2.type, n3 = 0, i2 = 0, s2 = r3.length, a2 = 0; a2 < s2; a2++) {
          var l3 = r3[a2], u3 = 1;
          o2 === 1 && (u3 = l3.length), t3.writeVarint(S2(1, u3));
          for (var h3 = o2 === 3 ? l3.length - 1 : l3.length, c2 = 0; c2 < h3; c2++) {
            c2 === 1 && o2 !== 1 && t3.writeVarint(S2(2, h3 - 1));
            var f2 = l3[c2].x - n3, p3 = l3[c2].y - i2;
            t3.writeVarint(M2(f2)), t3.writeVarint(M2(p3)), n3 += f2, i2 += p3;
          }
          o2 === 3 && t3.writeVarint(S2(7, 1));
        }
      }
      function b(e2, t3) {
        var r3 = typeof e2;
        r3 === "string" ? t3.writeStringField(1, e2) : r3 === "boolean" ? t3.writeBooleanField(7, e2) : r3 === "number" && (e2 % 1 != 0 ? t3.writeDoubleField(3, e2) : e2 < 0 ? t3.writeSVarintField(6, e2) : t3.writeVarintField(5, e2));
      }
      function T2(e2, t3, r3, o2, n3, i2) {
        if (n3 - o2 <= r3)
          return;
        const s2 = o2 + n3 >> 1;
        k(e2, t3, s2, o2, n3, i2 % 2), T2(e2, t3, r3, o2, s2 - 1, i2 + 1), T2(e2, t3, r3, s2 + 1, n3, i2 + 1);
      }
      function k(e2, t3, r3, o2, n3, i2) {
        for (; n3 > o2; ) {
          if (n3 - o2 > 600) {
            const s3 = n3 - o2 + 1, a3 = r3 - o2 + 1, l4 = Math.log(s3), u3 = 0.5 * Math.exp(2 * l4 / 3), h3 = 0.5 * Math.sqrt(l4 * u3 * (s3 - u3) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
            k(e2, t3, r3, Math.max(o2, Math.floor(r3 - a3 * u3 / s3 + h3)), Math.min(n3, Math.floor(r3 + (s3 - a3) * u3 / s3 + h3)), i2);
          }
          const s2 = t3[2 * r3 + i2];
          let a2 = o2, l3 = n3;
          for (I2(e2, t3, o2, r3), t3[2 * n3 + i2] > s2 && I2(e2, t3, o2, n3); a2 < l3; ) {
            for (I2(e2, t3, a2, l3), a2++, l3--; t3[2 * a2 + i2] < s2; )
              a2++;
            for (; t3[2 * l3 + i2] > s2; )
              l3--;
          }
          t3[2 * o2 + i2] === s2 ? I2(e2, t3, o2, l3) : (l3++, I2(e2, t3, l3, n3)), l3 <= r3 && (o2 = l3 + 1), r3 <= l3 && (n3 = l3 - 1);
        }
      }
      function I2(e2, t3, r3, o2) {
        _(e2, r3, o2), _(t3, 2 * r3, 2 * o2), _(t3, 2 * r3 + 1, 2 * o2 + 1);
      }
      function _(e2, t3, r3) {
        const o2 = e2[t3];
        e2[t3] = e2[r3], e2[r3] = o2;
      }
      function L2(e2, t3, r3, o2) {
        const n3 = e2 - r3, i2 = t3 - o2;
        return n3 * n3 + i2 * i2;
      }
      d.fromVectorTileJs = y2, d.fromGeojsonVt = function(e2, t3) {
        t3 = t3 || {};
        var r3 = {};
        for (var o2 in e2)
          r3[o2] = new f(e2[o2].features, t3), r3[o2].name = o2, r3[o2].version = t3.version, r3[o2].extent = t3.extent;
        return y2({ layers: r3 });
      }, d.GeoJSONWrapper = m2;
      const C2 = (e2) => e2[0], O2 = (e2) => e2[1];
      class z2 {
        constructor(e2, t3 = C2, r3 = O2, o2 = 64, n3 = Float64Array) {
          this.nodeSize = o2, this.points = e2;
          const i2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new i2(e2.length), a2 = this.coords = new n3(2 * e2.length);
          for (let o3 = 0; o3 < e2.length; o3++)
            s2[o3] = o3, a2[2 * o3] = t3(e2[o3]), a2[2 * o3 + 1] = r3(e2[o3]);
          T2(s2, a2, o2, 0, s2.length - 1, 0);
        }
        range(e2, t3, r3, o2) {
          return function(e3, t4, r4, o3, n3, i2, s2) {
            const a2 = [0, e3.length - 1, 0], l3 = [];
            let u3, h3;
            for (; a2.length; ) {
              const c2 = a2.pop(), f2 = a2.pop(), p3 = a2.pop();
              if (f2 - p3 <= s2) {
                for (let s3 = p3; s3 <= f2; s3++)
                  u3 = t4[2 * s3], h3 = t4[2 * s3 + 1], u3 >= r4 && u3 <= n3 && h3 >= o3 && h3 <= i2 && l3.push(e3[s3]);
                continue;
              }
              const g2 = Math.floor((p3 + f2) / 2);
              u3 = t4[2 * g2], h3 = t4[2 * g2 + 1], u3 >= r4 && u3 <= n3 && h3 >= o3 && h3 <= i2 && l3.push(e3[g2]);
              const d2 = (c2 + 1) % 2;
              (c2 === 0 ? r4 <= u3 : o3 <= h3) && (a2.push(p3), a2.push(g2 - 1), a2.push(d2)), (c2 === 0 ? n3 >= u3 : i2 >= h3) && (a2.push(g2 + 1), a2.push(f2), a2.push(d2));
            }
            return l3;
          }(this.ids, this.coords, e2, t3, r3, o2, this.nodeSize);
        }
        within(e2, t3, r3) {
          return function(e3, t4, r4, o2, n3, i2) {
            const s2 = [0, e3.length - 1, 0], a2 = [], l3 = n3 * n3;
            for (; s2.length; ) {
              const u3 = s2.pop(), h3 = s2.pop(), c2 = s2.pop();
              if (h3 - c2 <= i2) {
                for (let n4 = c2; n4 <= h3; n4++)
                  L2(t4[2 * n4], t4[2 * n4 + 1], r4, o2) <= l3 && a2.push(e3[n4]);
                continue;
              }
              const f2 = Math.floor((c2 + h3) / 2), p3 = t4[2 * f2], g2 = t4[2 * f2 + 1];
              L2(p3, g2, r4, o2) <= l3 && a2.push(e3[f2]);
              const d2 = (u3 + 1) % 2;
              (u3 === 0 ? r4 - n3 <= p3 : o2 - n3 <= g2) && (s2.push(c2), s2.push(f2 - 1), s2.push(d2)), (u3 === 0 ? r4 + n3 >= p3 : o2 + n3 >= g2) && (s2.push(f2 + 1), s2.push(h3), s2.push(d2));
            }
            return a2;
          }(this.ids, this.coords, e2, t3, r3, this.nodeSize);
        }
      }
      const E2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, F2 = Math.fround || (N2 = new Float32Array(1), (e2) => (N2[0] = +e2, N2[0]));
      var N2;
      class j {
        constructor(e2) {
          this.options = A2(Object.create(E2), e2), this.trees = new Array(this.options.maxZoom + 1);
        }
        load(e2) {
          const { log: t3, minZoom: r3, maxZoom: o2, nodeSize: n3 } = this.options;
          t3 && console.time("total time");
          const i2 = `prepare ${e2.length} points`;
          t3 && console.time(i2), this.points = e2;
          let s2 = [];
          for (let t4 = 0; t4 < e2.length; t4++)
            e2[t4].geometry && s2.push(G2(e2[t4], t4));
          this.trees[o2 + 1] = new z2(s2, D2, $, n3, Float32Array), t3 && console.timeEnd(i2);
          for (let e3 = o2; e3 >= r3; e3--) {
            const r4 = +Date.now();
            s2 = this._cluster(s2, e3), this.trees[e3] = new z2(s2, D2, $, n3, Float32Array), t3 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - r4);
          }
          return t3 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t3) {
          let r3 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const o2 = Math.max(-90, Math.min(90, e2[1]));
          let n3 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const i2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            r3 = -180, n3 = 180;
          else if (r3 > n3) {
            const e3 = this.getClusters([r3, o2, 180, i2], t3), s3 = this.getClusters([-180, o2, n3, i2], t3);
            return e3.concat(s3);
          }
          const s2 = this.trees[this._limitZoom(t3)], a2 = s2.range(Y2(r3), X2(i2), Y2(n3), X2(o2)), l3 = [];
          for (const e3 of a2) {
            const t4 = s2.points[e3];
            l3.push(t4.numPoints ? J2(t4) : this.points[t4.index]);
          }
          return l3;
        }
        getChildren(e2) {
          const t3 = this._getOriginId(e2), r3 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", n3 = this.trees[r3];
          if (!n3)
            throw new Error(o2);
          const i2 = n3.points[t3];
          if (!i2)
            throw new Error(o2);
          const s2 = this.options.radius / (this.options.extent * Math.pow(2, r3 - 1)), a2 = n3.within(i2.x, i2.y, s2), l3 = [];
          for (const t4 of a2) {
            const r4 = n3.points[t4];
            r4.parentId === e2 && l3.push(r4.numPoints ? J2(r4) : this.points[r4.index]);
          }
          if (l3.length === 0)
            throw new Error(o2);
          return l3;
        }
        getLeaves(e2, t3, r3) {
          const o2 = [];
          return this._appendLeaves(o2, e2, t3 = t3 || 10, r3 = r3 || 0, 0), o2;
        }
        getTile(e2, t3, r3) {
          const o2 = this.trees[this._limitZoom(e2)], n3 = Math.pow(2, e2), { extent: i2, radius: s2 } = this.options, a2 = s2 / i2, l3 = (r3 - a2) / n3, u3 = (r3 + 1 + a2) / n3, h3 = { features: [] };
          return this._addTileFeatures(o2.range((t3 - a2) / n3, l3, (t3 + 1 + a2) / n3, u3), o2.points, t3, r3, n3, h3), t3 === 0 && this._addTileFeatures(o2.range(1 - a2 / n3, l3, 1, u3), o2.points, n3, r3, n3, h3), t3 === n3 - 1 && this._addTileFeatures(o2.range(0, l3, a2 / n3, u3), o2.points, -1, r3, n3, h3), h3.features.length ? h3 : null;
        }
        getClusterExpansionZoom(e2) {
          let t3 = this._getOriginZoom(e2) - 1;
          for (; t3 <= this.options.maxZoom; ) {
            const r3 = this.getChildren(e2);
            if (t3++, r3.length !== 1)
              break;
            e2 = r3[0].properties.cluster_id;
          }
          return t3;
        }
        _appendLeaves(e2, t3, r3, o2, n3) {
          const i2 = this.getChildren(t3);
          for (const t4 of i2) {
            const i3 = t4.properties;
            if (i3 && i3.cluster ? n3 + i3.point_count <= o2 ? n3 += i3.point_count : n3 = this._appendLeaves(e2, i3.cluster_id, r3, o2, n3) : n3 < o2 ? n3++ : e2.push(t4), e2.length === r3)
              break;
          }
          return n3;
        }
        _addTileFeatures(e2, t3, r3, o2, n3, i2) {
          for (const s2 of e2) {
            const e3 = t3[s2], a2 = e3.numPoints;
            let l3, u3, h3;
            if (a2)
              l3 = W2(e3), u3 = e3.x, h3 = e3.y;
            else {
              const t4 = this.points[e3.index];
              l3 = t4.properties, u3 = Y2(t4.geometry.coordinates[0]), h3 = X2(t4.geometry.coordinates[1]);
            }
            const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (u3 * n3 - r3)), Math.round(this.options.extent * (h3 * n3 - o2))]], tags: l3 };
            let f2;
            a2 ? f2 = e3.id : this.options.generateId ? f2 = e3.index : this.points[e3.index].id && (f2 = this.points[e3.index].id), f2 !== void 0 && (c2.id = f2), i2.features.push(c2);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(+e2, this.options.maxZoom + 1));
        }
        _cluster(e2, t3) {
          const r3 = [], { radius: o2, extent: n3, reduce: i2, minPoints: s2 } = this.options, a2 = o2 / (n3 * Math.pow(2, t3));
          for (let o3 = 0; o3 < e2.length; o3++) {
            const n4 = e2[o3];
            if (n4.zoom <= t3)
              continue;
            n4.zoom = t3;
            const l3 = this.trees[t3 + 1], u3 = l3.within(n4.x, n4.y, a2), h3 = n4.numPoints || 1;
            let c2 = h3;
            for (const e3 of u3) {
              const r4 = l3.points[e3];
              r4.zoom > t3 && (c2 += r4.numPoints || 1);
            }
            if (c2 > h3 && c2 >= s2) {
              let e3 = n4.x * h3, s3 = n4.y * h3, a3 = i2 && h3 > 1 ? this._map(n4, true) : null;
              const f2 = (o3 << 5) + (t3 + 1) + this.points.length;
              for (const r4 of u3) {
                const o4 = l3.points[r4];
                if (o4.zoom <= t3)
                  continue;
                o4.zoom = t3;
                const u4 = o4.numPoints || 1;
                e3 += o4.x * u4, s3 += o4.y * u4, o4.parentId = f2, i2 && (a3 || (a3 = this._map(n4, true)), i2(a3, this._map(o4)));
              }
              n4.parentId = f2, r3.push(Z2(e3 / c2, s3 / c2, f2, c2, a3));
            } else if (r3.push(n4), c2 > 1)
              for (const e3 of u3) {
                const o4 = l3.points[e3];
                o4.zoom <= t3 || (o4.zoom = t3, r3.push(o4));
              }
          }
          return r3;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t3) {
          if (e2.numPoints)
            return t3 ? A2({}, e2.properties) : e2.properties;
          const r3 = this.points[e2.index].properties, o2 = this.options.map(r3);
          return t3 && o2 === r3 ? A2({}, o2) : o2;
        }
      }
      function Z2(e2, t3, r3, o2, n3) {
        return { x: F2(e2), y: F2(t3), zoom: 1 / 0, id: r3, parentId: -1, numPoints: o2, properties: n3 };
      }
      function G2(e2, t3) {
        const [r3, o2] = e2.geometry.coordinates;
        return { x: F2(Y2(r3)), y: F2(X2(o2)), zoom: 1 / 0, index: t3, parentId: -1 };
      }
      function J2(e2) {
        return { type: "Feature", id: e2.id, properties: W2(e2), geometry: { type: "Point", coordinates: [(t3 = e2.x, 360 * (t3 - 0.5)), V2(e2.y)] } };
        var t3;
      }
      function W2(e2) {
        const t3 = e2.numPoints, r3 = t3 >= 1e4 ? `${Math.round(t3 / 1e3)}k` : t3 >= 1e3 ? Math.round(t3 / 100) / 10 + "k" : t3;
        return A2(A2({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t3, point_count_abbreviated: r3 });
      }
      function Y2(e2) {
        return e2 / 360 + 0.5;
      }
      function X2(e2) {
        const t3 = Math.sin(e2 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
        return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
      }
      function V2(e2) {
        const t3 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
      }
      function A2(e2, t3) {
        for (const r3 in t3)
          e2[r3] = t3[r3];
        return e2;
      }
      function D2(e2) {
        return e2.x;
      }
      function $(e2) {
        return e2.y;
      }
      function B2(e2, t3, r3, o2) {
        for (var n3, i2 = o2, s2 = r3 - t3 >> 1, a2 = r3 - t3, l3 = e2[t3], u3 = e2[t3 + 1], h3 = e2[r3], c2 = e2[r3 + 1], f2 = t3 + 3; f2 < r3; f2 += 3) {
          var p3 = R2(e2[f2], e2[f2 + 1], l3, u3, h3, c2);
          if (p3 > i2)
            n3 = f2, i2 = p3;
          else if (p3 === i2) {
            var g2 = Math.abs(f2 - s2);
            g2 < a2 && (n3 = f2, a2 = g2);
          }
        }
        i2 > o2 && (n3 - t3 > 3 && B2(e2, t3, n3, o2), e2[n3 + 2] = i2, r3 - n3 > 3 && B2(e2, n3, r3, o2));
      }
      function R2(e2, t3, r3, o2, n3, i2) {
        var s2 = n3 - r3, a2 = i2 - o2;
        if (s2 !== 0 || a2 !== 0) {
          var l3 = ((e2 - r3) * s2 + (t3 - o2) * a2) / (s2 * s2 + a2 * a2);
          l3 > 1 ? (r3 = n3, o2 = i2) : l3 > 0 && (r3 += s2 * l3, o2 += a2 * l3);
        }
        return (s2 = e2 - r3) * s2 + (a2 = t3 - o2) * a2;
      }
      function q2(e2, t3, r3, o2) {
        var n3 = { id: e2 === void 0 ? null : e2, type: t3, geometry: r3, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(e3) {
          var t4 = e3.geometry, r4 = e3.type;
          if (r4 === "Point" || r4 === "MultiPoint" || r4 === "LineString")
            U2(e3, t4);
          else if (r4 === "Polygon" || r4 === "MultiLineString")
            for (var o3 = 0; o3 < t4.length; o3++)
              U2(e3, t4[o3]);
          else if (r4 === "MultiPolygon")
            for (o3 = 0; o3 < t4.length; o3++)
              for (var n4 = 0; n4 < t4[o3].length; n4++)
                U2(e3, t4[o3][n4]);
        }(n3), n3;
      }
      function U2(e2, t3) {
        for (var r3 = 0; r3 < t3.length; r3 += 3)
          e2.minX = Math.min(e2.minX, t3[r3]), e2.minY = Math.min(e2.minY, t3[r3 + 1]), e2.maxX = Math.max(e2.maxX, t3[r3]), e2.maxY = Math.max(e2.maxY, t3[r3 + 1]);
      }
      function Q2(e2, t3, r3, o2) {
        if (t3.geometry) {
          var n3 = t3.geometry.coordinates, i2 = t3.geometry.type, s2 = Math.pow(r3.tolerance / ((1 << r3.maxZoom) * r3.extent), 2), a2 = [], l3 = t3.id;
          if (r3.promoteId ? l3 = t3.properties[r3.promoteId] : r3.generateId && (l3 = o2 || 0), i2 === "Point")
            H2(n3, a2);
          else if (i2 === "MultiPoint")
            for (var u3 = 0; u3 < n3.length; u3++)
              H2(n3[u3], a2);
          else if (i2 === "LineString")
            K2(n3, a2, s2, false);
          else if (i2 === "MultiLineString") {
            if (r3.lineMetrics) {
              for (u3 = 0; u3 < n3.length; u3++)
                K2(n3[u3], a2 = [], s2, false), e2.push(q2(l3, "LineString", a2, t3.properties));
              return;
            }
            ee2(n3, a2, s2, false);
          } else if (i2 === "Polygon")
            ee2(n3, a2, s2, true);
          else {
            if (i2 !== "MultiPolygon") {
              if (i2 === "GeometryCollection") {
                for (u3 = 0; u3 < t3.geometry.geometries.length; u3++)
                  Q2(e2, { id: l3, geometry: t3.geometry.geometries[u3], properties: t3.properties }, r3, o2);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (u3 = 0; u3 < n3.length; u3++) {
              var h3 = [];
              ee2(n3[u3], h3, s2, true), a2.push(h3);
            }
          }
          e2.push(q2(l3, i2, a2, t3.properties));
        }
      }
      function H2(e2, t3) {
        t3.push(te2(e2[0])), t3.push(re2(e2[1])), t3.push(0);
      }
      function K2(e2, t3, r3, o2) {
        for (var n3, i2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
          var l3 = te2(e2[a2][0]), u3 = re2(e2[a2][1]);
          t3.push(l3), t3.push(u3), t3.push(0), a2 > 0 && (s2 += o2 ? (n3 * u3 - l3 * i2) / 2 : Math.sqrt(Math.pow(l3 - n3, 2) + Math.pow(u3 - i2, 2))), n3 = l3, i2 = u3;
        }
        var h3 = t3.length - 3;
        t3[2] = 1, B2(t3, 0, h3, r3), t3[h3 + 2] = 1, t3.size = Math.abs(s2), t3.start = 0, t3.end = t3.size;
      }
      function ee2(e2, t3, r3, o2) {
        for (var n3 = 0; n3 < e2.length; n3++) {
          var i2 = [];
          K2(e2[n3], i2, r3, o2), t3.push(i2);
        }
      }
      function te2(e2) {
        return e2 / 360 + 0.5;
      }
      function re2(e2) {
        var t3 = Math.sin(e2 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
        return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
      }
      function oe2(e2, t3, r3, o2, n3, i2, s2, a2) {
        if (o2 /= t3, i2 >= (r3 /= t3) && s2 < o2)
          return e2;
        if (s2 < r3 || i2 >= o2)
          return null;
        for (var l3 = [], u3 = 0; u3 < e2.length; u3++) {
          var h3 = e2[u3], c2 = h3.geometry, f2 = h3.type, p3 = n3 === 0 ? h3.minX : h3.minY, g2 = n3 === 0 ? h3.maxX : h3.maxY;
          if (p3 >= r3 && g2 < o2)
            l3.push(h3);
          else if (!(g2 < r3 || p3 >= o2)) {
            var d2 = [];
            if (f2 === "Point" || f2 === "MultiPoint")
              ne2(c2, d2, r3, o2, n3);
            else if (f2 === "LineString")
              ie2(c2, d2, r3, o2, n3, false, a2.lineMetrics);
            else if (f2 === "MultiLineString")
              ae2(c2, d2, r3, o2, n3, false);
            else if (f2 === "Polygon")
              ae2(c2, d2, r3, o2, n3, true);
            else if (f2 === "MultiPolygon")
              for (var m3 = 0; m3 < c2.length; m3++) {
                var y3 = [];
                ae2(c2[m3], y3, r3, o2, n3, true), y3.length && d2.push(y3);
              }
            if (d2.length) {
              if (a2.lineMetrics && f2 === "LineString") {
                for (m3 = 0; m3 < d2.length; m3++)
                  l3.push(q2(h3.id, f2, d2[m3], h3.tags));
                continue;
              }
              f2 !== "LineString" && f2 !== "MultiLineString" || (d2.length === 1 ? (f2 = "LineString", d2 = d2[0]) : f2 = "MultiLineString"), f2 !== "Point" && f2 !== "MultiPoint" || (f2 = d2.length === 3 ? "Point" : "MultiPoint"), l3.push(q2(h3.id, f2, d2, h3.tags));
            }
          }
        }
        return l3.length ? l3 : null;
      }
      function ne2(e2, t3, r3, o2, n3) {
        for (var i2 = 0; i2 < e2.length; i2 += 3) {
          var s2 = e2[i2 + n3];
          s2 >= r3 && s2 <= o2 && (t3.push(e2[i2]), t3.push(e2[i2 + 1]), t3.push(e2[i2 + 2]));
        }
      }
      function ie2(e2, t3, r3, o2, n3, i2, s2) {
        for (var a2, l3, u3 = se2(e2), h3 = n3 === 0 ? ue2 : he2, c2 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
          var p3 = e2[f2], g2 = e2[f2 + 1], d2 = e2[f2 + 2], m3 = e2[f2 + 3], y3 = e2[f2 + 4], v3 = n3 === 0 ? p3 : g2, x3 = n3 === 0 ? m3 : y3, w2 = false;
          s2 && (a2 = Math.sqrt(Math.pow(p3 - m3, 2) + Math.pow(g2 - y3, 2))), v3 < r3 ? x3 > r3 && (l3 = h3(u3, p3, g2, m3, y3, r3), s2 && (u3.start = c2 + a2 * l3)) : v3 > o2 ? x3 < o2 && (l3 = h3(u3, p3, g2, m3, y3, o2), s2 && (u3.start = c2 + a2 * l3)) : le2(u3, p3, g2, d2), x3 < r3 && v3 >= r3 && (l3 = h3(u3, p3, g2, m3, y3, r3), w2 = true), x3 > o2 && v3 <= o2 && (l3 = h3(u3, p3, g2, m3, y3, o2), w2 = true), !i2 && w2 && (s2 && (u3.end = c2 + a2 * l3), t3.push(u3), u3 = se2(e2)), s2 && (c2 += a2);
        }
        var S3 = e2.length - 3;
        p3 = e2[S3], g2 = e2[S3 + 1], d2 = e2[S3 + 2], (v3 = n3 === 0 ? p3 : g2) >= r3 && v3 <= o2 && le2(u3, p3, g2, d2), S3 = u3.length - 3, i2 && S3 >= 3 && (u3[S3] !== u3[0] || u3[S3 + 1] !== u3[1]) && le2(u3, u3[0], u3[1], u3[2]), u3.length && t3.push(u3);
      }
      function se2(e2) {
        var t3 = [];
        return t3.size = e2.size, t3.start = e2.start, t3.end = e2.end, t3;
      }
      function ae2(e2, t3, r3, o2, n3, i2) {
        for (var s2 = 0; s2 < e2.length; s2++)
          ie2(e2[s2], t3, r3, o2, n3, i2, false);
      }
      function le2(e2, t3, r3, o2) {
        e2.push(t3), e2.push(r3), e2.push(o2);
      }
      function ue2(e2, t3, r3, o2, n3, i2) {
        var s2 = (i2 - t3) / (o2 - t3);
        return e2.push(i2), e2.push(r3 + (n3 - r3) * s2), e2.push(1), s2;
      }
      function he2(e2, t3, r3, o2, n3, i2) {
        var s2 = (i2 - r3) / (n3 - r3);
        return e2.push(t3 + (o2 - t3) * s2), e2.push(i2), e2.push(1), s2;
      }
      function ce2(e2, t3) {
        for (var r3 = [], o2 = 0; o2 < e2.length; o2++) {
          var n3, i2 = e2[o2], s2 = i2.type;
          if (s2 === "Point" || s2 === "MultiPoint" || s2 === "LineString")
            n3 = fe2(i2.geometry, t3);
          else if (s2 === "MultiLineString" || s2 === "Polygon") {
            n3 = [];
            for (var a2 = 0; a2 < i2.geometry.length; a2++)
              n3.push(fe2(i2.geometry[a2], t3));
          } else if (s2 === "MultiPolygon")
            for (n3 = [], a2 = 0; a2 < i2.geometry.length; a2++) {
              for (var l3 = [], u3 = 0; u3 < i2.geometry[a2].length; u3++)
                l3.push(fe2(i2.geometry[a2][u3], t3));
              n3.push(l3);
            }
          r3.push(q2(i2.id, s2, n3, i2.tags));
        }
        return r3;
      }
      function fe2(e2, t3) {
        var r3 = [];
        r3.size = e2.size, e2.start !== void 0 && (r3.start = e2.start, r3.end = e2.end);
        for (var o2 = 0; o2 < e2.length; o2 += 3)
          r3.push(e2[o2] + t3, e2[o2 + 1], e2[o2 + 2]);
        return r3;
      }
      function pe2(e2, t3) {
        if (e2.transformed)
          return e2;
        var r3, o2, n3, i2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
        for (r3 = 0; r3 < e2.features.length; r3++) {
          var l3 = e2.features[r3], u3 = l3.geometry, h3 = l3.type;
          if (l3.geometry = [], h3 === 1)
            for (o2 = 0; o2 < u3.length; o2 += 2)
              l3.geometry.push(ge2(u3[o2], u3[o2 + 1], t3, i2, s2, a2));
          else
            for (o2 = 0; o2 < u3.length; o2++) {
              var c2 = [];
              for (n3 = 0; n3 < u3[o2].length; n3 += 2)
                c2.push(ge2(u3[o2][n3], u3[o2][n3 + 1], t3, i2, s2, a2));
              l3.geometry.push(c2);
            }
        }
        return e2.transformed = true, e2;
      }
      function ge2(e2, t3, r3, o2, n3, i2) {
        return [Math.round(r3 * (e2 * o2 - n3)), Math.round(r3 * (t3 * o2 - i2))];
      }
      function de2(e2, t3, r3, o2, n3) {
        for (var i2 = t3 === n3.maxZoom ? 0 : n3.tolerance / ((1 << t3) * n3.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r3, y: o2, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
          s2.numFeatures++, me2(s2, e2[a2], i2, n3);
          var l3 = e2[a2].minX, u3 = e2[a2].minY, h3 = e2[a2].maxX, c2 = e2[a2].maxY;
          l3 < s2.minX && (s2.minX = l3), u3 < s2.minY && (s2.minY = u3), h3 > s2.maxX && (s2.maxX = h3), c2 > s2.maxY && (s2.maxY = c2);
        }
        return s2;
      }
      function me2(e2, t3, r3, o2) {
        var n3 = t3.geometry, i2 = t3.type, s2 = [];
        if (i2 === "Point" || i2 === "MultiPoint")
          for (var a2 = 0; a2 < n3.length; a2 += 3)
            s2.push(n3[a2]), s2.push(n3[a2 + 1]), e2.numPoints++, e2.numSimplified++;
        else if (i2 === "LineString")
          ye(s2, n3, e2, r3, false, false);
        else if (i2 === "MultiLineString" || i2 === "Polygon")
          for (a2 = 0; a2 < n3.length; a2++)
            ye(s2, n3[a2], e2, r3, i2 === "Polygon", a2 === 0);
        else if (i2 === "MultiPolygon")
          for (var l3 = 0; l3 < n3.length; l3++) {
            var u3 = n3[l3];
            for (a2 = 0; a2 < u3.length; a2++)
              ye(s2, u3[a2], e2, r3, true, a2 === 0);
          }
        if (s2.length) {
          var h3 = t3.tags || null;
          if (i2 === "LineString" && o2.lineMetrics) {
            for (var c2 in h3 = {}, t3.tags)
              h3[c2] = t3.tags[c2];
            h3.mapbox_clip_start = n3.start / n3.size, h3.mapbox_clip_end = n3.end / n3.size;
          }
          var f2 = { geometry: s2, type: i2 === "Polygon" || i2 === "MultiPolygon" ? 3 : i2 === "LineString" || i2 === "MultiLineString" ? 2 : 1, tags: h3 };
          t3.id !== null && (f2.id = t3.id), e2.features.push(f2);
        }
      }
      function ye(e2, t3, r3, o2, n3, i2) {
        var s2 = o2 * o2;
        if (o2 > 0 && t3.size < (n3 ? s2 : o2))
          r3.numPoints += t3.length / 3;
        else {
          for (var a2 = [], l3 = 0; l3 < t3.length; l3 += 3)
            (o2 === 0 || t3[l3 + 2] > s2) && (r3.numSimplified++, a2.push(t3[l3]), a2.push(t3[l3 + 1])), r3.numPoints++;
          n3 && function(e3, t4) {
            for (var r4 = 0, o3 = 0, n4 = e3.length, i3 = n4 - 2; o3 < n4; i3 = o3, o3 += 2)
              r4 += (e3[o3] - e3[i3]) * (e3[o3 + 1] + e3[i3 + 1]);
            if (r4 > 0 === t4)
              for (o3 = 0, n4 = e3.length; o3 < n4 / 2; o3 += 2) {
                var s3 = e3[o3], a3 = e3[o3 + 1];
                e3[o3] = e3[n4 - 2 - o3], e3[o3 + 1] = e3[n4 - 1 - o3], e3[n4 - 2 - o3] = s3, e3[n4 - 1 - o3] = a3;
              }
          }(a2, i2), e2.push(a2);
        }
      }
      function ve2(e2, t3) {
        var r3 = (t3 = this.options = function(e3, t4) {
          for (var r4 in t4)
            e3[r4] = t4[r4];
          return e3;
        }(Object.create(this.options), t3)).debug;
        if (r3 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (t3.promoteId && t3.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var o2 = function(e3, t4) {
          var r4 = [];
          if (e3.type === "FeatureCollection")
            for (var o3 = 0; o3 < e3.features.length; o3++)
              Q2(r4, e3.features[o3], t4, o3);
          else
            Q2(r4, e3.type === "Feature" ? e3 : { geometry: e3 }, t4);
          return r4;
        }(e2, t3);
        this.tiles = {}, this.tileCoords = [], r3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (o2 = function(e3, t4) {
          var r4 = t4.buffer / t4.extent, o3 = e3, n3 = oe2(e3, 1, -1 - r4, r4, 0, -1, 2, t4), i2 = oe2(e3, 1, 1 - r4, 2 + r4, 0, -1, 2, t4);
          return (n3 || i2) && (o3 = oe2(e3, 1, -r4, 1 + r4, 0, -1, 2, t4) || [], n3 && (o3 = ce2(n3, 1).concat(o3)), i2 && (o3 = o3.concat(ce2(i2, -1)))), o3;
        }(o2, t3)).length && this.splitTile(o2, 0, 0, 0), r3 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function xe(e2, t3, r3) {
        return 32 * ((1 << e2) * r3 + t3) + e2;
      }
      function we2(e2, t3) {
        const r3 = e2.tileID.canonical;
        if (!this._geoJSONIndex)
          return t3(null, null);
        const o2 = this._geoJSONIndex.getTile(r3.z, r3.x, r3.y);
        if (!o2)
          return t3(null, null);
        const n3 = new h(o2.features);
        let i2 = d(n3);
        i2.byteOffset === 0 && i2.byteLength === i2.buffer.byteLength || (i2 = new Uint8Array(i2)), t3(null, { vectorTile: n3, rawData: i2.buffer });
      }
      ve2.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, ve2.prototype.splitTile = function(e2, t3, r3, o2, n3, i2, s2) {
        for (var a2 = [e2, t3, r3, o2], l3 = this.options, u3 = l3.debug; a2.length; ) {
          o2 = a2.pop(), r3 = a2.pop(), t3 = a2.pop(), e2 = a2.pop();
          var h3 = 1 << t3, c2 = xe(t3, r3, o2), f2 = this.tiles[c2];
          if (!f2 && (u3 > 1 && console.time("creation"), f2 = this.tiles[c2] = de2(e2, t3, r3, o2, l3), this.tileCoords.push({ z: t3, x: r3, y: o2 }), u3)) {
            u3 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, r3, o2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
            var p3 = "z" + t3;
            this.stats[p3] = (this.stats[p3] || 0) + 1, this.total++;
          }
          if (f2.source = e2, n3) {
            if (t3 === l3.maxZoom || t3 === n3)
              continue;
            var g2 = 1 << n3 - t3;
            if (r3 !== Math.floor(i2 / g2) || o2 !== Math.floor(s2 / g2))
              continue;
          } else if (t3 === l3.indexMaxZoom || f2.numPoints <= l3.indexMaxPoints)
            continue;
          if (f2.source = null, e2.length !== 0) {
            u3 > 1 && console.time("clipping");
            var d2, m3, y3, v3, x3, w2, S3 = 0.5 * l3.buffer / l3.extent, M3 = 0.5 - S3, P3 = 0.5 + S3, b2 = 1 + S3;
            d2 = m3 = y3 = v3 = null, x3 = oe2(e2, h3, r3 - S3, r3 + P3, 0, f2.minX, f2.maxX, l3), w2 = oe2(e2, h3, r3 + M3, r3 + b2, 0, f2.minX, f2.maxX, l3), e2 = null, x3 && (d2 = oe2(x3, h3, o2 - S3, o2 + P3, 1, f2.minY, f2.maxY, l3), m3 = oe2(x3, h3, o2 + M3, o2 + b2, 1, f2.minY, f2.maxY, l3), x3 = null), w2 && (y3 = oe2(w2, h3, o2 - S3, o2 + P3, 1, f2.minY, f2.maxY, l3), v3 = oe2(w2, h3, o2 + M3, o2 + b2, 1, f2.minY, f2.maxY, l3), w2 = null), u3 > 1 && console.timeEnd("clipping"), a2.push(d2 || [], t3 + 1, 2 * r3, 2 * o2), a2.push(m3 || [], t3 + 1, 2 * r3, 2 * o2 + 1), a2.push(y3 || [], t3 + 1, 2 * r3 + 1, 2 * o2), a2.push(v3 || [], t3 + 1, 2 * r3 + 1, 2 * o2 + 1);
          }
        }
      }, ve2.prototype.getTile = function(e2, t3, r3) {
        var o2 = this.options, n3 = o2.extent, i2 = o2.debug;
        if (e2 < 0 || e2 > 24)
          return null;
        var s2 = 1 << e2, a2 = xe(e2, t3 = (t3 % s2 + s2) % s2, r3);
        if (this.tiles[a2])
          return pe2(this.tiles[a2], n3);
        i2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t3, r3);
        for (var l3, u3 = e2, h3 = t3, c2 = r3; !l3 && u3 > 0; )
          u3--, h3 = Math.floor(h3 / 2), c2 = Math.floor(c2 / 2), l3 = this.tiles[xe(u3, h3, c2)];
        return l3 && l3.source ? (i2 > 1 && console.log("found parent tile z%d-%d-%d", u3, h3, c2), i2 > 1 && console.time("drilling down"), this.splitTile(l3.source, u3, h3, c2, e2, t3, r3), i2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? pe2(this.tiles[a2], n3) : null) : null;
      };
      class Se2 extends e.VectorTileWorkerSource {
        constructor(e2, t3, r3, o2, n3) {
          super(e2, t3, r3, o2, we2), n3 && (this.loadGeoJSON = n3);
        }
        loadData(t3, r3) {
          const o2 = t3 && t3.request, n3 = o2 && o2.collectResourceTiming;
          this.loadGeoJSON(t3, (s2, a2) => {
            if (s2 || !a2)
              return r3(s2);
            if (typeof a2 != "object")
              return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
            {
              i(a2, true);
              try {
                if (t3.filter) {
                  const r4 = e.createExpression(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if (r4.result === "error")
                    throw new Error(r4.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                  const o3 = a2.features.filter((e2) => r4.value.evaluate({ zoom: 0 }, e2));
                  a2 = { type: "FeatureCollection", features: o3 };
                }
                this._geoJSONIndex = t3.cluster ? new j(function({ superclusterOptions: t4, clusterProperties: r4 }) {
                  if (!r4 || !t4)
                    return t4;
                  const o3 = {}, n4 = {}, i2 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a3 = Object.keys(r4);
                  for (const t5 of a3) {
                    const [i3, s4] = r4[t5], a4 = e.createExpression(s4), l4 = e.createExpression(typeof i3 == "string" ? [i3, ["accumulated"], ["get", t5]] : i3);
                    o3[t5] = a4.value, n4[t5] = l4.value;
                  }
                  return t4.map = (e2) => {
                    s3.properties = e2;
                    const t5 = {};
                    for (const e3 of a3)
                      t5[e3] = o3[e3].evaluate(i2, s3);
                    return t5;
                  }, t4.reduce = (e2, t5) => {
                    s3.properties = t5;
                    for (const t6 of a3)
                      i2.accumulated = e2[t6], e2[t6] = n4[t6].evaluate(i2, s3);
                  }, t4;
                }(t3)).load(a2.features) : function(e2, t4) {
                  return new ve2(e2, t4);
                }(a2, t3.geojsonVtOptions);
              } catch (s3) {
                return r3(s3);
              }
              this.loaded = {};
              const l3 = {};
              if (n3) {
                const r4 = e.getPerformanceMeasurement(o2);
                r4 && (l3.resourceTiming = {}, l3.resourceTiming[t3.source] = JSON.parse(JSON.stringify(r4)));
              }
              r3(null, l3);
            }
          });
        }
        reloadTile(e2, t3) {
          const r3 = this.loaded;
          return r3 && r3[e2.uid] ? super.reloadTile(e2, t3) : this.loadTile(e2, t3);
        }
        loadGeoJSON(t3, r3) {
          if (t3.request)
            e.getJSON(t3.request, r3);
          else {
            if (typeof t3.data != "string")
              return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
            try {
              return r3(null, JSON.parse(t3.data));
            } catch (e2) {
              return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
          } catch (e3) {
            t3(e3);
          }
        }
        getClusterChildren(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getChildren(e2.clusterId));
          } catch (e3) {
            t3(e3);
          }
        }
        getClusterLeaves(e2, t3) {
          try {
            t3(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
          } catch (e3) {
            t3(e3);
          }
        }
      }
      class Me2 {
        constructor(t3) {
          this.self = t3, this.actor = new e.Actor(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: Se2 }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t4) => {
            if (this.workerSourceTypes[e2])
              throw new Error(`Worker source with name "${e2}" already registered.`);
            this.workerSourceTypes[e2] = t4;
          }, this.self.registerRTLTextPlugin = (t4) => {
            if (e.plugin.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.plugin.applyArabicShaping = t4.applyArabicShaping, e.plugin.processBidirectionalText = t4.processBidirectionalText, e.plugin.processStyledBidirectionalText = t4.processStyledBidirectionalText;
          };
        }
        clearCaches(e2, t3, r3) {
          delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.workerSources[e2], delete this.demWorkerSources[e2], r3();
        }
        checkIfReady(e2, t3, r3) {
          r3();
        }
        setReferrer(e2, t3) {
          this.referrer = t3;
        }
        spriteLoaded(t3, r3) {
          this.isSpriteLoaded[t3] = r3;
          for (const o2 in this.workerSources[t3]) {
            const n3 = this.workerSources[t3][o2];
            for (const t4 in n3)
              n3[t4] instanceof e.VectorTileWorkerSource && (n3[t4].isSpriteLoaded = r3, n3[t4].fire(new e.Event("isSpriteLoaded")));
          }
        }
        setImages(e2, t3, r3) {
          this.availableImages[e2] = t3;
          for (const r4 in this.workerSources[e2]) {
            const o2 = this.workerSources[e2][r4];
            for (const e3 in o2)
              o2[e3].availableImages = t3;
          }
          r3();
        }
        enableTerrain(e2, t3, r3) {
          this.terrain = t3, r3();
        }
        setProjection(t3, r3) {
          this.projections[t3] = e.getProjection(r3);
        }
        setLayers(e2, t3, r3) {
          this.getLayerIndex(e2).replace(t3), r3();
        }
        updateLayers(e2, t3, r3) {
          this.getLayerIndex(e2).update(t3.layers, t3.removedIds), r3();
        }
        loadTile(t3, r3, o2) {
          const n3 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r3) : r3;
          n3.projection = this.projections[t3] || this.defaultProjection, this.getWorkerSource(t3, r3.type, r3.source).loadTile(n3, o2);
        }
        loadDEMTile(t3, r3, o2) {
          const n3 = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r3) : r3;
          this.getDEMWorkerSource(t3, r3.source).loadTile(n3, o2);
        }
        reloadTile(t3, r3, o2) {
          const n3 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r3) : r3;
          n3.projection = this.projections[t3] || this.defaultProjection, this.getWorkerSource(t3, r3.type, r3.source).reloadTile(n3, o2);
        }
        abortTile(e2, t3, r3) {
          this.getWorkerSource(e2, t3.type, t3.source).abortTile(t3, r3);
        }
        removeTile(e2, t3, r3) {
          this.getWorkerSource(e2, t3.type, t3.source).removeTile(t3, r3);
        }
        removeSource(e2, t3, r3) {
          if (!this.workerSources[e2] || !this.workerSources[e2][t3.type] || !this.workerSources[e2][t3.type][t3.source])
            return;
          const o2 = this.workerSources[e2][t3.type][t3.source];
          delete this.workerSources[e2][t3.type][t3.source], o2.removeSource !== void 0 ? o2.removeSource(t3, r3) : r3();
        }
        loadWorkerSource(e2, t3, r3) {
          try {
            this.self.importScripts(t3.url), r3();
          } catch (e3) {
            r3(e3.toString());
          }
        }
        syncRTLPluginState(t3, r3, o2) {
          try {
            e.plugin.setState(r3);
            const t4 = e.plugin.getPluginURL();
            if (e.plugin.isLoaded() && !e.plugin.isParsed() && t4 != null) {
              this.self.importScripts(t4);
              const r4 = e.plugin.isParsed();
              o2(r4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), r4);
            }
          } catch (e2) {
            o2(e2.toString());
          }
        }
        getAvailableImages(e2) {
          let t3 = this.availableImages[e2];
          return t3 || (t3 = []), t3;
        }
        getLayerIndex(e2) {
          let t3 = this.layerIndexes[e2];
          return t3 || (t3 = this.layerIndexes[e2] = new o()), t3;
        }
        getWorkerSource(e2, t3, r3) {
          return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t3] || (this.workerSources[e2][t3] = {}), this.workerSources[e2][t3][r3] || (this.workerSources[e2][t3][r3] = new this.workerSourceTypes[t3]({ send: (t4, r4, o2, n3, i2, s2) => {
            this.actor.send(t4, r4, o2, e2, i2, s2);
          }, scheduler: this.actor.scheduler }, this.getLayerIndex(e2), this.getAvailableImages(e2), this.isSpriteLoaded[e2])), this.workerSources[e2][t3][r3];
        }
        getDEMWorkerSource(e2, t3) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t3] || (this.demWorkerSources[e2][t3] = new n2()), this.demWorkerSources[e2][t3];
        }
        enforceCacheSizeLimit(t3, r3) {
          e.enforceCacheSizeLimit(r3);
        }
        getWorkerPerformanceMetrics(e2, t3, r3) {
          r3(void 0, void 0);
        }
      }
      return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope && (self.worker = new Me2(self)), Me2;
    });
    define(["./shared"], function(e) {
      function t2(e2, i2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(i2) || e2.length !== i2.length)
            return false;
          for (let o2 = 0; o2 < e2.length; o2++)
            if (!t2(e2[o2], i2[o2]))
              return false;
          return true;
        }
        if (typeof e2 == "object" && e2 !== null && i2 !== null) {
          if (typeof i2 != "object")
            return false;
          if (Object.keys(e2).length !== Object.keys(i2).length)
            return false;
          for (const o2 in e2)
            if (!t2(e2[o2], i2[o2]))
              return false;
          return true;
        }
        return e2 === i2;
      }
      var i = o;
      function o(e2) {
        return !function(e3) {
          return typeof window == "undefined" || typeof document == "undefined" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return false;
            var e4, t4, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
            try {
              t4 = new Worker(o2), e4 = true;
            } catch (t5) {
              e4 = false;
            }
            return t4 && t4.terminate(), URL.revokeObjectURL(o2), e4;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var e4 = document.createElement("canvas");
            e4.width = e4.height = 1;
            var t4 = e4.getContext("2d");
            if (!t4)
              return false;
            var i2 = t4.getImageData(0, 0, 1, 1);
            return i2 && i2.width === e4.width;
          }() ? (r2[t3 = e3 && e3.failIfMajorPerformanceCaveat] === void 0 && (r2[t3] = function(e4) {
            var t4, i2 = function(e5) {
              var t5 = document.createElement("canvas"), i3 = Object.create(o.webGLContextAttributes);
              return i3.failIfMajorPerformanceCaveat = e5, t5.getContext("webgl", i3) || t5.getContext("experimental-webgl", i3);
            }(e4);
            if (!i2)
              return false;
            try {
              t4 = i2.createShader(i2.VERTEX_SHADER);
            } catch (e5) {
              return false;
            }
            return !(!t4 || i2.isContextLost()) && (i2.shaderSource(t4, "void main() {}"), i2.compileShader(t4), i2.getShaderParameter(t4, i2.COMPILE_STATUS) === true);
          }(t3)), r2[t3] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var t3;
        }(e2);
      }
      var r2 = {};
      function n2(t3, i2, o2) {
        const r3 = e.window.document.createElement(t3);
        return i2 !== void 0 && (r3.className = i2), o2 && o2.appendChild(r3), r3;
      }
      function a(t3, i2, o2) {
        const r3 = e.window.document.createElementNS("http://www.w3.org/2000/svg", t3);
        for (const e2 of Object.keys(i2))
          r3.setAttributeNS(null, e2, i2[e2]);
        return o2 && o2.appendChild(r3), r3;
      }
      o.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
      const s = e.window.document && e.window.document.documentElement.style, l2 = s && s.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
      let c;
      function h() {
        s && l2 && (c = s[l2], s[l2] = "none");
      }
      function u2() {
        s && l2 && (s[l2] = c);
      }
      function _(t3) {
        t3.preventDefault(), t3.stopPropagation(), e.window.removeEventListener("click", _, true);
      }
      function d() {
        e.window.addEventListener("click", _, true), e.window.setTimeout(() => {
          e.window.removeEventListener("click", _, true);
        }, 0);
      }
      function p2(e2, t3) {
        const i2 = e2.getBoundingClientRect();
        return g(e2, i2, t3);
      }
      function m2(e2, t3) {
        const i2 = e2.getBoundingClientRect(), o2 = [];
        for (let r3 = 0; r3 < t3.length; r3++)
          o2.push(g(e2, i2, t3[r3]));
        return o2;
      }
      function f(t3) {
        return e.window.InstallTrigger !== void 0 && t3.button === 2 && t3.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t3.button;
      }
      function g(t3, i2, o2) {
        const r3 = t3.offsetWidth === i2.width ? 1 : t3.offsetWidth / i2.width;
        return new e.pointGeometry((o2.clientX - i2.left) * r3, (o2.clientY - i2.top) * r3);
      }
      function v2(e2, t3) {
        var i2 = t3[0], o2 = t3[1], r3 = t3[2], n3 = t3[3], a2 = i2 * n3 - r3 * o2;
        return a2 ? (e2[0] = n3 * (a2 = 1 / a2), e2[1] = -o2 * a2, e2[2] = -r3 * a2, e2[3] = i2 * a2, e2) : null;
      }
      function x2(e2) {
        const { userImage: t3 } = e2;
        return !!(t3 && t3.render && t3.render()) && (e2.data.replace(new Uint8Array(t3.data.buffer)), true);
      }
      class y2 extends e.Evented {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e2) {
          if (this.loaded !== e2 && (this.loaded = e2, e2)) {
            for (const { ids: e3, callback: t3 } of this.requestors)
              this._notify(e3, t3);
            this.requestors = [];
          }
        }
        hasImage(e2) {
          return !!this.getImage(e2);
        }
        getImage(e2) {
          return this.images[e2];
        }
        addImage(e2, t3) {
          this._validate(e2, t3) && (this.images[e2] = t3);
        }
        _validate(t3, i2) {
          let o2 = true;
          return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t3}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t3}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.ErrorEvent(new Error(`Image "${t3}" has invalid "content" value`))), o2 = false), o2;
        }
        _validateStretch(e2, t3) {
          if (!e2)
            return true;
          let i2 = 0;
          for (const o2 of e2) {
            if (o2[0] < i2 || o2[1] < o2[0] || t3 < o2[1])
              return false;
            i2 = o2[1];
          }
          return true;
        }
        _validateContent(e2, t3) {
          return !(e2 && (e2.length !== 4 || e2[0] < 0 || t3.data.width < e2[0] || e2[1] < 0 || t3.data.height < e2[1] || e2[2] < 0 || t3.data.width < e2[2] || e2[3] < 0 || t3.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
        }
        updateImage(e2, t3) {
          t3.version = this.images[e2].version + 1, this.images[e2] = t3, this.updatedImages[e2] = true;
        }
        removeImage(e2) {
          const t3 = this.images[e2];
          delete this.images[e2], delete this.patterns[e2], t3.userImage && t3.userImage.onRemove && t3.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e2, t3) {
          let i2 = true;
          if (!this.isLoaded())
            for (const t4 of e2)
              this.images[t4] || (i2 = false);
          this.isLoaded() || i2 ? this._notify(e2, t3) : this.requestors.push({ ids: e2, callback: t3 });
        }
        _notify(t3, i2) {
          const o2 = {};
          for (const i3 of t3) {
            this.images[i3] || this.fire(new e.Event("styleimagemissing", { id: i3 }));
            const t4 = this.images[i3];
            t4 ? o2[i3] = { data: t4.data.clone(), pixelRatio: t4.pixelRatio, sdf: t4.sdf, version: t4.version, stretchX: t4.stretchX, stretchY: t4.stretchY, content: t4.content, hasRenderCallback: Boolean(t4.userImage && t4.userImage.render) } : e.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          i2(null, o2);
        }
        getPixelSize() {
          const { width: e2, height: t3 } = this.atlasImage;
          return { width: e2, height: t3 };
        }
        getPattern(t3) {
          const i2 = this.patterns[t3], o2 = this.getImage(t3);
          if (!o2)
            return null;
          if (i2 && i2.position.version === o2.version)
            return i2.position;
          if (i2)
            i2.position.version = o2.version;
          else {
            const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r3 = new e.ImagePosition(i3, o2);
            this.patterns[t3] = { bin: i3, position: r3 };
          }
          return this._updatePatternAtlas(), this.patterns[t3].position;
        }
        bind(t3) {
          const i2 = t3.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e.Texture(t3, this.atlasImage, i2.RGBA), this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t3 = [];
          for (const e2 in this.patterns)
            t3.push(this.patterns[e2].bin);
          const { w: i2, h: o2 } = e.potpack(t3), r3 = this.atlasImage;
          r3.resize({ width: i2 || 1, height: o2 || 1 });
          for (const t4 in this.patterns) {
            const { bin: i3 } = this.patterns[t4], o3 = i3.x + 1, n3 = i3.y + 1, a2 = this.images[t4].data, s2 = a2.width, l3 = a2.height;
            e.RGBAImage.copy(a2, r3, { x: 0, y: 0 }, { x: o3, y: n3 }, { width: s2, height: l3 }), e.RGBAImage.copy(a2, r3, { x: 0, y: l3 - 1 }, { x: o3, y: n3 - 1 }, { width: s2, height: 1 }), e.RGBAImage.copy(a2, r3, { x: 0, y: 0 }, { x: o3, y: n3 + l3 }, { width: s2, height: 1 }), e.RGBAImage.copy(a2, r3, { x: s2 - 1, y: 0 }, { x: o3 - 1, y: n3 }, { width: 1, height: l3 }), e.RGBAImage.copy(a2, r3, { x: 0, y: 0 }, { x: o3 + s2, y: n3 }, { width: 1, height: l3 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e2) {
          for (const t3 of e2) {
            if (this.callbackDispatchedThisFrame[t3])
              continue;
            this.callbackDispatchedThisFrame[t3] = true;
            const e3 = this.images[t3];
            x2(e3) && this.updateImage(t3, e3);
          }
        }
      }
      const b = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class {
        constructor() {
          this.specification = e.spec.light.position;
        }
        possiblyEvaluate(t3, i2) {
          return function([t4, i3, o2]) {
            const r3 = e.degToRad(i3 + 90), n3 = e.degToRad(o2);
            return { x: t4 * Math.cos(r3) * Math.sin(n3), y: t4 * Math.sin(r3) * Math.sin(n3), z: t4 * Math.cos(n3), azimuthal: i3, polar: o2 };
          }(t3.expression.evaluate(i2));
        }
        interpolate(t3, i2, o2) {
          return { x: e.number(t3.x, i2.x, o2), y: e.number(t3.y, i2.y, o2), z: e.number(t3.z, i2.z, o2), azimuthal: e.number(t3.azimuthal, i2.azimuthal, o2), polar: e.number(t3.polar, i2.polar, o2) };
        }
      }(), color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) }), w = "-transition";
      class T2 extends e.Evented {
        constructor(t3) {
          super(), this._transitionable = new e.Transitionable(b), this.setLight(t3), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t3, i2 = {}) {
          if (!this._validate(e.validateLight, t3, i2))
            for (const i3 in t3) {
              const o2 = t3[i3];
              e.endsWith(i3, w) ? this._transitionable.setTransition(i3.slice(0, -w.length), o2) : this._transitionable.setValue(i3, o2);
            }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(t3, i2, o2) {
          return (!o2 || o2.validate !== false) && e.emitValidationErrors(this, t3.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
        }
      }
      const E2 = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) }), C2 = "-transition";
      class I2 extends e.Evented {
        constructor(t3, i2) {
          super(), this._transitionable = new e.Transitionable(E2), this.set(t3), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t3) {
          for (const i2 in t3) {
            const o2 = t3[i2];
            e.endsWith(i2, C2) ? this._transitionable.setTransition(i2.slice(0, -C2.length), o2) : this._transitionable.setValue(i2, o2);
          }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
      }
      function M2(t3, i2, o2, r3) {
        const n3 = e.smoothstep(45, 65, o2), [a2, s2] = S2(t3, r3), l3 = e.length(i2);
        let c2 = 1 - Math.min(1, Math.exp((l3 - a2) / (s2 - a2) * -6));
        return c2 *= c2 * c2, c2 = Math.min(1, 1.00747 * c2), c2 * n3 * t3.alpha;
      }
      function S2(e2, t3) {
        const i2 = 0.5 / Math.tan(0.5 * t3);
        return [e2.range[0] + i2, e2.range[1] + i2];
      }
      const z2 = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]), "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]), "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"]) }), D2 = "-transition";
      class P2 extends e.Evented {
        constructor(t3, i2) {
          super(), this._transitionable = new e.Transitionable(z2), this.set(t3), this._transitioning = this._transitionable.untransitioned(), this._transform = i2;
        }
        get state() {
          const t3 = this._transform, i2 = t3.projection.name === "globe", o2 = e.globeToMercatorTransition(t3.zoom), r3 = this.properties.get("range"), n3 = [0.5, 3];
          return { range: i2 ? [e.number(n3[0], r3[0], o2), e.number(n3[1], r3[1], o2)] : r3, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t3, i2 = {}) {
          if (!this._validate(e.validateFog, t3, i2)) {
            for (const i3 of Object.keys(e.spec.fog))
              t3 && t3[i3] === void 0 && (t3[i3] = e.spec.fog[i3].default);
            for (const i3 in t3) {
              const o2 = t3[i3];
              e.endsWith(i3, D2) ? this._transitionable.setTransition(i3.slice(0, -D2.length), o2) : this._transitionable.setValue(i3, o2);
            }
          }
        }
        getOpacity(t3) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const i2 = this.properties && this.properties.get("color") || 1;
          return (this._transform.projection.name === "globe" ? 1 : e.smoothstep(45, 65, t3)) * i2.a;
        }
        getOpacityAtLatLng(t3, i2) {
          return this._transform.projection.supportsFog ? function(t4, i3, o2) {
            const r3 = e.MercatorCoordinate.fromLngLat(i3), n3 = o2.elevation ? o2.elevation.getAtPointOrZero(r3) : 0, a2 = [r3.x, r3.y, n3];
            return e.transformMat4(a2, a2, o2.mercatorFogMatrix), M2(t4, a2, o2.pitch, o2._fov);
          }(this.state, t3, i2) : 0;
        }
        getFovAdjustedRange(e2) {
          return this._transform.projection.supportsFog ? S2(this.state, e2) : [0, 1];
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(t3, i2, o2) {
          return (!o2 || o2.validate !== false) && e.emitValidationErrors(this, t3.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
        }
      }
      class A2 {
        constructor(t3, i2) {
          this.workerPool = t3, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
          const o2 = this.workerPool.acquire(this.id);
          for (let e2 = 0; e2 < o2.length; e2++) {
            const t4 = new A2.Actor(o2[e2], i2, this.id);
            t4.name = `Worker ${e2}`, this.actors.push(t4);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(t3, i2, o2) {
          e.asyncAll(this.actors, (e2, o3) => {
            e2.send(t3, i2, o3);
          }, o2 = o2 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((e2) => {
            e2.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      function L2(t3, i2, o2) {
        return i2 * (e.EXTENT / (t3.tileSize * Math.pow(2, o2 - t3.tileID.overscaledZ)));
      }
      A2.Actor = e.Actor;
      class R2 {
        constructor(e2, t3, i2, o2) {
          this.screenBounds = e2, this.cameraPoint = t3, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
        }
        static createFromScreenPoints(t3, i2) {
          let o2, r3;
          if (t3 instanceof e.pointGeometry || typeof t3[0] == "number") {
            const n3 = e.pointGeometry.convert(t3);
            o2 = [e.pointGeometry.convert(t3)], r3 = i2.isPointAboveHorizon(n3);
          } else {
            const n3 = e.pointGeometry.convert(t3[0]), a2 = e.pointGeometry.convert(t3[1]);
            o2 = [n3, a2], r3 = e.polygonizeBounds(n3, a2).every((e2) => i2.isPointAboveHorizon(e2));
          }
          return new R2(o2, i2.getCameraPoint(), r3, i2);
        }
        isPointQuery() {
          return this.screenBounds.length === 1;
        }
        bufferedScreenGeometry(t3) {
          return e.polygonizeBounds(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t3);
        }
        bufferedCameraGeometry(t3) {
          const i2 = this.screenBounds[0], o2 = this.screenBounds.length === 1 ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r3 = e.polygonizeBounds(i2, o2, 0, false);
          return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r3.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r3[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r3[3] = this.cameraPoint)), e.bufferConvexPolygon(r3, t3);
        }
        bufferedCameraGeometryGlobe(t3) {
          const i2 = this.screenBounds[0], o2 = this.screenBounds.length === 1 ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r3 = e.polygonizeBounds(i2, o2, t3), n3 = this.cameraPoint.clone();
          switch (3 * ((n3.y > i2.y) + (n3.y > o2.y)) + ((n3.x > i2.x) + (n3.x > o2.x))) {
            case 0:
              r3[0] = n3, r3[4] = n3.clone();
              break;
            case 1:
              r3.splice(1, 0, n3);
              break;
            case 2:
              r3[1] = n3;
              break;
            case 3:
              r3.splice(4, 0, n3);
              break;
            case 5:
              r3.splice(2, 0, n3);
              break;
            case 6:
              r3[3] = n3;
              break;
            case 7:
              r3.splice(3, 0, n3);
              break;
            case 8:
              r3[2] = n3;
          }
          return r3;
        }
        containsTile(t3, i2, o2, r3 = 0) {
          const n3 = t3.queryPadding / i2._pixelsPerMercatorPixel + 1, a2 = o2 ? this._bufferedCameraMercator(n3, i2) : this._bufferedScreenMercator(n3, i2);
          let s2 = t3.tileID.wrap + (a2.unwrapped ? r3 : 0);
          const l3 = a2.polygon.map((i3) => e.getTilePoint(t3.tileTransform, i3, s2));
          if (!e.polygonIntersectsBox(l3, 0, 0, e.EXTENT, e.EXTENT))
            return;
          s2 = t3.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r3 : 0);
          const c2 = this.screenGeometryMercator.polygon.map((i3) => e.getTileVec3(t3.tileTransform, i3, s2)), h3 = c2.map((t4) => new e.pointGeometry(t4[0], t4[1])), u3 = i2.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0), _2 = e.getTileVec3(t3.tileTransform, u3, s2), d2 = c2.map((t4) => {
            const i3 = e.sub(t4, t4, _2);
            return e.normalize(i3, i3), new e.Ray(_2, i3);
          }), p3 = L2(t3, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: h3, tilespaceRays: d2, bufferedTilespaceGeometry: l3, bufferedTilespaceBounds: (m3 = e.getBounds(l3), m3.min.x = e.clamp(m3.min.x, 0, e.EXTENT), m3.min.y = e.clamp(m3.min.y, 0, e.EXTENT), m3.max.x = e.clamp(m3.max.x, 0, e.EXTENT), m3.max.y = e.clamp(m3.max.y, 0, e.EXTENT), m3), tile: t3, tileID: t3.tileID, pixelToTileUnitsFactor: p3 };
          var m3;
        }
        _bufferedScreenMercator(e2, t3) {
          const i2 = k(e2);
          if (this._screenRaycastCache[i2])
            return this._screenRaycastCache[i2];
          {
            let o2;
            return o2 = t3.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(e2), t3) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t3.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
          }
        }
        _bufferedCameraMercator(e2, t3) {
          const i2 = k(e2);
          if (this._cameraRaycastCache[i2])
            return this._cameraRaycastCache[i2];
          {
            let o2;
            return o2 = t3.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t3) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t3.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
          }
        }
        _projectAndResample(t3, i2) {
          const o2 = function(t4, i3) {
            const o3 = e.multiply([], i3.pixelMatrix, i3.globeMatrix), r4 = [0, -e.GLOBE_RADIUS, 0, 1], n3 = [0, e.GLOBE_RADIUS, 0, 1], a2 = [0, 0, 0, 1];
            e.transformMat4$1(r4, r4, o3), e.transformMat4$1(n3, n3, o3), e.transformMat4$1(a2, a2, o3);
            const s2 = new e.pointGeometry(r4[0] / r4[3], r4[1] / r4[3]), l3 = new e.pointGeometry(n3[0] / n3[3], n3[1] / n3[3]), c2 = e.polygonContainsPoint(t4, s2) && r4[3] < a2[3], h3 = e.polygonContainsPoint(t4, l3) && n3[3] < a2[3];
            if (!c2 && !h3)
              return null;
            const u3 = function(e2, t5, i4) {
              for (let o4 = 1; o4 < e2.length; o4++) {
                const r5 = B2(t5.pointCoordinate3D(e2[o4 - 1]).x), n4 = B2(t5.pointCoordinate3D(e2[o4]).x);
                if (i4 < 0) {
                  if (r5 < n4)
                    return { idx: o4, t: -r5 / (n4 - 1 - r5) };
                } else if (n4 < r5)
                  return { idx: o4, t: (1 - r5) / (n4 + 1 - r5) };
              }
              return null;
            }(t4, i3, c2 ? -1 : 1);
            if (!u3)
              return null;
            const { idx: _2, t: d2 } = u3;
            let p3 = _2 > 1 ? O2(t4.slice(0, _2), i3) : [], m3 = _2 < t4.length ? O2(t4.slice(_2), i3) : [];
            p3 = p3.map((t5) => new e.pointGeometry(B2(t5.x), t5.y)), m3 = m3.map((t5) => new e.pointGeometry(B2(t5.x), t5.y));
            const f2 = [...p3];
            f2.length === 0 && f2.push(m3[m3.length - 1]);
            const g2 = e.number(f2[f2.length - 1].y, (m3.length === 0 ? p3[0] : m3[0]).y, d2);
            let v3;
            return v3 = c2 ? [new e.pointGeometry(0, g2), new e.pointGeometry(0, 0), new e.pointGeometry(1, 0), new e.pointGeometry(1, g2)] : [new e.pointGeometry(1, g2), new e.pointGeometry(1, 1), new e.pointGeometry(0, 1), new e.pointGeometry(0, g2)], f2.push(...v3), m3.length === 0 ? f2.push(p3[0]) : f2.push(...m3), { polygon: f2.map((t5) => new e.MercatorCoordinate(t5.x, t5.y)), unwrapped: false };
          }(t3, i2);
          if (o2)
            return o2;
          const r3 = function(t4, i3) {
            let o3 = false, r4 = -1 / 0, n3 = 0;
            for (let e2 = 0; e2 < t4.length - 1; e2++)
              t4[e2].x > r4 && (r4 = t4[e2].x, n3 = e2);
            for (let e2 = 0; e2 < t4.length - 1; e2++) {
              const i4 = (n3 + e2) % (t4.length - 1), r5 = t4[i4], a3 = t4[i4 + 1];
              Math.abs(r5.x - a3.x) > 0.5 && (r5.x < a3.x ? (r5.x += 1, i4 === 0 && (t4[t4.length - 1].x += 1)) : (a3.x += 1, i4 + 1 === t4.length - 1 && (t4[0].x += 1)), o3 = true);
            }
            const a2 = e.mercatorXfromLng(i3.center.lng);
            return o3 && a2 < Math.abs(a2 - 1) && t4.forEach((e2) => {
              e2.x -= 1;
            }), { polygon: t4, unwrapped: o3 };
          }(O2(t3, i2).map((t4) => new e.pointGeometry(B2(t4.x), t4.y)), i2);
          return { polygon: r3.polygon.map((t4) => new e.MercatorCoordinate(t4.x, t4.y)), unwrapped: r3.unwrapped };
        }
      }
      function O2(t3, i2) {
        return e.resample(t3, (e2) => {
          const t4 = i2.pointCoordinate3D(e2);
          e2.x = t4.x, e2.y = t4.y;
        }, 1 / 256);
      }
      function B2(e2) {
        return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
      }
      function k(e2) {
        return 100 * e2 | 0;
      }
      function F2(t3, i2, o2, r3, n3) {
        const a2 = function(o3, r4) {
          if (o3)
            return n3(o3);
          if (r4) {
            const o4 = e.pick(e.extend(r4, t3), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            r4.vector_layers && (o4.vectorLayers = r4.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e2) => e2.id)), r4.language_options && (o4.languageOptions = r4.language_options), r4.language && r4.language[r4.id] && (o4.language = r4.language[r4.id]), r4.worldview_options && (o4.worldviewOptions = r4.worldview_options), r4.worldview ? o4.worldview = r4.worldview[r4.id] : r4.worldview_default && (o4.worldview = r4.worldview_default), o4.tiles = i2.canonicalizeTileset(o4, t3.url), n3(null, o4);
          }
        };
        return t3.url ? e.getJSON(i2.transformRequest(i2.normalizeSourceURL(t3.url, null, o2, r3), e.ResourceType.Source), a2) : e.exported.frame(() => a2(null, t3));
      }
      class U2 {
        constructor(t3, i2, o2) {
          this.bounds = e.LngLatBounds.convert(this.validateBounds(t3)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
        }
        validateBounds(e2) {
          return Array.isArray(e2) && e2.length === 4 ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
        }
        contains(t3) {
          const i2 = Math.pow(2, t3.z), o2 = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i2), r3 = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i2), n3 = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i2), a2 = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i2);
          return t3.x >= o2 && t3.x < n3 && t3.y >= r3 && t3.y < a2;
        }
      }
      class N2 {
        constructor(e2, t3, i2) {
          this.context = e2;
          const o2 = e2.gl;
          this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || t3.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t3 = this.context.gl;
          this.context.unbindVAO(), this.bind(), t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const G2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class j {
        constructor(e2, t3, i2, o2) {
          this.length = t3.length, this.attributes = i2, this.itemSize = t3.bytesPerElement, this.dynamicDraw = o2, this.context = e2;
          const r3 = e2.gl;
          this.buffer = r3.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r3.bufferData(r3.ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? r3.DYNAMIC_DRAW : r3.STATIC_DRAW), this.dynamicDraw || t3.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t3 = this.context.gl;
          this.bind(), t3.bufferSubData(t3.ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        enableAttributes(e2, t3) {
          for (let i2 = 0; i2 < this.attributes.length; i2++) {
            const o2 = t3.attributes[this.attributes[i2].name];
            o2 !== void 0 && e2.enableVertexAttribArray(o2);
          }
        }
        setVertexAttribPointers(e2, t3, i2) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const r3 = this.attributes[o2], n3 = t3.attributes[r3.name];
            n3 !== void 0 && e2.vertexAttribPointer(n3, r3.components, e2[G2[r3.type]], false, this.itemSize, r3.offset + this.itemSize * (i2 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class Z2 {
        constructor(e2) {
          this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e2) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class V2 extends Z2 {
        getDefault() {
          return e.Color.transparent;
        }
        set(e2) {
          const t3 = this.current;
          (e2.r !== t3.r || e2.g !== t3.g || e2.b !== t3.b || e2.a !== t3.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class W2 extends Z2 {
        getDefault() {
          return 1;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
        }
      }
      class X2 extends Z2 {
        getDefault() {
          return 0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
        }
      }
      class q2 extends Z2 {
        getDefault() {
          return [true, true, true, true];
        }
        set(e2) {
          const t3 = this.current;
          (e2[0] !== t3[0] || e2[1] !== t3[1] || e2[2] !== t3[2] || e2[3] !== t3[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class $ extends Z2 {
        getDefault() {
          return true;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class H2 extends Z2 {
        getDefault() {
          return 255;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class Y2 extends Z2 {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e2) {
          const t3 = this.current;
          (e2.func !== t3.func || e2.ref !== t3.ref || e2.mask !== t3.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
        }
      }
      class K2 extends Z2 {
        getDefault() {
          const e2 = this.gl;
          return [e2.KEEP, e2.KEEP, e2.KEEP];
        }
        set(e2) {
          const t3 = this.current;
          (e2[0] !== t3[0] || e2[1] !== t3[1] || e2[2] !== t3[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
        }
      }
      class J2 extends Z2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e2 ? t3.enable(t3.STENCIL_TEST) : t3.disable(t3.STENCIL_TEST), this.current = e2, this.dirty = false;
        }
      }
      class Q2 extends Z2 {
        getDefault() {
          return [0, 1];
        }
        set(e2) {
          const t3 = this.current;
          (e2[0] !== t3[0] || e2[1] !== t3[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class ee2 extends Z2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e2 ? t3.enable(t3.DEPTH_TEST) : t3.disable(t3.DEPTH_TEST), this.current = e2, this.dirty = false;
        }
      }
      class te2 extends Z2 {
        getDefault() {
          return this.gl.LESS;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
        }
      }
      class ie2 extends Z2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e2 ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), this.current = e2, this.dirty = false;
        }
      }
      class oe2 extends Z2 {
        getDefault() {
          const e2 = this.gl;
          return [e2.ONE, e2.ZERO];
        }
        set(e2) {
          const t3 = this.current;
          (e2[0] !== t3[0] || e2[1] !== t3[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class re2 extends Z2 {
        getDefault() {
          return e.Color.transparent;
        }
        set(e2) {
          const t3 = this.current;
          (e2.r !== t3.r || e2.g !== t3.g || e2.b !== t3.b || e2.a !== t3.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class ne2 extends Z2 {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
        }
      }
      class ae2 extends Z2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e2 ? t3.enable(t3.CULL_FACE) : t3.disable(t3.CULL_FACE), this.current = e2, this.dirty = false;
        }
      }
      class se2 extends Z2 {
        getDefault() {
          return this.gl.BACK;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class le2 extends Z2 {
        getDefault() {
          return this.gl.CCW;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class ce2 extends Z2 {
        getDefault() {
          return null;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
        }
      }
      class he2 extends Z2 {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
        }
      }
      class ue2 extends Z2 {
        getDefault() {
          const e2 = this.gl;
          return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
        }
        set(e2) {
          const t3 = this.current;
          (e2[0] !== t3[0] || e2[1] !== t3[1] || e2[2] !== t3[2] || e2[3] !== t3[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class _e extends Z2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindFramebuffer(t3.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class de2 extends Z2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindRenderbuffer(t3.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class pe2 extends Z2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindTexture(t3.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
        }
      }
      class me2 extends Z2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindBuffer(t3.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class fe2 extends Z2 {
        getDefault() {
          return null;
        }
        set(e2) {
          const t3 = this.gl;
          t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class ge2 extends Z2 {
        constructor(e2) {
          super(e2), this.vao = e2.extVertexArrayObject;
        }
        getDefault() {
          return null;
        }
        set(e2) {
          this.vao && (e2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e2), this.current = e2, this.dirty = false);
        }
      }
      class ve2 extends Z2 {
        getDefault() {
          return 4;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.pixelStorei(t3.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
        }
      }
      class xe extends Z2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class ye extends Z2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class be2 extends Z2 {
        constructor(e2, t3) {
          super(e2), this.context = e2, this.parent = t3;
        }
        getDefault() {
          return null;
        }
      }
      class we2 extends be2 {
        setDirty() {
          this.dirty = true;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t3 = this.gl;
          t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
        }
      }
      class Te2 extends be2 {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t3 = this.gl;
          t3.framebufferRenderbuffer(t3.FRAMEBUFFER, this.attachment(), t3.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class Ee2 extends Te2 {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class Ce2 {
        constructor(e2, t3, i2, o2) {
          this.context = e2, this.width = t3, this.height = i2;
          const r3 = this.framebuffer = e2.gl.createFramebuffer();
          this.colorAttachment = new we2(e2, r3), o2 && (this.depthAttachment = new Te2(e2, r3));
        }
        destroy() {
          const e2 = this.context.gl, t3 = this.colorAttachment.get();
          if (t3 && e2.deleteTexture(t3), this.depthAttachment) {
            const t4 = this.depthAttachment.get();
            t4 && e2.deleteRenderbuffer(t4);
          }
          e2.deleteFramebuffer(this.framebuffer);
        }
      }
      class Ie2 {
        constructor(e2) {
          this.gl = e2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V2(this), this.clearDepth = new W2(this), this.clearStencil = new X2(this), this.colorMask = new q2(this), this.depthMask = new $(this), this.stencilMask = new H2(this), this.stencilFunc = new Y2(this), this.stencilOp = new K2(this), this.stencilTest = new J2(this), this.depthRange = new Q2(this), this.depthTest = new ee2(this), this.depthFunc = new te2(this), this.blend = new ie2(this), this.blendFunc = new oe2(this), this.blendColor = new re2(this), this.blendEquation = new ne2(this), this.cullFace = new ae2(this), this.cullFaceSide = new se2(this), this.frontFace = new le2(this), this.program = new ce2(this), this.activeTexture = new he2(this), this.viewport = new ue2(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de2(this), this.bindTexture = new pe2(this), this.bindVertexBuffer = new me2(this), this.bindElementBuffer = new fe2(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge2(this), this.pixelStoreUnpack = new ve2(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extStandardDerivativesForceOff = false, this.extTextureHalfFloat = e2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (e2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = e2.getExtension("OES_standard_derivatives"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e2, t3) {
          return new N2(this, e2, t3);
        }
        createVertexBuffer(e2, t3, i2) {
          return new j(this, e2, t3, i2);
        }
        createRenderbuffer(e2, t3, i2) {
          const o2 = this.gl, r3 = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(r3), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t3, i2), this.bindRenderbuffer.set(null), r3;
        }
        createFramebuffer(e2, t3, i2) {
          return new Ce2(this, e2, t3, i2);
        }
        clear({ color: e2, depth: t3, stencil: i2 }) {
          const o2 = this.gl;
          let r3 = 0;
          e2 && (r3 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), t3 !== void 0 && (r3 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t3), this.depthMask.set(true)), i2 !== void 0 && (r3 |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), o2.clear(r3);
        }
        setCullFace(e2) {
          e2.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
        }
        setDepthMode(e2) {
          e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
        }
        setStencilMode(e2) {
          e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(i2) {
          t2(i2.blendFunction, e.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(i2.blendFunction), this.blendColor.set(i2.blendColor)), this.colorMask.set(i2.mask);
        }
        unbindVAO() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        }
      }
      class Me2 extends e.Evented {
        constructor(t3, i2, o2, r3) {
          super(), this.id = t3, this.dispatcher = o2, this.setEventedParent(r3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.extend({ type: "raster" }, i2), e.extend(this, e.pick(i2, ["url", "scheme", "tileSize"]));
        }
        load() {
          this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = F2(this._options, this.map._requestManager, null, null, (t3, i2) => {
            this._tileJSONRequest = null, this._loaded = true, t3 ? this.fire(new e.ErrorEvent(t3)) : i2 && (e.extend(this, i2), i2.bounds && (this.tileBounds = new U2(i2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(i2.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        serialize() {
          return e.extend({}, this._options);
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(t3, i2) {
          const o2 = e.exported.devicePixelRatio >= 2, r3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
          t3.request = e.getImage(this.map._requestManager.transformRequest(r3, e.ResourceType.Tile), (o3, r4, n3, a2) => (delete t3.request, t3.aborted ? (t3.state = "unloaded", i2(null)) : o3 ? (t3.state = "errored", i2(o3)) : r4 ? (this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: n3, expires: a2 }), t3.setTexture(r4, this.map.painter), t3.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i2(null)) : i2(null)));
        }
        static loadTileData(e2, t3, i2) {
          e2.setTexture(t3, i2);
        }
        static unloadTileData(e2, t3) {
          e2.texture && t3.saveTileTexture(e2.texture);
        }
        abortTile(e2, t3) {
          e2.request && (e2.request.cancel(), delete e2.request), t3();
        }
        unloadTile(e2, t3) {
          e2.texture && this.map.painter.saveTileTexture(e2.texture), t3();
        }
        hasTransition() {
          return false;
        }
      }
      let Se2;
      function ze(t3, i2, o2, r3, n3, a2, s2, l3) {
        const c2 = [t3, o2, n3, i2, r3, a2, 1, 1, 1], h3 = [s2, l3, 1], u3 = e.adjoint([], c2), [_2, d2, p3] = e.transformMat3(h3, h3, e.transpose(u3, u3));
        return e.multiply$1(c2, [_2, 0, 0, 0, d2, 0, 0, 0, p3], c2);
      }
      class De2 extends e.Evented {
        constructor(e2, t3, i2, o2) {
          super(), this.id = e2, this.dispatcher = i2, this.coordinates = t3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = t3;
        }
        load(t3, i2) {
          this._loaded = i2 || false, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i3, o2) => {
            if (this._loaded = true, i3)
              this.fire(new e.ErrorEvent(i3));
            else if (o2) {
              const { HTMLImageElement: i4 } = e.window;
              this.image = o2 instanceof i4 ? e.exported.getImageData(o2) : o2, this.width = this.image.width, this.height = this.image.height, t3 && (this.coordinates = t3), this._finishLoading();
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e2) {
          return this.image && e2.url ? (this.options.url = e2.url, this.load(e2.coordinates, this._loaded), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this.texture && this.texture.destroy();
        }
        setCoordinates(t3) {
          this.coordinates = t3, this._boundsArray = void 0;
          const i2 = t3.map(e.MercatorCoordinate.fromLngLat);
          return this.tileID = function(t4) {
            let i3 = 1 / 0, o2 = 1 / 0, r3 = -1 / 0, n3 = -1 / 0;
            for (const e2 of t4)
              i3 = Math.min(i3, e2.x), o2 = Math.min(o2, e2.y), r3 = Math.max(r3, e2.x), n3 = Math.max(n3, e2.y);
            const a2 = Math.max(r3 - i3, n3 - o2), s2 = Math.max(0, Math.floor(-Math.log(a2) / Math.LN2)), l3 = Math.pow(2, s2);
            return new e.CanonicalTileID(s2, Math.floor((i3 + r3) / 2 * l3), Math.floor((o2 + n3) / 2 * l3));
          }(i2), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0;
        }
        _prepareData(t3) {
          for (const e2 in this.tiles) {
            const t4 = this.tiles[e2];
            t4.state !== "loaded" && (t4.state = "loaded", t4.texture = this.texture);
          }
          if (this._boundsArray)
            return;
          const i2 = e.tileTransform(this.tileID, this.map.transform.projection), [o2, r3, n3, a2] = this.coordinates.map((t4) => {
            const o3 = i2.projection.project(t4[0], t4[1]);
            return e.getTilePoint(i2, o3)._round();
          });
          this.perspectiveTransform = function(t4, i3, o3, r4, n4, a3, s3, l3, c2, h3) {
            const u3 = ze(0, 0, t4, 0, 0, i3, t4, i3), _2 = ze(o3, r4, n4, a3, s3, l3, c2, h3);
            return e.multiply$1(_2, e.adjoint(u3, u3), _2), [_2[6] / _2[8] * t4 / e.EXTENT, _2[7] / _2[8] * i3 / e.EXTENT];
          }(this.width, this.height, o2.x, o2.y, r3.x, r3.y, a2.x, a2.y, n3.x, n3.y);
          const s2 = this._boundsArray = new e.StructArrayLayout4i8();
          s2.emplaceBack(o2.x, o2.y, 0, 0), s2.emplaceBack(r3.x, r3.y, e.EXTENT, 0), s2.emplaceBack(a2.x, a2.y, 0, e.EXTENT), s2.emplaceBack(n3.x, n3.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t3.createVertexBuffer(s2, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image)
            return;
          const t3 = this.map.painter.context, i2 = t3.gl;
          this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t3, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE)), this._prepareData(t3);
        }
        loadTile(e2, t3) {
          this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}, t3(null)) : (e2.state = "errored", t3(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
      }
      const Pe2 = { vector: class extends e.Evented {
        constructor(t3, i2, o2, r3) {
          if (super(), this.id = t3, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.extend(this, e.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r3), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
        }
        load(t3) {
          this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" }));
          const i2 = this.language || this.map._language, o2 = this.worldview || this.map._worldview;
          this._tileJSONRequest = F2(this._options, this.map._requestManager, i2, o2, (r3, n3) => {
            this._tileJSONRequest = null, this._loaded = true, r3 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code. Found: ${i2}`), o2 && o2.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.ErrorEvent(r3))) : n3 && (e.extend(this, n3), n3.bounds && (this.tileBounds = new U2(n3.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n3.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t3 && t3(r3);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        setSourceProperty(e2) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), e2(), this.load(() => {
            const e3 = this.map.style._getSourceCaches(this.id);
            for (const t3 of e3)
              t3.clearTiles();
          });
        }
        setTiles(e2) {
          return this.setSourceProperty(() => {
            this._options.tiles = e2;
          }), this;
        }
        setUrl(e2) {
          return this.setSourceProperty(() => {
            this.url = e2, this._options.url = e2;
          }), this;
        }
        _setLanguage(e2) {
          return e2 === this.language || this.setSourceProperty(() => {
            this.language = e2;
          }), this;
        }
        _setWorldview(e2) {
          return e2 === this.worldview ? this : this.worldviewOptions && e2 && !this.worldviewOptions[e2] ? (console.warn(`Vector tile source "${this.id}" does not support worldview "${e2}".`), this) : (this.setSourceProperty(() => {
            this.worldview = e2;
          }), this);
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        serialize() {
          return e.extend({}, this._options);
        }
        loadTile(t3, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme)), r3 = { request: this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), data: void 0, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t3.isSymbolTile };
          if (r3.request.collectResourceTiming = this._collectResourceTiming, t3.actor && t3.state !== "expired")
            t3.state === "loading" ? t3.reloadCallback = i2 : t3.request = t3.actor.send("reloadTile", r3, n3.bind(this));
          else if (t3.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
            t3.request = t3.actor.send("loadTile", r3, n3.bind(this), void 0, true);
          else {
            const i3 = e.loadVectorTile.call({ deduped: this._deduped }, r3, (e2, i4) => {
              e2 || !i4 ? n3.call(this, e2) : (r3.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t3.actor && t3.actor.send("loadTile", r3, n3.bind(this), void 0, true));
            }, true);
            t3.request = { cancel: i3 };
          }
          function n3(o3, r4) {
            return delete t3.request, t3.aborted ? i2(null) : o3 && o3.status !== 404 ? i2(o3) : (r4 && r4.resourceTiming && (t3.resourceTiming = r4.resourceTiming), this.map._refreshExpiredTiles && r4 && t3.setExpiryData(r4), t3.loadVectorData(r4, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (t3.reloadCallback && (this.loadTile(t3, t3.reloadCallback), t3.reloadCallback = null)));
          }
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        unloadTile(e2) {
          e2.unloadVectorData(), e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
      }, raster: Me2, "raster-dem": class extends Me2 {
        constructor(t3, i2, o2, r3) {
          super(t3, i2, o2, r3), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
        }
        loadTile(t3, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function r3(e2, o3) {
            e2 && (t3.state = "errored", i2(e2)), o3 && (t3.dem = o3, t3.dem.onDeserialize(), t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true, t3.state = "loaded", i2(null));
          }
          t3.request = e.getImage(this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), function(o3, n3, a2, s2) {
            if (delete t3.request, t3.aborted)
              t3.state = "unloaded", i2(null);
            else if (o3)
              t3.state = "errored", i2(o3);
            else if (n3) {
              this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: a2, expires: s2 });
              const i3 = e.window.ImageBitmap && n3 instanceof e.window.ImageBitmap && (Se2 == null && (Se2 = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && typeof e.window.createImageBitmap == "function"), Se2), o4 = 1 - (n3.width - e.prevPowerOfTwo(n3.width)) / 2;
              o4 < 1 || t3.neighboringTiles || (t3.neighboringTiles = this._getNeighboringTiles(t3.tileID));
              const l3 = i3 ? n3 : e.exported.getImageData(n3, o4), c2 = { uid: t3.uid, coord: t3.tileID, source: this.id, rawImageData: l3, encoding: this.encoding, padding: o4 };
              t3.actor && t3.state !== "expired" || (t3.actor = this.dispatcher.getActor(), t3.actor.send("loadDEMTile", c2, r3.bind(this), void 0, true));
            }
          }.bind(this));
        }
        _getNeighboringTiles(t3) {
          const i2 = t3.canonical, o2 = Math.pow(2, i2.z), r3 = (i2.x - 1 + o2) % o2, n3 = i2.x === 0 ? t3.wrap - 1 : t3.wrap, a2 = (i2.x + 1 + o2) % o2, s2 = i2.x + 1 === o2 ? t3.wrap + 1 : t3.wrap, l3 = {};
          return l3[new e.OverscaledTileID(t3.overscaledZ, n3, i2.z, r3, i2.y).key] = { backfilled: false }, l3[new e.OverscaledTileID(t3.overscaledZ, s2, i2.z, a2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l3[new e.OverscaledTileID(t3.overscaledZ, n3, i2.z, r3, i2.y - 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t3.overscaledZ, t3.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t3.overscaledZ, s2, i2.z, a2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l3[new e.OverscaledTileID(t3.overscaledZ, n3, i2.z, r3, i2.y + 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t3.overscaledZ, t3.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t3.overscaledZ, s2, i2.z, a2, i2.y + 1).key] = { backfilled: false }), l3;
        }
        unloadTile(e2) {
          e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded";
        }
      }, geojson: class extends e.Evented {
        constructor(t3, i2, o2, r3) {
          super(), this.id = t3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r3), this._data = i2.data, this._options = e.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== void 0 && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
          const n3 = e.EXTENT / this.tileSize;
          this.workerOptions = e.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (i2.buffer !== void 0 ? i2.buffer : 128) * n3, tolerance: (i2.tolerance !== void 0 ? i2.tolerance : 0.375) * n3, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: i2.clusterMaxZoom !== void 0 ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.EXTENT, radius: (i2.clusterRadius !== void 0 ? i2.clusterRadius : 50) * n3, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
        }
        onAdd(e2) {
          this.map = e2, this.setData(this._data);
        }
        setData(e2) {
          return this._data = e2, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e2, t3) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id }, t3), this;
        }
        getClusterChildren(e2, t3) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id }, t3), this;
        }
        getClusterLeaves(e2, t3, i2, o2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e2, limit: t3, offset: i2 }, o2), this;
        }
        _updateWorkerData() {
          if (this._pendingLoad)
            return void (this._coalesce = true);
          this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = false;
          const t3 = e.extend({}, this.workerOptions), i2 = this._data;
          typeof i2 == "string" ? (t3.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i2), e.ResourceType.Source), t3.request.collectResourceTiming = this._collectResourceTiming) : t3.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t3, (t4, i3) => {
            if (this._loaded = true, this._pendingLoad = null, t4)
              this.fire(new e.ErrorEvent(t4));
            else {
              const t5 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (t5.resourceTiming = i3.resourceTiming[this.id]), this.fire(new e.Event("data", t5)), this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t3, i2) {
          const o2 = t3.actor ? "reloadTile" : "loadTile";
          t3.actor = this.actor, t3.request = this.actor.send(o2, { type: this.type, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e2, r3) => (delete t3.request, t3.unloadVectorData(), t3.aborted ? i2(null) : e2 ? i2(e2) : (t3.loadVectorData(r3, this.map.painter, o2 === "reloadTile"), i2(null))), void 0, o2 === "loadTile");
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
        }
        unloadTile(e2) {
          e2.unloadVectorData(), this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return e.extend({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class extends De2 {
        constructor(e2, t3, i2, o2) {
          super(e2, t3, i2, o2), this.roundZoom = true, this.type = "video", this.options = t3;
        }
        load() {
          this._loaded = false;
          const t3 = this.options;
          this.urls = [];
          for (const i2 of t3.urls)
            this.urls.push(this.map._requestManager.transformRequest(i2, e.ResourceType.Source).url);
          e.getVideo(this.urls, (t4, i2) => {
            this._loaded = true, t4 ? this.fire(new e.ErrorEvent(t4)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t3) {
          if (this.video) {
            const i2 = this.video.seekable;
            t3 < i2.start(0) || t3 > i2.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t3;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e2) {
          this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const t3 = this.map.painter.context, i2 = t3.gl;
          this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t3, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t3);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: De2, canvas: class extends De2 {
        constructor(t3, i2, o2, r3) {
          super(t3, i2, o2, r3), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((e2) => !Array.isArray(e2) || e2.length !== 2 || e2.some((e3) => typeof e3 != "number")) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t3}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t3}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t3}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === void 0 || i2.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e2) {
          this.map = e2, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t3 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t3 = true), this._hasInvalidDimensions())
            return;
          if (Object.keys(this.tiles).length === 0)
            return;
          const i2 = this.map.painter.context;
          this.texture ? (t3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.Texture(i2, this.canvas, i2.gl.RGBA, { premultiply: true }), this._prepareData(i2);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e2 of [this.canvas.width, this.canvas.height])
            if (isNaN(e2) || e2 <= 0)
              return true;
          return false;
        }
      }, custom: class extends e.Evented {
        constructor(t3, i2, o2, r3) {
          super(), this.id = t3, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r3), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U2(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = true, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t3) {
          this._map = t3, this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t3), this.load();
        }
        onRemove(e2) {
          this._implementation.onRemove && this._implementation.onRemove(e2);
        }
        hasTile(e2) {
          if (this._implementation.hasTile) {
            const { x: t3, y: i2, z: o2 } = e2.canonical;
            return this._implementation.hasTile({ x: t3, y: i2, z: o2 });
          }
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(t3, i2) {
          const { x: o2, y: r3, z: n3 } = t3.tileID.canonical, a2 = new e.window.AbortController(), s2 = this._implementation.loadTile({ x: o2, y: r3, z: n3 }, { signal: a2.signal });
          if (!s2)
            return this.loadTileData(t3, { width: this.tileSize, height: this.tileSize, data: null }), t3.state = "loaded", i2(null);
          s2.cancel = () => a2.abort(), t3.request = s2.then(function(o3) {
            return delete t3.request, t3.aborted ? (t3.state = "unloaded", i2(null)) : o3 ? function(t4) {
              return t4 instanceof e.window.ImageData || t4 instanceof e.window.ImageBitmap || t4 instanceof e.window.HTMLCanvasElement;
            }(o3) ? (this.loadTileData(t3, o3), t3.state = "loaded", void i2(null)) : (t3.state = "errored", i2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`))) : (this.loadTileData(t3, { width: this.tileSize, height: this.tileSize, data: null }), t3.state = "loaded", i2(null));
          }.bind(this)).catch((e2) => {
            e2.code !== 20 && (t3.state = "errored", i2(e2));
          });
        }
        loadTileData(e2, t3) {
          Me2.loadTileData(e2, t3, this._map.painter);
        }
        unloadTileData(e2) {
          Me2.unloadTileData(e2, this._map.painter);
        }
        prepareTile(e2) {
          if (!this._implementation.prepareTile)
            return null;
          const { x: t3, y: i2, z: o2 } = e2.tileID.canonical, r3 = this._implementation.prepareTile({ x: t3, y: i2, z: o2 });
          return r3 ? (this.loadTileData(e2, r3), e2.state = "loaded", r3) : null;
        }
        unloadTile(e2, t3) {
          if (this.unloadTileData(e2), this._implementation.unloadTile) {
            const { x: t4, y: i2, z: o2 } = e2.tileID.canonical;
            this._implementation.unloadTile({ x: t4, y: i2, z: o2 });
          }
          t3();
        }
        abortTile(e2, t3) {
          e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t3();
        }
        hasTransition() {
          return false;
        }
        _coveringTiles() {
          return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
        }
        _update() {
          this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, Ae2 = function(t3, i2, o2, r3) {
        const n3 = new Pe2[i2.type](t3, i2, o2, r3);
        if (n3.id !== t3)
          throw new Error(`Expected Source id to be ${t3} instead of ${n3.id}`);
        return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n3), n3;
      };
      function Le2(t3, i2) {
        const o2 = e.identity([]);
        return e.scale(o2, o2, [0.5 * t3.width, 0.5 * -t3.height, 1]), e.translate(o2, o2, [1, -1, 0]), e.multiply(o2, o2, t3.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
      }
      function Re2(e2, t3, i2, o2, r3, n3, a2, s2 = false) {
        const l3 = e2.tilesIn(o2, a2, s2);
        l3.sort(Be2);
        const c2 = [];
        for (const o3 of l3)
          c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t3, i2, e2._state, o3, r3, n3, Le2(e2.transform, o3.tile.tileID), s2) });
        const h3 = function(e3) {
          const t4 = {}, i3 = {};
          for (const o3 of e3) {
            const e4 = o3.queryResults, r4 = o3.wrappedTileID, n4 = i3[r4] = i3[r4] || {};
            for (const i4 in e4) {
              const o4 = e4[i4], r5 = n4[i4] = n4[i4] || {}, a3 = t4[i4] = t4[i4] || [];
              for (const e5 of o4)
                r5[e5.featureIndex] || (r5[e5.featureIndex] = true, a3.push(e5));
            }
          }
          return t4;
        }(c2);
        for (const t4 in h3)
          h3[t4].forEach((t5) => {
            const i3 = t5.feature, o3 = i3.layer;
            o3 && o3.type !== "background" && o3.type !== "sky" && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = i3.id !== void 0 ? e2.getFeatureState(o3["source-layer"], i3.id) : {});
          });
        return h3;
      }
      function Oe2(e2, t3) {
        const i2 = e2.getRenderableIds().map((t4) => e2.getTileByID(t4)), o2 = [], r3 = {};
        for (let e3 = 0; e3 < i2.length; e3++) {
          const n3 = i2[e3], a2 = n3.tileID.canonical.key;
          r3[a2] || (r3[a2] = true, n3.querySourceFeatures(o2, t3));
        }
        return o2;
      }
      function Be2(e2, t3) {
        const i2 = e2.tileID, o2 = t3.tileID;
        return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
      }
      function ke2() {
        return gn.workerClass != null ? new gn.workerClass() : new e.window.Worker(gn.workerUrl);
      }
      const Fe2 = "mapboxgl_preloaded_worker_pool";
      class Ue2 {
        constructor() {
          this.active = {};
        }
        acquire(e2) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Ue2.workerCount; )
              this.workers.push(new ke2());
          return this.active[e2] = true, this.workers.slice();
        }
        release(e2) {
          delete this.active[e2], this.numActive() === 0 && (this.workers.forEach((e3) => {
            e3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Fe2];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let Ne2;
      function Ge2() {
        return Ne2 || (Ne2 = new Ue2()), Ne2;
      }
      function je2(t3, i2) {
        const o2 = {};
        for (const e2 in t3)
          e2 !== "ref" && (o2[e2] = t3[e2]);
        return e.refProperties.forEach((e2) => {
          e2 in i2 && (o2[e2] = i2[e2]);
        }), o2;
      }
      function Ze2(e2) {
        e2 = e2.slice();
        const t3 = Object.create(null);
        for (let i2 = 0; i2 < e2.length; i2++)
          t3[e2[i2].id] = e2[i2];
        for (let i2 = 0; i2 < e2.length; i2++)
          "ref" in e2[i2] && (e2[i2] = je2(e2[i2], t3[e2[i2].ref]));
        return e2;
      }
      Ue2.workerCount = 2;
      const Ve = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
      function We(e2, t3, i2) {
        i2.push({ command: Ve.addSource, args: [e2, t3[e2]] });
      }
      function Xe2(e2, t3, i2) {
        t3.push({ command: Ve.removeSource, args: [e2] }), i2[e2] = true;
      }
      function qe2(e2, t3, i2, o2) {
        Xe2(e2, i2, o2), We(e2, t3, i2);
      }
      function $e2(e2, i2, o2) {
        let r3;
        for (r3 in e2[o2])
          if (e2[o2].hasOwnProperty(r3) && r3 !== "data" && !t2(e2[o2][r3], i2[o2][r3]))
            return false;
        for (r3 in i2[o2])
          if (i2[o2].hasOwnProperty(r3) && r3 !== "data" && !t2(e2[o2][r3], i2[o2][r3]))
            return false;
        return true;
      }
      function He2(e2, i2, o2, r3, n3, a2) {
        let s2;
        for (s2 in i2 = i2 || {}, e2 = e2 || {})
          e2.hasOwnProperty(s2) && (t2(e2[s2], i2[s2]) || o2.push({ command: a2, args: [r3, s2, i2[s2], n3] }));
        for (s2 in i2)
          i2.hasOwnProperty(s2) && !e2.hasOwnProperty(s2) && (t2(e2[s2], i2[s2]) || o2.push({ command: a2, args: [r3, s2, i2[s2], n3] }));
      }
      function Ye2(e2) {
        return e2.id;
      }
      function Ke2(e2, t3) {
        return e2[t3.id] = t3, e2;
      }
      class Je2 {
        constructor(e2, t3) {
          this.reset(e2, t3);
        }
        reset(e2, t3) {
          this.points = e2 || [], this._distances = [0];
          for (let e3 = 1; e3 < this.points.length; e3++)
            this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t3) {
          if (this.points.length === 1)
            return this.points[0];
          t3 = e.clamp(t3, 0, 1);
          let i2 = 1, o2 = this._distances[i2];
          const r3 = t3 * this.paddedLength + this.padding;
          for (; o2 < r3 && i2 < this._distances.length; )
            o2 = this._distances[++i2];
          const n3 = i2 - 1, a2 = this._distances[n3], s2 = o2 - a2, l3 = s2 > 0 ? (r3 - a2) / s2 : 0;
          return this.points[n3].mult(1 - l3).add(this.points[i2].mult(l3));
        }
      }
      class Qe2 {
        constructor(e2, t3, i2) {
          const o2 = this.boxCells = [], r3 = this.circleCells = [];
          this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t3 / i2);
          for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
            o2.push([]), r3.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t3, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t3, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e2, t3, i2, o2, r3) {
          this._forEachCell(t3, i2, o2, r3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t3), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r3);
        }
        insertCircle(e2, t3, i2, o2) {
          this._forEachCell(t3 - o2, i2 - o2, t3 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t3), this.circles.push(i2), this.circles.push(o2);
        }
        _insertBoxCell(e2, t3, i2, o2, r3, n3) {
          this.boxCells[r3].push(n3);
        }
        _insertCircleCell(e2, t3, i2, o2, r3, n3) {
          this.circleCells[r3].push(n3);
        }
        _query(e2, t3, i2, o2, r3, n3) {
          if (i2 < 0 || e2 > this.width || o2 < 0 || t3 > this.height)
            return !r3 && [];
          const a2 = [];
          if (e2 <= 0 && t3 <= 0 && this.width <= i2 && this.height <= o2) {
            if (r3)
              return true;
            for (let e3 = 0; e3 < this.boxKeys.length; e3++)
              a2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
              const t4 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
              a2.push({ key: this.circleKeys[e3], x1: t4 - o3, y1: i3 - o3, x2: t4 + o3, y2: i3 + o3 });
            }
            return n3 ? a2.filter(n3) : a2;
          }
          return this._forEachCell(e2, t3, i2, o2, this._queryCell, a2, { hitTest: r3, seenUids: { box: {}, circle: {} } }, n3), r3 ? a2.length > 0 : a2;
        }
        _queryCircle(e2, t3, i2, o2, r3) {
          const n3 = e2 - i2, a2 = e2 + i2, s2 = t3 - i2, l3 = t3 + i2;
          if (a2 < 0 || n3 > this.width || l3 < 0 || s2 > this.height)
            return !o2 && [];
          const c2 = [];
          return this._forEachCell(n3, s2, a2, l3, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t3, radius: i2 }, seenUids: { box: {}, circle: {} } }, r3), o2 ? c2.length > 0 : c2;
        }
        query(e2, t3, i2, o2, r3) {
          return this._query(e2, t3, i2, o2, false, r3);
        }
        hitTest(e2, t3, i2, o2, r3) {
          return this._query(e2, t3, i2, o2, true, r3);
        }
        hitTestCircle(e2, t3, i2, o2) {
          return this._queryCircle(e2, t3, i2, true, o2);
        }
        _queryCell(e2, t3, i2, o2, r3, n3, a2, s2) {
          const l3 = a2.seenUids, c2 = this.boxCells[r3];
          if (c2 !== null) {
            const r4 = this.bboxes;
            for (const h4 of c2)
              if (!l3.box[h4]) {
                l3.box[h4] = true;
                const c3 = 4 * h4;
                if (e2 <= r4[c3 + 2] && t3 <= r4[c3 + 3] && i2 >= r4[c3 + 0] && o2 >= r4[c3 + 1] && (!s2 || s2(this.boxKeys[h4]))) {
                  if (a2.hitTest)
                    return n3.push(true), true;
                  n3.push({ key: this.boxKeys[h4], x1: r4[c3], y1: r4[c3 + 1], x2: r4[c3 + 2], y2: r4[c3 + 3] });
                }
              }
          }
          const h3 = this.circleCells[r3];
          if (h3 !== null) {
            const r4 = this.circles;
            for (const c3 of h3)
              if (!l3.circle[c3]) {
                l3.circle[c3] = true;
                const h4 = 3 * c3;
                if (this._circleAndRectCollide(r4[h4], r4[h4 + 1], r4[h4 + 2], e2, t3, i2, o2) && (!s2 || s2(this.circleKeys[c3]))) {
                  if (a2.hitTest)
                    return n3.push(true), true;
                  {
                    const e3 = r4[h4], t4 = r4[h4 + 1], i3 = r4[h4 + 2];
                    n3.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t4 - i3, x2: e3 + i3, y2: t4 + i3 });
                  }
                }
              }
          }
        }
        _queryCellCircle(e2, t3, i2, o2, r3, n3, a2, s2) {
          const l3 = a2.circle, c2 = a2.seenUids, h3 = this.boxCells[r3];
          if (h3 !== null) {
            const e3 = this.bboxes;
            for (const t4 of h3)
              if (!c2.box[t4]) {
                c2.box[t4] = true;
                const i3 = 4 * t4;
                if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!s2 || s2(this.boxKeys[t4])))
                  return n3.push(true), true;
              }
          }
          const u3 = this.circleCells[r3];
          if (u3 !== null) {
            const e3 = this.circles;
            for (const t4 of u3)
              if (!c2.circle[t4]) {
                c2.circle[t4] = true;
                const i3 = 3 * t4;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l3.x, l3.y, l3.radius) && (!s2 || s2(this.circleKeys[t4])))
                  return n3.push(true), true;
              }
          }
        }
        _forEachCell(e2, t3, i2, o2, r3, n3, a2, s2) {
          const l3 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t3), h3 = this._convertToXCellCoord(i2), u3 = this._convertToYCellCoord(o2);
          for (let _2 = l3; _2 <= h3; _2++)
            for (let l4 = c2; l4 <= u3; l4++)
              if (r3.call(this, e2, t3, i2, o2, this.xCellCount * l4 + _2, n3, a2, s2))
                return;
        }
        _convertToXCellCoord(e2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
        }
        _convertToYCellCoord(e2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
        }
        _circlesCollide(e2, t3, i2, o2, r3, n3) {
          const a2 = o2 - e2, s2 = r3 - t3, l3 = i2 + n3;
          return l3 * l3 > a2 * a2 + s2 * s2;
        }
        _circleAndRectCollide(e2, t3, i2, o2, r3, n3, a2) {
          const s2 = (n3 - o2) / 2, l3 = Math.abs(e2 - (o2 + s2));
          if (l3 > s2 + i2)
            return false;
          const c2 = (a2 - r3) / 2, h3 = Math.abs(t3 - (r3 + c2));
          if (h3 > c2 + i2)
            return false;
          if (l3 <= s2 || h3 <= c2)
            return true;
          const u3 = l3 - s2, _2 = h3 - c2;
          return u3 * u3 + _2 * _2 <= i2 * i2;
        }
      }
      const et = Math.tan(85 * Math.PI / 180);
      function tt(t3, i2, o2, r3, n3, a2, s2) {
        const l3 = e.create();
        if (o2)
          if (a2.name === "globe") {
            const t4 = e.calculateGlobeLabelMatrix(n3, i2);
            e.multiply(l3, l3, t4);
          } else {
            const t4 = v2([], s2);
            l3[0] = t4[0], l3[1] = t4[1], l3[4] = t4[2], l3[5] = t4[3], r3 || e.rotateZ(l3, l3, n3.angle);
          }
        else
          e.multiply(l3, n3.labelPlaneMatrix, t3);
        return l3;
      }
      function it(e2, t3, i2, o2, r3, n3, a2) {
        const s2 = tt(e2, t3, i2, o2, r3, n3, a2);
        return n3.name === "globe" && i2 || (s2[2] = s2[6] = s2[10] = s2[14] = 0), s2;
      }
      function ot(t3, i2, o2, r3, n3, a2, s2) {
        if (o2) {
          if (a2.name === "globe") {
            const l3 = tt(t3, i2, o2, r3, n3, a2, s2);
            return e.invert(l3, l3), e.multiply(l3, t3, l3), l3;
          }
          {
            const i3 = e.clone(t3), o3 = e.identity([]);
            return o3[0] = s2[0], o3[1] = s2[1], o3[4] = s2[2], o3[5] = s2[3], e.multiply(i3, i3, o3), r3 || e.rotateZ(i3, i3, -n3.angle), i3;
          }
        }
        return n3.glCoordMatrix;
      }
      function rt(t3, i2, o2 = 0) {
        const r3 = [t3.x, t3.y, o2, 1];
        o2 ? e.transformMat4$1(r3, r3, i2) : gt(r3, r3, i2);
        const n3 = r3[3];
        return { point: [r3[0] / n3, r3[1] / n3, r3[2] / n3], signedDistanceFromCamera: n3 };
      }
      function nt(t3, i2) {
        const o2 = [t3[0], t3[1], t3[2], 1];
        e.transformMat4$1(o2, o2, i2);
        const r3 = o2[3];
        return { point: [o2[0] / r3, o2[1] / r3, o2[2] / r3], signedDistanceFromCamera: r3 };
      }
      function at(e2, t3) {
        return Math.min(0.5 + e2 / t3 * 0.5, 1.5);
      }
      function st(e2, t3) {
        const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
        return i2 >= -t3[0] && i2 <= t3[0] && o2 >= -t3[1] && o2 <= t3[1];
      }
      function lt(t3, i2, o2, r3, n3, a2, s2, l3, c2, h3) {
        const u3 = o2.transform, _2 = r3 ? t3.textSizeData : t3.iconSizeData, d2 = e.evaluateSizeForZoom(_2, o2.transform.zoom), p3 = u3.projection.name === "globe", m3 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f2 = r3 ? t3.text.dynamicLayoutVertexArray : t3.icon.dynamicLayoutVertexArray;
        f2.clear();
        let g2 = null;
        p3 && (g2 = r3 ? t3.text.globeExtVertexArray : t3.icon.globeExtVertexArray);
        const v3 = t3.lineVertexArray, x3 = r3 ? t3.text.placedSymbolArray : t3.icon.placedSymbolArray, y3 = o2.transform.width / o2.transform.height;
        let b2 = false;
        for (let r4 = 0; r4 < x3.length; r4++) {
          const p4 = x3.get(r4);
          if (p4.writingMode !== e.WritingMode.vertical || b2 || r4 !== 0 && x3.get(r4 - 1).writingMode === e.WritingMode.horizontal || (b2 = true), (p4.hidden || p4.writingMode === e.WritingMode.vertical) && !b2) {
            ft(p4.numGlyphs, f2);
            continue;
          }
          b2 = false;
          const w2 = new e.pointGeometry(p4.tileAnchorX, p4.tileAnchorY), T3 = c2 ? c2(w2) : [0, 0, 0], E3 = u3.projection.projectTilePoint(w2.x, w2.y, h3.canonical), C3 = [E3.x + T3[0], E3.y + T3[1], E3.z + T3[2]], I3 = [...C3, 1];
          if (e.transformMat4$1(I3, I3, i2), !st(I3, m3)) {
            ft(p4.numGlyphs, f2);
            continue;
          }
          const M3 = at(o2.transform.cameraToCenterDistance, I3[3]), S3 = e.evaluateSizeForFeature(_2, d2, p4), z3 = s2 ? S3 / M3 : S3 * M3, D3 = rt(new e.pointGeometry(C3[0], C3[1]), n3, C3[2]);
          if (D3.signedDistanceFromCamera <= 0) {
            ft(p4.numGlyphs, f2);
            continue;
          }
          let P3 = {};
          const A3 = s2 ? null : c2, L3 = ut(p4, z3, false, l3, i2, n3, a2, t3.glyphOffsetArray, v3, f2, g2, D3.point, w2, P3, y3, A3, u3.projection, h3, s2);
          b2 = L3.useVertical, A3 && L3.needsFlipping && (P3 = {}), (L3.notEnoughRoom || b2 || L3.needsFlipping && ut(p4, z3, true, l3, i2, n3, a2, t3.glyphOffsetArray, v3, f2, g2, D3.point, w2, P3, y3, A3, u3.projection, h3, s2).notEnoughRoom) && ft(p4.numGlyphs, f2);
        }
        r3 ? (t3.text.dynamicLayoutVertexBuffer.updateData(f2), g2 && t3.text.globeExtVertexBuffer.updateData(g2)) : (t3.icon.dynamicLayoutVertexBuffer.updateData(f2), g2 && t3.icon.globeExtVertexBuffer.updateData(g2));
      }
      function ct(e2, t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3) {
        const f2 = s2.glyphStartIndex + s2.numGlyphs, g2 = s2.lineStartIndex, v3 = s2.lineStartIndex + s2.lineLength, x3 = t3.getoffsetX(s2.glyphStartIndex), y3 = t3.getoffsetX(f2 - 1), b2 = pt(e2 * x3, i2, o2, r3, n3, a2, s2.segment, g2, v3, l3, c2, h3, u3, _2, true, d2, p3, m3);
        if (!b2)
          return null;
        const w2 = pt(e2 * y3, i2, o2, r3, n3, a2, s2.segment, g2, v3, l3, c2, h3, u3, _2, true, d2, p3, m3);
        return w2 ? { first: b2, last: w2 } : null;
      }
      function ht(t3, i2, o2, r3) {
        return t3.writingMode === e.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * r3 ? { useVertical: true } : t3.writingMode === e.WritingMode.vertical ? i2.y < o2.y ? { needsFlipping: true } : null : t3.flipState !== 0 && function(e2, t4, i3) {
          const o3 = (t4.x - e2.x) * i3;
          return o3 === 0 || Math.abs((t4.y - e2.y) / o3) > et;
        }(i2, o2, r3) ? t3.flipState === 1 ? { needsFlipping: true } : null : i2.x > o2.x ? { needsFlipping: true } : null;
      }
      function ut(t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3, f2, g2, v3, x3) {
        const y3 = i2 / 24, b2 = t3.lineOffsetX * y3, w2 = t3.lineOffsetY * y3;
        let T3;
        if (t3.numGlyphs > 1) {
          const i3 = t3.glyphStartIndex + t3.numGlyphs, n4 = t3.lineStartIndex, h4 = t3.lineStartIndex + t3.lineLength, u4 = ct(y3, l3, b2, w2, o2, _2, d2, t3, c2, a2, p3, f2, false, g2, v3, x3);
          if (!u4)
            return { notEnoughRoom: true };
          const E3 = nt(u4.first.point, s2).point, C3 = nt(u4.last.point, s2).point, I3 = new e.pointGeometry(E3[0], E3[1]), M3 = new e.pointGeometry(C3[0], C3[1]);
          if (r3 && !o2) {
            const e2 = ht(t3, I3, M3, m3);
            if (t3.flipState = e2 && e2.needsFlipping ? 1 : 2, e2)
              return e2;
          }
          T3 = [u4.first];
          for (let e2 = t3.glyphStartIndex + 1; e2 < i3 - 1; e2++)
            T3.push(pt(y3 * l3.getoffsetX(e2), b2, w2, o2, _2, d2, t3.segment, n4, h4, c2, a2, p3, f2, false, false, g2, v3, x3));
          T3.push(u4.last);
        } else {
          if (r3 && !o2) {
            const i4 = rt(d2, n3).point, o3 = t3.lineStartIndex + t3.segment + 1, r4 = new e.pointGeometry(c2.getx(o3), c2.gety(o3)), a3 = rt(r4, n3), s3 = a3.signedDistanceFromCamera > 0 ? a3.point : dt(d2, r4, i4, 1, n3, void 0, g2, v3.canonical), l4 = ht(t3, new e.pointGeometry(i4[0], i4[1]), new e.pointGeometry(s3[0], s3[1]), m3);
            if (t3.flipState = l4 && l4.needsFlipping ? 1 : 2, l4)
              return l4;
          }
          const i3 = pt(y3 * l3.getoffsetX(t3.glyphStartIndex), b2, w2, o2, _2, d2, t3.segment, t3.lineStartIndex, t3.lineStartIndex + t3.lineLength, c2, a2, p3, f2, false, false, g2, v3, x3);
          if (!i3)
            return { notEnoughRoom: true };
          T3 = [i3];
        }
        if (u3)
          for (const t4 of T3)
            e.updateGlobeVertexNormal(u3, h3.length + 0, t4.up[0], t4.up[1], t4.up[2]), e.updateGlobeVertexNormal(u3, h3.length + 1, t4.up[0], t4.up[1], t4.up[2]), e.updateGlobeVertexNormal(u3, h3.length + 2, t4.up[0], t4.up[1], t4.up[2]), e.updateGlobeVertexNormal(u3, h3.length + 3, t4.up[0], t4.up[1], t4.up[2]), e.addDynamicAttributes(h3, t4.point[0], t4.point[1], t4.point[2], t4.angle);
        else
          for (const t4 of T3)
            e.addDynamicAttributes(h3, t4.point[0], t4.point[1], t4.point[2], t4.angle);
        return {};
      }
      function _t(t3, i2, o2, r3, n3) {
        const a2 = r3.projectTilePoint(t3.x, t3.y, i2);
        if (!n3)
          return rt(a2, o2, a2.z);
        const s2 = n3(t3);
        return rt(new e.pointGeometry(a2.x + s2[0], a2.y + s2[1]), o2, a2.z + s2[2]);
      }
      function dt(t3, i2, o2, r3, n3, a2, s2, l3) {
        const c2 = _t(t3.add(t3.sub(i2)._unit()), l3, n3, s2, a2).point, h3 = e.sub([], o2, c2);
        return e.scaleAndAdd([], o2, h3, r3 / e.length(h3));
      }
      function pt(t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3, f2, g2, v3) {
        const x3 = r3 ? t3 - i2 : t3 + i2;
        let y3 = x3 > 0 ? 1 : -1, b2 = 0;
        r3 && (y3 *= -1, b2 = Math.PI), y3 < 0 && (b2 += Math.PI);
        let w2 = y3 > 0 ? l3 + s2 : l3 + s2 + 1, T3 = n3, E3 = n3, C3 = 0, I3 = 0;
        const M3 = Math.abs(x3), S3 = [], z3 = [];
        let D3 = a2;
        const P3 = () => {
          const t4 = w2 - y3;
          return C3 === 0 ? a2 : new e.pointGeometry(h3.getx(t4), h3.gety(t4));
        }, A3 = () => dt(P3(), D3, E3, M3 - C3 + 1, u3, d2, f2, g2.canonical);
        for (; C3 + I3 <= M3; ) {
          if (w2 += y3, w2 < l3 || w2 >= c2)
            return null;
          if (E3 = T3, S3.push(T3), p3 && z3.push(D3 || P3()), T3 = _2[w2], T3 === void 0) {
            D3 = new e.pointGeometry(h3.getx(w2), h3.gety(w2));
            const t4 = _t(D3, g2.canonical, u3, f2, d2);
            T3 = t4.signedDistanceFromCamera > 0 ? _2[w2] = t4.point : A3();
          } else
            D3 = null;
          C3 += I3, I3 = e.distance(E3, T3);
        }
        D3 = D3 || new e.pointGeometry(h3.getx(w2), h3.gety(w2));
        const L3 = P3();
        m3 && d2 && (_2[w2] = T3 = _2[w2] === void 0 ? T3 : A3(), I3 = e.distance(E3, T3));
        const R3 = (M3 - C3) / I3, O3 = D3.sub(L3).mult(R3)._add(L3), B3 = e.sub([], T3, E3), k2 = e.scaleAndAdd([], E3, B3, R3);
        let F3 = [0, 0, 1], U3 = B3[0], N3 = B3[1];
        if (v3 && (F3 = f2.upVector(g2.canonical, O3.x, O3.y), F3[0] !== 0 || F3[1] !== 0 || F3[2] !== 1)) {
          const t4 = [1, 0, 0], i3 = [0, 1, 0];
          t4[0] = F3[2], t4[1] = 0, t4[2] = -F3[0], e.cross(i3, F3, t4), e.normalize(t4, t4), e.normalize(i3, i3), U3 = e.dot(B3, t4), N3 = e.dot(B3, i3);
        }
        if (o2) {
          const t4 = e.cross([], F3, B3);
          e.normalize(t4, t4), e.scaleAndAdd(k2, k2, t4, o2 * y3);
        }
        const G3 = b2 + Math.atan2(N3, U3);
        return S3.push(k2), p3 && z3.push(O3), { point: k2, angle: G3, path: S3, tilePath: z3, up: F3 };
      }
      const mt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function ft(e2, t3) {
        for (let i2 = 0; i2 < e2; i2++) {
          const e3 = t3.length;
          t3.resize(e3 + 4), t3.float32.set(mt, 4 * e3);
        }
      }
      function gt(e2, t3, i2) {
        const o2 = t3[0], r3 = t3[1];
        return e2[0] = i2[0] * o2 + i2[4] * r3 + i2[12], e2[1] = i2[1] * o2 + i2[5] * r3 + i2[13], e2[3] = i2[3] * o2 + i2[7] * r3 + i2[15], e2;
      }
      const vt = 100;
      class xt {
        constructor(e2, t3, i2 = new Qe2(e2.width + 200, e2.height + 200, 25), o2 = new Qe2(e2.width + 200, e2.height + 200, 25)) {
          this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + vt, this.screenBottomBoundary = e2.height + vt, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t3;
        }
        placeCollisionBox(e2, t3, i2, o2, r3, n3, a2, s2) {
          let l3 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, h3 = i2.projectedAnchorZ;
          const u3 = i2.elevation, _2 = i2.tileID;
          if (u3 && _2) {
            const t4 = e2.getProjection().upVector(_2.canonical, i2.tileAnchorX, i2.tileAnchorY), o3 = e2.getProjection().upVectorScale(_2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            l3 += t4[0] * u3 * o3, c2 += t4[1] * u3 * o3, h3 += t4[2] * u3 * o3;
          }
          const d2 = this.projectAndGetPerspectiveRatio(a2, [l3, c2, h3], i2.tileID, e2.projection.name === "globe" || !!u3 || this.transform.pitch > 0, e2.getProjection()), p3 = n3 * d2.perspectiveRatio, m3 = (i2.x1 * t3 + o2.x - i2.padding) * p3 + d2.point.x, f2 = (i2.y1 * t3 + o2.y - i2.padding) * p3 + d2.point.y, g2 = (i2.x2 * t3 + o2.x + i2.padding) * p3 + d2.point.x, v3 = (i2.y2 * t3 + o2.y + i2.padding) * p3 + d2.point.y, x3 = d2.perspectiveRatio <= 0.55 || d2.occluded;
          return !this.isInsideGrid(m3, f2, g2, v3) || !r3 && this.grid.hitTest(m3, f2, g2, v3, s2) || x3 ? { box: [], offscreen: false, occluded: d2.occluded } : { box: [m3, f2, g2, v3], offscreen: this.isOffscreen(m3, f2, g2, v3), occluded: false };
        }
        placeCollisionCircles(t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3) {
          const f2 = [], g2 = this.transform.elevation, v3 = g2 ? g2.getAtTileOffsetFunc(m3, this.transform.center.lat, this.transform.worldSize, t3.getProjection()) : (e2) => [0, 0, 0], x3 = new e.pointGeometry(o2.tileAnchorX, o2.tileAnchorY), y3 = t3.getProjection().projectTilePoint(o2.tileAnchorX, o2.tileAnchorY, m3.canonical), b2 = v3(x3), w2 = [y3.x + b2[0], y3.y + b2[1], y3.z + b2[2]], T3 = t3.projection.name === "globe", E3 = this.projectAndGetPerspectiveRatio(s2, [w2[0], w2[1], w2[2]], m3, T3 || !!g2 || this.transform.pitch > 0, t3.getProjection()), { perspectiveRatio: C3 } = E3, I3 = (u3 ? a2 / C3 : a2 * C3) / e.ONE_EM, M3 = rt(new e.pointGeometry(w2[0], w2[1]), l3, w2[2]).point, S3 = E3.signedDistanceFromCamera > 0 ? ct(I3, n3, o2.lineOffsetX * I3, o2.lineOffsetY * I3, false, M3, x3, o2, r3, l3, {}, g2 && !u3 ? v3 : null, u3 && !!g2, t3.getProjection(), m3, u3) : null;
          let z3 = false, D3 = false, P3 = true;
          if (S3 && !E3.occluded) {
            const t4 = 0.5 * d2 * C3 + p3, o3 = new e.pointGeometry(-100, -100), r4 = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n4 = new Je2(), a3 = S3.first, s3 = S3.last;
            let l4 = [];
            for (let e2 = a3.path.length - 1; e2 >= 1; e2--)
              l4.push(a3.path[e2]);
            for (let e2 = 1; e2 < s3.path.length; e2++)
              l4.push(s3.path[e2]);
            const u4 = 2.5 * t4;
            if (c2) {
              const e2 = l4.map(g2 && !T3 ? (e3, t5) => {
                const i3 = v3(t5 < a3.path.length - 1 ? a3.tilePath[a3.path.length - 1 - t5] : s3.tilePath[t5 - a3.path.length + 2]);
                return e3[2] = i3[2], nt(e3, c2);
              } : (e3) => nt(e3, c2));
              l4 = e2.some((e3) => e3.signedDistanceFromCamera <= 0) ? [] : e2.map((e3) => e3.point);
            }
            let m4 = [];
            if (l4.length > 0) {
              const t5 = l4.map((t6) => new e.pointGeometry(t6[0], t6[1]));
              let i3 = 1 / 0, n5 = -1 / 0, a4 = 1 / 0, s4 = -1 / 0;
              for (let e2 = 0; e2 < t5.length; e2++)
                i3 = Math.min(i3, t5[e2].x), a4 = Math.min(a4, t5[e2].y), n5 = Math.max(n5, t5[e2].x), s4 = Math.max(s4, t5[e2].y);
              m4 = i3 >= o3.x && n5 <= r4.x && a4 >= o3.y && s4 <= r4.y ? [t5] : n5 < o3.x || i3 > r4.x || s4 < o3.y || a4 > r4.y ? [] : e.clipLine([t5], o3.x, o3.y, r4.x, r4.y);
            }
            for (const e2 of m4) {
              n4.reset(e2, 0.25 * t4);
              let o4 = 0;
              o4 = n4.length <= 0.5 * t4 ? 1 : Math.ceil(n4.paddedLength / u4) + 1;
              for (let e3 = 0; e3 < o4; e3++) {
                const r5 = e3 / Math.max(o4 - 1, 1), a4 = n4.lerp(r5), s4 = a4.x + vt, l5 = a4.y + vt;
                f2.push(s4, l5, t4, 0);
                const c3 = s4 - t4, u5 = l5 - t4, d3 = s4 + t4, p4 = l5 + t4;
                if (P3 = P3 && this.isOffscreen(c3, u5, d3, p4), D3 = D3 || this.isInsideGrid(c3, u5, d3, p4), !i2 && this.grid.hitTestCircle(s4, l5, t4, _2) && (z3 = true, !h3))
                  return { circles: [], offscreen: false, collisionDetected: z3, occluded: false };
              }
            }
          }
          return { circles: !h3 && z3 || !D3 ? [] : f2, offscreen: P3, collisionDetected: z3, occluded: E3.occluded };
        }
        queryRenderedSymbols(t3) {
          if (t3.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const i2 = [];
          let o2 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, a2 = -1 / 0;
          for (const s3 of t3) {
            const t4 = new e.pointGeometry(s3.x + vt, s3.y + vt);
            o2 = Math.min(o2, t4.x), r3 = Math.min(r3, t4.y), n3 = Math.max(n3, t4.x), a2 = Math.max(a2, t4.y), i2.push(t4);
          }
          const s2 = this.grid.query(o2, r3, n3, a2).concat(this.ignoredGrid.query(o2, r3, n3, a2)), l3 = {}, c2 = {};
          for (const t4 of s2) {
            const o3 = t4.key;
            if (l3[o3.bucketInstanceId] === void 0 && (l3[o3.bucketInstanceId] = {}), l3[o3.bucketInstanceId][o3.featureIndex])
              continue;
            const r4 = [new e.pointGeometry(t4.x1, t4.y1), new e.pointGeometry(t4.x2, t4.y1), new e.pointGeometry(t4.x2, t4.y2), new e.pointGeometry(t4.x1, t4.y2)];
            e.polygonIntersectsPolygon(i2, r4) && (l3[o3.bucketInstanceId][o3.featureIndex] = true, c2[o3.bucketInstanceId] === void 0 && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
          }
          return c2;
        }
        insertCollisionBox(e2, t3, i2, o2, r3) {
          (t3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r3 }, e2[0], e2[1], e2[2], e2[3]);
        }
        insertCollisionCircles(e2, t3, i2, o2, r3) {
          const n3 = t3 ? this.ignoredGrid : this.grid, a2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r3 };
          for (let t4 = 0; t4 < e2.length; t4 += 4)
            n3.insertCircle(a2, e2[t4], e2[t4 + 1], e2[t4 + 2]);
        }
        projectAndGetPerspectiveRatio(t3, i2, o2, r3, n3) {
          const a2 = [i2[0], i2[1], i2[2], 1];
          let s2 = false;
          if (i2[2] || this.transform.pitch > 0) {
            e.transformMat4$1(a2, a2, t3);
            const r4 = n3.name === "globe";
            this.fogState && o2 && !r4 && (s2 = function(t4, i3, o3, r5, n4, a3) {
              const s3 = a3.calculateFogTileMatrix(n4), l3 = [i3, o3, r5];
              return e.transformMat4(l3, l3, s3), M2(t4, l3, a3.pitch, a3._fov);
            }(this.fogState, i2[0], i2[1], i2[2], o2.toUnwrapped(), this.transform) > 0.9);
          } else
            gt(a2, a2, t3);
          return { point: new e.pointGeometry((a2[0] / a2[3] + 1) / 2 * this.transform.width + vt, (-a2[1] / a2[3] + 1) / 2 * this.transform.height + vt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(n3) / a2[3] * 0.5, 1.5), signedDistanceFromCamera: a2[3], occluded: r3 && a2[2] > a2[3] || s2 };
        }
        isOffscreen(e2, t3, i2, o2) {
          return i2 < vt || e2 >= this.screenRightBoundary || o2 < vt || t3 > this.screenBottomBoundary;
        }
        isInsideGrid(e2, t3, i2, o2) {
          return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t3 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t3 = e.identity([]);
          return e.translate(t3, t3, [-100, -100, 0]), t3;
        }
      }
      function yt(t3, i2, o2) {
        const r3 = i2.createTileMatrix(t3, t3.worldSize, o2.toUnwrapped());
        return e.multiply(new Float32Array(16), t3.projMatrix, r3);
      }
      function bt(e2, t3, i2) {
        if (t3.projection.name === i2.projection.name)
          return e2.projMatrix;
        const o2 = i2.clone();
        return o2.setProjection(t3.projection), yt(o2, t3.getProjection(), e2);
      }
      function wt(e2, t3, i2) {
        return t3.name === i2.projection.name ? e2.projMatrix : yt(i2, t3, e2);
      }
      class Tt {
        constructor(e2, t3, i2, o2) {
          this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t3 : -t3))) : o2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Et {
        constructor(e2, t3, i2, o2, r3, n3 = false) {
          this.text = new Tt(e2 ? e2.text : null, t3, i2, r3), this.icon = new Tt(e2 ? e2.icon : null, t3, o2, r3), this.clipped = n3;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Ct {
        constructor(e2, t3, i2, o2 = false) {
          this.text = e2, this.icon = t3, this.skipFade = i2, this.clipped = o2;
        }
      }
      class It {
        constructor() {
          this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
        }
      }
      class Mt {
        constructor(e2, t3, i2, o2, r3) {
          this.bucketInstanceId = e2, this.featureIndex = t3, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r3;
        }
      }
      class St {
        constructor(e2) {
          this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e2]) {
            const t3 = ++this.maxGroupID;
            this.collisionGroups[e2] = { ID: t3, predicate: (e3) => e3.collisionGroupID === t3 };
          }
          return this.collisionGroups[e2];
        }
      }
      function zt(t3, i2, o2, r3, n3) {
        const { horizontalAlign: a2, verticalAlign: s2 } = e.getAnchorAlignment(t3), l3 = -(a2 - 0.5) * i2, c2 = -(s2 - 0.5) * o2, h3 = e.evaluateVariableOffset(t3, r3);
        return new e.pointGeometry(l3 + h3[0] * n3, c2 + h3[1] * n3);
      }
      function Dt(t3, i2, o2, r3, n3) {
        const a2 = new e.pointGeometry(t3, i2);
        return o2 && a2._rotate(r3 ? n3 : -n3), a2;
      }
      class Pt {
        constructor(e2, t3, i2, o2, r3) {
          this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new xt(this.transform, r3), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t3, this.retainedQueryData = {}, this.collisionGroups = new St(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t3, i2, o2, r3) {
          const n3 = o2.getBucket(i2), a2 = o2.latestFeatureIndex;
          if (!n3 || !a2 || i2.id !== n3.layerIds[0])
            return;
          const s2 = n3.layers[0].layout, l3 = o2.collisionBoxArray, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h3 = o2.tileSize / e.EXTENT, u3 = o2.tileID.toUnwrapped();
          this.transform.setProjection(n3.projection);
          const _2 = (d2 = o2.tileID, p3 = n3.getProjection(), m3 = this.transform, p3.name === this.projection ? m3.calculateProjMatrix(d2.toUnwrapped()) : yt(m3, p3, d2));
          var d2, p3, m3;
          const f2 = s2.get("text-pitch-alignment") === "map", g2 = s2.get("text-rotation-alignment") === "map";
          i2.compileFilter();
          const v3 = i2.dynamicFilter(), x3 = i2.dynamicFilterNeedsFeature(), y3 = this.transform.calculatePixelsToTileUnitsMatrix(o2), b2 = it(_2, o2.tileID.canonical, f2, g2, this.transform, n3.getProjection(), y3);
          let w2 = null;
          if (f2) {
            const t4 = ot(_2, o2.tileID.canonical, f2, g2, this.transform, n3.getProjection(), y3);
            w2 = e.multiply([], this.transform.labelPlaneMatrix, t4);
          }
          let T3 = null;
          v3 && o2.latestFeatureIndex && (T3 = { unwrappedTileID: u3, dynamicFilter: v3, dynamicFilterNeedsFeature: x3, featureIndex: o2.latestFeatureIndex }), this.retainedQueryData[n3.bucketInstanceId] = new Mt(n3.bucketInstanceId, a2, n3.sourceLayerIndex, n3.index, o2.tileID);
          const E3 = { bucket: n3, layout: s2, posMatrix: _2, textLabelPlaneMatrix: b2, labelToScreenMatrix: w2, clippingData: T3, scale: c2, textPixelRatio: h3, holdingForFade: o2.holdingForFade(), collisionBoxArray: l3, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n3.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n3.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n3.sourceID) };
          if (r3)
            for (const e2 of n3.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r4 } = e2;
              t3.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r4, parameters: E3 });
            }
          else
            t3.push({ symbolInstanceStart: 0, symbolInstanceEnd: n3.symbolInstances.length, parameters: E3 });
        }
        attemptAnchorPlacement(e2, t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3, f2, g2) {
          const v3 = [u3.textOffset0, u3.textOffset1], x3 = zt(e2, i2, o2, v3, r3), y3 = this.collisionIndex.placeCollisionBox(d2, r3, t3, Dt(x3.x, x3.y, n3, a2, this.transform.angle), h3, s2, l3, c2.predicate);
          if ((!m3 || this.collisionIndex.placeCollisionBox(d2, d2.getSymbolInstanceIconSize(g2, this.transform.zoom, _2), m3, Dt(x3.x, x3.y, n3, a2, this.transform.angle), h3, s2, l3, c2.predicate).box.length !== 0) && y3.box.length > 0) {
            let t4;
            return this.prevPlacement && this.prevPlacement.variableOffsets[u3.crossTileID] && this.prevPlacement.placements[u3.crossTileID] && this.prevPlacement.placements[u3.crossTileID].text && (t4 = this.prevPlacement.variableOffsets[u3.crossTileID].anchor), this.variableOffsets[u3.crossTileID] = { textOffset: v3, width: i2, height: o2, anchor: e2, textScale: r3, prevAnchor: t4 }, this.markUsedJustification(d2, e2, u3, p3), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, p3, u3), this.placedOrientations[u3.crossTileID] = p3), { shift: x3, placedGlyphBoxes: y3 };
          }
        }
        placeLayerBucketPart(t3, i2, o2, r3) {
          const { bucket: n3, layout: a2, posMatrix: s2, textLabelPlaneMatrix: l3, labelToScreenMatrix: c2, clippingData: h3, textPixelRatio: u3, holdingForFade: _2, collisionBoxArray: d2, partiallyEvaluatedTextSize: p3, partiallyEvaluatedIconSize: m3, collisionGroup: f2 } = t3.parameters, g2 = a2.get("text-optional"), v3 = a2.get("icon-optional"), x3 = a2.get("text-allow-overlap"), y3 = a2.get("icon-allow-overlap"), b2 = a2.get("text-rotation-alignment") === "map", w2 = a2.get("text-pitch-alignment") === "map", T3 = a2.get("icon-text-fit") !== "none", E3 = a2.get("symbol-z-order") === "viewport-y";
          this.transform.setProjection(n3.projection);
          let C3 = x3 && (y3 || !n3.hasIconData() || v3), I3 = y3 && (x3 || !n3.hasTextData() || g2);
          !n3.collisionArrays && d2 && n3.deserializeCollisionBoxes(d2), o2 && r3 && n3.updateCollisionDebugBuffers(this.transform.zoom, d2);
          const M3 = (t4, r4, d3) => {
            if (h3) {
              const o3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
              let r5 = null;
              if (h3.dynamicFilterNeedsFeature) {
                const e2 = this.retainedQueryData[n3.bucketInstanceId];
                r5 = h3.featureIndex.loadFeature({ featureIndex: t4.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (!(0, h3.dynamicFilter)(o3, r5, this.retainedQueryData[n3.bucketInstanceId].tileID.canonical, new e.pointGeometry(t4.tileAnchorX, t4.tileAnchorY), this.transform.calculateDistanceTileData(h3.unwrappedTileID)))
                return this.placements[t4.crossTileID] = new Ct(false, false, false, true), void (i2[t4.crossTileID] = true);
            }
            if (i2[t4.crossTileID])
              return;
            if (_2)
              return void (this.placements[t4.crossTileID] = new Ct(false, false, false));
            let E4 = false, M4 = false, S3 = true, z3 = false, D3 = false, P3 = null, A3 = { box: null, offscreen: null, occluded: null }, L3 = { box: null, offscreen: null, occluded: null }, R3 = null, O3 = null, B3 = null, k2 = 0, F3 = 0, U3 = 0;
            d3.textFeatureIndex ? k2 = d3.textFeatureIndex : t4.useRuntimeCollisionCircles && (k2 = t4.featureIndex), d3.verticalTextFeatureIndex && (F3 = d3.verticalTextFeatureIndex);
            const N3 = (e2) => {
              e2.tileID = this.retainedQueryData[n3.bucketInstanceId].tileID, (this.transform.elevation || e2.elevation) && (e2.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[n3.bucketInstanceId].tileID, e2.tileAnchorX, e2.tileAnchorY) : 0);
            }, G3 = d3.textBox;
            if (G3) {
              N3(G3);
              const i3 = (i4) => {
                let o4 = e.WritingMode.horizontal;
                if (n3.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e2 = this.prevPlacement.placedOrientations[t4.crossTileID];
                  e2 && (this.placedOrientations[t4.crossTileID] = e2, o4 = e2, this.markUsedOrientation(n3, o4, t4));
                }
                return o4;
              }, o3 = (i4, o4) => {
                if (n3.allowVerticalPlacement && t4.numVerticalGlyphVertices > 0 && d3.verticalTextBox) {
                  for (const t5 of n3.writingModes)
                    if (t5 === e.WritingMode.vertical ? (A3 = o4(), L3 = A3) : A3 = i4(), A3 && A3.box && A3.box.length)
                      break;
                } else
                  A3 = i4();
              };
              if (a2.get("text-variable-anchor")) {
                let l4 = a2.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[t4.crossTileID]) {
                  const e2 = this.prevPlacement.variableOffsets[t4.crossTileID];
                  l4.indexOf(e2.anchor) > 0 && (l4 = l4.filter((t5) => t5 !== e2.anchor), l4.unshift(e2.anchor));
                }
                const c3 = (e2, i4, o4) => {
                  const a3 = n3.getSymbolInstanceTextSize(p3, t4, this.transform.zoom, r4), c4 = (e2.x2 - e2.x1) * a3 + 2 * e2.padding, h5 = (e2.y2 - e2.y1) * a3 + 2 * e2.padding, _3 = T3 && !y3 ? i4 : null;
                  _3 && N3(_3);
                  let d4 = { box: [], offscreen: false, occluded: false };
                  const g3 = x3 ? 2 * l4.length : l4.length;
                  for (let i5 = 0; i5 < g3; ++i5) {
                    const g4 = this.attemptAnchorPlacement(l4[i5 % l4.length], e2, c4, h5, a3, b2, w2, u3, s2, f2, i5 >= l4.length, t4, r4, n3, o4, _3, p3, m3);
                    if (g4 && (d4 = g4.placedGlyphBoxes, d4 && d4.box && d4.box.length)) {
                      E4 = true, P3 = g4.shift;
                      break;
                    }
                  }
                  return d4;
                };
                o3(() => c3(G3, d3.iconBox, e.WritingMode.horizontal), () => {
                  const i4 = d3.verticalTextBox;
                  return i4 && N3(i4), n3.allowVerticalPlacement && !(A3 && A3.box && A3.box.length) && t4.numVerticalGlyphVertices > 0 && i4 ? c3(i4, d3.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                }), A3 && (E4 = A3.box, S3 = A3.offscreen, z3 = A3.occluded);
                const h4 = i3(A3 && A3.box);
                if (!E4 && this.prevPlacement) {
                  const e2 = this.prevPlacement.variableOffsets[t4.crossTileID];
                  e2 && (this.variableOffsets[t4.crossTileID] = e2, this.markUsedJustification(n3, e2.anchor, t4, h4));
                }
              } else {
                const a3 = (i4, o4) => {
                  const a4 = n3.getSymbolInstanceTextSize(p3, t4, this.transform.zoom, r4), l4 = this.collisionIndex.placeCollisionBox(n3, a4, i4, new e.pointGeometry(0, 0), x3, u3, s2, f2.predicate);
                  return l4 && l4.box && l4.box.length && (this.markUsedOrientation(n3, o4, t4), this.placedOrientations[t4.crossTileID] = o4), l4;
                };
                o3(() => a3(G3, e.WritingMode.horizontal), () => {
                  const i4 = d3.verticalTextBox;
                  return n3.allowVerticalPlacement && t4.numVerticalGlyphVertices > 0 && i4 ? (N3(i4), a3(i4, e.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                }), i3(A3 && A3.box && A3.box.length);
              }
            }
            if (R3 = A3, E4 = R3 && R3.box && R3.box.length > 0, S3 = R3 && R3.offscreen, z3 = R3 && R3.occluded, t4.useRuntimeCollisionCircles) {
              const i3 = n3.text.placedSymbolArray.get(t4.centerJustifiedTextSymbolIndex >= 0 ? t4.centerJustifiedTextSymbolIndex : t4.verticalPlacedTextSymbolIndex), r5 = e.evaluateSizeForFeature(n3.textSizeData, p3, i3), h4 = a2.get("text-padding");
              O3 = this.collisionIndex.placeCollisionCircles(n3, x3, i3, n3.lineVertexArray, n3.glyphOffsetArray, r5, s2, l3, c2, o2, w2, f2.predicate, t4.collisionCircleDiameter * r5 / e.ONE_EM, h4, this.retainedQueryData[n3.bucketInstanceId].tileID), E4 = x3 || O3.circles.length > 0 && !O3.collisionDetected, S3 = S3 && O3.offscreen, z3 = O3.occluded;
            }
            if (d3.iconFeatureIndex && (U3 = d3.iconFeatureIndex), d3.iconBox) {
              const t5 = (t6) => {
                N3(t6);
                const i3 = T3 && P3 ? Dt(P3.x, P3.y, b2, w2, this.transform.angle) : new e.pointGeometry(0, 0), o3 = n3.getSymbolInstanceIconSize(m3, this.transform.zoom, r4);
                return this.collisionIndex.placeCollisionBox(n3, o3, t6, i3, y3, u3, s2, f2.predicate);
              };
              L3 && L3.box && L3.box.length && d3.verticalIconBox ? (B3 = t5(d3.verticalIconBox), M4 = B3.box.length > 0) : (B3 = t5(d3.iconBox), M4 = B3.box.length > 0), S3 = S3 && B3.offscreen, D3 = B3.occluded;
            }
            const j2 = g2 || t4.numHorizontalGlyphVertices === 0 && t4.numVerticalGlyphVertices === 0, Z3 = v3 || t4.numIconVertices === 0;
            if (j2 || Z3 ? Z3 ? j2 || (M4 = M4 && E4) : E4 = M4 && E4 : M4 = E4 = M4 && E4, E4 && R3 && R3.box && this.collisionIndex.insertCollisionBox(R3.box, a2.get("text-ignore-placement"), n3.bucketInstanceId, L3 && L3.box && F3 ? F3 : k2, f2.ID), M4 && B3 && this.collisionIndex.insertCollisionBox(B3.box, a2.get("icon-ignore-placement"), n3.bucketInstanceId, U3, f2.ID), O3 && (E4 && this.collisionIndex.insertCollisionCircles(O3.circles, a2.get("text-ignore-placement"), n3.bucketInstanceId, k2, f2.ID), o2)) {
              const e2 = n3.bucketInstanceId;
              let t5 = this.collisionCircleArrays[e2];
              t5 === void 0 && (t5 = this.collisionCircleArrays[e2] = new It());
              for (let e3 = 0; e3 < O3.circles.length; e3 += 4)
                t5.circles.push(O3.circles[e3 + 0]), t5.circles.push(O3.circles[e3 + 1]), t5.circles.push(O3.circles[e3 + 2]), t5.circles.push(O3.collisionDetected ? 1 : 0);
            }
            const V3 = n3.projection.name !== "globe";
            C3 = C3 && (V3 || !z3), I3 = I3 && (V3 || !D3), this.placements[t4.crossTileID] = new Ct(E4 || C3, M4 || I3, S3 || n3.justReloaded), i2[t4.crossTileID] = true;
          };
          if (E3) {
            const e2 = n3.getSortedSymbolIndexes(this.transform.angle);
            for (let t4 = e2.length - 1; t4 >= 0; --t4) {
              const i3 = e2[t4];
              M3(n3.symbolInstances.get(i3), i3, n3.collisionArrays[i3]);
            }
          } else
            for (let e2 = t3.symbolInstanceStart; e2 < t3.symbolInstanceEnd; e2++)
              M3(n3.symbolInstances.get(e2), e2, n3.collisionArrays[e2]);
          if (o2 && n3.bucketInstanceId in this.collisionCircleArrays) {
            const t4 = this.collisionCircleArrays[n3.bucketInstanceId];
            e.invert(t4.invProjMatrix, s2), t4.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          n3.justReloaded = false;
        }
        markUsedJustification(t3, i2, o2, r3) {
          let n3;
          n3 = r3 === e.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[e.getAnchorJustification(i2)];
          const a2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
          for (const e2 of a2)
            e2 >= 0 && (t3.text.placedSymbolArray.get(e2).crossTileID = n3 >= 0 && e2 !== n3 ? 0 : o2.crossTileID);
        }
        markUsedOrientation(t3, i2, o2) {
          const r3 = i2 === e.WritingMode.horizontal || i2 === e.WritingMode.horizontalOnly ? i2 : 0, n3 = i2 === e.WritingMode.vertical ? i2 : 0, a2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
          for (const e2 of a2)
            t3.text.placedSymbolArray.get(e2).placedOrientation = r3;
          o2.verticalPlacedTextSymbolIndex && (t3.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = n3);
        }
        commit(e2) {
          this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t3 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = t3 ? t3.zoomAdjustment(this.transform.zoom) : 0;
          const o2 = t3 ? t3.symbolFadeChange(e2) : 1, r3 = t3 ? t3.opacities : {}, n3 = t3 ? t3.variableOffsets : {}, a2 = t3 ? t3.placedOrientations : {};
          for (const e3 in this.placements) {
            const t4 = this.placements[e3], n4 = r3[e3];
            n4 ? (this.opacities[e3] = new Et(n4, o2, t4.text, t4.icon, null, t4.clipped), i2 = i2 || t4.text !== n4.text.placed || t4.icon !== n4.icon.placed) : (this.opacities[e3] = new Et(null, o2, t4.text, t4.icon, t4.skipFade, t4.clipped), i2 = i2 || t4.text || t4.icon);
          }
          for (const e3 in r3) {
            const t4 = r3[e3];
            if (!this.opacities[e3]) {
              const r4 = new Et(t4, o2, false, false);
              r4.isHidden() || (this.opacities[e3] = r4, i2 = i2 || t4.text.placed || t4.icon.placed);
            }
          }
          for (const e3 in n3)
            this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = n3[e3]);
          for (const e3 in a2)
            this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = a2[e3]);
          i2 ? this.lastPlacementChangeTime = e2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t3 ? t3.lastPlacementChangeTime : e2);
        }
        updateLayerOpacities(e2, t3) {
          const i2 = {};
          for (const o2 of t3) {
            const t4 = o2.getBucket(e2);
            t4 && o2.latestFeatureIndex && e2.id === t4.layerIds[0] && this.updateBucketOpacities(t4, i2, o2.collisionBoxArray);
          }
        }
        updateBucketOpacities(t3, i2, o2) {
          t3.hasTextData() && t3.text.opacityVertexArray.clear(), t3.hasIconData() && t3.icon.opacityVertexArray.clear(), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexArray.clear(), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexArray.clear();
          const r3 = t3.layers[0].layout, n3 = !!t3.layers[0].dynamicFilter(), a2 = new Et(null, 0, false, false, true), s2 = r3.get("text-allow-overlap"), l3 = r3.get("icon-allow-overlap"), c2 = r3.get("text-variable-anchor"), h3 = r3.get("text-rotation-alignment") === "map", u3 = r3.get("text-pitch-alignment") === "map", _2 = r3.get("icon-text-fit") !== "none", d2 = new Et(null, 0, s2 && (l3 || !t3.hasIconData() || r3.get("icon-optional")), l3 && (s2 || !t3.hasTextData() || r3.get("text-optional")), true);
          !t3.collisionArrays && o2 && (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) && t3.deserializeCollisionBoxes(o2);
          const p3 = (e2, t4, i3) => {
            for (let o3 = 0; o3 < t4 / 4; o3++)
              e2.opacityVertexArray.emplaceBack(i3);
          };
          let m3 = 0;
          for (let o3 = 0; o3 < t3.symbolInstances.length; o3++) {
            const r4 = t3.symbolInstances.get(o3), { numHorizontalGlyphVertices: s3, numVerticalGlyphVertices: l4, crossTileID: f2 } = r4;
            let g2 = this.opacities[f2];
            i2[f2] ? g2 = a2 : g2 || (g2 = d2, this.opacities[f2] = g2), i2[f2] = true;
            const v3 = s3 > 0 || l4 > 0, x3 = r4.numIconVertices > 0, y3 = this.placedOrientations[r4.crossTileID], b2 = y3 === e.WritingMode.vertical, w2 = y3 === e.WritingMode.horizontal || y3 === e.WritingMode.horizontalOnly;
            if (!v3 && !x3 || g2.isHidden() || m3++, v3) {
              const e2 = Nt(g2.text);
              p3(t3.text, s3, b2 ? Gt : e2), p3(t3.text, l4, w2 ? Gt : e2);
              const i3 = g2.text.isHidden();
              [r4.rightJustifiedTextSymbolIndex, r4.centerJustifiedTextSymbolIndex, r4.leftJustifiedTextSymbolIndex].forEach((e3) => {
                e3 >= 0 && (t3.text.placedSymbolArray.get(e3).hidden = i3 || b2 ? 1 : 0);
              }), r4.verticalPlacedTextSymbolIndex >= 0 && (t3.text.placedSymbolArray.get(r4.verticalPlacedTextSymbolIndex).hidden = i3 || w2 ? 1 : 0);
              const o4 = this.variableOffsets[r4.crossTileID];
              o4 && this.markUsedJustification(t3, o4.anchor, r4, y3);
              const n4 = this.placedOrientations[r4.crossTileID];
              n4 && (this.markUsedJustification(t3, "left", r4, n4), this.markUsedOrientation(t3, n4, r4));
            }
            if (x3) {
              const e2 = Nt(g2.icon);
              r4.placedIconSymbolIndex >= 0 && (p3(t3.icon, r4.numIconVertices, b2 ? Gt : e2), t3.icon.placedSymbolArray.get(r4.placedIconSymbolIndex).hidden = g2.icon.isHidden()), r4.verticalPlacedIconSymbolIndex >= 0 && (p3(t3.icon, r4.numVerticalIconVertices, w2 ? Gt : e2), t3.icon.placedSymbolArray.get(r4.verticalPlacedIconSymbolIndex).hidden = g2.icon.isHidden());
            }
            if (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) {
              const i3 = t3.collisionArrays[o3];
              if (i3) {
                let o4 = new e.pointGeometry(0, 0), r5 = true;
                if (i3.textBox || i3.verticalTextBox) {
                  if (c2) {
                    const e2 = this.variableOffsets[f2];
                    e2 ? (o4 = zt(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), h3 && o4._rotate(u3 ? this.transform.angle : -this.transform.angle)) : r5 = false;
                  }
                  n3 && (r5 = !g2.clipped), i3.textBox && At(t3.textCollisionBox.collisionVertexArray, g2.text.placed, !r5 || b2, o4.x, o4.y), i3.verticalTextBox && At(t3.textCollisionBox.collisionVertexArray, g2.text.placed, !r5 || w2, o4.x, o4.y);
                }
                const a3 = r5 && Boolean(!w2 && i3.verticalIconBox);
                i3.iconBox && At(t3.iconCollisionBox.collisionVertexArray, g2.icon.placed, a3, _2 ? o4.x : 0, _2 ? o4.y : 0), i3.verticalIconBox && At(t3.iconCollisionBox.collisionVertexArray, g2.icon.placed, !a3, _2 ? o4.x : 0, _2 ? o4.y : 0);
              }
            }
          }
          if (t3.fullyClipped = m3 === 0, t3.sortFeatures(this.transform.angle), this.retainedQueryData[t3.bucketInstanceId] && (this.retainedQueryData[t3.bucketInstanceId].featureSortOrder = t3.featureSortOrder), t3.hasTextData() && t3.text.opacityVertexBuffer && t3.text.opacityVertexBuffer.updateData(t3.text.opacityVertexArray), t3.hasIconData() && t3.icon.opacityVertexBuffer && t3.icon.opacityVertexBuffer.updateData(t3.icon.opacityVertexArray), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexBuffer && t3.iconCollisionBox.collisionVertexBuffer.updateData(t3.iconCollisionBox.collisionVertexArray), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexBuffer && t3.textCollisionBox.collisionVertexBuffer.updateData(t3.textCollisionBox.collisionVertexArray), t3.bucketInstanceId in this.collisionCircleArrays) {
            const e2 = this.collisionCircleArrays[t3.bucketInstanceId];
            t3.placementInvProjMatrix = e2.invProjMatrix, t3.placementViewportMatrix = e2.viewportMatrix, t3.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t3.bucketInstanceId];
          }
        }
        symbolFadeChange(e2) {
          return this.fadeDuration === 0 ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e2) {
          return Math.max(0, (this.transform.zoom - e2) / 1.5);
        }
        hasTransitions(e2) {
          return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e2, t3) {
          const i2 = this.zoomAtLastRecencyCheck === t3 ? 1 - this.zoomAdjustment(t3) : 1;
          return this.zoomAtLastRecencyCheck = t3, this.commitTime + this.fadeDuration * i2 > e2;
        }
        setStale() {
          this.stale = true;
        }
      }
      function At(e2, t3, i2, o2, r3) {
        e2.emplaceBack(t3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), e2.emplaceBack(t3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), e2.emplaceBack(t3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), e2.emplaceBack(t3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0);
      }
      const Lt = Math.pow(2, 25), Rt = Math.pow(2, 24), Ot = Math.pow(2, 17), Bt = Math.pow(2, 16), kt = Math.pow(2, 9), Ft = Math.pow(2, 8), Ut = Math.pow(2, 1);
      function Nt(e2) {
        if (e2.opacity === 0 && !e2.placed)
          return 0;
        if (e2.opacity === 1 && e2.placed)
          return 4294967295;
        const t3 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
        return i2 * Lt + t3 * Rt + i2 * Ot + t3 * Bt + i2 * kt + t3 * Ft + i2 * Ut + t3;
      }
      const Gt = 0;
      class jt {
        constructor(e2) {
          this._sortAcrossTiles = e2.layout.get("symbol-z-order") !== "viewport-y" && e2.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e2, t3, i2, o2, r3) {
          const n3 = this._bucketParts;
          for (; this._currentTileIndex < e2.length; )
            if (t3.getBucketParts(n3, o2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r3())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n3.sort((e3, t4) => e3.sortKey - t4.sortKey)); this._currentPartIndex < n3.length; ) {
            const e3 = n3[this._currentPartIndex];
            if (t3.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, e3.symbolInstanceStart === 0), this._currentPartIndex++, r3())
              return true;
          }
          return false;
        }
      }
      class Zt {
        constructor(e2, t3, i2, o2, r3, n3, a2, s2) {
          this.placement = new Pt(e2, r3, n3, a2, s2), this._currentPlacementIndex = t3.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t3, i2, o2) {
          const r3 = e.exported.now(), n3 = () => {
            const t4 = e.exported.now() - r3;
            return !this._forceFullPlacement && t4 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const e2 = i2[t3[this._currentPlacementIndex]], r4 = this.placement.collisionIndex.transform.zoom;
            if (e2.type === "symbol" && (!e2.minzoom || e2.minzoom <= r4) && (!e2.maxzoom || e2.maxzoom > r4)) {
              if (this._inProgressLayer || (this._inProgressLayer = new jt(e2)), this._inProgressLayer.continuePlacement(o2[e2.source], this.placement, this._showCollisionBoxes, e2, n3))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e2) {
          return this.placement.commit(e2), this.placement;
        }
      }
      const Vt = 512 / e.EXTENT / 2;
      class Wt {
        constructor(e2, t3, i2) {
          this.tileID = e2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
          for (let i3 = 0; i3 < t3.length; i3++) {
            const o2 = t3.get(i3), r3 = o2.key;
            this.indexedSymbolInstances[r3] || (this.indexedSymbolInstances[r3] = []), this.indexedSymbolInstances[r3].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, e2) });
          }
        }
        getScaledCoordinates(t3, i2) {
          const o2 = Vt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
          return { x: Math.floor((i2.canonical.x * e.EXTENT + t3.tileAnchorX) * o2), y: Math.floor((i2.canonical.y * e.EXTENT + t3.tileAnchorY) * o2) };
        }
        findMatches(e2, t3, i2) {
          const o2 = this.tileID.canonical.z < t3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t3.canonical.z);
          for (let r3 = 0; r3 < e2.length; r3++) {
            const n3 = e2.get(r3);
            if (n3.crossTileID)
              continue;
            const a2 = this.indexedSymbolInstances[n3.key];
            if (!a2)
              continue;
            const s2 = this.getScaledCoordinates(n3, t3);
            for (const e3 of a2)
              if (Math.abs(e3.coord.x - s2.x) <= o2 && Math.abs(e3.coord.y - s2.y) <= o2 && !i2[e3.crossTileID]) {
                i2[e3.crossTileID] = true, n3.crossTileID = e3.crossTileID;
                break;
              }
          }
        }
      }
      class Xt {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class qt {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e2) {
          const t3 = Math.round((e2 - this.lng) / 360);
          if (t3 !== 0)
            for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], o2 = {};
              for (const e4 in i2) {
                const r3 = i2[e4];
                r3.tileID = r3.tileID.unwrapTo(r3.tileID.wrap + t3), o2[r3.tileID.key] = r3;
              }
              this.indexes[e3] = o2;
            }
          this.lng = e2;
        }
        addBucket(e2, t3, i2) {
          if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
            if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t3.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
          }
          for (let e3 = 0; e3 < t3.symbolInstances.length; e3++)
            t3.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
          const o2 = this.usedCrossTileIDs[e2.overscaledZ];
          for (const i3 in this.indexes) {
            const r3 = this.indexes[i3];
            if (Number(i3) > e2.overscaledZ)
              for (const i4 in r3) {
                const n3 = r3[i4];
                n3.tileID.isChildOf(e2) && n3.findMatches(t3.symbolInstances, e2, o2);
              }
            else {
              const n3 = r3[e2.scaledTo(Number(i3)).key];
              n3 && n3.findMatches(t3.symbolInstances, e2, o2);
            }
          }
          for (let e3 = 0; e3 < t3.symbolInstances.length; e3++) {
            const r3 = t3.symbolInstances.get(e3);
            r3.crossTileID || (r3.crossTileID = i2.generate(), o2[r3.crossTileID] = true);
          }
          return this.indexes[e2.overscaledZ] === void 0 && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Wt(e2, t3.symbolInstances, t3.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e2, t3) {
          for (const i2 in t3.indexedSymbolInstances)
            for (const o2 of t3.indexedSymbolInstances[i2])
              delete this.usedCrossTileIDs[e2][o2.crossTileID];
        }
        removeStaleBuckets(e2) {
          let t3 = false;
          for (const i2 in this.indexes) {
            const o2 = this.indexes[i2];
            for (const r3 in o2)
              e2[o2[r3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r3]), delete o2[r3], t3 = true);
          }
          return t3;
        }
      }
      class $t {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Xt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e2, t3, i2, o2) {
          let r3 = this.layerIndexes[e2.id];
          r3 === void 0 && (r3 = this.layerIndexes[e2.id] = new qt());
          let n3 = false;
          const a2 = {};
          o2.name !== "globe" && r3.handleWrapJump(i2);
          for (const i3 of t3) {
            const t4 = i3.getBucket(e2);
            t4 && e2.id === t4.layerIds[0] && (t4.bucketInstanceId || (t4.bucketInstanceId = ++this.maxBucketInstanceId), r3.addBucket(i3.tileID, t4, this.crossTileIDs) && (n3 = true), a2[t4.bucketInstanceId] = true);
          }
          return r3.removeStaleBuckets(a2) && (n3 = true), n3;
        }
        pruneUnusedLayers(e2) {
          const t3 = {};
          e2.forEach((e3) => {
            t3[e3] = true;
          });
          for (const e3 in this.layerIndexes)
            t3[e3] || delete this.layerIndexes[e3];
        }
      }
      const Ht = (t3, i2) => e.emitValidationErrors(t3, i2 && i2.filter((e2) => e2.identifier !== "source.canvas")), Yt = e.pick(Ve, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), Kt = e.pick(Ve, ["setCenter", "setZoom", "setBearing", "setPitch"]), Jt = { version: 8, layers: [], sources: {} }, Qt = { fill: true, line: true, background: true, hillshade: true, raster: true };
      class ei2 extends e.Evented {
        constructor(t3, i2 = {}) {
          super(), this.map = t3, this.dispatcher = new A2(Ge2(), this), this.imageManager = new y2(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t3._requestManager, i2.localFontFamily ? e.LocalGlyphMode.all : i2.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i2.localFontFamily || i2.localIdeographFontFamily), this.lineAtlas = new e.LineAtlas(256, 512), this.crossTileSymbolIndex = new $t(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this.zoomHistory = new e.ZoomHistory(), this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
          const o2 = this;
          this._rtlTextPluginCallback = ei2.registerForPluginStateChange((t4) => {
            o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t4.pluginStatus, pluginURL: t4.pluginURL }, (t5, i3) => {
              if (e.triggerPluginCompletionEvent(t5), i3 && i3.every((e2) => e2))
                for (const e2 in o2._sourceCaches) {
                  const t6 = o2._sourceCaches[e2], i4 = t6.getSource().type;
                  i4 !== "vector" && i4 !== "geojson" || t6.reload();
                }
            });
          }), this.on("data", (e2) => {
            if (e2.dataType !== "source" || e2.sourceDataType !== "metadata")
              return;
            const t4 = this.getSource(e2.sourceId);
            if (t4 && t4.vectorLayerIds)
              for (const e3 in this._layers) {
                const i3 = this._layers[e3];
                i3.source === t4.id && this._validateLayer(i3);
              }
          });
        }
        loadURL(t3, i2 = {}) {
          this.fire(new e.Event("dataloading", { dataType: "style" }));
          const o2 = typeof i2.validate == "boolean" ? i2.validate : !e.isMapboxURL(t3);
          t3 = this.map._requestManager.normalizeStyleURL(t3, i2.accessToken);
          const r3 = this.map._requestManager.transformRequest(t3, e.ResourceType.Style);
          this._request = e.getJSON(r3, (t4, i3) => {
            this._request = null, t4 ? this.fire(new e.ErrorEvent(t4)) : i3 && this._load(i3, o2);
          });
        }
        loadJSON(t3, i2 = {}) {
          this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame(() => {
            this._request = null, this._load(t3, i2.validate !== false);
          });
        }
        loadEmpty() {
          this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(Jt, false);
        }
        _updateLayerCount(e2, t3) {
          const i2 = t3 ? 1 : -1;
          e2.is3D() && (this._num3DLayers += i2), e2.type === "circle" && (this._numCircleLayers += i2), e2.type === "symbol" && (this._numSymbolLayers += i2);
        }
        _load(t3, i2) {
          if (i2 && Ht(this, e.validateStyle(t3)))
            return;
          this._loaded = true, this.stylesheet = e.clone$1(t3), this._updateMapProjection();
          for (const e2 in t3.sources)
            this.addSource(e2, t3.sources[e2], { validate: false });
          this._changed = false, t3.sprite ? this._loadSprite(t3.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t3.glyphs);
          const o2 = Ze2(this.stylesheet.layers);
          this._order = o2.map((e2) => e2.id), this._layers = {}, this._serializedLayers = {};
          for (let t4 of o2)
            t4 = e.createStyleLayer(t4), t4.setEventedParent(this, { layer: { id: t4.id } }), this._layers[t4.id] = t4, this._serializedLayers[t4.id] = t4.serialize(), this._updateLayerCount(t4, true);
          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T2(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load"));
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && this.terrain.drapeRenderMode === 0;
        }
        setProjection(e2) {
          e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
        }
        _updateMapProjection() {
          this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
        }
        _loadSprite(t3) {
          this._spriteRequest = function(t4, i2, o2) {
            let r3, n3, a2;
            const s2 = e.exported.devicePixelRatio > 1 ? "@2x" : "";
            let l3 = e.getJSON(i2.transformRequest(i2.normalizeSpriteURL(t4, s2, ".json"), e.ResourceType.SpriteJSON), (e2, t5) => {
              l3 = null, a2 || (a2 = e2, r3 = t5, h3());
            }), c2 = e.getImage(i2.transformRequest(i2.normalizeSpriteURL(t4, s2, ".png"), e.ResourceType.SpriteImage), (e2, t5) => {
              c2 = null, a2 || (a2 = e2, n3 = t5, h3());
            });
            function h3() {
              if (a2)
                o2(a2);
              else if (r3 && n3) {
                const t5 = e.exported.getImageData(n3), i3 = {};
                for (const o3 in r3) {
                  const { width: n4, height: a3, x: s3, y: l4, sdf: c3, pixelRatio: h4, stretchX: u3, stretchY: _2, content: d2 } = r3[o3], p3 = new e.RGBAImage({ width: n4, height: a3 });
                  e.RGBAImage.copy(t5, p3, { x: s3, y: l4 }, { x: 0, y: 0 }, { width: n4, height: a3 }), i3[o3] = { data: p3, pixelRatio: h4, sdf: c3, stretchX: u3, stretchY: _2, content: d2 };
                }
                o2(null, i3);
              }
            }
            return { cancel() {
              l3 && (l3.cancel(), l3 = null), c2 && (c2.cancel(), c2 = null);
            } };
          }(t3, this.map._requestManager, (t4, i2) => {
            if (this._spriteRequest = null, t4)
              this.fire(new e.ErrorEvent(t4));
            else if (i2)
              for (const e2 in i2)
                this.imageManager.addImage(e2, i2[e2]);
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e.Event("data", { dataType: "style" }));
          });
        }
        _validateLayer(t3) {
          const i2 = this.getSource(t3.source);
          if (!i2)
            return;
          const o2 = t3.sourceLayer;
          o2 && (i2.type === "geojson" || i2.vectorLayerIds && i2.vectorLayerIds.indexOf(o2) === -1) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t3.id}"`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (const e2 in this._sourceCaches)
            if (!this._sourceCaches[e2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeLayers(e2) {
          const t3 = [];
          for (const i2 of e2) {
            const e3 = this._layers[i2];
            e3.type !== "custom" && t3.push(e3.serialize());
          }
          return t3;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition())
            return true;
          if (this.fog && this.fog.hasTransition())
            return true;
          for (const e2 in this._sourceCaches)
            if (this._sourceCaches[e2].hasTransition())
              return true;
          for (const e2 in this._layers)
            if (this._layers[e2].hasTransition())
              return true;
          return false;
        }
        get order() {
          return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
        }
        isLayerDraped(e2) {
          return !!this.terrain && Qt[e2.type];
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        update(t3) {
          if (!this._loaded)
            return;
          const i2 = this._changed;
          if (this._changed) {
            const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
            (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
            for (const e3 in this._updatedSources) {
              const t4 = this._updatedSources[e3];
              t4 === "reload" ? this._reloadSource(e3) : t4 === "clear" && this._clearSource(e3);
            }
            this._updateTilesForChangedImages();
            for (const e3 in this._updatedPaintProps)
              this._layers[e3].updateTransitions(t3);
            this.light.updateTransitions(t3), this.fog && this.fog.updateTransitions(t3), this._resetUpdates();
          }
          const o2 = {};
          for (const e2 in this._sourceCaches) {
            const t4 = this._sourceCaches[e2];
            o2[e2] = t4.used, t4.used = false;
          }
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            if (i3.recalculate(t3, this._availableImages), !i3.isHidden(t3.zoom)) {
              const e3 = this._getLayerSourceCache(i3);
              e3 && (e3.used = true);
            }
            const o3 = this.map.painter;
            if (o3) {
              const e3 = i3.getProgramIds();
              if (!e3)
                continue;
              const r3 = i3.getProgramConfiguration(t3.zoom);
              for (const t4 of e3)
                o3.useProgram(t4, r3);
            }
          }
          for (const t4 in o2) {
            const i3 = this._sourceCaches[t4];
            o2[t4] !== i3.used && i3.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
          }
          this.light.recalculate(t3), this.terrain && this.terrain.recalculate(t3), this.fog && this.fog.recalculate(t3), this.z = t3.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i2 && this.fire(new e.Event("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e2 = Object.keys(this._changedImages);
          if (e2.length) {
            for (const t3 in this._sourceCaches)
              this._sourceCaches[t3].reloadTilesForDependencies(["icons", "patterns"], e2);
            this._changedImages = {};
          }
        }
        _updateWorkerLayers(e2, t3) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e2), removedIds: t3 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }
        setState(i2) {
          if (this._checkLoaded(), Ht(this, e.validateStyle(i2)))
            return false;
          (i2 = e.clone$1(i2)).layers = Ze2(i2.layers);
          const o2 = function(e2, i3) {
            if (!e2)
              return [{ command: Ve.setStyle, args: [i3] }];
            let o3 = [];
            try {
              if (!t2(e2.version, i3.version))
                return [{ command: Ve.setStyle, args: [i3] }];
              t2(e2.center, i3.center) || o3.push({ command: Ve.setCenter, args: [i3.center] }), t2(e2.zoom, i3.zoom) || o3.push({ command: Ve.setZoom, args: [i3.zoom] }), t2(e2.bearing, i3.bearing) || o3.push({ command: Ve.setBearing, args: [i3.bearing] }), t2(e2.pitch, i3.pitch) || o3.push({ command: Ve.setPitch, args: [i3.pitch] }), t2(e2.sprite, i3.sprite) || o3.push({ command: Ve.setSprite, args: [i3.sprite] }), t2(e2.glyphs, i3.glyphs) || o3.push({ command: Ve.setGlyphs, args: [i3.glyphs] }), t2(e2.transition, i3.transition) || o3.push({ command: Ve.setTransition, args: [i3.transition] }), t2(e2.light, i3.light) || o3.push({ command: Ve.setLight, args: [i3.light] }), t2(e2.fog, i3.fog) || o3.push({ command: Ve.setFog, args: [i3.fog] }), t2(e2.projection, i3.projection) || o3.push({ command: Ve.setProjection, args: [i3.projection] });
              const r4 = {}, n3 = [];
              !function(e3, i4, o4, r5) {
                let n4;
                for (n4 in i4 = i4 || {}, e3 = e3 || {})
                  e3.hasOwnProperty(n4) && (i4.hasOwnProperty(n4) || Xe2(n4, o4, r5));
                for (n4 in i4)
                  i4.hasOwnProperty(n4) && (e3.hasOwnProperty(n4) ? t2(e3[n4], i4[n4]) || (e3[n4].type === "geojson" && i4[n4].type === "geojson" && $e2(e3, i4, n4) ? o4.push({ command: Ve.setGeoJSONSourceData, args: [n4, i4[n4].data] }) : qe2(n4, i4, o4, r5)) : We(n4, i4, o4));
              }(e2.sources, i3.sources, n3, r4);
              const a2 = [];
              e2.layers && e2.layers.forEach((e3) => {
                e3.source && r4[e3.source] ? o3.push({ command: Ve.removeLayer, args: [e3.id] }) : a2.push(e3);
              });
              let s2 = e2.terrain;
              s2 && r4[s2.source] && (o3.push({ command: Ve.setTerrain, args: [void 0] }), s2 = void 0), o3 = o3.concat(n3), t2(s2, i3.terrain) || o3.push({ command: Ve.setTerrain, args: [i3.terrain] }), function(e3, i4, o4) {
                i4 = i4 || [];
                const r5 = (e3 = e3 || []).map(Ye2), n4 = i4.map(Ye2), a3 = e3.reduce(Ke2, {}), s3 = i4.reduce(Ke2, {}), l3 = r5.slice(), c2 = Object.create(null);
                let h3, u3, _2, d2, p3, m3, f2;
                for (h3 = 0, u3 = 0; h3 < r5.length; h3++)
                  _2 = r5[h3], s3.hasOwnProperty(_2) ? u3++ : (o4.push({ command: Ve.removeLayer, args: [_2] }), l3.splice(l3.indexOf(_2, u3), 1));
                for (h3 = 0, u3 = 0; h3 < n4.length; h3++)
                  _2 = n4[n4.length - 1 - h3], l3[l3.length - 1 - h3] !== _2 && (a3.hasOwnProperty(_2) ? (o4.push({ command: Ve.removeLayer, args: [_2] }), l3.splice(l3.lastIndexOf(_2, l3.length - u3), 1)) : u3++, m3 = l3[l3.length - h3], o4.push({ command: Ve.addLayer, args: [s3[_2], m3] }), l3.splice(l3.length - h3, 0, _2), c2[_2] = true);
                for (h3 = 0; h3 < n4.length; h3++)
                  if (_2 = n4[h3], d2 = a3[_2], p3 = s3[_2], !c2[_2] && !t2(d2, p3))
                    if (t2(d2.source, p3.source) && t2(d2["source-layer"], p3["source-layer"]) && t2(d2.type, p3.type)) {
                      for (f2 in He2(d2.layout, p3.layout, o4, _2, null, Ve.setLayoutProperty), He2(d2.paint, p3.paint, o4, _2, null, Ve.setPaintProperty), t2(d2.filter, p3.filter) || o4.push({ command: Ve.setFilter, args: [_2, p3.filter] }), t2(d2.minzoom, p3.minzoom) && t2(d2.maxzoom, p3.maxzoom) || o4.push({ command: Ve.setLayerZoomRange, args: [_2, p3.minzoom, p3.maxzoom] }), d2)
                        d2.hasOwnProperty(f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? He2(d2[f2], p3[f2], o4, _2, f2.slice(6), Ve.setPaintProperty) : t2(d2[f2], p3[f2]) || o4.push({ command: Ve.setLayerProperty, args: [_2, f2, p3[f2]] }));
                      for (f2 in p3)
                        p3.hasOwnProperty(f2) && !d2.hasOwnProperty(f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? He2(d2[f2], p3[f2], o4, _2, f2.slice(6), Ve.setPaintProperty) : t2(d2[f2], p3[f2]) || o4.push({ command: Ve.setLayerProperty, args: [_2, f2, p3[f2]] }));
                    } else
                      o4.push({ command: Ve.removeLayer, args: [_2] }), m3 = l3[l3.lastIndexOf(_2) + 1], o4.push({ command: Ve.addLayer, args: [p3, m3] });
              }(a2, i3.layers, o3);
            } catch (e3) {
              console.warn("Unable to compute style diff:", e3), o3 = [{ command: Ve.setStyle, args: [i3] }];
            }
            return o3;
          }(this.serialize(), i2).filter((e2) => !(e2.command in Kt));
          if (o2.length === 0)
            return false;
          const r3 = o2.filter((e2) => !(e2.command in Yt));
          if (r3.length > 0)
            throw new Error(`Unimplemented: ${r3.map((e2) => e2.command).join(", ")}.`);
          return o2.forEach((e2) => {
            e2.command !== "setTransition" && e2.command !== "setProjection" && this[e2.command].apply(this, e2.args);
          }), this.stylesheet = i2, this._updateMapProjection(), true;
        }
        addImage(t3, i2) {
          return this.getImage(t3) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t3, i2), this._afterImageUpdated(t3), this);
        }
        updateImage(e2, t3) {
          this.imageManager.updateImage(e2, t3);
        }
        getImage(e2) {
          return this.imageManager.getImage(e2);
        }
        removeImage(t3) {
          return this.getImage(t3) ? (this.imageManager.removeImage(t3), this._afterImageUpdated(t3), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(t3) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addSource(t3, i2, o2 = {}) {
          if (this._checkLoaded(), this.getSource(t3) !== void 0)
            throw new Error("There is already a source with this ID");
          if (!i2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.validateSource, `sources.${t3}`, i2, null, o2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const r3 = Ae2(t3, i2, this.dispatcher, this);
          r3.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(t3), source: r3.serialize(), sourceId: t3 }));
          const n3 = (i3) => {
            const o3 = (i3 ? "symbol:" : "other:") + t3, n4 = this._sourceCaches[o3] = new e.SourceCache(o3, r3, i3);
            (i3 ? this._symbolSourceCaches : this._otherSourceCaches)[t3] = n4, n4.style = this, n4.onAdd(this.map);
          };
          n3(false), i2.type !== "vector" && i2.type !== "geojson" || n3(true), r3.onAdd && r3.onAdd(this.map), this._changed = true;
        }
        removeSource(t3) {
          this._checkLoaded();
          const i2 = this.getSource(t3);
          if (!i2)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === t3)
              return this.fire(new e.ErrorEvent(new Error(`Source "${t3}" cannot be removed while layer "${i3}" is using it.`)));
          if (this.terrain && this.terrain.get().source === t3)
            return this.fire(new e.ErrorEvent(new Error(`Source "${t3}" cannot be removed while terrain is using it.`)));
          const o2 = this._getSourceCaches(t3);
          for (const t4 of o2)
            delete this._sourceCaches[t4.id], delete this._updatedSources[t4.id], t4.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t4.getSource().id })), t4.setEventedParent(null), t4.clearTiles();
          return delete this._otherSourceCaches[t3], delete this._symbolSourceCaches[t3], i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changed = true, this;
        }
        setGeoJSONSourceData(e2, t3) {
          this._checkLoaded(), this.getSource(e2).setData(t3), this._changed = true;
        }
        getSource(e2) {
          const t3 = this._getSourceCache(e2);
          return t3 && t3.getSource();
        }
        addLayer(t3, i2, o2 = {}) {
          this._checkLoaded();
          const r3 = t3.id;
          if (this.getLayer(r3))
            return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r3}" already exists on this map`)));
          let n3;
          if (t3.type === "custom") {
            if (Ht(this, e.validateCustomStyleLayer(t3)))
              return;
            n3 = e.createStyleLayer(t3);
          } else {
            if (typeof t3.source == "object" && (this.addSource(r3, t3.source), t3 = e.clone$1(t3), t3 = e.extend(t3, { source: r3 })), this._validate(e.validateLayer, `layers.${r3}`, t3, { arrayIndex: -1 }, o2))
              return;
            n3 = e.createStyleLayer(t3), this._validateLayer(n3), n3.setEventedParent(this, { layer: { id: r3 } }), this._serializedLayers[n3.id] = n3.serialize(), this._updateLayerCount(n3, true);
          }
          const a2 = i2 ? this._order.indexOf(i2) : this._order.length;
          if (i2 && a2 === -1)
            return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`)));
          this._order.splice(a2, 0, r3), this._layerOrderChanged = true, this._layers[r3] = n3;
          const s2 = this._getLayerSourceCache(n3);
          if (this._removedLayers[r3] && n3.source && s2 && n3.type !== "custom") {
            const e2 = this._removedLayers[r3];
            delete this._removedLayers[r3], e2.type !== n3.type ? this._updatedSources[n3.source] = "clear" : (this._updatedSources[n3.source] = "reload", s2.pause());
          }
          this._updateLayer(n3), n3.onAdd && n3.onAdd(this.map), this._updateDrapeFirstLayers();
        }
        moveLayer(t3, i2) {
          if (this._checkLoaded(), this._changed = true, !this._layers[t3])
            return void this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be moved.`)));
          if (t3 === i2)
            return;
          const o2 = this._order.indexOf(t3);
          this._order.splice(o2, 1);
          const r3 = i2 ? this._order.indexOf(i2) : this._order.length;
          i2 && r3 === -1 ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`))) : (this._order.splice(r3, 0, t3), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
        }
        removeLayer(t3) {
          this._checkLoaded();
          const i2 = this._layers[t3];
          if (!i2)
            return void this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be removed.`)));
          i2.setEventedParent(null), this._updateLayerCount(i2, false);
          const o2 = this._order.indexOf(t3);
          this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t3] = i2, delete this._layers[t3], delete this._serializedLayers[t3], delete this._updatedLayers[t3], delete this._updatedPaintProps[t3], i2.onRemove && i2.onRemove(this.map), this._updateDrapeFirstLayers();
        }
        getLayer(e2) {
          return this._layers[e2];
        }
        hasLayer(e2) {
          return e2 in this._layers;
        }
        hasLayerType(e2) {
          for (const t3 in this._layers)
            if (this._layers[t3].type === e2)
              return true;
          return false;
        }
        setLayerZoomRange(t3, i2, o2) {
          this._checkLoaded();
          const r3 = this.getLayer(t3);
          r3 ? r3.minzoom === i2 && r3.maxzoom === o2 || (i2 != null && (r3.minzoom = i2), o2 != null && (r3.maxzoom = o2), this._updateLayer(r3)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot have zoom extent.`)));
        }
        setFilter(i2, o2, r3 = {}) {
          this._checkLoaded();
          const n3 = this.getLayer(i2);
          if (n3) {
            if (!t2(n3.filter, o2))
              return o2 == null ? (n3.filter = void 0, void this._updateLayer(n3)) : void (this._validate(e.validateFilter, `layers.${n3.id}.filter`, o2, { layerType: n3.type }, r3) || (n3.filter = e.clone$1(o2), this._updateLayer(n3)));
          } else
            this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be filtered.`)));
        }
        getFilter(t3) {
          const i2 = this.getLayer(t3);
          return i2 && e.clone$1(i2.filter);
        }
        setLayoutProperty(i2, o2, r3, n3 = {}) {
          this._checkLoaded();
          const a2 = this.getLayer(i2);
          a2 ? t2(a2.getLayoutProperty(o2), r3) || (a2.setLayoutProperty(o2, r3, n3), this._updateLayer(a2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
        }
        getLayoutProperty(t3, i2) {
          const o2 = this.getLayer(t3);
          if (o2)
            return o2.getLayoutProperty(i2);
          this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style.`)));
        }
        setPaintProperty(i2, o2, r3, n3 = {}) {
          this._checkLoaded();
          const a2 = this.getLayer(i2);
          a2 ? t2(a2.getPaintProperty(o2), r3) || (a2.setPaintProperty(o2, r3, n3) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[i2] = true) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
        }
        getPaintProperty(e2, t3) {
          const i2 = this.getLayer(e2);
          return i2 && i2.getPaintProperty(t3);
        }
        setFeatureState(t3, i2) {
          this._checkLoaded();
          const o2 = t3.source, r3 = t3.sourceLayer, n3 = this.getSource(o2);
          if (!n3)
            return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
          const a2 = n3.type;
          if (a2 === "geojson" && r3)
            return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if (a2 === "vector" && !r3)
            return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          t3.id === void 0 && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
          const s2 = this._getSourceCaches(o2);
          for (const e2 of s2)
            e2.setFeatureState(r3, t3.id, i2);
        }
        removeFeatureState(t3, i2) {
          this._checkLoaded();
          const o2 = t3.source, r3 = this.getSource(o2);
          if (!r3)
            return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
          const n3 = r3.type, a2 = n3 === "vector" ? t3.sourceLayer : void 0;
          if (n3 === "vector" && !a2)
            return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (i2 && typeof t3.id != "string" && typeof t3.id != "number")
            return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
          const s2 = this._getSourceCaches(o2);
          for (const e2 of s2)
            e2.removeFeatureState(a2, t3.id, i2);
        }
        getFeatureState(t3) {
          this._checkLoaded();
          const i2 = t3.source, o2 = t3.sourceLayer, r3 = this.getSource(i2);
          if (r3) {
            if (r3.type !== "vector" || o2)
              return t3.id === void 0 && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i2)[0].getFeatureState(o2, t3.id);
            this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new e.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
        }
        getTransition() {
          return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          const t3 = {};
          for (const e2 in this._sourceCaches) {
            const i2 = this._sourceCaches[e2].getSource();
            t3[i2.id] || (t3[i2.id] = i2.serialize());
          }
          return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.stylesheet.terrain, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t3, layers: this._serializeLayers(this._order) }, (e2) => e2 !== void 0);
        }
        _updateLayer(e2) {
          this._updatedLayers[e2.id] = true;
          const t3 = this._getLayerSourceCache(e2);
          e2.source && !this._updatedSources[e2.source] && t3 && t3.getSource().type !== "raster" && (this._updatedSources[e2.source] = "reload", t3.pause()), this._changed = true, e2.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(e2) {
          const t3 = (e3) => this._layers[e3].type === "fill-extrusion", i2 = {}, o2 = [];
          for (let r4 = this._order.length - 1; r4 >= 0; r4--) {
            const n3 = this._order[r4];
            if (t3(n3)) {
              i2[n3] = r4;
              for (const t4 of e2) {
                const e3 = t4[n3];
                if (e3)
                  for (const t5 of e3)
                    o2.push(t5);
              }
            }
          }
          o2.sort((e3, t4) => t4.intersectionZ - e3.intersectionZ);
          const r3 = [];
          for (let n3 = this._order.length - 1; n3 >= 0; n3--) {
            const a2 = this._order[n3];
            if (t3(a2))
              for (let e3 = o2.length - 1; e3 >= 0; e3--) {
                const t4 = o2[e3].feature;
                if (i2[t4.layer.id] < n3)
                  break;
                r3.push(t4), o2.pop();
              }
            else
              for (const t4 of e2) {
                const e3 = t4[a2];
                if (e3)
                  for (const t5 of e3)
                    r3.push(t5.feature);
              }
          }
          return r3;
        }
        queryRenderedFeatures(t3, i2, o2) {
          i2 && i2.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i2.filter, null, i2);
          const r3 = {};
          if (i2 && i2.layers) {
            if (!Array.isArray(i2.layers))
              return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (const t4 of i2.layers) {
              const i3 = this._layers[t4];
              if (!i3)
                return this.fire(new e.ErrorEvent(new Error(`The layer '${t4}' does not exist in the map's style and cannot be queried for features.`))), [];
              r3[i3.source] = true;
            }
          }
          const n3 = [];
          i2.availableImages = this._availableImages;
          const a2 = i2 && i2.layers ? i2.layers.some((e2) => {
            const t4 = this.getLayer(e2);
            return t4 && t4.is3D();
          }) : this.has3DLayers(), s2 = R2.createFromScreenPoints(t3, o2);
          for (const e2 in this._sourceCaches) {
            const t4 = this._sourceCaches[e2].getSource().id;
            i2.layers && !r3[t4] || n3.push(Re2(this._sourceCaches[e2], this._layers, this._serializedLayers, s2, i2, o2, a2, !!this.map._showQueryGeometry));
          }
          return this.placement && n3.push(function(e2, t4, i3, o3, r4, n4, a3) {
            const s3 = {}, l3 = n4.queryRenderedSymbols(o3), c2 = [];
            for (const e3 of Object.keys(l3).map(Number))
              c2.push(a3[e3]);
            c2.sort(Be2);
            for (const i4 of c2) {
              const o4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t4, i4.bucketIndex, i4.sourceLayerIndex, r4.filter, r4.layers, r4.availableImages, e2);
              for (const e3 in o4) {
                const t5 = s3[e3] = s3[e3] || [], r5 = o4[e3];
                r5.sort((e4, t6) => {
                  const o5 = i4.featureSortOrder;
                  if (o5) {
                    const i5 = o5.indexOf(e4.featureIndex);
                    return o5.indexOf(t6.featureIndex) - i5;
                  }
                  return t6.featureIndex - e4.featureIndex;
                });
                for (const e4 of r5)
                  t5.push(e4);
              }
            }
            for (const t5 in s3)
              s3[t5].forEach((o4) => {
                const r5 = o4.feature, n5 = i3(e2[t5]).getFeatureState(r5.layer["source-layer"], r5.id);
                r5.source = r5.layer.source, r5.layer["source-layer"] && (r5.sourceLayer = r5.layer["source-layer"]), r5.state = n5;
              });
            return s3;
          }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n3);
        }
        querySourceFeatures(t3, i2) {
          i2 && i2.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i2.filter, null, i2);
          const o2 = this._getSourceCaches(t3);
          let r3 = [];
          for (const e2 of o2)
            r3 = r3.concat(Oe2(e2, i2));
          return r3;
        }
        addSourceType(e2, t3, i2) {
          return ei2.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (ei2.setSourceType(e2, t3), t3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t3.workerSourceURL }, i2) : i2(null, null));
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e2, i2 = {}) {
          this._checkLoaded();
          const o2 = this.light.getLight();
          let r3 = false;
          for (const i3 in e2)
            if (!t2(e2[i3], o2[i3])) {
              r3 = true;
              break;
            }
          if (!r3)
            return;
          const n3 = this._setTransitionParameters({ duration: 300, delay: 0 });
          this.light.setLight(e2, i2), this.light.updateTransitions(n3);
        }
        getTerrain() {
          return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        setTerrain(i2, o2 = 1) {
          if (this._checkLoaded(), !i2)
            return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          if (o2 === 1) {
            if (typeof i2.source == "object") {
              const t3 = "terrain-dem-src";
              this.addSource(t3, i2.source), i2 = e.clone$1(i2), i2 = e.extend(i2, { source: t3 });
            }
            if (this._validate(e.validateTerrain, "terrain", i2))
              return;
          }
          if (!this.terrain || this.terrain && o2 !== this.terrain.drapeRenderMode)
            this._createTerrain(i2, o2);
          else {
            const o3 = this.terrain, r3 = o3.get();
            for (const t3 of Object.keys(e.spec.terrain))
              !i2.hasOwnProperty(t3) && e.spec.terrain[t3].default && (i2[t3] = e.spec.terrain[t3].default);
            for (const e2 in i2)
              if (!t2(i2[e2], r3[e2])) {
                o3.set(i2), this.stylesheet.terrain = i2;
                const e3 = this._setTransitionParameters({ duration: 0 });
                o3.updateTransitions(e3);
                break;
              }
          }
          this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
        }
        _createFog(e2) {
          const t3 = this.fog = new P2(e2, this.map.transform);
          this.stylesheet.fog = e2;
          const i2 = this._setTransitionParameters({ duration: 0 });
          t3.updateTransitions(i2);
        }
        _updateMarkersOpacity() {
          this.map._markers.length !== 0 && this.map._requestDomTask(() => {
            for (const e2 of this.map._markers)
              e2._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(e2) {
          if (this._checkLoaded(), !e2)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const i2 = this.fog, o2 = i2.get();
            Object.keys(e2).length === 0 && i2.set(e2);
            for (const r3 in e2)
              if (!t2(e2[r3], o2[r3])) {
                i2.set(e2), this.stylesheet.fog = e2;
                const t3 = this._setTransitionParameters({ duration: 0 });
                i2.updateTransitions(t3);
                break;
              }
          } else
            this._createFog(e2);
          this._markersNeedUpdate = true;
        }
        _setTransitionParameters(t3) {
          return { now: e.exported.now(), transition: e.extend(t3, this.stylesheet.transition) };
        }
        _updateDrapeFirstLayers() {
          if (!this.map._optimizeForTerrain || !this.terrain)
            return;
          const e2 = this._order.filter((e3) => this.isLayerDraped(this._layers[e3])), t3 = this._order.filter((e3) => !this.isLayerDraped(this._layers[e3]));
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t3);
        }
        _createTerrain(e2, t3) {
          const i2 = this.terrain = new I2(e2, t3);
          this.stylesheet.terrain = e2, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
          const o2 = this._setTransitionParameters({ duration: 0 });
          i2.updateTransitions(o2);
        }
        _force3DLayerUpdate() {
          for (const e2 in this._layers) {
            const t3 = this._layers[e2];
            t3.type === "fill-extrusion" && this._updateLayer(t3);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const e2 in this._layers) {
            const t3 = this._layers[e2];
            t3.type === "symbol" && this._updateLayer(t3);
          }
        }
        _validate(t3, i2, o2, r3, n3 = {}) {
          return (!n3 || n3.validate !== false) && Ht(this, t3.call(e.validateStyle, e.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: e.spec }, r3)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e2 in this._layers)
            this._layers[e2].setEventedParent(null);
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].clearTiles(), this._sourceCaches[e2].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }
        _clearSource(e2) {
          const t3 = this._getSourceCaches(e2);
          for (const e3 of t3)
            e3.clearTiles();
        }
        _reloadSource(e2) {
          const t3 = this._getSourceCaches(e2);
          for (const e3 of t3)
            e3.resume(), e3.reload();
        }
        _updateSources(e2) {
          for (const t3 in this._sourceCaches)
            this._sourceCaches[t3].update(e2);
        }
        _generateCollisionBoxes() {
          for (const e2 in this._sourceCaches) {
            const t3 = this._sourceCaches[e2];
            t3.resume(), t3.reload();
          }
        }
        _updatePlacement(t3, i2, o2, r3, n3 = false) {
          let a2 = false, s2 = false;
          const l3 = {};
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            if (i3.type !== "symbol")
              continue;
            if (!l3[i3.source]) {
              const e3 = this._getLayerSourceCache(i3);
              if (!e3)
                continue;
              l3[i3.source] = e3.getRenderableIds(true).map((t4) => e3.getTileByID(t4)).sort((e4, t4) => t4.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t4.tileID) ? -1 : 1));
            }
            const o3 = this.crossTileSymbolIndex.addLayer(i3, l3[i3.source], t3.center.lng, t3.projection);
            a2 = a2 || o3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n3 = n3 || this._layerOrderChanged || o2 === 0, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n3 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t3.zoom)) && (this.pauseablePlacement = new Zt(t3, this._order, n3, i2, o2, r3, this.placement, this.fog && t3.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), s2 = true), a2 && this.pauseablePlacement.placement.setStale()), s2 || a2)
            for (const e2 of this._order) {
              const t4 = this._layers[e2];
              t4.type === "symbol" && this.placement.updateLayerOpacities(t4, l3[t4.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].releaseSymbolFadeTiles();
        }
        getImages(e2, t3, i2) {
          this.imageManager.getImages(t3.icons, i2), this._updateTilesForChangedImages();
          const o2 = (e3) => {
            e3 && e3.setDependencies(t3.tileID.key, t3.type, t3.icons);
          };
          o2(this._otherSourceCaches[t3.source]), o2(this._symbolSourceCaches[t3.source]);
        }
        getGlyphs(e2, t3, i2) {
          this.glyphManager.getGlyphs(t3.stacks, i2);
        }
        getResource(t3, i2, o2) {
          return e.makeRequest(i2, o2);
        }
        _getSourceCache(e2) {
          return this._otherSourceCaches[e2];
        }
        _getLayerSourceCache(e2) {
          return e2.type === "symbol" ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
        }
        _getSourceCaches(e2) {
          const t3 = [];
          return this._otherSourceCaches[e2] && t3.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t3.push(this._symbolSourceCaches[e2]), t3;
        }
        _isSourceCacheLoaded(t3) {
          const i2 = this._getSourceCaches(t3);
          return i2.length === 0 ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t3}'`))), false) : i2.every((e2) => e2.loaded());
        }
        has3DLayers() {
          return this._num3DLayers > 0;
        }
        hasSymbolLayers() {
          return this._numSymbolLayers > 0;
        }
        hasCircleLayers() {
          return this._numCircleLayers > 0;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      ei2.getSourceType = function(e2) {
        return Pe2[e2];
      }, ei2.setSourceType = function(e2, t3) {
        Pe2[e2] = t3;
      }, ei2.registerForPluginStateChange = e.registerForPluginStateChange;
      var ti2 = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", ii2 = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", oi2 = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {return currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", ri2 = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ni2 = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
      let ai2 = {}, si2 = {};
      const li2 = [];
      di2(ti2, li2), di2(oi2, li2), di2(ri2, li2), di2(ni2, li2), ai2 = pi2("", oi2), si2 = pi2(ni2, ri2);
      const ci2 = pi2("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), hi2 = ti2, ui2 = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
      var _i = { background: pi2("uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: pi2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: pi2("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);vec4 world_center=vec4(pos,1);\n#else \nmat3 surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: pi2("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: pi2("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\nvec3 pos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: pi2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: pi2("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: pi2("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: pi2("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: pi2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: pi2("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: pi2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: pi2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: pi2("uniform lowp vec3 u_lightpos;varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;varying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\nvoid main() {vec4 color=v_color;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(v_normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying highp vec3 v_normal;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;vec3 pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_normal=normal;v_depth=gl_Position.w;\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);directional*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\nv_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: pi2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);\n#else\nvec3 p=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);directional*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\nv_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: pi2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: pi2("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: pi2("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist_a=texture2D(u_dash_image,v_tex_a).a;float sdfdist_b=texture2D(u_dash_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\n#ifdef RENDER_LINE_GRADIENT\nhighp vec4 out_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nvec4 out_color=color;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);}}\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: pi2("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: pi2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: pi2("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nvec3 world_pos=vec3(tile_anchor,0)+h;float globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);vec4 offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\nvec4 offsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);vec4 projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: pi2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nvec3 world_pos=vec3(tile_anchor,0)+h;float globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);vec4 offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\nvec4 offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);vec4 projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: pi2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nvec3 world_pos=vec3(tile_anchor,0)+h;float globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);vec4 projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: pi2("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: pi2("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: pi2("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ii2), skyboxGradient: pi2("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ii2), skyboxCapture: pi2("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: pi2("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);vec4 color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\nvec4 color=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idy=u_grid_matrix[1][2];float S=u_grid_matrix[2][2];vec3 latLng=u_grid_matrix*vec3(a_pos,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=a_pos[0]*S;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;\n#ifdef GLOBE_POLES\nvec3 up_vector=normalize(globe_pos)*u_tile_up_scale;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: pi2("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);\n#ifdef PROJECTION_GLOBE_VIEW\nfloat globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));float horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nfloat horizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };
      function di2(e2, t3) {
        const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
        for (let e3 of i2)
          if (e3 = e3.trim(), e3[0] === "#" && e3.includes("if") && !e3.includes("endif")) {
            e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i3 = e3.split(" ");
            for (const e4 of i3)
              t3.includes(e4) || t3.push(e4);
          }
      }
      function pi2(e2, t3) {
        const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = t3.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r3 = {}, n3 = [...li2];
        return di2(e2, n3), di2(t3, n3), { fragmentSource: e2 = e2.replace(i2, (e3, t4, i3, o3, n4) => (r3[n4] = true, t4 === "define" ? `
#ifndef HAS_UNIFORM_u_${n4}
varying ${i3} ${o3} ${n4};
#else
uniform ${i3} ${o3} u_${n4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${n4}
    ${i3} ${o3} ${n4} = u_${n4};
#endif
`)), vertexSource: t3 = t3.replace(i2, (e3, t4, i3, o3, n4) => {
          const a2 = o3 === "float" ? "vec2" : "vec4", s2 = n4.match(/color/) ? "color" : a2;
          return r3[n4] ? t4 === "define" ? `
#ifndef HAS_UNIFORM_u_${n4}
uniform lowp float u_${n4}_t;
attribute ${i3} ${a2} a_${n4};
varying ${i3} ${o3} ${n4};
#else
uniform ${i3} ${o3} u_${n4};
#endif
` : s2 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${n4}
    ${n4} = a_${n4};
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n4}
    ${n4} = unpack_mix_${s2}(a_${n4}, u_${n4}_t);
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
` : t4 === "define" ? `
#ifndef HAS_UNIFORM_u_${n4}
uniform lowp float u_${n4}_t;
attribute ${i3} ${a2} a_${n4};
#else
uniform ${i3} ${o3} u_${n4};
#endif
` : s2 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${n4}
    ${i3} ${o3} ${n4} = a_${n4};
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n4}
    ${i3} ${o3} ${n4} = unpack_mix_${s2}(a_${n4}, u_${n4}_t);
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
`;
        }), staticAttributes: o2, usedDefines: n3 };
      }
      class mi2 {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(e2, t3, i2, o2, r3, n3, a2) {
          this.context = e2;
          let s2 = this.boundPaintVertexBuffers.length !== o2.length;
          for (let e3 = 0; !s2 && e3 < o2.length; e3++)
            this.boundPaintVertexBuffers[e3] !== o2[e3] && (s2 = true);
          let l3 = this.boundDynamicVertexBuffers.length !== a2.length;
          for (let e3 = 0; !l3 && e3 < a2.length; e3++)
            this.boundDynamicVertexBuffers[e3] !== a2[e3] && (l3 = true);
          if (!e2.extVertexArrayObject || !this.vao || this.boundProgram !== t3 || this.boundLayoutVertexBuffer !== i2 || s2 || l3 || this.boundIndexBuffer !== r3 || this.boundVertexOffset !== n3)
            this.freshBind(t3, i2, o2, r3, n3, a2);
          else {
            e2.bindVertexArrayOES.set(this.vao);
            for (const e3 of a2)
              e3 && e3.bind();
            r3 && r3.dynamicDraw && r3.bind();
          }
        }
        freshBind(e2, t3, i2, o2, r3, n3) {
          let a2;
          const s2 = e2.numAttributes, l3 = this.context, c2 = l3.gl;
          if (l3.extVertexArrayObject)
            this.vao && this.destroy(), this.vao = l3.extVertexArrayObject.createVertexArrayOES(), l3.bindVertexArrayOES.set(this.vao), a2 = 0, this.boundProgram = e2, this.boundLayoutVertexBuffer = t3, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r3, this.boundDynamicVertexBuffers = n3;
          else {
            a2 = l3.currentNumAttributes || 0;
            for (let e3 = s2; e3 < a2; e3++)
              c2.disableVertexAttribArray(e3);
          }
          t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r3);
          for (const t4 of i2)
            t4.enableAttributes(c2, e2), t4.bind(), t4.setVertexAttribPointers(c2, e2, r3);
          for (const t4 of n3)
            t4 && (t4.enableAttributes(c2, e2), t4.bind(), t4.setVertexAttribPointers(c2, e2, r3));
          o2 && o2.bind(), l3.currentNumAttributes = s2;
        }
        destroy() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        }
      }
      function fi2(t3, i2) {
        const o2 = Math.pow(2, i2.canonical.z), r3 = i2.canonical.y;
        return [new e.MercatorCoordinate(0, r3 / o2).toLngLat().lat, new e.MercatorCoordinate(0, (r3 + 1) / o2).toLngLat().lat];
      }
      function gi2(t3, i2, o2, r3, n3, a2, s2) {
        const l3 = t3.context, c2 = l3.gl, h3 = o2.fbo;
        if (!h3)
          return;
        t3.prepareDrawTile();
        const u3 = t3.useProgram("hillshade");
        l3.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h3.colorAttachment.get());
        const _2 = ((e2, t4, i3, o3) => {
          const r4 = i3.paint.get("hillshade-shadow-color"), n4 = i3.paint.get("hillshade-highlight-color"), a3 = i3.paint.get("hillshade-accent-color");
          let s3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          i3.paint.get("hillshade-illumination-anchor") === "viewport" && (s3 -= e2.transform.angle);
          const l4 = !e2.options.moving;
          return { u_matrix: o3 || e2.transform.calculateProjMatrix(t4.tileID.toUnwrapped(), l4), u_image: 0, u_latrange: fi2(0, t4.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), s3], u_shadow: r4, u_highlight: n4, u_accent: a3 };
        })(t3, o2, r3, t3.terrain ? i2.projMatrix : null);
        t3.prepareDrawProgram(l3, u3, i2.toUnwrapped());
        const { tileBoundsBuffer: d2, tileBoundsIndexBuffer: p3, tileBoundsSegments: m3 } = t3.getTileBoundsBuffers(o2);
        u3.draw(l3, c2.TRIANGLES, n3, a2, s2, e.CullFaceMode.disabled, _2, r3.id, d2, p3, m3);
      }
      function vi2(t3, i2, o2) {
        if (!i2.needsDEMTextureUpload)
          return;
        const r3 = t3.context, n3 = r3.gl;
        r3.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t3.getTileTexture(o2.stride);
        const a2 = o2.getPixels();
        i2.demTexture ? i2.demTexture.update(a2, { premultiply: false }) : i2.demTexture = new e.Texture(r3, a2, n3.RGBA, { premultiply: false }), i2.needsDEMTextureUpload = false;
      }
      function xi2(t3, i2, o2, r3, n3, a2) {
        const s2 = t3.context, l3 = s2.gl;
        if (!i2.dem)
          return;
        const c2 = i2.dem;
        if (s2.activeTexture.set(l3.TEXTURE1), vi2(t3, i2, c2), !i2.demTexture)
          return;
        i2.demTexture.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
        const h3 = c2.dim;
        s2.activeTexture.set(l3.TEXTURE0);
        let u3 = i2.fbo;
        if (!u3) {
          const t4 = new e.Texture(s2, { width: h3, height: h3, data: null }, l3.RGBA);
          t4.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), u3 = i2.fbo = s2.createFramebuffer(h3, h3, true), u3.colorAttachment.set(t4.texture);
        }
        s2.bindFramebuffer.set(u3.framebuffer), s2.viewport.set([0, 0, h3, h3]);
        const { tileBoundsBuffer: _2, tileBoundsIndexBuffer: d2, tileBoundsSegments: p3 } = t3.getMercatorTileBoundsBuffers();
        t3.useProgram("hillshadePrepare").draw(s2, l3.TRIANGLES, r3, n3, a2, e.CullFaceMode.disabled, ((t4, i3) => {
          const o3 = i3.stride, r4 = e.create();
          return e.ortho(r4, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r4, r4, [0, -e.EXTENT, 0]), { u_matrix: r4, u_image: 1, u_dimension: [o3, o3], u_zoom: t4.overscaledZ, u_unpack: i3.unpackVector };
        })(i2.tileID, c2), o2.id, _2, d2, p3), i2.needsHillshadePrepare = false;
      }
      const yi2 = (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_image0: new e.Uniform1i(t3), u_skirt_height: new e.Uniform1f(t3) }), bi2 = (e2, t3) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t3 }), wi2 = (e2, t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t3, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r3, u_merc_center: n3, u_image0: 0, u_frustum_tl: a2, u_frustum_tr: s2, u_frustum_br: l3, u_frustum_bl: c2, u_globe_pos: h3, u_globe_radius: u3, u_viewport: _2, u_grid_matrix: d2 ? Float32Array.from(d2) : new Float32Array(9) });
      function Ti2(e2, t3) {
        return e2 != null && t3 != null && !(!e2.hasData() || !t3.hasData()) && e2.demTexture != null && t3.demTexture != null && e2.tileID.key !== t3.tileID.key;
      }
      const Ei2 = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e2, t3, i2, o2, r3) {
          if (e2 in this.operations) {
            const t4 = this.operations[e2];
            t4.to.tileID.key !== i2.tileID.key && (t4.queued = i2);
          } else
            this.operations[e2] = { startTime: o2, phase: 0, duration: r3, from: t3, to: i2, queued: null };
        }
        getMorphValuesForProxy(e2) {
          if (!(e2 in this.operations))
            return null;
          const t3 = this.operations[e2];
          return { from: t3.from, to: t3.to, phase: t3.phase };
        }
        update(e2) {
          for (const t3 in this.operations) {
            const i2 = this.operations[t3];
            for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
              if (!this._nextOp(i2, e2)) {
                delete this.operations[t3];
                break;
              }
          }
        }
        _nextOp(e2, t3) {
          return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t3, true);
        }
        _validOp(e2) {
          return e2.from.hasData() && e2.to.hasData();
        }
      }(), Ci2 = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
      function Ii2(e2, t3) {
        const i2 = 1 << e2.z;
        return !t3 && (e2.x === 0 || e2.x === i2 - 1) || e2.y === 0 || e2.y === i2 - 1;
      }
      const Mi2 = (e2) => ({ u_matrix: e2 });
      function Si2(t3, i2, o2, r3, n3) {
        if (n3 > 0) {
          const a2 = e.exported.now(), s2 = (a2 - t3.timeAdded) / n3, l3 = i2 ? (a2 - i2.timeAdded) / n3 : -1, c2 = o2.getSource(), h3 = r3.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u3 = !i2 || Math.abs(i2.tileID.overscaledZ - h3) > Math.abs(t3.tileID.overscaledZ - h3), _2 = u3 && t3.refreshedUponExpiration ? 1 : e.clamp(u3 ? s2 : 1 - l3, 0, 1);
          return t3.refreshedUponExpiration && s2 >= 1 && (t3.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class zi2 extends e.SourceCache {
        constructor(e2) {
          const t3 = { type: "raster-dem", maxzoom: e2.transform.maxZoom }, i2 = new A2(Ge2(), null), o2 = Ae2("mock-dem", t3, i2, e2.style);
          super("mock-dem", o2, false), o2.setEventedParent(this), this._sourceLoaded = true;
        }
        _loadTile(e2, t3) {
          e2.state = "loaded", t3(null);
        }
      }
      class Di2 extends e.SourceCache {
        constructor(e2) {
          const t3 = Ae2("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, new A2(Ge2(), null), e2.style);
          super("proxy", t3, false), t3.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(t3, i2, o2) {
          if (t3.freezeTileCoverage)
            return;
          this.transform = t3;
          const r3 = t3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
            if (i3[o3.key] = "", !this._tiles[o3.key]) {
              const i4 = new e.Tile(o3, this._source.tileSize * o3.overscaleFactor(), t3.tileZoom);
              i4.state = "loaded", this._tiles[o3.key] = i4;
            }
            return i3;
          }, {});
          for (const e2 in this._tiles)
            e2 in r3 || (this.freeFBO(e2), this._tiles[e2].unloadVectorData(), delete this._tiles[e2]);
        }
        freeFBO(e2) {
          const t3 = this.proxyCachedFBO[e2];
          if (t3 !== void 0) {
            const i2 = Object.values(t3);
            this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Pi2 extends e.OverscaledTileID {
        constructor(e2, t3, i2) {
          super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t3, this.projMatrix = i2;
        }
      }
      class Ai2 extends e.Elevation {
        constructor(t3, i2) {
          super(), this.painter = t3, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [o2, r3, n3] = function(t4) {
            const i3 = new e.StructArrayLayout4i8(), o3 = new e.StructArrayLayout3ui6(), r4 = 131;
            i3.reserve(17161), o3.reserve(33800);
            const n4 = e.EXTENT / 128, a3 = e.EXTENT + n4 / 2, s3 = a3 + n4;
            for (let t5 = -n4; t5 < s3; t5 += n4)
              for (let o4 = -n4; o4 < s3; o4 += n4) {
                const r5 = o4 < 0 || o4 > a3 || t5 < 0 || t5 > a3 ? 24575 : 0, n5 = e.clamp(Math.round(o4), 0, e.EXTENT), s4 = e.clamp(Math.round(t5), 0, e.EXTENT);
                i3.emplaceBack(n5 + r5, s4, n5, s4);
              }
            const l3 = (e2, t5) => {
              const i4 = t5 * r4 + e2;
              o3.emplaceBack(i4 + 1, i4, i4 + r4), o3.emplaceBack(i4 + r4, i4 + r4 + 1, i4 + 1);
            };
            for (let e2 = 1; e2 < 129; e2++)
              for (let t5 = 1; t5 < 129; t5++)
                l3(t5, e2);
            return [0, 129].forEach((e2) => {
              for (let t5 = 0; t5 < 130; t5++)
                l3(t5, e2), l3(e2, t5);
            }), [i3, o3, 32768];
          }(), a2 = t3.context;
          this.gridBuffer = a2.createVertexBuffer(o2, e.boundsAttributes.members), this.gridIndexBuffer = a2.createIndexBuffer(r3), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, r3.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, n3), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Di2(i2.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, 0, e.EXTENT, 0, e.EXTENT, 0, 1);
          const s2 = a2.gl;
          this._overlapStencilMode = new e.StencilMode({ func: s2.GEQUAL, mask: 255 }, 0, 255, s2.KEEP, s2.KEEP, s2.REPLACE), this._previousZoom = t3.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new zi2(i2.map);
        }
        set style(e2) {
          e2.on("data", this._onStyleDataEvent.bind(this)), e2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e2, this._checkRenderCacheEfficiency();
        }
        update(t3, i2, o2) {
          if (t3 && t3.terrain) {
            this._style !== t3 && (this.style = t3), this.enabled = true;
            const r3 = t3.terrain.properties;
            this.sourceCache = t3.terrain.drapeRenderMode === 0 ? this._mockSourceCache : t3._getSourceCache(r3.get("source")), this._exaggeration = r3.get("exaggeration");
            const n3 = () => {
              this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const t4 = this.getScaledDemTileSize();
              this.sourceCache.update(i2, t4, true), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n3(), this._initializing = true), n3(), i2.updateElevation(!o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true;
          } else
            this._disable();
        }
        resetTileLookupCache(e2) {
          this._findCoveringTileCache[e2] = {};
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _checkRenderCacheEfficiency() {
          const t3 = this.renderCacheEfficiency(this._style);
          this._style.map._optimizeForTerrain || t3.efficiency !== 100 && e.warnOnce(`Terrain render cache efficiency is not optimal (${t3.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t3.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
        }
        _onStyleDataEvent(e2) {
          e2.coord && e2.dataType === "source" ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : e2.dataType === "style" && (this._invalidateRenderCache = true);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const e2 in this._style._sourceCaches)
              this._style._sourceCaches[e2].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e2 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e2, e2];
        }
        set useVertexMorphing(e2) {
          this._useVertexMorphing = e2;
        }
        updateTileBinding(t3) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const i2 = this.proxySourceCache, o2 = this.painter.transform;
          this._initializing && (this._initializing = o2._centerAltitude === 0 && this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o2.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
          const r3 = this.proxyCoords = i2.getIds().map((e2) => {
            const t4 = i2.getTileByID(e2).tileID;
            return t4.projMatrix = o2.calculateProjMatrix(t4.toUnwrapped()), t4;
          });
          !function(t4, i3) {
            const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r4 = new e.pointGeometry(o3.x, o3.y);
            t4.sort((t5, i4) => {
              if (i4.overscaledZ - t5.overscaledZ)
                return i4.overscaledZ - t5.overscaledZ;
              const o4 = new e.pointGeometry(t5.canonical.x + (1 << t5.canonical.z) * t5.wrap, t5.canonical.y), n4 = new e.pointGeometry(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), a3 = r4.mult(1 << t5.canonical.z);
              return a3.x -= 0.5, a3.y -= 0.5, a3.distSqr(o4) - a3.distSqr(n4);
            });
          }(r3, this.painter), this._previousZoom = o2.zoom;
          const n3 = this.proxyToSource || {};
          this.proxyToSource = {}, r3.forEach((e2) => {
            this.proxyToSource[e2.key] = {};
          }), this.terrainTileForTile = {};
          const a2 = this._style._sourceCaches;
          for (const e2 in a2) {
            const i3 = a2[e2];
            if (!i3.used)
              continue;
            if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t3[e2], n3), i3.usedForTerrain)
              continue;
            const o3 = t3[e2];
            i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
          }
          this.proxiedCoords[i2.id] = r3.map((e2) => new Pi2(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(r3), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n3), this.renderingToTexture = false, this._updateTimestamp = e.exported.now();
          const s2 = {};
          this._visibleDemTiles = [];
          for (const e2 of this.proxyCoords) {
            const t4 = this.terrainTileForTile[e2.key];
            if (!t4)
              continue;
            const i3 = t4.tileID.key;
            i3 in s2 || (this._visibleDemTiles.push(t4), s2[i3] = i3);
          }
        }
        _assignTerrainTiles(e2) {
          this._initializing || e2.forEach((e3) => {
            if (this.terrainTileForTile[e3.key])
              return;
            const t3 = this._findTileCoveringTileID(e3, this.sourceCache);
            t3 && (this.terrainTileForTile[e3.key] = t3);
          });
        }
        _prepareDEMTextures() {
          const e2 = this.painter.context, t3 = e2.gl;
          for (const i2 in this.terrainTileForTile) {
            const o2 = this.terrainTileForTile[i2], r3 = o2.dem;
            !r3 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t3.TEXTURE1), vi2(this.painter, o2, r3));
          }
        }
        _prepareDemTileUniforms(e2, t3, i2, o2) {
          if (!t3 || t3.demTexture == null)
            return false;
          const r3 = e2.tileID.canonical, n3 = Math.pow(2, t3.tileID.canonical.z - r3.z), a2 = o2 || "";
          return i2[`u_dem_tl${a2}`] = [r3.x * n3 % 1, r3.y * n3 % 1], i2[`u_dem_scale${a2}`] = n3, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        get emptyDepthBufferTexture() {
          const t3 = this.painter.context, i2 = t3.gl;
          if (!this._emptyDepthBufferTexture) {
            const o2 = new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
            this._emptyDepthBufferTexture = new e.Texture(t3, o2, i2.RGBA, { premultiply: false });
          }
          return this._emptyDepthBufferTexture;
        }
        _getLoadedAreaMinimum() {
          let e2 = 0;
          const t3 = this._visibleDemTiles.reduce((t4, i2) => {
            if (!i2.dem)
              return t4;
            const o2 = i2.dem.tree.minimums[0];
            return o2 > 0 && e2++, t4 + o2;
          }, 0);
          return e2 ? t3 / e2 : 0;
        }
        _updateEmptyDEMTexture() {
          const t3 = this.painter.context, i2 = t3.gl;
          t3.activeTexture.set(i2.TEXTURE2);
          const o2 = this._getLoadedAreaMinimum(), r3 = new e.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e.DEMData.pack(o2, this.sourceCache.getSource().encoding)));
          this._emptyDEMTextureDirty = false;
          let n3 = this._emptyDEMTexture;
          return n3 ? n3.update(r3, { premultiply: false }) : n3 = this._emptyDEMTexture = new e.Texture(t3, r3, i2.RGBA, { premultiply: false }), n3;
        }
        setupElevationDraw(t3, i2, o2) {
          const r3 = this.painter.context, n3 = r3.gl, a2 = (s2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(s2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0, u_tile_tl_up: [0, 0, 1], u_tile_tr_up: [0, 0, 1], u_tile_br_up: [0, 0, 1], u_tile_bl_up: [0, 0, 1], u_tile_up_scale: 1 });
          var s2;
          a2.u_dem_size = this.sourceCache.getSource().tileSize, a2.u_exaggeration = this.exaggeration();
          const l3 = this.painter.transform, c2 = l3.projection, h3 = t3.tileID.canonical;
          a2.u_tile_tl_up = c2.upVector(h3, 0, 0), a2.u_tile_tr_up = c2.upVector(h3, e.EXTENT, 0), a2.u_tile_br_up = c2.upVector(h3, e.EXTENT, e.EXTENT), a2.u_tile_bl_up = c2.upVector(h3, 0, e.EXTENT), a2.u_tile_up_scale = o2 && o2.useDenormalizedUpVectorScale ? e.GLOBE_METERS_TO_ECEF : c2.upVectorScale(h3, l3.center.lat, l3.worldSize).metersToTile;
          let u3 = null, _2 = null, d2 = 1;
          if (o2 && o2.morphing && this._useVertexMorphing) {
            const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
            d2 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t3, e2, a2, "_prev") && (_2 = e2), this._prepareDemTileUniforms(t3, i3, a2) && (u3 = i3));
          }
          if (_2 && u3 ? (r3.activeTexture.set(n3.TEXTURE2), u3.demTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE, n3.NEAREST), r3.activeTexture.set(n3.TEXTURE4), _2.demTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE, n3.NEAREST), a2.u_dem_lerp = d2) : (u3 = this.terrainTileForTile[t3.tileID.key], r3.activeTexture.set(n3.TEXTURE2), (this._prepareDemTileUniforms(t3, u3, a2) ? u3.demTexture : this.emptyDEMTexture).bind(n3.NEAREST, n3.CLAMP_TO_EDGE)), r3.activeTexture.set(n3.TEXTURE3), o2 && o2.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE), this._depthFBO && (a2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE), a2.u_depth_size_inv = [1, 1]), o2 && o2.useMeterToDem && u3) {
            const t4 = (1 << u3.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            a2.u_meter_to_dem = t4;
          }
          o2 && o2.labelPlaneMatrixInv && (a2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r3, a2);
        }
        renderToBackBuffer(t3) {
          const i2 = this.painter, o2 = this.painter.context;
          t3.length !== 0 && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t4, i3, o3, r3, n3) {
            if (t4.transform.projection.name === "globe")
              !function(t5, i4, o4, r4, n4) {
                const a2 = t5.context, s2 = a2.gl;
                let l3, c2;
                const h3 = t5.options.showTerrainWireframe ? 2 : 0, u3 = t5.transform, _2 = e.globeUseCustomAntiAliasing(t5, a2, u3), d2 = (e2, i5) => {
                  if (c2 === e2)
                    return;
                  const o5 = [Ci2[e2], "PROJECTION_GLOBE_VIEW"];
                  _2 && o5.push("CUSTOM_ANTIALIASING"), i5 && o5.push(Ci2[h3]), l3 = t5.useProgram("globeRaster", null, o5), c2 = e2;
                }, p3 = t5.colorModeForRenderPass(), m3 = new e.DepthMode(s2.LEQUAL, e.DepthMode.ReadWrite, t5.depthRangeFor3D);
                Ei2.update(n4);
                const f2 = e.calculateGlobeMercatorMatrix(u3), g2 = [e.mercatorXfromLng(u3.center.lng), e.mercatorYfromLat(u3.center.lat)], v3 = h3 ? [false, true] : [false], x3 = t5.globeSharedBuffers, y3 = [u3.width * e.exported.devicePixelRatio, u3.height * e.exported.devicePixelRatio], b2 = Float32Array.from(u3.globeMatrix), w2 = { useDenormalizedUpVectorScale: true };
                if (v3.forEach((h4) => {
                  c2 = -1;
                  const _3 = h4 ? s2.LINES : s2.TRIANGLES;
                  for (const c3 of r4) {
                    const r5 = o4.getTile(c3), v4 = e.StencilMode.disabled, T3 = i4.prevTerrainTileForTile[c3.key], E3 = i4.terrainTileForTile[c3.key];
                    Ti2(T3, E3) && Ei2.newMorphing(c3.key, T3, E3, n4, 250), a2.activeTexture.set(s2.TEXTURE0), r5.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
                    const C3 = Ei2.getMorphValuesForProxy(c3.key), I3 = C3 ? 1 : 0;
                    C3 && e.extend$1(w2, { morphing: { srcDemTile: C3.from, dstDemTile: C3.to, phase: e.easeCubicInOut(C3.phase) } });
                    const M3 = e.tileCornersToBounds(c3.canonical), S3 = e.getLatitudinalLod(M3.getCenter().lat), z3 = e.getGridMatrix(c3.canonical, M3, S3), D3 = e.globeNormalizeECEF(e.globeTileBounds(c3.canonical)), P3 = wi2(u3.projMatrix, b2, f2, D3, e.globeToMercatorTransition(u3.zoom), g2, u3.frustumCorners.TL, u3.frustumCorners.TR, u3.frustumCorners.BR, u3.frustumCorners.BL, u3.globeCenterInViewSpace, u3.globeRadius, y3, z3);
                    if (d2(I3, h4), i4.setupElevationDraw(r5, l3, w2), t5.prepareDrawProgram(a2, l3, c3.toUnwrapped()), x3) {
                      const [i5, o5, r6] = h4 ? x3.getWirefameBuffers(t5.context, S3) : x3.getGridBuffers(S3);
                      l3.draw(a2, _3, m3, v4, p3, e.CullFaceMode.backCCW, P3, "globe_raster", i5, o5, r6);
                    }
                  }
                }), x3) {
                  const n5 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  _2 && n5.push("CUSTOM_ANTIALIASING"), l3 = t5.useProgram("globeRaster", null, n5);
                  for (const n6 of r4) {
                    const { x: r5, y: c3, z: h4 } = n6.canonical, _3 = c3 === 0, d3 = c3 === (1 << h4) - 1, [f3, v4, b3, T3] = x3.getPoleBuffers(h4);
                    if (T3 && (_3 || d3)) {
                      const c4 = o4.getTile(n6);
                      a2.activeTexture.set(s2.TEXTURE0), c4.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
                      let x4 = e.globePoleMatrixForTile(h4, r5, u3);
                      const E3 = e.globeNormalizeECEF(e.globeTileBounds(n6.canonical)), C3 = (t6, i5) => t6.draw(a2, s2.TRIANGLES, m3, e.StencilMode.disabled, p3, e.CullFaceMode.disabled, wi2(u3.projMatrix, x4, x4, E3, 0, g2, u3.frustumCorners.TL, u3.frustumCorners.TR, u3.frustumCorners.BR, u3.frustumCorners.BL, u3.globeCenterInViewSpace, u3.globeRadius, y3), "globe_pole_raster", i5, b3, T3);
                      i4.setupElevationDraw(c4, l3, w2), t5.prepareDrawProgram(a2, l3, n6.toUnwrapped()), _3 && C3(l3, f3), d3 && (x4 = e.scale(e.create(), x4, [1, -1, 1]), C3(l3, v4));
                    }
                  }
                }
              }(t4, i3, o3, r3, n3);
            else {
              const a2 = t4.context, s2 = a2.gl;
              let l3, c2;
              const h3 = t4.options.showTerrainWireframe ? 2 : 0, u3 = (e2, i4) => {
                if (c2 === e2)
                  return;
                const o4 = [Ci2[e2]];
                i4 && o4.push(Ci2[h3]), l3 = t4.useProgram("terrainRaster", null, o4), c2 = e2;
              }, _2 = t4.colorModeForRenderPass(), d2 = new e.DepthMode(s2.LEQUAL, e.DepthMode.ReadWrite, t4.depthRangeFor3D);
              Ei2.update(n3);
              const p3 = t4.transform, m3 = 6 * Math.pow(1.5, 22 - p3.zoom) * i3.exaggeration();
              (h3 ? [false, true] : [false]).forEach((h4) => {
                c2 = -1;
                const f2 = h4 ? s2.LINES : s2.TRIANGLES, [g2, v3] = h4 ? i3.getWirefameBuffer() : [i3.gridIndexBuffer, i3.gridSegments];
                for (const c3 of r3) {
                  const r4 = o3.getTile(c3), x3 = e.StencilMode.disabled, y3 = i3.prevTerrainTileForTile[c3.key], b2 = i3.terrainTileForTile[c3.key];
                  Ti2(y3, b2) && Ei2.newMorphing(c3.key, y3, b2, n3, 250), a2.activeTexture.set(s2.TEXTURE0), r4.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST);
                  const w2 = Ei2.getMorphValuesForProxy(c3.key), T3 = w2 ? 1 : 0;
                  let E3;
                  w2 && (E3 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: e.easeCubicInOut(w2.phase) } });
                  const C3 = bi2(c3.projMatrix, Ii2(c3.canonical, p3.renderWorldCopies) ? m3 / 10 : m3);
                  u3(T3, h4), i3.setupElevationDraw(r4, l3, E3), t4.prepareDrawProgram(a2, l3, c3.toUnwrapped()), l3.draw(a2, f2, d2, x3, _2, e.CullFaceMode.backCCW, C3, "terrain_raster", i3.gridBuffer, g2, v3);
                }
              });
            }
          }(i2, this, this.proxySourceCache, t3, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t3.splice(0, t3.length));
        }
        renderBatch(t3) {
          if (this._drapedRenderBatches.length === 0)
            return t3 + 1;
          this.renderingToTexture = true;
          const i2 = this.painter, o2 = this.painter.context, r3 = this.proxySourceCache, n3 = this.proxiedCoords[r3.id], a2 = this._drapedRenderBatches.shift(), s2 = [], l3 = i2.style.order;
          let c2 = 0;
          for (const h3 of n3) {
            const n4 = r3.getTileByID(h3.proxyTileKey), u3 = r3.proxyCachedFBO[h3.key] ? r3.proxyCachedFBO[h3.key][t3] : void 0, _2 = u3 !== void 0 ? r3.renderCache[u3] : this.pool[c2++], d2 = u3 !== void 0;
            if (n4.texture = _2.tex, d2 && !_2.dirty) {
              s2.push(n4.tileID);
              continue;
            }
            let p3;
            o2.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = false, _2.dirty && (o2.clear({ color: e.Color.transparent, stencil: 0 }), _2.dirty = false);
            for (let e2 = a2.start; e2 <= a2.end; ++e2) {
              const t4 = i2.style._layers[l3[e2]];
              if (t4.isHidden(i2.transform.zoom))
                continue;
              const r4 = i2.style._getLayerSourceCache(t4), n5 = r4 ? this.proxyToSource[h3.key][r4.id] : [h3];
              if (!n5)
                continue;
              const a3 = n5;
              o2.viewport.set([0, 0, _2.fb.width, _2.fb.height]), p3 !== (r4 ? r4.id : null) && (this._setupStencil(_2, n5, t4, r4), p3 = r4 ? r4.id : null), i2.renderLayer(i2, r4, t4, a3);
            }
            this.renderedToTile ? (_2.dirty = true, s2.push(n4.tileID)) : d2 || --c2, c2 === 5 && (c2 = 0, this.renderToBackBuffer(s2));
          }
          return this.renderToBackBuffer(s2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), a2.end + 1;
        }
        postRender() {
        }
        renderCacheEfficiency(e2) {
          const t3 = e2.order.length;
          if (t3 === 0)
            return { efficiency: 100 };
          let i2, o2 = 0, r3 = 0, n3 = false;
          for (let a2 = 0; a2 < t3; ++a2) {
            const t4 = e2._layers[e2.order[a2]];
            this._style.isLayerDraped(t4) ? (n3 && ++o2, ++r3) : n3 || (n3 = true, i2 = t4.id);
          }
          return r3 === 0 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r3), firstUndrapedLayer: i2 };
        }
        getMinElevationBelowMSL() {
          let e2 = 0;
          return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t3) => {
            e2 = Math.min(e2, t3.dem.tree.minimums[0]);
          }), e2 === 0 ? e2 : (e2 - 30) * this._exaggeration;
        }
        raycast(e2, t3, i2) {
          if (!this._visibleDemTiles)
            return null;
          const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
            const r3 = o3.tileID, n3 = 1 << r3.overscaledZ, { x: a2, y: s2 } = r3.canonical, l3 = a2 / n3, c2 = (a2 + 1) / n3, h3 = s2 / n3, u3 = (s2 + 1) / n3;
            return { minx: l3, miny: h3, maxx: c2, maxy: u3, t: o3.dem.tree.raycastRoot(l3, h3, c2, u3, e2, t3, i2), tile: o3 };
          });
          o2.sort((e3, t4) => (e3.t !== null ? e3.t : Number.MAX_VALUE) - (t4.t !== null ? t4.t : Number.MAX_VALUE));
          for (const r3 of o2) {
            if (r3.t == null)
              return null;
            const o3 = r3.tile.dem.tree.raycast(r3.minx, r3.miny, r3.maxx, r3.maxy, e2, t3, i2);
            if (o3 != null)
              return o3;
          }
          return null;
        }
        _createFBO() {
          const t3 = this.painter.context, i2 = t3.gl, o2 = this.drapeBufferSize;
          t3.activeTexture.set(i2.TEXTURE0);
          const r3 = new e.Texture(t3, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
          r3.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          const n3 = t3.createFramebuffer(o2[0], o2[1], false);
          return n3.colorAttachment.set(r3.texture), n3.depthAttachment = new Ee2(t3, n3.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t3.createRenderbuffer(t3.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, n3.depthAttachment.set(this._sharedDepthStencil), t3.clear({ stencil: 0 })) : n3.depthAttachment.set(this._sharedDepthStencil), t3.extTextureFilterAnisotropic && !t3.extTextureFilterAnisotropicForceOff && i2.texParameterf(i2.TEXTURE_2D, t3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t3.extTextureFilterAnisotropicMax), { fb: n3, tex: r3, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._style.light && this._style.light.hasTransition())
            return true;
          for (const e2 in this._style._sourceCaches)
            if (this._style._sourceCaches[e2].hasTransition())
              return true;
          return this._style.order.some((e2) => {
            const t3 = this._style._layers[e2], i2 = t3.isHidden(this.painter.transform.zoom), o2 = t3.getCrossfadeParameters(), r3 = !!o2 && o2.t !== 1, n3 = t3.hasTransition();
            return t3.type !== "custom" && !i2 && (r3 || n3);
          });
        }
        _clearRasterFadeFromRenderCache() {
          let e2 = false;
          for (const t3 in this._style._sourceCaches)
            if (this._style._sourceCaches[t3]._source instanceof Me2) {
              e2 = true;
              break;
            }
          if (e2)
            for (let e3 = 0; e3 < this._style.order.length; ++e3) {
              const t3 = this._style._layers[this._style.order[e3]], i2 = t3.isHidden(this.painter.transform.zoom), o2 = this._style._getLayerSourceCache(t3);
              if (t3.type !== "raster" || i2 || !o2)
                continue;
              const r3 = t3.paint.get("raster-fade-duration");
              for (const e4 of this.proxyCoords) {
                const t4 = this.proxyToSource[e4.key][o2.id];
                if (t4)
                  for (const e5 of t4) {
                    const t5 = Si2(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r3);
                    (t5.opacity !== 1 || t5.mix !== 0) && this._clearRenderCacheForTile(o2.id, e5);
                  }
              }
            }
        }
        _setupDrapedRenderBatches() {
          const e2 = this._style.order, t3 = e2.length;
          if (t3 === 0)
            return;
          const i2 = [];
          let o2, r3 = 0, n3 = this._style._layers[e2[r3]];
          for (; !this._style.isLayerDraped(n3) && n3.isHidden(this.painter.transform.zoom) && ++r3 < t3; )
            n3 = this._style._layers[e2[r3]];
          for (; r3 < t3; ++r3) {
            const t4 = this._style._layers[e2[r3]];
            t4.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t4) ? o2 === void 0 && (o2 = r3) : o2 !== void 0 && (i2.push({ start: o2, end: r3 - 1 }), o2 = void 0));
          }
          o2 !== void 0 && i2.push({ start: o2, end: r3 - 1 }), this._drapedRenderBatches = i2;
        }
        _setupRenderCache(e2) {
          const t3 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
            if (this._invalidateRenderCache = false, t3.renderCache.length > t3.renderCachePool.length) {
              const e3 = Object.values(t3.proxyCachedFBO);
              t3.proxyCachedFBO = {};
              for (let i3 = 0; i3 < e3.length; ++i3) {
                const o3 = Object.values(e3[i3]);
                t3.renderCachePool.push(...o3);
              }
            }
            return;
          }
          this._clearRasterFadeFromRenderCache();
          const i2 = this.proxyCoords, o2 = this._tilesDirty;
          for (let r4 = i2.length - 1; r4 >= 0; r4--) {
            const n3 = i2[r4];
            if (t3.getTileByID(n3.key), t3.proxyCachedFBO[n3.key] !== void 0) {
              const i3 = e2[n3.key], r5 = this.proxyToSource[n3.key];
              let a2 = 0;
              for (const e3 in r5) {
                const t4 = r5[e3], n4 = i3[e3];
                if (!n4 || n4.length !== t4.length || t4.some((t5, i4) => t5 !== n4[i4] || o2[e3] && o2[e3].hasOwnProperty(t5.key))) {
                  a2 = -1;
                  break;
                }
                ++a2;
              }
              for (const e3 in t3.proxyCachedFBO[n3.key])
                t3.renderCache[t3.proxyCachedFBO[n3.key][e3]].dirty = a2 < 0 || a2 !== Object.values(i3).length;
            }
          }
          const r3 = [...this._drapedRenderBatches];
          r3.sort((e3, t4) => t4.end - t4.start - (e3.end - e3.start));
          for (const e3 of r3)
            for (const o3 of i2) {
              if (t3.proxyCachedFBO[o3.key])
                continue;
              let i3 = t3.renderCachePool.pop();
              i3 === void 0 && t3.renderCache.length < 50 && (i3 = t3.renderCache.length, t3.renderCache.push(this._createFBO())), i3 !== void 0 && (t3.proxyCachedFBO[o3.key] = {}, t3.proxyCachedFBO[o3.key][e3.start] = i3, t3.renderCache[i3].dirty = true);
            }
          this._tilesDirty = {};
        }
        _setupStencil(e2, t3, i2, o2) {
          if (!o2 || !this._sourceTilesOverlap[o2.id])
            return void (this._overlapStencilType && (this._overlapStencilType = false));
          const r3 = this.painter.context, n3 = r3.gl;
          if (t3.length <= 1)
            return void (this._overlapStencilType = false);
          let a2;
          if (i2.isTileClipped())
            a2 = t3.length, this._overlapStencilMode.test = { func: n3.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t3[0].overscaledZ > t3[t3.length - 1].overscaledZ))
              return void (this._overlapStencilType = false);
            a2 = 1, this._overlapStencilMode.test = { func: n3.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + a2 > 255 && (r3.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += a2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t3, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
        }
        stencilModeForRTTOverlap(t3) {
          return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t3.key]), this._overlapStencilMode) : e.StencilMode.disabled;
        }
        _renderTileClippingMasks(t3, i2) {
          const o2 = this.painter, r3 = this.painter.context, n3 = r3.gl;
          o2._tileClippingMaskIDs = {}, r3.setColorMode(e.ColorMode.disabled), r3.setDepthMode(e.DepthMode.disabled);
          const a2 = o2.useProgram("clippingMask");
          for (const s2 of t3) {
            const t4 = o2._tileClippingMaskIDs[s2.key] = --i2;
            a2.draw(r3, n3.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n3.ALWAYS, mask: 0 }, t4, 255, n3.KEEP, n3.KEEP, n3.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Mi2(s2.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
          }
        }
        pointCoordinate(t3) {
          const i2 = this.painter.transform;
          if (t3.x < 0 || t3.x > i2.width || t3.y < 0 || t3.y > i2.height)
            return null;
          const o2 = [t3.x, t3.y, 1, 1];
          e.transformMat4$1(o2, o2, i2.pixelMatrixInverse), e.scale$1(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
          const r3 = i2._camera.position, n3 = e.mercatorZfromAltitude(1, i2.center.lat), a2 = [r3[0], r3[1], r3[2] / n3, 0], s2 = e.subtract([], o2.slice(0, 3), a2);
          e.normalize(s2, s2);
          const l3 = this.raycast(a2, s2, this._exaggeration);
          return l3 !== null && l3 ? (e.scaleAndAdd(a2, a2, s2, l3), a2[3] = a2[2], a2[2] *= n3, a2) : null;
        }
        drawDepth() {
          const t3 = this.painter, i2 = t3.context, o2 = this.proxySourceCache, r3 = Math.ceil(t3.width), n3 = Math.ceil(t3.height);
          if (!this._depthFBO || this._depthFBO.width === r3 && this._depthFBO.height === n3 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
            const t4 = i2.gl, o3 = i2.createFramebuffer(r3, n3, true);
            i2.activeTexture.set(t4.TEXTURE0);
            const a2 = new e.Texture(i2, { width: r3, height: n3, data: null }, t4.RGBA);
            a2.bind(t4.NEAREST, t4.CLAMP_TO_EDGE), o3.colorAttachment.set(a2.texture);
            const s2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r3, n3);
            o3.depthAttachment.set(s2), this._depthFBO = o3, this._depthTexture = a2;
          }
          i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r3, n3]), function(t4, i3, o3, r4) {
            if (t4.transform.projection.name === "globe")
              return;
            const n4 = t4.context, a2 = n4.gl;
            n4.clear({ depth: 1 });
            const s2 = t4.useProgram("terrainDepth"), l3 = new e.DepthMode(a2.LESS, e.DepthMode.ReadWrite, t4.depthRangeFor3D);
            for (const t5 of r4) {
              const r5 = o3.getTile(t5), c2 = bi2(t5.projMatrix, 0);
              i3.setupElevationDraw(r5, s2), s2.draw(n4, a2.TRIANGLES, l3, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c2, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
            }
          }(t3, this, o2, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(e2, t3, i2) {
          if (e2.getSource() instanceof De2)
            return this._setupProxiedCoordsForImageSource(e2, t3, i2);
          this._findCoveringTileCache[e2.id] = this._findCoveringTileCache[e2.id] || {};
          const o2 = this.proxiedCoords[e2.id] = [], r3 = this.proxyCoords;
          for (let t4 = 0; t4 < r3.length; t4++) {
            const n4 = r3[t4], a2 = this._findTileCoveringTileID(n4, e2);
            if (a2) {
              const t5 = this._createProxiedId(n4, a2, i2[n4.key] && i2[n4.key][e2.id]);
              o2.push(t5), this.proxyToSource[n4.key][e2.id] = [t5];
            }
          }
          let n3 = false;
          for (let r4 = 0; r4 < t3.length; r4++) {
            const a2 = e2.getTile(t3[r4]);
            if (!a2 || !a2.hasData())
              continue;
            const s2 = this._findTileCoveringTileID(a2.tileID, this.proxySourceCache);
            if (s2 && s2.tileID.canonical.z !== a2.tileID.canonical.z) {
              const t4 = this.proxyToSource[s2.tileID.key][e2.id], r5 = this._createProxiedId(s2.tileID, a2, i2[s2.tileID.key] && i2[s2.tileID.key][e2.id]);
              t4 ? t4.splice(t4.length - 1, 0, r5) : this.proxyToSource[s2.tileID.key][e2.id] = [r5], o2.push(r5), n3 = true;
            }
          }
          this._sourceTilesOverlap[e2.id] = n3;
        }
        _setupProxiedCoordsForImageSource(t3, i2, o2) {
          if (!t3.getSource().loaded())
            return;
          const r3 = this.proxiedCoords[t3.id] = [], n3 = this.proxyCoords, a2 = t3.getSource(), s2 = new e.pointGeometry(a2.tileID.x, a2.tileID.y)._div(1 << a2.tileID.z), l3 = a2.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e2, t4) => (e2.min.x = Math.min(e2.min.x, t4.x - s2.x), e2.min.y = Math.min(e2.min.y, t4.y - s2.y), e2.max.x = Math.max(e2.max.x, t4.x - s2.x), e2.max.y = Math.max(e2.max.y, t4.y - s2.y), e2), { min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c2 = (t4, i3) => {
            const o3 = t4.wrap + t4.canonical.x / (1 << t4.canonical.z), r4 = t4.canonical.y / (1 << t4.canonical.z), n4 = e.EXTENT / (1 << t4.canonical.z), a3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), s3 = i3.canonical.y / (1 << i3.canonical.z);
            return o3 + n4 < a3 + l3.min.x || o3 > a3 + l3.max.x || r4 + n4 < s3 + l3.min.y || r4 > s3 + l3.max.y;
          };
          for (let e2 = 0; e2 < n3.length; e2++) {
            const a3 = n3[e2];
            for (let e3 = 0; e3 < i2.length; e3++) {
              const n4 = t3.getTile(i2[e3]);
              if (!n4 || !n4.hasData())
                continue;
              if (c2(a3, n4.tileID))
                continue;
              const s3 = this._createProxiedId(a3, n4, o2[a3.key] && o2[a3.key][t3.id]), l4 = this.proxyToSource[a3.key][t3.id];
              l4 ? l4.push(s3) : this.proxyToSource[a3.key][t3.id] = [s3], r3.push(s3);
            }
          }
        }
        _createProxiedId(t3, i2, o2) {
          let r3 = this.orthoMatrix;
          if (o2) {
            const e2 = o2.find((e3) => e3.key === i2.tileID.key);
            if (e2)
              return e2;
          }
          if (i2.tileID.key !== t3.key) {
            const o3 = t3.canonical.z - i2.tileID.canonical.z;
            let n3, a2, s2;
            r3 = e.create();
            const l3 = i2.tileID.wrap - t3.wrap << t3.overscaledZ;
            o3 > 0 ? (n3 = e.EXTENT >> o3, a2 = n3 * ((i2.tileID.canonical.x << o3) - t3.canonical.x + l3), s2 = n3 * ((i2.tileID.canonical.y << o3) - t3.canonical.y)) : (n3 = e.EXTENT << -o3, a2 = e.EXTENT * (i2.tileID.canonical.x - (t3.canonical.x + l3 << -o3)), s2 = e.EXTENT * (i2.tileID.canonical.y - (t3.canonical.y << -o3))), e.ortho(r3, 0, n3, 0, n3, 0, 1), e.translate(r3, r3, [a2, s2, 0]);
          }
          return new Pi2(i2.tileID, t3.key, r3);
        }
        _findTileCoveringTileID(t3, i2) {
          let o2 = i2.getTile(t3);
          if (o2 && o2.hasData())
            return o2;
          const r3 = this._findCoveringTileCache[i2.id], n3 = r3[t3.key];
          if (o2 = n3 ? i2.getTileByID(n3) : null, o2 && o2.hasData() || n3 === null)
            return o2;
          let a2 = o2 ? o2.tileID : t3, s2 = a2.overscaledZ;
          const l3 = i2.getSource().minzoom, c2 = [];
          if (!n3) {
            const r4 = i2.getSource().maxzoom;
            if (t3.canonical.z >= r4) {
              const o3 = t3.canonical.z - r4;
              i2.getSource().reparseOverscaled ? (s2 = Math.max(t3.canonical.z + 2, i2.transform.tileZoom), a2 = new e.OverscaledTileID(s2, t3.wrap, r4, t3.canonical.x >> o3, t3.canonical.y >> o3)) : o3 !== 0 && (s2 = r4, a2 = new e.OverscaledTileID(s2, t3.wrap, r4, t3.canonical.x >> o3, t3.canonical.y >> o3));
            }
            a2.key !== t3.key && (c2.push(a2.key), o2 = i2.getTile(a2));
          }
          const h3 = (e2) => {
            c2.forEach((t4) => {
              r3[t4] = e2;
            }), c2.length = 0;
          };
          for (s2 -= 1; s2 >= l3 && (!o2 || !o2.hasData()); s2--) {
            o2 && h3(o2.tileID.key);
            const e2 = a2.calculateScaledKey(s2);
            if (o2 = i2.getTileByID(e2), o2 && o2.hasData())
              break;
            const t4 = r3[e2];
            if (t4 === null)
              break;
            t4 === void 0 ? c2.push(e2) : o2 = i2.getTileByID(t4);
          }
          return h3(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
        }
        findDEMTileFor(e2) {
          return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e2, t3) {
          let i2 = this._tilesDirty[e2];
          i2 || (i2 = this._tilesDirty[e2] = {}), i2[t3.key] = true;
        }
        getWirefameBuffer() {
          if (!this.wireframeSegments) {
            const t3 = function(t4) {
              let i2 = 0;
              const o2 = new e.StructArrayLayout2ui4(), r3 = 131;
              for (let e2 = 1; e2 < 129; e2++) {
                for (let t5 = 1; t5 < 129; t5++)
                  i2 = e2 * r3 + t5, o2.emplaceBack(i2, i2 + 1), o2.emplaceBack(i2, i2 + r3), o2.emplaceBack(i2 + 1, i2 + r3), e2 === 128 && o2.emplaceBack(i2 + r3, i2 + r3 + 1);
                o2.emplaceBack(i2 + 1, i2 + 1 + r3);
              }
              return o2;
            }();
            this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t3), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t3.length);
          }
          return [this.wireframeIndexBuffer, this.wireframeSegments];
        }
      }
      class Li2 {
        static cacheKey(e2, t3, i2, o2) {
          let r3 = `${t3}${o2 ? o2.cacheKey : ""}`;
          for (const t4 of i2)
            e2.usedDefines.includes(t4) && (r3 += `/${t4}`);
          return r3;
        }
        constructor(t3, i2, o2, r3, n3, a2) {
          const s2 = t3.gl;
          this.program = s2.createProgram();
          const l3 = function(e2) {
            const t4 = [];
            for (let i3 = 0; i3 < e2.length; i3++) {
              if (e2[i3] === null)
                continue;
              const o3 = e2[i3].split(" ");
              t4.push(o3.pop());
            }
            return t4;
          }(o2.staticAttributes), c2 = r3 ? r3.getBinderAttributes() : [], h3 = l3.concat(c2);
          let u3 = r3 ? r3.defines() : [];
          u3 = u3.concat(a2.map((e2) => `#define ${e2}`));
          const _2 = u3.concat(t3.extStandardDerivatives ? "#extension GL_OES_standard_derivatives : enable\n".concat(ui2) : ui2, ui2, hi2, ci2.fragmentSource, si2.fragmentSource, o2.fragmentSource).join("\n"), d2 = u3.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", hi2, ci2.vertexSource, si2.vertexSource, ai2.vertexSource, o2.vertexSource).join("\n"), p3 = s2.createShader(s2.FRAGMENT_SHADER);
          if (s2.isContextLost())
            return void (this.failedToCreate = true);
          s2.shaderSource(p3, _2), s2.compileShader(p3), s2.attachShader(this.program, p3);
          const m3 = s2.createShader(s2.VERTEX_SHADER);
          if (s2.isContextLost())
            this.failedToCreate = true;
          else {
            s2.shaderSource(m3, d2), s2.compileShader(m3), s2.attachShader(this.program, m3), this.attributes = {}, this.numAttributes = h3.length;
            for (let e2 = 0; e2 < this.numAttributes; e2++)
              h3[e2] && (s2.bindAttribLocation(this.program, e2, h3[e2]), this.attributes[h3[e2]] = e2);
            s2.linkProgram(this.program), s2.deleteShader(m3), s2.deleteShader(p3), this.fixedUniforms = n3(t3), this.binderUniforms = r3 ? r3.getUniforms(t3) : [], a2.indexOf("TERRAIN") !== -1 && (this.terrainUniforms = ((t4) => ({ u_dem: new e.Uniform1i(t4), u_dem_prev: new e.Uniform1i(t4), u_dem_unpack: new e.Uniform4f(t4), u_dem_tl: new e.Uniform2f(t4), u_dem_scale: new e.Uniform1f(t4), u_dem_tl_prev: new e.Uniform2f(t4), u_dem_scale_prev: new e.Uniform1f(t4), u_dem_size: new e.Uniform1f(t4), u_dem_lerp: new e.Uniform1f(t4), u_exaggeration: new e.Uniform1f(t4), u_depth: new e.Uniform1i(t4), u_depth_size_inv: new e.Uniform2f(t4), u_meter_to_dem: new e.Uniform1f(t4), u_label_plane_matrix_inv: new e.UniformMatrix4f(t4), u_tile_tl_up: new e.Uniform3f(t4), u_tile_tr_up: new e.Uniform3f(t4), u_tile_br_up: new e.Uniform3f(t4), u_tile_bl_up: new e.Uniform3f(t4), u_tile_up_scale: new e.Uniform1f(t4) }))(t3)), a2.indexOf("FOG") !== -1 && (this.fogUniforms = ((t4) => ({ u_fog_matrix: new e.UniformMatrix4f(t4), u_fog_range: new e.Uniform2f(t4), u_fog_color: new e.Uniform4f(t4), u_fog_horizon_blend: new e.Uniform1f(t4), u_fog_temporal_offset: new e.Uniform1f(t4), u_frustum_tl: new e.Uniform3f(t4), u_frustum_tr: new e.Uniform3f(t4), u_frustum_br: new e.Uniform3f(t4), u_frustum_bl: new e.Uniform3f(t4), u_globe_pos: new e.Uniform3f(t4), u_globe_radius: new e.Uniform1f(t4), u_globe_transition: new e.Uniform1f(t4), u_is_globe: new e.Uniform1i(t4), u_viewport: new e.Uniform2f(t4) }))(t3));
          }
        }
        setTerrainUniformValues(e2, t3) {
          if (!this.terrainUniforms)
            return;
          const i2 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t3)
              i2[e3].set(this.program, e3, t3[e3]);
          }
        }
        setFogUniformValues(e2, t3) {
          if (!this.fogUniforms)
            return;
          const i2 = this.fogUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t3)
              i2[e3].set(this.program, e3, t3[e3]);
          }
        }
        draw(e2, t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3) {
          const m3 = e2.gl;
          if (this.failedToCreate)
            return;
          e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(o2), e2.setColorMode(r3), e2.setCullFace(n3);
          for (const e3 of Object.keys(this.fixedUniforms))
            this.fixedUniforms[e3].set(this.program, e3, a2[e3]);
          d2 && d2.setUniforms(this.program, e2, this.binderUniforms, u3, { zoom: _2 });
          const f2 = { [m3.LINES]: 2, [m3.TRIANGLES]: 3, [m3.LINE_STRIP]: 1 }[t3];
          for (const i3 of h3.get()) {
            const o3 = i3.vaos || (i3.vaos = {});
            (o3[s2] || (o3[s2] = new mi2())).bind(e2, this, l3, d2 ? d2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, p3 || []), m3.drawElements(t3, i3.primitiveLength * f2, m3.UNSIGNED_SHORT, i3.primitiveOffset * f2 * 2);
          }
        }
      }
      function Ri2(e2, t3, i2) {
        const o2 = 1 / L2(i2, 1, t3.transform.tileZoom), r3 = Math.pow(2, i2.tileID.overscaledZ), n3 = i2.tileSize * Math.pow(2, t3.transform.tileZoom) / r3, a2 = n3 * (i2.tileID.canonical.x + i2.tileID.wrap * r3), s2 = n3 * i2.tileID.canonical.y;
        return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, e2.fromScale, e2.toScale], u_fade: e2.t, u_pixel_coord_upper: [a2 >> 16, s2 >> 16], u_pixel_coord_lower: [65535 & a2, 65535 & s2] };
      }
      const Oi2 = e.create(), Bi2 = (t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3) => {
        const _2 = i2.style.light, d2 = _2.properties.get("position"), p3 = [d2.x, d2.y, d2.z], m3 = e.create$1();
        _2.properties.get("anchor") === "viewport" && (e.fromRotation(m3, -i2.transform.angle), e.transformMat3(p3, p3, m3));
        const f2 = _2.properties.get("color"), g2 = i2.transform, v3 = { u_matrix: t3, u_lightpos: p3, u_lightintensity: _2.properties.get("intensity"), u_lightcolor: [f2.r, f2.g, f2.b], u_vertical_gradient: +o2, u_opacity: r3, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Oi2, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n3, u_edge_radius: a2 };
        return g2.projection.name === "globe" && (v3.u_tile_id = [s2.canonical.x, s2.canonical.y, 1 << s2.canonical.z], v3.u_zoom_transition = c2, v3.u_inv_rot_matrix = u3, v3.u_merc_center = h3, v3.u_up_dir = g2.projection.upVector(new e.CanonicalTileID(0, 0, 0), h3[0] * e.EXTENT, h3[1] * e.EXTENT), v3.u_height_lift = l3), v3;
      }, ki2 = (t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2) => {
        const p3 = Bi2(t3, i2, o2, r3, n3, a2, s2, h3, u3, _2, d2), m3 = { u_height_factor: -Math.pow(2, s2.overscaledZ) / c2.tileSize / 8 };
        return e.extend(p3, Ri2(l3, i2, c2), m3);
      }, Fi2 = (e2) => ({ u_matrix: e2 }), Ui2 = (t3, i2, o2, r3) => e.extend(Fi2(t3), Ri2(o2, i2, r3)), Ni2 = (e2, t3) => ({ u_matrix: e2, u_world: t3 }), Gi2 = (t3, i2, o2, r3, n3) => e.extend(Ui2(t3, i2, o2, r3), { u_world: n3 }), ji2 = e.create(), Zi2 = (t3, i2, o2, r3, n3, a2) => {
        const s2 = t3.transform, l3 = s2.projection.name === "globe";
        let c2;
        if (a2.paint.get("circle-pitch-alignment") === "map")
          if (l3) {
            const t4 = e.globePixelsToTileUnits(s2.zoom, i2.canonical) * s2._pixelsPerMercatorPixel;
            c2 = Float32Array.from([t4, 0, 0, t4]);
          } else
            c2 = s2.calculatePixelsToTileUnitsMatrix(o2);
        else
          c2 = new Float32Array([s2.pixelsToGLUnits[0], 0, 0, s2.pixelsToGLUnits[1]]);
        const h3 = { u_camera_to_center_distance: s2.cameraToCenterDistance, u_matrix: t3.translatePosMatrix(i2.projMatrix, o2, a2.paint.get("circle-translate"), a2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: c2, u_inv_rot_matrix: ji2, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (l3) {
          h3.u_inv_rot_matrix = r3, h3.u_merc_center = n3, h3.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], h3.u_zoom_transition = e.globeToMercatorTransition(s2.zoom);
          const t4 = n3[0] * e.EXTENT, o3 = n3[1] * e.EXTENT;
          h3.u_up_dir = s2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t4, o3);
        }
        return h3;
      }, Vi2 = (e2) => {
        const t3 = [];
        return e2.paint.get("circle-pitch-alignment") === "map" && t3.push("PITCH_WITH_MAP"), e2.paint.get("circle-pitch-scale") === "map" && t3.push("SCALE_WITH_MAP"), t3;
      }, Wi2 = (t3, i2, o2, r3) => {
        const n3 = e.EXTENT / o2.tileSize;
        return { u_matrix: t3, u_camera_to_center_distance: i2.getCameraToCenterDistance(r3), u_extrude_scale: [i2.pixelsToGLUnits[0] / n3, i2.pixelsToGLUnits[1] / n3] };
      }, Xi2 = (e2, t3, i2 = 1) => ({ u_matrix: e2, u_color: t3, u_overlay: 0, u_overlay_scale: i2 }), qi2 = e.create(), $i2 = (t3, i2, o2, r3, n3, a2, s2) => {
        const l3 = t3.transform, c2 = l3.projection.name === "globe", h3 = c2 ? e.globePixelsToTileUnits(l3.zoom, i2.canonical) * l3._pixelsPerMercatorPixel : L2(o2, 1, a2), u3 = { u_matrix: i2.projMatrix, u_extrude_scale: h3, u_intensity: s2, u_inv_rot_matrix: qi2, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (c2) {
          u3.u_inv_rot_matrix = r3, u3.u_merc_center = n3, u3.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], u3.u_zoom_transition = e.globeToMercatorTransition(l3.zoom);
          const t4 = n3[0] * e.EXTENT, o3 = n3[1] * e.EXTENT;
          u3.u_up_dir = l3.projection.upVector(new e.CanonicalTileID(0, 0, 0), t4, o3);
        }
        return u3;
      }, Hi2 = (e2, t3, i2, o2, r3, n3, a2, s2) => {
        const l3 = e2.transform, c2 = l3.calculatePixelsToTileUnitsMatrix(t3), h3 = { u_matrix: Ji2(e2, t3, i2, r3), u_pixels_to_tile_units: c2, u_device_pixel_ratio: a2, u_units_to_pixels: [1 / l3.pixelsToGLUnits[0], 1 / l3.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: n3, u_texsize: [0, 0], u_scale: [0, 0, 0], u_mix: 0, u_alpha_discard_threshold: 0, u_trim_offset: s2 };
        if (Qi2(i2)) {
          const i3 = Ki2(t3, e2.transform);
          h3.u_texsize = t3.lineAtlasTexture.size, h3.u_scale = [i3, o2.fromScale, o2.toScale], h3.u_mix = o2.t;
        }
        return h3;
      }, Yi2 = (e2, t3, i2, o2, r3, n3) => {
        const a2 = e2.transform, s2 = Ki2(t3, a2);
        return { u_matrix: Ji2(e2, t3, i2, r3), u_texsize: t3.imageAtlasTexture.size, u_pixels_to_tile_units: a2.calculatePixelsToTileUnitsMatrix(t3), u_device_pixel_ratio: n3, u_image: 0, u_scale: [s2, o2.fromScale, o2.toScale], u_fade: o2.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
      };
      function Ki2(e2, t3) {
        return 1 / L2(e2, 1, t3.tileZoom);
      }
      function Ji2(e2, t3, i2, o2) {
        return e2.translatePosMatrix(o2 || t3.tileID.projMatrix, t3, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
      }
      function Qi2(e2) {
        const t3 = e2.paint.get("line-dasharray").value;
        return t3.value || t3.kind !== "constant";
      }
      const eo = (e2, t3, i2, o2, r3, n3) => {
        return { u_matrix: e2, u_tl_parent: t3, u_scale_parent: i2, u_fade_t: o2.mix, u_opacity: o2.opacity * r3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r3.paint.get("raster-brightness-min"), u_brightness_high: r3.paint.get("raster-brightness-max"), u_saturation_factor: (s2 = r3.paint.get("raster-saturation"), s2 > 0 ? 1 - 1 / (1.001 - s2) : -s2), u_contrast_factor: (a2 = r3.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: to2(r3.paint.get("raster-hue-rotate")), u_perspective_transform: n3 };
        var a2, s2;
      };
      function to2(e2) {
        e2 *= Math.PI / 180;
        const t3 = Math.sin(e2), i2 = Math.cos(e2);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t3 - i2 + 1) / 3, (Math.sqrt(3) * t3 - i2 + 1) / 3];
      }
      const io = e.create(), oo = (t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3, f2) => {
        const g2 = n3.transform, v3 = { u_is_size_zoom_constant: +(t3 === "constant" || t3 === "source"), u_is_size_feature_constant: +(t3 === "constant" || t3 === "camera"), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: g2.cameraToCenterDistance, u_rotate_symbol: +o2, u_aspect_ratio: g2.width / g2.height, u_fade_change: n3.options.fadeDuration ? n3.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: s2, u_coord_matrix: l3, u_is_text: +c2, u_pitch_with_map: +r3, u_texsize: h3, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: io, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: io, u_up_vector: [0, -1, 0] };
        return f2.name === "globe" && (v3.u_tile_id = [u3.canonical.x, u3.canonical.y, 1 << u3.canonical.z], v3.u_zoom_transition = _2, v3.u_inv_rot_matrix = p3, v3.u_merc_center = d2, v3.u_camera_forward = g2._camera.forward(), v3.u_ecef_origin = e.globeECEFOrigin(g2.globeMatrix, u3.toUnwrapped()), v3.u_tile_matrix = Float32Array.from(g2.globeMatrix), v3.u_up_vector = m3), v3;
      }, ro = (t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3, f2, g2) => e.extend(oo(t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, _2, d2, p3, m3, f2, g2), { u_gamma_scale: r3 ? n3.transform.cameraToCenterDistance * Math.cos(n3.terrain ? 0 : n3.transform._pitch) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +u3 }), no = (t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2, d2, p3, m3, f2) => e.extend(ro(t3, i2, o2, r3, n3, a2, s2, l3, true, c2, true, u3, _2, d2, p3, m3, f2), { u_texsize_icon: h3, u_texture_icon: 1 }), ao = (e2, t3, i2) => ({ u_matrix: e2, u_opacity: t3, u_color: i2 }), so = (t3, i2, o2, r3, n3, a2) => e.extend(function(e2, t4, i3, o3) {
        const r4 = i3.imageManager.getPattern(e2.from.toString()), n4 = i3.imageManager.getPattern(e2.to.toString()), { width: a3, height: s2 } = i3.imageManager.getPixelSize(), l3 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / l3, h3 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l3), u3 = c2 * o3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: r4.tl, u_pattern_br_a: r4.br, u_pattern_tl_b: n4.tl, u_pattern_br_b: n4.br, u_texsize: [a3, s2], u_mix: t4.t, u_pattern_size_a: r4.displaySize, u_pattern_size_b: n4.displaySize, u_scale_a: t4.fromScale, u_scale_b: t4.toScale, u_tile_units_to_pixels: 1 / L2(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h3 >> 16, u3 >> 16], u_pixel_coord_lower: [65535 & h3, 65535 & u3] };
      }(r3, a2, o2, n3), { u_matrix: t3, u_opacity: i2 }), lo = { fillExtrusion: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_lightpos: new e.Uniform3f(t3), u_lightintensity: new e.Uniform1f(t3), u_lightcolor: new e.Uniform3f(t3), u_vertical_gradient: new e.Uniform1f(t3), u_opacity: new e.Uniform1f(t3), u_edge_radius: new e.Uniform1f(t3), u_ao: new e.Uniform2f(t3), u_tile_id: new e.Uniform3f(t3), u_zoom_transition: new e.Uniform1f(t3), u_inv_rot_matrix: new e.UniformMatrix4f(t3), u_merc_center: new e.Uniform2f(t3), u_up_dir: new e.Uniform3f(t3), u_height_lift: new e.Uniform1f(t3) }), fillExtrusionPattern: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_lightpos: new e.Uniform3f(t3), u_lightintensity: new e.Uniform1f(t3), u_lightcolor: new e.Uniform3f(t3), u_vertical_gradient: new e.Uniform1f(t3), u_height_factor: new e.Uniform1f(t3), u_edge_radius: new e.Uniform1f(t3), u_ao: new e.Uniform2f(t3), u_tile_id: new e.Uniform3f(t3), u_zoom_transition: new e.Uniform1f(t3), u_inv_rot_matrix: new e.UniformMatrix4f(t3), u_merc_center: new e.Uniform2f(t3), u_up_dir: new e.Uniform3f(t3), u_height_lift: new e.Uniform1f(t3), u_image: new e.Uniform1i(t3), u_texsize: new e.Uniform2f(t3), u_pixel_coord_upper: new e.Uniform2f(t3), u_pixel_coord_lower: new e.Uniform2f(t3), u_scale: new e.Uniform3f(t3), u_fade: new e.Uniform1f(t3), u_opacity: new e.Uniform1f(t3) }), fill: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3) }), fillPattern: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_image: new e.Uniform1i(t3), u_texsize: new e.Uniform2f(t3), u_pixel_coord_upper: new e.Uniform2f(t3), u_pixel_coord_lower: new e.Uniform2f(t3), u_scale: new e.Uniform3f(t3), u_fade: new e.Uniform1f(t3) }), fillOutline: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_world: new e.Uniform2f(t3) }), fillOutlinePattern: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_world: new e.Uniform2f(t3), u_image: new e.Uniform1i(t3), u_texsize: new e.Uniform2f(t3), u_pixel_coord_upper: new e.Uniform2f(t3), u_pixel_coord_lower: new e.Uniform2f(t3), u_scale: new e.Uniform3f(t3), u_fade: new e.Uniform1f(t3) }), circle: (t3) => ({ u_camera_to_center_distance: new e.Uniform1f(t3), u_extrude_scale: new e.UniformMatrix2f(t3), u_device_pixel_ratio: new e.Uniform1f(t3), u_matrix: new e.UniformMatrix4f(t3), u_inv_rot_matrix: new e.UniformMatrix4f(t3), u_merc_center: new e.Uniform2f(t3), u_tile_id: new e.Uniform3f(t3), u_zoom_transition: new e.Uniform1f(t3), u_up_dir: new e.Uniform3f(t3) }), collisionBox: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_camera_to_center_distance: new e.Uniform1f(t3), u_extrude_scale: new e.Uniform2f(t3) }), collisionCircle: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_inv_matrix: new e.UniformMatrix4f(t3), u_camera_to_center_distance: new e.Uniform1f(t3), u_viewport_size: new e.Uniform2f(t3) }), debug: (t3) => ({ u_color: new e.UniformColor(t3), u_matrix: new e.UniformMatrix4f(t3), u_overlay: new e.Uniform1i(t3), u_overlay_scale: new e.Uniform1f(t3) }), clippingMask: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3) }), heatmap: (t3) => ({ u_extrude_scale: new e.Uniform1f(t3), u_intensity: new e.Uniform1f(t3), u_matrix: new e.UniformMatrix4f(t3), u_inv_rot_matrix: new e.UniformMatrix4f(t3), u_merc_center: new e.Uniform2f(t3), u_tile_id: new e.Uniform3f(t3), u_zoom_transition: new e.Uniform1f(t3), u_up_dir: new e.Uniform3f(t3) }), heatmapTexture: (t3) => ({ u_image: new e.Uniform1i(t3), u_color_ramp: new e.Uniform1i(t3), u_opacity: new e.Uniform1f(t3) }), hillshade: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_image: new e.Uniform1i(t3), u_latrange: new e.Uniform2f(t3), u_light: new e.Uniform2f(t3), u_shadow: new e.UniformColor(t3), u_highlight: new e.UniformColor(t3), u_accent: new e.UniformColor(t3) }), hillshadePrepare: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_image: new e.Uniform1i(t3), u_dimension: new e.Uniform2f(t3), u_zoom: new e.Uniform1f(t3), u_unpack: new e.Uniform4f(t3) }), line: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_pixels_to_tile_units: new e.UniformMatrix2f(t3), u_device_pixel_ratio: new e.Uniform1f(t3), u_units_to_pixels: new e.Uniform2f(t3), u_dash_image: new e.Uniform1i(t3), u_gradient_image: new e.Uniform1i(t3), u_image_height: new e.Uniform1f(t3), u_texsize: new e.Uniform2f(t3), u_scale: new e.Uniform3f(t3), u_mix: new e.Uniform1f(t3), u_alpha_discard_threshold: new e.Uniform1f(t3), u_trim_offset: new e.Uniform2f(t3) }), linePattern: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_texsize: new e.Uniform2f(t3), u_pixels_to_tile_units: new e.UniformMatrix2f(t3), u_device_pixel_ratio: new e.Uniform1f(t3), u_image: new e.Uniform1i(t3), u_units_to_pixels: new e.Uniform2f(t3), u_scale: new e.Uniform3f(t3), u_fade: new e.Uniform1f(t3), u_alpha_discard_threshold: new e.Uniform1f(t3) }), raster: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_tl_parent: new e.Uniform2f(t3), u_scale_parent: new e.Uniform1f(t3), u_fade_t: new e.Uniform1f(t3), u_opacity: new e.Uniform1f(t3), u_image0: new e.Uniform1i(t3), u_image1: new e.Uniform1i(t3), u_brightness_low: new e.Uniform1f(t3), u_brightness_high: new e.Uniform1f(t3), u_saturation_factor: new e.Uniform1f(t3), u_contrast_factor: new e.Uniform1f(t3), u_spin_weights: new e.Uniform3f(t3), u_perspective_transform: new e.Uniform2f(t3) }), symbolIcon: (t3) => ({ u_is_size_zoom_constant: new e.Uniform1i(t3), u_is_size_feature_constant: new e.Uniform1i(t3), u_size_t: new e.Uniform1f(t3), u_size: new e.Uniform1f(t3), u_camera_to_center_distance: new e.Uniform1f(t3), u_rotate_symbol: new e.Uniform1i(t3), u_aspect_ratio: new e.Uniform1f(t3), u_fade_change: new e.Uniform1f(t3), u_matrix: new e.UniformMatrix4f(t3), u_label_plane_matrix: new e.UniformMatrix4f(t3), u_coord_matrix: new e.UniformMatrix4f(t3), u_is_text: new e.Uniform1i(t3), u_pitch_with_map: new e.Uniform1i(t3), u_texsize: new e.Uniform2f(t3), u_tile_id: new e.Uniform3f(t3), u_zoom_transition: new e.Uniform1f(t3), u_inv_rot_matrix: new e.UniformMatrix4f(t3), u_merc_center: new e.Uniform2f(t3), u_camera_forward: new e.Uniform3f(t3), u_tile_matrix: new e.UniformMatrix4f(t3), u_up_vector: new e.Uniform3f(t3), u_ecef_origin: new e.Uniform3f(t3), u_texture: new e.Uniform1i(t3) }), symbolSDF: (t3) => ({ u_is_size_zoom_constant: new e.Uniform1i(t3), u_is_size_feature_constant: new e.Uniform1i(t3), u_size_t: new e.Uniform1f(t3), u_size: new e.Uniform1f(t3), u_camera_to_center_distance: new e.Uniform1f(t3), u_rotate_symbol: new e.Uniform1i(t3), u_aspect_ratio: new e.Uniform1f(t3), u_fade_change: new e.Uniform1f(t3), u_matrix: new e.UniformMatrix4f(t3), u_label_plane_matrix: new e.UniformMatrix4f(t3), u_coord_matrix: new e.UniformMatrix4f(t3), u_is_text: new e.Uniform1i(t3), u_pitch_with_map: new e.Uniform1i(t3), u_texsize: new e.Uniform2f(t3), u_texture: new e.Uniform1i(t3), u_gamma_scale: new e.Uniform1f(t3), u_device_pixel_ratio: new e.Uniform1f(t3), u_tile_id: new e.Uniform3f(t3), u_zoom_transition: new e.Uniform1f(t3), u_inv_rot_matrix: new e.UniformMatrix4f(t3), u_merc_center: new e.Uniform2f(t3), u_camera_forward: new e.Uniform3f(t3), u_tile_matrix: new e.UniformMatrix4f(t3), u_up_vector: new e.Uniform3f(t3), u_ecef_origin: new e.Uniform3f(t3), u_is_halo: new e.Uniform1i(t3) }), symbolTextAndIcon: (t3) => ({ u_is_size_zoom_constant: new e.Uniform1i(t3), u_is_size_feature_constant: new e.Uniform1i(t3), u_size_t: new e.Uniform1f(t3), u_size: new e.Uniform1f(t3), u_camera_to_center_distance: new e.Uniform1f(t3), u_rotate_symbol: new e.Uniform1i(t3), u_aspect_ratio: new e.Uniform1f(t3), u_fade_change: new e.Uniform1f(t3), u_matrix: new e.UniformMatrix4f(t3), u_label_plane_matrix: new e.UniformMatrix4f(t3), u_coord_matrix: new e.UniformMatrix4f(t3), u_is_text: new e.Uniform1i(t3), u_pitch_with_map: new e.Uniform1i(t3), u_texsize: new e.Uniform2f(t3), u_texsize_icon: new e.Uniform2f(t3), u_texture: new e.Uniform1i(t3), u_texture_icon: new e.Uniform1i(t3), u_gamma_scale: new e.Uniform1f(t3), u_device_pixel_ratio: new e.Uniform1f(t3), u_is_halo: new e.Uniform1i(t3) }), background: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_opacity: new e.Uniform1f(t3), u_color: new e.UniformColor(t3) }), backgroundPattern: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_opacity: new e.Uniform1f(t3), u_image: new e.Uniform1i(t3), u_pattern_tl_a: new e.Uniform2f(t3), u_pattern_br_a: new e.Uniform2f(t3), u_pattern_tl_b: new e.Uniform2f(t3), u_pattern_br_b: new e.Uniform2f(t3), u_texsize: new e.Uniform2f(t3), u_mix: new e.Uniform1f(t3), u_pattern_size_a: new e.Uniform2f(t3), u_pattern_size_b: new e.Uniform2f(t3), u_scale_a: new e.Uniform1f(t3), u_scale_b: new e.Uniform1f(t3), u_pixel_coord_upper: new e.Uniform2f(t3), u_pixel_coord_lower: new e.Uniform2f(t3), u_tile_units_to_pixels: new e.Uniform1f(t3) }), terrainRaster: yi2, terrainDepth: yi2, skybox: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_sun_direction: new e.Uniform3f(t3), u_cubemap: new e.Uniform1i(t3), u_opacity: new e.Uniform1f(t3), u_temporal_offset: new e.Uniform1f(t3) }), skyboxGradient: (t3) => ({ u_matrix: new e.UniformMatrix4f(t3), u_color_ramp: new e.Uniform1i(t3), u_center_direction: new e.Uniform3f(t3), u_radius: new e.Uniform1f(t3), u_opacity: new e.Uniform1f(t3), u_temporal_offset: new e.Uniform1f(t3) }), skyboxCapture: (t3) => ({ u_matrix_3f: new e.UniformMatrix3f(t3), u_sun_direction: new e.Uniform3f(t3), u_sun_intensity: new e.Uniform1f(t3), u_color_tint_r: new e.Uniform4f(t3), u_color_tint_m: new e.Uniform4f(t3), u_luminance: new e.Uniform1f(t3) }), globeRaster: (t3) => ({ u_proj_matrix: new e.UniformMatrix4f(t3), u_globe_matrix: new e.UniformMatrix4f(t3), u_normalize_matrix: new e.UniformMatrix4f(t3), u_merc_matrix: new e.UniformMatrix4f(t3), u_zoom_transition: new e.Uniform1f(t3), u_merc_center: new e.Uniform2f(t3), u_image0: new e.Uniform1i(t3), u_grid_matrix: new e.UniformMatrix3f(t3), u_frustum_tl: new e.Uniform3f(t3), u_frustum_tr: new e.Uniform3f(t3), u_frustum_br: new e.Uniform3f(t3), u_frustum_bl: new e.Uniform3f(t3), u_globe_pos: new e.Uniform3f(t3), u_globe_radius: new e.Uniform1f(t3), u_viewport: new e.Uniform2f(t3) }), globeAtmosphere: (t3) => ({ u_frustum_tl: new e.Uniform3f(t3), u_frustum_tr: new e.Uniform3f(t3), u_frustum_br: new e.Uniform3f(t3), u_frustum_bl: new e.Uniform3f(t3), u_horizon: new e.Uniform1f(t3), u_transition: new e.Uniform1f(t3), u_fadeout_range: new e.Uniform1f(t3), u_color: new e.Uniform4f(t3), u_high_color: new e.Uniform4f(t3), u_space_color: new e.Uniform4f(t3), u_star_intensity: new e.Uniform1f(t3), u_star_density: new e.Uniform1f(t3), u_star_size: new e.Uniform1f(t3), u_temporal_offset: new e.Uniform1f(t3), u_horizon_angle: new e.Uniform1f(t3), u_rotation_matrix: new e.UniformMatrix4f(t3) }) };
      let co;
      function ho(t3, i2, o2, r3, n3, a2, s2) {
        const l3 = t3.context, c2 = l3.gl, h3 = t3.transform, u3 = t3.useProgram("collisionBox"), _2 = [];
        let d2 = 0, p3 = 0;
        for (let m4 = 0; m4 < r3.length; m4++) {
          const f3 = r3[m4], g3 = i2.getTile(f3), v4 = g3.getBucket(o2);
          if (!v4)
            continue;
          const x4 = bt(f3, v4, h3);
          let y4 = x4;
          n3[0] === 0 && n3[1] === 0 || (y4 = t3.translatePosMatrix(x4, g3, n3, a2));
          const b2 = s2 ? v4.textCollisionBox : v4.iconCollisionBox, w2 = v4.collisionCircleArray;
          if (w2.length > 0) {
            const t4 = e.create(), i3 = y4;
            e.mul(t4, v4.placementInvProjMatrix, h3.glCoordMatrix), e.mul(t4, t4, v4.placementViewportMatrix), _2.push({ circleArray: w2, circleOffset: p3, transform: i3, invTransform: t4, projection: v4.getProjection() }), d2 += w2.length / 4, p3 = d2;
          }
          b2 && (t3.terrain && t3.terrain.setupElevationDraw(g3, u3), u3.draw(l3, c2.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.disabled, Wi2(y4, h3, g3, v4.getProjection()), o2.id, b2.layoutVertexBuffer, b2.indexBuffer, b2.segments, null, h3.zoom, null, [b2.collisionVertexBuffer, b2.collisionVertexBufferExt]));
        }
        if (!s2 || !_2.length)
          return;
        const m3 = t3.useProgram("collisionCircle"), f2 = new e.StructArrayLayout2f1f2i16();
        f2.resize(4 * d2), f2._trim();
        let g2 = 0;
        for (const e2 of _2)
          for (let t4 = 0; t4 < e2.circleArray.length / 4; t4++) {
            const i3 = 4 * t4, o3 = e2.circleArray[i3 + 0], r4 = e2.circleArray[i3 + 1], n4 = e2.circleArray[i3 + 2], a3 = e2.circleArray[i3 + 3];
            f2.emplace(g2++, o3, r4, n4, a3, 0), f2.emplace(g2++, o3, r4, n4, a3, 1), f2.emplace(g2++, o3, r4, n4, a3, 2), f2.emplace(g2++, o3, r4, n4, a3, 3);
          }
        (!co || co.length < 2 * d2) && (co = function(t4) {
          const i3 = 2 * t4, o3 = new e.StructArrayLayout3ui6();
          o3.resize(i3), o3._trim();
          for (let e2 = 0; e2 < i3; e2++) {
            const t5 = 6 * e2;
            o3.uint16[t5 + 0] = 4 * e2 + 0, o3.uint16[t5 + 1] = 4 * e2 + 1, o3.uint16[t5 + 2] = 4 * e2 + 2, o3.uint16[t5 + 3] = 4 * e2 + 2, o3.uint16[t5 + 4] = 4 * e2 + 3, o3.uint16[t5 + 5] = 4 * e2 + 0;
          }
          return o3;
        }(d2));
        const v3 = l3.createIndexBuffer(co, true), x3 = l3.createVertexBuffer(f2, e.collisionCircleLayout.members, true);
        for (const i3 of _2) {
          const r4 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y3 = h3).getCameraToCenterDistance(i3.projection), u_viewport_size: [y3.width, y3.height] };
          m3.draw(l3, c2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.disabled, r4, o2.id, x3, v3, e.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h3.zoom);
        }
        var y3;
        x3.destroy(), v3.destroy();
      }
      const uo = e.create();
      function _o(t3, i2, o2, r3, n3, a2) {
        const { horizontalAlign: s2, verticalAlign: l3 } = e.getAnchorAlignment(t3), c2 = -(s2 - 0.5) * i2, h3 = -(l3 - 0.5) * o2, u3 = e.evaluateVariableOffset(t3, r3);
        return new e.pointGeometry((c2 / n3 + u3[0]) * a2, (h3 / n3 + u3[1]) * a2);
      }
      function po(t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3) {
        const _2 = t3.text.placedSymbolArray, d2 = t3.text.dynamicLayoutVertexArray, p3 = t3.icon.dynamicLayoutVertexArray, m3 = {}, f2 = wt(l3, t3.getProjection(), a2), g2 = a2.elevation, v3 = t3.getProjection().upVectorScale(l3.canonical, a2.center.lat, a2.worldSize);
        d2.clear();
        for (let p4 = 0; p4 < _2.length; p4++) {
          const x3 = _2.get(p4), y3 = t3.allowVerticalPlacement && !x3.placedOrientation, b2 = x3.hidden || !x3.crossTileID || y3 ? null : r3[x3.crossTileID];
          if (b2) {
            const r4 = new e.pointGeometry(x3.tileAnchorX, x3.tileAnchorY), _3 = t3.getProjection().upVector(l3.canonical, r4.x, r4.y), p5 = g2 ? g2.getAtTileOffset(l3, r4.x, r4.y) : 0, y4 = nt([x3.projectedAnchorX + p5 * _3[0] * v3.metersToTile, x3.projectedAnchorY + p5 * _3[1] * v3.metersToTile, x3.projectedAnchorZ + p5 * _3[2] * v3.metersToTile], o2 ? f2 : s2), w2 = at(a2.getCameraToCenterDistance(t3.getProjection()), y4.signedDistanceFromCamera);
            let T3 = n3.evaluateSizeForFeature(t3.textSizeData, h3, x3) * w2 / e.ONE_EM;
            o2 && (T3 *= t3.tilePixelRatio / c2);
            const { width: E3, height: C3, anchor: I3, textOffset: M3, textScale: S3 } = b2, z3 = _o(I3, E3, C3, M3, S3, T3);
            let D3;
            if (o2) {
              const e2 = r4.add(z3), { x: i3, y: o3, z: n4 } = t3.getProjection().projectTilePoint(e2.x, e2.y, l3.canonical);
              D3 = nt([i3 + p5 * _3[0] * v3.metersToTile, o3 + p5 * _3[1] * v3.metersToTile, n4 + p5 * _3[2] * v3.metersToTile], s2).point;
            } else {
              const e2 = i2 ? z3.rotate(-a2.angle) : z3;
              D3 = [y4.point[0] + e2.x, y4.point[1] + e2.y, 0];
            }
            const P3 = t3.allowVerticalPlacement && x3.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
            for (let t4 = 0; t4 < x3.numGlyphs; t4++)
              e.addDynamicAttributes(d2, D3[0], D3[1], D3[2], P3);
            u3 && x3.associatedIconIndex >= 0 && (m3[x3.associatedIconIndex] = { shiftedAnchor: D3, angle: P3 });
          } else
            ft(x3.numGlyphs, d2);
        }
        if (u3) {
          p3.clear();
          const i3 = t3.icon.placedSymbolArray;
          for (let t4 = 0; t4 < i3.length; t4++) {
            const o3 = i3.get(t4);
            if (o3.hidden)
              ft(o3.numGlyphs, p3);
            else {
              const i4 = m3[t4];
              if (i4)
                for (let t5 = 0; t5 < o3.numGlyphs; t5++)
                  e.addDynamicAttributes(p3, i4.shiftedAnchor[0], i4.shiftedAnchor[1], i4.shiftedAnchor[2], i4.angle);
              else
                ft(o3.numGlyphs, p3);
            }
          }
          t3.icon.dynamicLayoutVertexBuffer.updateData(p3);
        }
        t3.text.dynamicLayoutVertexBuffer.updateData(d2);
      }
      function mo(e2, t3, i2) {
        return i2.iconsInText && t3 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
      }
      function fo(t3, i2, o2, r3, n3, a2, s2, l3, c2, h3, u3, _2) {
        const d2 = t3.context, p3 = d2.gl, m3 = t3.transform, f2 = l3 === "map", g2 = c2 === "map", v3 = f2 && o2.layout.get("symbol-placement") !== "point", x3 = f2 && !g2 && !v3, y3 = o2.layout.get("symbol-sort-key").constantOr(1) !== void 0;
        let b2 = false;
        const w2 = t3.depthModeForSublayer(0, e.DepthMode.ReadOnly), T3 = [e.mercatorXfromLng(m3.center.lng), e.mercatorYfromLat(m3.center.lat)], E3 = o2.layout.get("text-variable-anchor"), C3 = m3.projection.name === "globe", I3 = [], M3 = [0, -1, 0];
        let S3 = M3;
        !C3 && !m3.mercatorFromTransition || f2 || (S3 = function(t4) {
          const i3 = t4._camera.getWorldToCamera(t4.worldSize, 1), o3 = e.multiply([], i3, t4.globeMatrix);
          e.invert(o3, o3);
          const r4 = [0, 0, 0], n4 = [0, 1, 0, 0];
          return e.transformMat4$1(n4, n4, o3), r4[0] = n4[0], r4[1] = n4[1], r4[2] = n4[2], e.normalize(r4, r4), r4;
        }(m3));
        for (const l4 of r3) {
          const r4 = i2.getTile(l4), c3 = r4.getBucket(o2);
          if (!c3)
            continue;
          if (c3.projection.name === "mercator" && C3)
            continue;
          const u4 = n3 ? c3.text : c3.icon;
          if (!u4 || c3.fullyClipped || !u4.segments.get().length)
            continue;
          const _3 = u4.programConfigurations.get(o2.id), d3 = n3 || c3.sdfIcons, w3 = n3 ? c3.textSizeData : c3.iconSizeData, z3 = g2 || m3.pitch !== 0, D3 = e.evaluateSizeForZoom(w3, m3.zoom);
          let P3, A3, L3, R3, O3 = [0, 0], B3 = null;
          if (n3) {
            if (A3 = r4.glyphAtlasTexture, L3 = p3.LINEAR, P3 = r4.glyphAtlasTexture.size, c3.iconsInText) {
              O3 = r4.imageAtlasTexture.size, B3 = r4.imageAtlasTexture;
              const e2 = w3.kind === "composite" || w3.kind === "camera";
              R3 = z3 || t3.options.rotating || t3.options.zooming || e2 ? p3.LINEAR : p3.NEAREST;
            }
          } else {
            const e2 = o2.layout.get("icon-size").constantOr(0) !== 1 || c3.iconsNeedLinear;
            A3 = r4.imageAtlasTexture, L3 = d3 || t3.options.rotating || t3.options.zooming || e2 || z3 ? p3.LINEAR : p3.NEAREST, P3 = r4.imageAtlasTexture.size;
          }
          const k2 = c3.projection.name === "globe", F3 = k2 ? S3 : M3, U3 = k2 ? e.globeToMercatorTransition(m3.zoom) : 0, N3 = wt(l4, c3.getProjection(), m3), G3 = m3.calculatePixelsToTileUnitsMatrix(r4), j2 = tt(N3, r4.tileID.canonical, g2, f2, m3, c3.getProjection(), G3), Z3 = t3.terrain && g2 && v3 ? e.invert(e.create(), j2) : uo, V3 = ot(N3, r4.tileID.canonical, g2, f2, m3, c3.getProjection(), G3), W3 = E3 && c3.hasTextData(), X3 = o2.layout.get("icon-text-fit") !== "none" && W3 && c3.hasIconData();
          if (v3) {
            const e2 = m3.elevation, i3 = e2 ? e2.getAtTileOffsetFunc(l4, m3.center.lat, m3.worldSize, c3.getProjection()) : (e3) => [0, 0, 0], o3 = it(N3, r4.tileID.canonical, g2, f2, m3, c3.getProjection(), G3);
            lt(c3, N3, t3, n3, o3, V3, g2, h3, i3, l4);
          }
          const q3 = v3 || n3 && E3 || X3, $2 = t3.translatePosMatrix(N3, r4, a2, s2), H3 = q3 ? uo : j2, Y3 = t3.translatePosMatrix(V3, r4, a2, s2, true), K3 = c3.getProjection().createInversionMatrix(m3, l4.canonical), J3 = [];
          t3.terrain && g2 && J3.push("PITCH_WITH_MAP_TERRAIN"), k2 && J3.push("PROJECTION_GLOBE_VIEW"), q3 && J3.push("PROJECTED_POS_ON_VIEWPORT");
          const Q3 = d3 && o2.paint.get(n3 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let ee3;
          ee3 = d3 ? c3.iconsInText ? no(w3.kind, D3, x3, g2, t3, $2, H3, Y3, P3, O3, l4, U3, T3, K3, F3, c3.getProjection()) : ro(w3.kind, D3, x3, g2, t3, $2, H3, Y3, n3, P3, true, l4, U3, T3, K3, F3, c3.getProjection()) : oo(w3.kind, D3, x3, g2, t3, $2, H3, Y3, n3, P3, l4, U3, T3, K3, F3, c3.getProjection());
          const te3 = { program: t3.useProgram(mo(d3, n3, c3), _3, J3), buffers: u4, uniformValues: ee3, atlasTexture: A3, atlasTextureIcon: B3, atlasInterpolation: L3, atlasInterpolationIcon: R3, isSDF: d3, hasHalo: Q3, tile: r4, labelPlaneMatrixInv: Z3 };
          if (y3 && c3.canOverlap) {
            b2 = true;
            const t4 = u4.segments.get();
            for (const i3 of t4)
              I3.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: te3 });
          } else
            I3.push({ segments: u4.segments, sortKey: 0, state: te3 });
        }
        b2 && I3.sort((e2, t4) => e2.sortKey - t4.sortKey);
        for (const e2 of I3) {
          const i3 = e2.state;
          if (t3.terrain && t3.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: !C3, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), d2.activeTexture.set(p3.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p3.CLAMP_TO_EDGE), i3.atlasTextureIcon && (d2.activeTexture.set(p3.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p3.CLAMP_TO_EDGE)), i3.isSDF) {
            const r4 = i3.uniformValues;
            i3.hasHalo && (r4.u_is_halo = 1, go(i3.buffers, e2.segments, o2, t3, i3.program, w2, u3, _2, r4)), r4.u_is_halo = 0;
          }
          go(i3.buffers, e2.segments, o2, t3, i3.program, w2, u3, _2, i3.uniformValues);
        }
      }
      function go(t3, i2, o2, r3, n3, a2, s2, l3, c2) {
        const h3 = r3.context, u3 = [t3.dynamicLayoutVertexBuffer, t3.opacityVertexBuffer, t3.globeExtVertexBuffer];
        n3.draw(h3, h3.gl.TRIANGLES, a2, s2, l3, e.CullFaceMode.disabled, c2, o2.id, t3.layoutVertexBuffer, t3.indexBuffer, i2, o2.paint, r3.transform.zoom, t3.programConfigurations.get(o2.id), u3);
      }
      function vo(t3, i2, o2, r3, n3, a2, s2) {
        const l3 = t3.context.gl, c2 = o2.paint.get("fill-pattern"), h3 = c2 && c2.constantOr(1), u3 = o2.getCrossfadeParameters();
        let _2, d2, p3, m3, f2;
        s2 ? (d2 = h3 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", _2 = l3.LINES) : (d2 = h3 ? "fillPattern" : "fill", _2 = l3.TRIANGLES);
        for (const g2 of r3) {
          const r4 = i2.getTile(g2);
          if (h3 && !r4.patternsLoaded())
            continue;
          const v3 = r4.getBucket(o2);
          if (!v3)
            continue;
          t3.prepareDrawTile();
          const x3 = v3.programConfigurations.get(o2.id), y3 = t3.useProgram(d2, x3);
          h3 && (t3.context.activeTexture.set(l3.TEXTURE0), r4.imageAtlasTexture.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), x3.updatePaintBuffers(u3));
          const b2 = c2.constantOr(null);
          if (b2 && r4.imageAtlas) {
            const e2 = r4.imageAtlas, t4 = e2.patternPositions[b2.to.toString()], i3 = e2.patternPositions[b2.from.toString()];
            t4 && i3 && x3.setConstantPatternPositions(t4, i3);
          }
          const w2 = t3.translatePosMatrix(g2.projMatrix, r4, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
          if (s2) {
            m3 = v3.indexBuffer2, f2 = v3.segments2;
            const e2 = t3.terrain && t3.terrain.renderingToTexture ? t3.terrain.drapeBufferSize : [l3.drawingBufferWidth, l3.drawingBufferHeight];
            p3 = d2 === "fillOutlinePattern" && h3 ? Gi2(w2, t3, u3, r4, e2) : Ni2(w2, e2);
          } else
            m3 = v3.indexBuffer, f2 = v3.segments, p3 = h3 ? Ui2(w2, t3, u3, r4) : Fi2(w2);
          t3.prepareDrawProgram(t3.context, y3, g2.toUnwrapped()), y3.draw(t3.context, _2, n3, t3.stencilModeForClipping(g2), a2, e.CullFaceMode.disabled, p3, o2.id, v3.layoutVertexBuffer, m3, f2, o2.paint, t3.transform.zoom, x3);
        }
      }
      function xo(t3, i2, o2, r3, n3, a2, s2) {
        const l3 = t3.context, c2 = l3.gl, h3 = t3.transform, u3 = o2.paint.get("fill-extrusion-pattern"), _2 = u3.constantOr(1), d2 = o2.getCrossfadeParameters(), p3 = o2.paint.get("fill-extrusion-opacity"), m3 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), o2.paint.get("fill-extrusion-ambient-occlusion-radius")], f2 = o2.layout.get("fill-extrusion-edge-radius"), g2 = h3.projection.name === "globe" ? e.fillExtrusionHeightLift() : 0, v3 = h3.projection.name === "globe", x3 = v3 ? e.globeToMercatorTransition(h3.zoom) : 0, y3 = [e.mercatorXfromLng(h3.center.lng), e.mercatorYfromLat(h3.center.lat)], b2 = [];
        v3 && (b2.push("PROJECTION_GLOBE_VIEW"), t3.style.terrainSetForDrapingOnly() && b2.push("TERRAIN")), m3[0] > 0 && b2.push("FAUX_AO");
        for (const w2 of r3) {
          const r4 = i2.getTile(w2), T3 = r4.getBucket(o2);
          if (!T3 || T3.projection.name !== h3.projection.name)
            continue;
          const E3 = T3.programConfigurations.get(o2.id), C3 = t3.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", E3, b2);
          if (t3.terrain) {
            const e2 = t3.terrain;
            if (t3.style.terrainSetForDrapingOnly())
              e2.setupElevationDraw(r4, C3, { useMeterToDem: true });
            else {
              if (!T3.enableTerrain)
                continue;
              if (e2.setupElevationDraw(r4, C3, { useMeterToDem: true }), yo(l3, i2, w2, T3, o2, e2), !T3.centroidVertexBuffer) {
                const e3 = C3.attributes.a_centroid_pos;
                e3 !== void 0 && c2.vertexAttrib2f(e3, 0, 0);
              }
            }
          }
          _2 && (t3.context.activeTexture.set(c2.TEXTURE0), r4.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), E3.updatePaintBuffers(d2));
          const I3 = u3.constantOr(null);
          if (I3 && r4.imageAtlas) {
            const e2 = r4.imageAtlas, t4 = e2.patternPositions[I3.to.toString()], i3 = e2.patternPositions[I3.from.toString()];
            t4 && i3 && E3.setConstantPatternPositions(t4, i3);
          }
          const M3 = t3.translatePosMatrix(w2.projMatrix, r4, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), S3 = h3.projection.createInversionMatrix(h3, w2.canonical), z3 = o2.paint.get("fill-extrusion-vertical-gradient"), D3 = _2 ? ki2(M3, t3, z3, p3, m3, f2, w2, d2, r4, g2, x3, y3, S3) : Bi2(M3, t3, z3, p3, m3, f2, w2, g2, x3, y3, S3);
          t3.prepareDrawProgram(l3, C3, w2.toUnwrapped());
          const P3 = [];
          t3.terrain && P3.push(T3.centroidVertexBuffer), v3 && P3.push(T3.layoutVertexExtBuffer), C3.draw(l3, l3.gl.TRIANGLES, n3, a2, s2, e.CullFaceMode.backCCW, D3, o2.id, T3.layoutVertexBuffer, T3.indexBuffer, T3.segments, o2.paint, t3.transform.zoom, E3, P3);
        }
      }
      function yo(t3, i2, o2, r3, n3, a2) {
        const s2 = [(t4) => {
          let i3 = t4.canonical.x - 1, o3 = t4.wrap;
          return i3 < 0 && (i3 = (1 << t4.canonical.z) - 1, o3--), new e.OverscaledTileID(t4.overscaledZ, o3, t4.canonical.z, i3, t4.canonical.y);
        }, (t4) => {
          let i3 = t4.canonical.x + 1, o3 = t4.wrap;
          return i3 === 1 << t4.canonical.z && (i3 = 0, o3++), new e.OverscaledTileID(t4.overscaledZ, o3, t4.canonical.z, i3, t4.canonical.y);
        }, (t4) => new e.OverscaledTileID(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, (t4.canonical.y === 0 ? 1 << t4.canonical.z : t4.canonical.y) - 1), (t4) => new e.OverscaledTileID(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y === (1 << t4.canonical.z) - 1 ? 0 : t4.canonical.y + 1)], l3 = (e2) => {
          const t4 = i2.getSource().minzoom, o3 = (e3) => {
            const t5 = i2.getTileByID(e3);
            if (t5 && t5.hasData())
              return t5.getBucket(n3);
          }, r4 = [0, -1, 1];
          for (const i3 of r4) {
            if (e2.overscaledZ + i3 < t4)
              continue;
            const r5 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
            if (r5)
              return r5;
          }
        }, c2 = [0, 0, 0], h3 = (t4, i3) => (c2[0] = Math.min(t4.min.y, i3.min.y), c2[1] = Math.max(t4.max.y, i3.max.y), c2[2] = e.EXTENT - i3.min.x > t4.max.x ? i3.min.x - e.EXTENT : t4.max.x, c2), u3 = (t4, i3) => (c2[0] = Math.min(t4.min.x, i3.min.x), c2[1] = Math.max(t4.max.x, i3.max.x), c2[2] = e.EXTENT - i3.min.y > t4.max.y ? i3.min.y - e.EXTENT : t4.max.y, c2), _2 = [(e2, t4) => h3(e2, t4), (e2, t4) => h3(t4, e2), (e2, t4) => u3(e2, t4), (e2, t4) => u3(t4, e2)], d2 = new e.pointGeometry(0, 0);
        let p3, m3, f2;
        const g2 = (t4, i3, r4, n4, s3) => {
          const l4 = [[n4 ? r4 : t4, n4 ? t4 : r4, 0], [n4 ? r4 : i3, n4 ? i3 : r4, 0]], c3 = s3 < 0 ? e.EXTENT + s3 : s3, h4 = [n4 ? c3 : (t4 + i3) / 2, n4 ? (t4 + i3) / 2 : c3, 0];
          return r4 === 0 && s3 < 0 || r4 !== 0 && s3 > 0 ? a2.getForTilePoints(f2, [h4], true, m3) : l4.push(h4), a2.getForTilePoints(o2, l4, true, p3), Math.max(l4[0][2], l4[1][2], h4[2]) / a2.exaggeration();
        };
        for (let t4 = 0; t4 < 4; t4++) {
          const i3 = (t4 < 2 ? 1 : 5) - t4, n4 = r3.borders[t4];
          if (n4.length === 0)
            continue;
          const c3 = f2 = s2[t4](o2), h4 = l3(c3);
          if (!(h4 && h4 instanceof e.FillExtrusionBucket && h4.enableTerrain))
            continue;
          if (r3.borderDoneWithNeighborZ[t4] === h4.canonical.z && h4.borderDoneWithNeighborZ[i3] === r3.canonical.z)
            continue;
          if (m3 = a2.findDEMTileFor(c3), !m3 || !m3.dem)
            continue;
          if (!p3) {
            const e2 = a2.findDEMTileFor(o2);
            if (!e2 || !e2.dem)
              return;
            p3 = e2;
          }
          const u4 = h4.borders[i3];
          let v3 = 0;
          const x3 = h4.borderDoneWithNeighborZ[i3] !== r3.canonical.z;
          if (r3.canonical.z === h4.canonical.z) {
            for (let o3 = 0; o3 < n4.length; o3++) {
              const a3 = r3.featuresOnBorder[n4[o3]], s3 = a3.borders[t4];
              let l4;
              for (; v3 < u4.length && (l4 = h4.featuresOnBorder[u4[v3]], !(l4.borders[i3][1] > s3[0] + 3)); )
                x3 && h4.encodeCentroid(void 0, l4, false), v3++;
              if (l4 && v3 < u4.length) {
                const o4 = v3;
                let n5 = 0;
                for (; !(l4.borders[i3][0] > s3[1] - 3) && (n5++, ++v3 !== u4.length); )
                  l4 = h4.featuresOnBorder[u4[v3]];
                if (l4 = h4.featuresOnBorder[u4[o4]], a3.intersectsCount() > 1 || l4.intersectsCount() > 1 || n5 !== 1) {
                  n5 !== 1 && (v3 = o4), r3.encodeCentroid(void 0, a3, false), x3 && h4.encodeCentroid(void 0, l4, false);
                  continue;
                }
                const c4 = _2[t4](a3, l4), p4 = t4 % 2 ? e.EXTENT - 1 : 0;
                d2.x = g2(c4[0], Math.min(e.EXTENT - 1, c4[1]), p4, t4 < 2, c4[2]), d2.y = 0, r3.encodeCentroid(d2, a3, false), x3 && h4.encodeCentroid(d2, l4, false);
              } else
                r3.encodeCentroid(void 0, a3, false);
            }
            r3.borderDoneWithNeighborZ[t4] = h4.canonical.z, r3.needsCentroidUpdate = true, x3 && (h4.borderDoneWithNeighborZ[i3] = r3.canonical.z, h4.needsCentroidUpdate = true);
          } else {
            for (const e2 of n4)
              r3.encodeCentroid(void 0, r3.featuresOnBorder[e2], false);
            if (x3) {
              for (const e2 of u4)
                h4.encodeCentroid(void 0, h4.featuresOnBorder[e2], false);
              h4.borderDoneWithNeighborZ[i3] = r3.canonical.z, h4.needsCentroidUpdate = true;
            }
            r3.borderDoneWithNeighborZ[t4] = h4.canonical.z, r3.needsCentroidUpdate = true;
          }
        }
        (r3.needsCentroidUpdate || !r3.centroidVertexBuffer && r3.centroidVertexArray.length !== 0) && r3.uploadCentroid(t3);
      }
      const bo = new e.Color(1, 0, 0, 1), wo = new e.Color(0, 1, 0, 1), To = new e.Color(0, 0, 1, 1), Eo = new e.Color(1, 0, 1, 1), Co = new e.Color(0, 1, 1, 1);
      function Io(t3, i2, o2) {
        const r3 = t3.context, n3 = t3.transform, a2 = r3.gl, s2 = n3.projection.name === "globe", l3 = s2 ? ["PROJECTION_GLOBE_VIEW"] : null;
        let c2 = o2.projMatrix;
        if (s2 && e.globeToMercatorTransition(n3.zoom) > 0) {
          const t4 = e.transitionTileAABBinECEF(o2.canonical, n3), i3 = e.globeDenormalizeECEF(t4);
          c2 = e.multiply(new Float32Array(16), n3.globeMatrix, i3), e.multiply(c2, n3.projMatrix, c2);
        }
        const h3 = t3.useProgram("debug", null, l3), u3 = i2.getTileByID(o2.key);
        t3.terrain && t3.terrain.setupElevationDraw(u3, h3);
        const _2 = e.DepthMode.disabled, d2 = e.StencilMode.disabled, p3 = t3.colorModeForRenderPass(), m3 = "$debug";
        r3.activeTexture.set(a2.TEXTURE0), t3.emptyTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), s2 ? u3._makeGlobeTileDebugBuffers(t3.context, n3) : u3._makeDebugTileBoundsBuffers(t3.context, n3.projection);
        const f2 = u3._tileDebugBuffer || t3.debugBuffer, g2 = u3._tileDebugIndexBuffer || t3.debugIndexBuffer, v3 = u3._tileDebugSegments || t3.debugSegments;
        h3.draw(r3, a2.LINE_STRIP, _2, d2, p3, e.CullFaceMode.disabled, Xi2(c2, e.Color.red), m3, f2, g2, v3, null, null, null, [u3._globeTileDebugBorderBuffer]);
        const x3 = u3.latestRawTileData, y3 = Math.floor((x3 && x3.byteLength || 0) / 1024), b2 = i2.getTile(o2).tileSize, w2 = 512 / Math.min(b2, 512) * (o2.overscaledZ / n3.zoom) * 0.5;
        let T3 = o2.canonical.toString();
        o2.overscaledZ !== o2.canonical.z && (T3 += ` => ${o2.overscaledZ}`), T3 += ` ${y3}kb`, function(e2, t4) {
          e2.initDebugOverlayCanvas();
          const i3 = e2.debugOverlayCanvas, o3 = e2.context.gl, r4 = e2.debugOverlayCanvas.getContext("2d");
          r4.clearRect(0, 0, i3.width, i3.height), r4.shadowColor = "white", r4.shadowBlur = 2, r4.lineWidth = 1.5, r4.strokeStyle = "white", r4.textBaseline = "top", r4.font = "bold 36px Open Sans, sans-serif", r4.fillText(t4, 5, 5), r4.strokeText(t4, 5, 5), e2.debugOverlayTexture.update(i3), e2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
        }(t3, T3);
        const E3 = u3._tileDebugTextBuffer || t3.debugBuffer, C3 = u3._tileDebugTextIndexBuffer || t3.quadTriangleIndexBuffer, I3 = u3._tileDebugTextSegments || t3.debugSegments;
        h3.draw(r3, a2.TRIANGLES, _2, d2, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Xi2(c2, e.Color.transparent, w2), m3, E3, C3, I3, null, null, null, [u3._globeTileDebugTextBuffer]);
      }
      function Mo(e2, t3, i2, o2) {
        zo(e2, 0, t3 + i2 / 2, e2.transform.width, i2, o2);
      }
      function So(e2, t3, i2, o2) {
        zo(e2, t3 - i2 / 2, 0, i2, e2.transform.height, o2);
      }
      function zo(t3, i2, o2, r3, n3, a2) {
        const s2 = t3.context, l3 = s2.gl;
        l3.enable(l3.SCISSOR_TEST), l3.scissor(i2 * e.exported.devicePixelRatio, o2 * e.exported.devicePixelRatio, r3 * e.exported.devicePixelRatio, n3 * e.exported.devicePixelRatio), s2.clear({ color: a2 }), l3.disable(l3.SCISSOR_TEST);
      }
      const Do = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Po } = Do;
      function Ao(e2, t3, i2, o2) {
        e2.emplaceBack(t3, i2, o2);
      }
      class Lo {
        constructor(t3) {
          this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), Ao(this.vertexArray, -1, -1, 1), Ao(this.vertexArray, 1, -1, 1), Ao(this.vertexArray, -1, 1, 1), Ao(this.vertexArray, 1, 1, 1), Ao(this.vertexArray, -1, -1, -1), Ao(this.vertexArray, 1, -1, -1), Ao(this.vertexArray, -1, 1, -1), Ao(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t3.createVertexBuffer(this.vertexArray, Po), this.indexBuffer = t3.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
        }
      }
      function Ro(t3, i2, o2, r3, n3, a2) {
        const s2 = t3.gl, l3 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h3 = i2.paint.get("sky-atmosphere-sun-intensity"), u3 = ((e2, t4, i3, o3, r4) => ({ u_matrix_3f: e2, u_sun_direction: t4, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r4.r, r4.g, r4.b, r4.a], u_luminance: 5e-5 }))(e.fromMat4(e.create$1(), r3), n3, h3, l3, c2);
        s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.TEXTURE_CUBE_MAP_POSITIVE_X + a2, i2.skyboxTexture, 0), o2.draw(t3, s2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u3, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
      }
      const Oo = e.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class Bo {
        constructor(t3) {
          const i2 = new e.StructArrayLayout5f20();
          i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
          const o2 = new e.StructArrayLayout3ui6();
          o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t3.createVertexBuffer(i2, Oo.members), this.indexBuffer = t3.createIndexBuffer(o2), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const ko = { symbol: function(t3, i2, o2, r3, n3) {
        if (t3.renderPass !== "translucent")
          return;
        const a2 = e.StencilMode.disabled, s2 = t3.colorModeForRenderPass();
        o2.layout.get("text-variable-anchor") && function(t4, i3, o3, r4, n4, a3, s3) {
          const l3 = i3.transform, c2 = n4 === "map", h3 = a3 === "map";
          for (const i4 of t4) {
            const t5 = r4.getTile(i4), n5 = t5.getBucket(o3);
            if (!n5 || !n5.text || !n5.text.segments.get().length)
              continue;
            const a4 = e.evaluateSizeForZoom(n5.textSizeData, l3.zoom), u3 = wt(i4, n5.getProjection(), l3), _2 = l3.calculatePixelsToTileUnitsMatrix(t5), d2 = tt(u3, t5.tileID.canonical, h3, c2, l3, n5.getProjection(), _2), p3 = o3.layout.get("icon-text-fit") !== "none" && n5.hasIconData();
            if (a4) {
              const o4 = Math.pow(2, l3.zoom - t5.tileID.overscaledZ);
              po(n5, c2, h3, s3, e.symbolSize, l3, d2, i4, o4, a4, p3);
            }
          }
        }(r3, t3, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), n3), o2.paint.get("icon-opacity").constantOr(1) !== 0 && fo(t3, i2, o2, r3, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), a2, s2), o2.paint.get("text-opacity").constantOr(1) !== 0 && fo(t3, i2, o2, r3, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), a2, s2), i2.map.showCollisionBoxes && (ho(t3, i2, o2, r3, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), ho(t3, i2, o2, r3, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
      }, circle: function(t3, i2, o2, r3) {
        if (t3.renderPass !== "translucent")
          return;
        const n3 = o2.paint.get("circle-opacity"), a2 = o2.paint.get("circle-stroke-width"), s2 = o2.paint.get("circle-stroke-opacity"), l3 = o2.layout.get("circle-sort-key").constantOr(1) !== void 0;
        if (n3.constantOr(1) === 0 && (a2.constantOr(1) === 0 || s2.constantOr(1) === 0))
          return;
        const c2 = t3.context, h3 = c2.gl, u3 = t3.transform, _2 = t3.depthModeForSublayer(0, e.DepthMode.ReadOnly), d2 = e.StencilMode.disabled, p3 = t3.colorModeForRenderPass(), m3 = u3.projection.name === "globe", f2 = [e.mercatorXfromLng(u3.center.lng), e.mercatorYfromLat(u3.center.lat)], g2 = [];
        for (let n4 = 0; n4 < r3.length; n4++) {
          const a3 = r3[n4], s3 = i2.getTile(a3), c3 = s3.getBucket(o2);
          if (!c3 || c3.projection.name !== u3.projection.name)
            continue;
          const h4 = c3.programConfigurations.get(o2.id), _3 = Vi2(o2);
          m3 && _3.push("PROJECTION_GLOBE_VIEW");
          const d3 = t3.useProgram("circle", h4, _3), p4 = c3.layoutVertexBuffer, v4 = c3.globeExtVertexBuffer, x3 = c3.indexBuffer, y3 = u3.projection.createInversionMatrix(u3, a3.canonical), b2 = { programConfiguration: h4, program: d3, layoutVertexBuffer: p4, globeExtVertexBuffer: v4, indexBuffer: x3, uniformValues: Zi2(t3, a3, s3, y3, f2, o2), tile: s3 };
          if (l3) {
            const t4 = c3.segments.get();
            for (const i3 of t4)
              g2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: b2 });
          } else
            g2.push({ segments: c3.segments, sortKey: 0, state: b2 });
        }
        l3 && g2.sort((e2, t4) => e2.sortKey - t4.sortKey);
        const v3 = { useDepthForOcclusion: !m3 };
        for (const i3 of g2) {
          const { programConfiguration: r4, program: n4, layoutVertexBuffer: a3, globeExtVertexBuffer: s3, indexBuffer: l4, uniformValues: m4, tile: f3 } = i3.state, g3 = i3.segments;
          t3.terrain && t3.terrain.setupElevationDraw(f3, n4, v3), t3.prepareDrawProgram(c2, n4, f3.tileID.toUnwrapped()), n4.draw(c2, h3.TRIANGLES, _2, d2, p3, e.CullFaceMode.disabled, m4, o2.id, a3, l4, g3, o2.paint, u3.zoom, r4, [s3]);
        }
      }, heatmap: function(t3, i2, o2, r3) {
        if (o2.paint.get("heatmap-opacity") !== 0)
          if (t3.renderPass === "offscreen") {
            const n3 = t3.context, a2 = n3.gl, s2 = e.StencilMode.disabled, l3 = new e.ColorMode([a2.ONE, a2.ONE], e.Color.transparent, [true, true, true, true]);
            !function(e2, t4, i3, o3) {
              const r4 = e2.gl, n4 = t4.width * o3, a3 = t4.height * o3;
              e2.activeTexture.set(r4.TEXTURE1), e2.viewport.set([0, 0, n4, a3]);
              let s3 = i3.heatmapFbo;
              if (!s3 || s3 && (s3.width !== n4 || s3.height !== a3)) {
                s3 && s3.destroy();
                const t5 = r4.createTexture();
                r4.bindTexture(r4.TEXTURE_2D, t5), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_WRAP_S, r4.CLAMP_TO_EDGE), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_WRAP_T, r4.CLAMP_TO_EDGE), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MIN_FILTER, r4.LINEAR), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MAG_FILTER, r4.LINEAR), s3 = i3.heatmapFbo = e2.createFramebuffer(n4, a3, false), function(e3, t6, i4, o4, r5, n5) {
                  const a4 = e3.gl;
                  a4.texImage2D(a4.TEXTURE_2D, 0, a4.RGBA, r5, n5, 0, a4.RGBA, e3.extRenderToTextureHalfFloat ? e3.extTextureHalfFloat.HALF_FLOAT_OES : a4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                }(e2, 0, t5, s3, n4, a3);
              } else
                r4.bindTexture(r4.TEXTURE_2D, s3.colorAttachment.get()), e2.bindFramebuffer.set(s3.framebuffer);
            }(n3, t3, o2, t3.transform.projection.name === "globe" ? 0.5 : 0.25), n3.clear({ color: e.Color.transparent });
            const c2 = t3.transform, h3 = c2.projection.name === "globe", u3 = h3 ? ["PROJECTION_GLOBE_VIEW"] : null, _2 = h3 ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled, d2 = [e.mercatorXfromLng(c2.center.lng), e.mercatorYfromLat(c2.center.lat)];
            for (let p3 = 0; p3 < r3.length; p3++) {
              const m3 = r3[p3];
              if (i2.hasRenderableParent(m3))
                continue;
              const f2 = i2.getTile(m3), g2 = f2.getBucket(o2);
              if (!g2 || g2.projection.name !== c2.projection.name)
                continue;
              const v3 = g2.programConfigurations.get(o2.id), x3 = t3.useProgram("heatmap", v3, u3), { zoom: y3 } = t3.transform;
              t3.terrain && t3.terrain.setupElevationDraw(f2, x3), t3.prepareDrawProgram(n3, x3, m3.toUnwrapped());
              const b2 = c2.projection.createInversionMatrix(c2, m3.canonical);
              x3.draw(n3, a2.TRIANGLES, e.DepthMode.disabled, s2, l3, _2, $i2(t3, m3, f2, b2, d2, y3, o2.paint.get("heatmap-intensity")), o2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, o2.paint, t3.transform.zoom, v3, h3 ? [g2.globeExtVertexBuffer] : null);
            }
            n3.viewport.set([0, 0, t3.width, t3.height]);
          } else
            t3.renderPass === "translucent" && (t3.context.setColorMode(t3.colorModeForRenderPass()), function(t4, i3) {
              const o3 = t4.context, r4 = o3.gl, n3 = i3.heatmapFbo;
              if (!n3)
                return;
              o3.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, n3.colorAttachment.get()), o3.activeTexture.set(r4.TEXTURE1);
              let a2 = i3.colorRampTexture;
              a2 || (a2 = i3.colorRampTexture = new e.Texture(o3, i3.colorRamp, r4.RGBA)), a2.bind(r4.LINEAR, r4.CLAMP_TO_EDGE), t4.useProgram("heatmapTexture").draw(o3, r4.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t4.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e2, t5, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t5.paint.get("heatmap-opacity") }))(0, i3), i3.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i3.paint, t4.transform.zoom);
            }(t3, o2));
      }, line: function(t3, i2, o2, r3) {
        if (t3.renderPass !== "translucent")
          return;
        const n3 = o2.paint.get("line-opacity"), a2 = o2.paint.get("line-width");
        if (n3.constantOr(1) === 0 || a2.constantOr(1) === 0)
          return;
        const s2 = t3.depthModeForSublayer(0, e.DepthMode.ReadOnly), l3 = t3.colorModeForRenderPass(), c2 = t3.terrain && t3.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio, h3 = o2.paint.get("line-dasharray"), u3 = h3.constantOr(1), _2 = o2.layout.get("line-cap"), d2 = o2.paint.get("line-pattern"), p3 = d2.constantOr(1), m3 = o2.paint.get("line-gradient"), f2 = o2.getCrossfadeParameters(), g2 = p3 ? "linePattern" : "line", v3 = t3.context, x3 = v3.gl, y3 = ((e2) => {
          const t4 = [];
          Qi2(e2) && t4.push("RENDER_LINE_DASH"), e2.paint.get("line-gradient") && t4.push("RENDER_LINE_GRADIENT");
          const i3 = e2.paint.get("line-trim-offset");
          i3[0] === 0 && i3[1] === 0 || t4.push("RENDER_LINE_TRIM_OFFSET");
          const o3 = e2.paint.get("line-pattern").constantOr(1), r4 = e2.paint.get("line-opacity").constantOr(1) !== 1;
          return !o3 && r4 && t4.push("RENDER_LINE_ALPHA_DISCARD"), t4;
        })(o2);
        let b2 = y3.includes("RENDER_LINE_ALPHA_DISCARD");
        t3.terrain && t3.terrain.clipOrMaskOverlapStencilType() && (b2 = false);
        for (const n4 of r3) {
          const r4 = i2.getTile(n4);
          if (p3 && !r4.patternsLoaded())
            continue;
          const a3 = r4.getBucket(o2);
          if (!a3)
            continue;
          t3.prepareDrawTile();
          const w2 = a3.programConfigurations.get(o2.id), T3 = t3.useProgram(g2, w2, y3), E3 = d2.constantOr(null);
          if (E3 && r4.imageAtlas) {
            const e2 = r4.imageAtlas, t4 = e2.patternPositions[E3.to.toString()], i3 = e2.patternPositions[E3.from.toString()];
            t4 && i3 && w2.setConstantPatternPositions(t4, i3);
          }
          const C3 = h3.constantOr(null), I3 = _2.constantOr(null);
          if (!p3 && C3 && I3 && r4.lineAtlas) {
            const e2 = r4.lineAtlas, t4 = e2.getDash(C3.to, I3), i3 = e2.getDash(C3.from, I3);
            t4 && i3 && w2.setConstantPatternPositions(t4, i3);
          }
          let [M3, S3] = o2.paint.get("line-trim-offset");
          if (I3 === "round" || I3 === "square") {
            const e2 = 1;
            M3 !== S3 && (M3 === 0 && (M3 -= e2), S3 === 1 && (S3 += e2));
          }
          const z3 = t3.terrain ? n4.projMatrix : null, D3 = p3 ? Yi2(t3, r4, o2, f2, z3, c2) : Hi2(t3, r4, o2, f2, z3, a3.lineClipsArray.length, c2, [M3, S3]);
          if (m3) {
            const r5 = a3.gradients[o2.id];
            let s3 = r5.texture;
            if (o2.gradientVersion !== r5.version) {
              let l4 = 256;
              if (o2.stepInterpolant) {
                const o3 = i2.getSource().maxzoom, r6 = n4.canonical.z === o3 ? Math.ceil(1 << t3.transform.maxZoom - n4.canonical.z) : 1;
                l4 = e.clamp(e.nextPowerOfTwo(a3.maxLineLength / e.EXTENT * 1024 * r6), 256, v3.maxTextureSize);
              }
              r5.gradient = e.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l4, image: r5.gradient || void 0, clips: a3.lineClipsArray }), r5.texture ? r5.texture.update(r5.gradient) : r5.texture = new e.Texture(v3, r5.gradient, x3.RGBA), r5.version = o2.gradientVersion, s3 = r5.texture;
            }
            v3.activeTexture.set(x3.TEXTURE1), s3.bind(o2.stepInterpolant ? x3.NEAREST : x3.LINEAR, x3.CLAMP_TO_EDGE);
          }
          u3 && (v3.activeTexture.set(x3.TEXTURE0), r4.lineAtlasTexture.bind(x3.LINEAR, x3.REPEAT), w2.updatePaintBuffers(f2)), p3 && (v3.activeTexture.set(x3.TEXTURE0), r4.imageAtlasTexture.bind(x3.LINEAR, x3.CLAMP_TO_EDGE), w2.updatePaintBuffers(f2)), t3.prepareDrawProgram(v3, T3, n4.toUnwrapped());
          const P3 = (i3) => {
            T3.draw(v3, x3.TRIANGLES, s2, i3, l3, e.CullFaceMode.disabled, D3, o2.id, a3.layoutVertexBuffer, a3.indexBuffer, a3.segments, o2.paint, t3.transform.zoom, w2, [a3.layoutVertexBuffer2]);
          };
          if (b2) {
            const i3 = t3.stencilModeForClipping(n4).ref;
            i3 === 0 && t3.terrain && v3.clear({ stencil: 0 });
            const o3 = { func: x3.EQUAL, mask: 255 };
            D3.u_alpha_discard_threshold = 0.8, P3(new e.StencilMode(o3, i3, 255, x3.KEEP, x3.KEEP, x3.INVERT)), D3.u_alpha_discard_threshold = 0, P3(new e.StencilMode(o3, i3, 255, x3.KEEP, x3.KEEP, x3.KEEP));
          } else
            P3(t3.stencilModeForClipping(n4));
        }
        b2 && (t3.resetStencilClippingMasks(), t3.terrain && v3.clear({ stencil: 0 }));
      }, fill: function(t3, i2, o2, r3) {
        const n3 = o2.paint.get("fill-color"), a2 = o2.paint.get("fill-opacity");
        if (a2.constantOr(1) === 0)
          return;
        const s2 = t3.colorModeForRenderPass(), l3 = o2.paint.get("fill-pattern"), c2 = t3.opaquePassEnabledForLayer() && !l3.constantOr(1) && n3.constantOr(e.Color.transparent).a === 1 && a2.constantOr(0) === 1 ? "opaque" : "translucent";
        if (t3.renderPass === c2) {
          const n4 = t3.depthModeForSublayer(1, t3.renderPass === "opaque" ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
          vo(t3, i2, o2, r3, n4, s2, false);
        }
        if (t3.renderPass === "translucent" && o2.paint.get("fill-antialias")) {
          const n4 = t3.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
          vo(t3, i2, o2, r3, n4, s2, true);
        }
      }, "fill-extrusion": function(t3, i2, o2, r3) {
        const n3 = o2.paint.get("fill-extrusion-opacity");
        if (n3 !== 0 && t3.renderPass === "translucent") {
          const a2 = new e.DepthMode(t3.context.gl.LEQUAL, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
          if (n3 !== 1 || o2.paint.get("fill-extrusion-pattern").constantOr(1))
            xo(t3, i2, o2, r3, a2, e.StencilMode.disabled, e.ColorMode.disabled), xo(t3, i2, o2, r3, a2, t3.stencilModeFor3D(), t3.colorModeForRenderPass()), t3.resetStencilClippingMasks();
          else {
            const n4 = t3.colorModeForRenderPass();
            xo(t3, i2, o2, r3, a2, e.StencilMode.disabled, n4);
          }
        }
      }, hillshade: function(t3, i2, o2, r3) {
        if (t3.renderPass !== "offscreen" && t3.renderPass !== "translucent")
          return;
        const n3 = t3.context, a2 = t3.depthModeForSublayer(0, e.DepthMode.ReadOnly), s2 = t3.colorModeForRenderPass(), l3 = t3.terrain && t3.terrain.renderingToTexture, [c2, h3] = t3.renderPass !== "translucent" || l3 ? [{}, r3] : t3.stencilConfigForOverlap(r3);
        for (const r4 of h3) {
          const n4 = i2.getTile(r4);
          if (n4.needsHillshadePrepare && t3.renderPass === "offscreen")
            xi2(t3, n4, o2, a2, e.StencilMode.disabled, s2);
          else if (t3.renderPass === "translucent") {
            const e2 = l3 && t3.terrain ? t3.terrain.stencilModeForRTTOverlap(r4) : c2[r4.overscaledZ];
            gi2(t3, r4, n4, o2, a2, e2, s2);
          }
        }
        n3.viewport.set([0, 0, t3.width, t3.height]), t3.resetStencilClippingMasks();
      }, raster: function(t3, i2, o2, r3, n3, a2) {
        if (t3.renderPass !== "translucent")
          return;
        if (o2.paint.get("raster-opacity") === 0)
          return;
        if (!r3.length)
          return;
        const s2 = t3.context, l3 = s2.gl, c2 = i2.getSource(), h3 = t3.useProgram("raster"), u3 = t3.colorModeForRenderPass(), _2 = t3.terrain && t3.terrain.renderingToTexture, [d2, p3] = c2 instanceof De2 || _2 ? [{}, r3] : t3.stencilConfigForOverlap(r3), m3 = p3[p3.length - 1].overscaledZ, f2 = !t3.options.moving;
        for (const r4 of p3) {
          const n4 = _2 ? e.DepthMode.disabled : t3.depthModeForSublayer(r4.overscaledZ - m3, o2.paint.get("raster-opacity") === 1 ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l3.LESS), p4 = r4.toUnwrapped(), g2 = i2.getTile(r4);
          if (_2 && (!g2 || !g2.hasData()))
            continue;
          const v3 = _2 ? r4.projMatrix : t3.transform.calculateProjMatrix(p4, f2), x3 = t3.terrain && _2 ? t3.terrain.stencilModeForRTTOverlap(r4) : d2[r4.overscaledZ], y3 = a2 ? 0 : o2.paint.get("raster-fade-duration");
          g2.registerFadeDuration(y3);
          const b2 = i2.findLoadedParent(r4, 0), w2 = Si2(g2, b2, i2, t3.transform, y3);
          let T3, E3;
          t3.terrain && t3.terrain.prepareDrawTile();
          const C3 = o2.paint.get("raster-resampling") === "nearest" ? l3.NEAREST : l3.LINEAR;
          s2.activeTexture.set(l3.TEXTURE0), g2.texture.bind(C3, l3.CLAMP_TO_EDGE), s2.activeTexture.set(l3.TEXTURE1), b2 ? (b2.texture.bind(C3, l3.CLAMP_TO_EDGE), T3 = Math.pow(2, b2.tileID.overscaledZ - g2.tileID.overscaledZ), E3 = [g2.tileID.canonical.x * T3 % 1, g2.tileID.canonical.y * T3 % 1]) : g2.texture.bind(C3, l3.CLAMP_TO_EDGE);
          const I3 = eo(v3, E3 || [0, 0], T3 || 1, w2, o2, c2 instanceof De2 ? c2.perspectiveTransform : [0, 0]);
          if (t3.prepareDrawProgram(s2, h3, p4), c2 instanceof De2)
            c2.boundsBuffer && c2.boundsSegments && h3.draw(s2, l3.TRIANGLES, n4, e.StencilMode.disabled, u3, e.CullFaceMode.disabled, I3, o2.id, c2.boundsBuffer, t3.quadTriangleIndexBuffer, c2.boundsSegments);
          else {
            const { tileBoundsBuffer: i3, tileBoundsIndexBuffer: r5, tileBoundsSegments: a3 } = t3.getTileBoundsBuffers(g2);
            h3.draw(s2, l3.TRIANGLES, n4, x3, u3, e.CullFaceMode.disabled, I3, o2.id, i3, r5, a3);
          }
        }
        t3.resetStencilClippingMasks();
      }, background: function(t3, i2, o2, r3) {
        const n3 = o2.paint.get("background-color"), a2 = o2.paint.get("background-opacity");
        if (a2 === 0)
          return;
        const s2 = t3.context, l3 = s2.gl, c2 = t3.transform, h3 = c2.tileSize, u3 = o2.paint.get("background-pattern");
        if (t3.isPatternMissing(u3))
          return;
        const _2 = !u3 && n3.a === 1 && a2 === 1 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t3.renderPass !== _2)
          return;
        const d2 = e.StencilMode.disabled, p3 = t3.depthModeForSublayer(0, _2 === "opaque" ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly), m3 = t3.colorModeForRenderPass(), f2 = t3.useProgram(u3 ? "backgroundPattern" : "background");
        let g2, v3 = r3;
        v3 || (g2 = t3.getBackgroundTiles(), v3 = Object.values(g2).map((e2) => e2.tileID)), u3 && (s2.activeTexture.set(l3.TEXTURE0), t3.imageManager.bind(t3.context));
        const x3 = o2.getCrossfadeParameters();
        for (const _3 of v3) {
          const v4 = _3.toUnwrapped(), y3 = r3 ? _3.projMatrix : t3.transform.calculateProjMatrix(v4);
          t3.prepareDrawTile();
          const b2 = i2 ? i2.getTile(_3) : g2 ? g2[_3.key] : new e.Tile(_3, h3, c2.zoom, t3), w2 = u3 ? so(y3, a2, t3, u3, { tileID: _3, tileSize: h3 }, x3) : ao(y3, a2, n3);
          t3.prepareDrawProgram(s2, f2, v4);
          const { tileBoundsBuffer: T3, tileBoundsIndexBuffer: E3, tileBoundsSegments: C3 } = t3.getTileBoundsBuffers(b2);
          f2.draw(s2, l3.TRIANGLES, p3, d2, m3, e.CullFaceMode.disabled, w2, o2.id, T3, E3, C3);
        }
      }, sky: function(t3, i2, o2) {
        const r3 = t3.transform, n3 = r3.projection.name === "mercator" || r3.projection.name === "globe" ? 1 : e.smoothstep(7, 8, r3.zoom), a2 = o2.paint.get("sky-opacity") * n3;
        if (a2 === 0)
          return;
        const s2 = t3.context, l3 = o2.paint.get("sky-type"), c2 = new e.DepthMode(s2.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), h3 = t3.frameCounter / 1e3 % 1;
        l3 === "atmosphere" ? t3.renderPass === "offscreen" ? o2.needsSkyboxCapture(t3) && (function(t4, i3, o3, r4) {
          const n4 = t4.context, a3 = n4.gl;
          let s3 = i3.skyboxFbo;
          if (!s3) {
            s3 = i3.skyboxFbo = n4.createFramebuffer(32, 32, false), i3.skyboxGeometry = new Lo(n4), i3.skyboxTexture = n4.gl.createTexture(), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_S, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_T, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MIN_FILTER, a3.LINEAR), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MAG_FILTER, a3.LINEAR);
            for (let e2 = 0; e2 < 6; ++e2)
              a3.texImage2D(a3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, a3.RGBA, 32, 32, 0, a3.RGBA, a3.UNSIGNED_BYTE, null);
          }
          n4.bindFramebuffer.set(s3.framebuffer), n4.viewport.set([0, 0, 32, 32]);
          const l4 = i3.getCenter(t4, true), c3 = t4.useProgram("skyboxCapture"), h4 = new Float64Array(16);
          e.identity(h4), e.rotateY(h4, h4, 0.5 * -Math.PI), Ro(n4, i3, c3, h4, l4, 0), e.identity(h4), e.rotateY(h4, h4, 0.5 * Math.PI), Ro(n4, i3, c3, h4, l4, 1), e.identity(h4), e.rotateX(h4, h4, 0.5 * -Math.PI), Ro(n4, i3, c3, h4, l4, 2), e.identity(h4), e.rotateX(h4, h4, 0.5 * Math.PI), Ro(n4, i3, c3, h4, l4, 3), e.identity(h4), Ro(n4, i3, c3, h4, l4, 4), e.identity(h4), e.rotateY(h4, h4, Math.PI), Ro(n4, i3, c3, h4, l4, 5), n4.viewport.set([0, 0, t4.width, t4.height]);
        }(t3, o2), o2.markSkyboxValid(t3)) : t3.renderPass === "sky" && function(t4, i3, o3, r4, n4) {
          const a3 = t4.context, s3 = a3.gl, l4 = t4.transform, c3 = t4.useProgram("skybox");
          a3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
          const h4 = ((e2, t5, i4, o4, r5) => ({ u_matrix: e2, u_sun_direction: t5, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r5 }))(l4.skyboxMatrix, i3.getCenter(t4, false), 0, r4, n4);
          t4.prepareDrawProgram(a3, c3), c3.draw(a3, s3.TRIANGLES, o3, e.StencilMode.disabled, t4.colorModeForRenderPass(), e.CullFaceMode.backCW, h4, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t3, o2, c2, a2, h3) : l3 === "gradient" && t3.renderPass === "sky" && function(t4, i3, o3, r4, n4) {
          const a3 = t4.context, s3 = a3.gl, l4 = t4.transform, c3 = t4.useProgram("skyboxGradient");
          i3.skyboxGeometry || (i3.skyboxGeometry = new Lo(a3)), a3.activeTexture.set(s3.TEXTURE0);
          let h4 = i3.colorRampTexture;
          h4 || (h4 = i3.colorRampTexture = new e.Texture(a3, i3.colorRamp, s3.RGBA)), h4.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
          const u3 = ((t5, i4, o4, r5, n5) => ({ u_matrix: t5, u_color_ramp: 0, u_center_direction: i4, u_radius: e.degToRad(o4), u_opacity: r5, u_temporal_offset: n5 }))(l4.skyboxMatrix, i3.getCenter(t4, false), i3.paint.get("sky-gradient-radius"), r4, n4);
          t4.prepareDrawProgram(a3, c3), c3.draw(a3, s3.TRIANGLES, o3, e.StencilMode.disabled, t4.colorModeForRenderPass(), e.CullFaceMode.backCW, u3, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t3, o2, c2, a2, h3);
      }, debug: function(e2, t3, i2) {
        for (let o2 = 0; o2 < i2.length; o2++)
          Io(e2, t3, i2[o2]);
      }, custom: function(t3, i2, o2) {
        const r3 = t3.context, n3 = o2.implementation;
        if (t3.transform.projection.unsupportedLayers && t3.transform.projection.unsupportedLayers.includes("custom"))
          e.warnOnce("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.");
        else if (t3.renderPass === "offscreen") {
          const e2 = n3.prerender;
          e2 && (t3.setCustomLayerDefaults(), r3.setColorMode(t3.colorModeForRenderPass()), e2.call(n3, r3.gl, t3.transform.customLayerMatrix()), r3.setDirty(), t3.setBaseState());
        } else if (t3.renderPass === "translucent") {
          t3.setCustomLayerDefaults(), r3.setColorMode(t3.colorModeForRenderPass()), r3.setStencilMode(e.StencilMode.disabled);
          const i3 = n3.renderingMode === "3d" ? new e.DepthMode(t3.context.gl.LEQUAL, e.DepthMode.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, e.DepthMode.ReadOnly);
          r3.setDepthMode(i3), n3.render(r3.gl, t3.transform.customLayerMatrix()), r3.setDirty(), t3.setBaseState(), r3.bindFramebuffer.set(null);
        }
      } };
      class Fo {
        constructor(t3, i2) {
          this.context = new Ie2(t3), this.transform = i2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new $t(), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
        }
        updateTerrain(e2, t3) {
          const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
          if (!(i2 || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new Ai2(this, e2));
          const o2 = this._terrain;
          this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t3);
        }
        _updateFog(e2) {
          const t3 = e2.fog;
          if (!t3 || this.transform.projection.name === "globe" || t3.getOpacity(this.transform.pitch) < 1 || t3.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [i2, o2] = t3.getFovAdjustedRange(this.transform._fov);
          if (i2 > o2)
            return void (this.transform.fogCullDistSq = null);
          const r3 = i2 + 0.78 * (o2 - i2);
          this.transform.fogCullDistSq = r3 * r3;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        resize(t3, i2) {
          if (this.width = t3 * e.exported.devicePixelRatio, this.height = i2 * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e2 of this.style.order)
              this.style._layers[e2].resize();
        }
        setup() {
          const t3 = this.context, i2 = new e.StructArrayLayout2i4();
          i2.emplaceBack(0, 0), i2.emplaceBack(e.EXTENT, 0), i2.emplaceBack(0, e.EXTENT), i2.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t3.createVertexBuffer(i2, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const o2 = new e.StructArrayLayout2i4();
          o2.emplaceBack(0, 0), o2.emplaceBack(e.EXTENT, 0), o2.emplaceBack(0, e.EXTENT), o2.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t3.createVertexBuffer(o2, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
          const r3 = new e.StructArrayLayout2i4();
          r3.emplaceBack(-1, -1), r3.emplaceBack(1, -1), r3.emplaceBack(-1, 1), r3.emplaceBack(1, 1), this.viewportBuffer = t3.createVertexBuffer(r3, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const n3 = new e.StructArrayLayout4i8();
          n3.emplaceBack(0, 0, 0, 0), n3.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n3.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n3.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t3.createVertexBuffer(n3, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const a2 = new e.StructArrayLayout3ui6();
          a2.emplaceBack(0, 1, 2), a2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t3.createIndexBuffer(a2);
          const s2 = new e.StructArrayLayout1ui2();
          for (const e2 of [0, 1, 3, 2, 0])
            s2.emplaceBack(e2);
          this.debugIndexBuffer = t3.createIndexBuffer(s2), this.emptyTexture = new e.Texture(t3, new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t3.gl.RGBA), this.identityMat = e.create();
          const l3 = this.context.gl;
          this.stencilClearMode = new e.StencilMode({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Bo(this.context);
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(e2) {
          return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const t3 = this.context, i2 = t3.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t3, i2.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Mi2(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(t3, i2, o2) {
          if (!i2 || this.currentStencilSource === i2.id || !t3.isTileClipped() || !o2 || o2.length === 0)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let e2 = false;
            for (const t4 of o2)
              if (this._tileClippingMaskIDs[t4.key] === void 0) {
                e2 = true;
                break;
              }
            if (!e2)
              return;
          }
          this.currentStencilSource = i2.id;
          const r3 = this.context, n3 = r3.gl;
          this.nextStencilID + o2.length > 256 && this.clearStencil(), r3.setColorMode(e.ColorMode.disabled), r3.setDepthMode(e.DepthMode.disabled);
          const a2 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const t4 of o2) {
            const o3 = i2.getTile(t4), s2 = this._tileClippingMaskIDs[t4.key] = this.nextStencilID++, { tileBoundsBuffer: l3, tileBoundsIndexBuffer: c2, tileBoundsSegments: h3 } = this.getTileBoundsBuffers(o3);
            a2.draw(r3, n3.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n3.ALWAYS, mask: 0 }, s2, 255, n3.KEEP, n3.KEEP, n3.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Mi2(t4.projMatrix), "$clipping", l3, c2, h3);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t3 = this.nextStencilID++, i2 = this.context.gl;
          return new e.StencilMode({ func: i2.NOTEQUAL, mask: 255 }, t3, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilModeForClipping(t3) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(t3);
          const i2 = this.context.gl;
          return new e.StencilMode({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t3.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilConfigForOverlap(t3) {
          const i2 = this.context.gl, o2 = t3.sort((e2, t4) => t4.overscaledZ - e2.overscaledZ), r3 = o2[o2.length - 1].overscaledZ, n3 = o2[0].overscaledZ - r3 + 1;
          if (n3 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + n3 > 256 && this.clearStencil();
            const t4 = {};
            for (let o3 = 0; o3 < n3; o3++)
              t4[o3 + r3] = new e.StencilMode({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
            return this.nextStencilID += n3, [t4, o2];
          }
          return [{ [r3]: e.StencilMode.disabled }, o2];
        }
        colorModeForRenderPass() {
          const t3 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new e.ColorMode([t3.CONSTANT_COLOR, t3.ONE], new e.Color(i2, i2, i2, 0), [true, true, true, true]);
          }
          return this.renderPass === "opaque" ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
        }
        depthModeForSublayer(t3, i2, o2) {
          if (!this.opaquePassEnabledForLayer())
            return e.DepthMode.disabled;
          const r3 = 1 - ((1 + this.currentLayer) * this.numSublayers + t3) * this.depthEpsilon;
          return new e.DepthMode(o2 || this.context.gl.LEQUAL, i2, [r3, r3]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t3, i2) {
          this.style = t3, this.options = i2, this.lineAtlas = t3.lineAtlas, this.imageManager = t3.imageManager, this.glyphManager = t3.glyphManager, this.symbolFadeChange = t3.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
          const o2 = this.style.order, r3 = this.style._sourceCaches;
          for (const e2 in r3) {
            const t4 = r3[e2];
            t4.used && t4.prepare(this.context);
          }
          const n3 = {}, a2 = {}, s2 = {};
          for (const e2 in r3) {
            const t4 = r3[e2];
            n3[e2] = t4.getVisibleCoordinates(), a2[e2] = n3[e2].slice().reverse(), s2[e2] = t4.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e2 = 0; e2 < o2.length; e2++)
            if (this.style._layers[o2[e2]].is3D()) {
              this.opaquePassCutoff = e2;
              break;
            }
          if (this.terrain && (this.terrain.updateTileBinding(s2), this.opaquePassCutoff = 0), this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), e.isMapAuthenticated(this.context.gl)) {
            this.renderPass = "offscreen";
            for (const e2 of o2) {
              const i3 = this.style._layers[e2], o3 = t3._getLayerSourceCache(i3);
              if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom))
                continue;
              const r4 = o3 ? a2[o3.id] : void 0;
              (i3.type === "custom" || i3.isSky() || r4 && r4.length) && this.renderLayer(this, o3, i3, r4);
            }
            if (this.depthRangeFor3D = [0, 1 - (t3.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i2.showOverdrawInspector ? e.Color.black : e.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
              for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e2 = this.style._layers[o2[this.currentLayer]], i3 = t3._getLayerSourceCache(e2);
                if (e2.isSky())
                  continue;
                const r4 = i3 ? a2[i3.id] : void 0;
                this._renderTileClippingMasks(e2, i3, r4), this.renderLayer(this, i3, e2, r4);
              }
            if (this.style.fog && this.transform.projection.supportsFog && function(t4, i3) {
              const o3 = t4.context, r4 = o3.gl, n4 = t4.transform, a3 = new e.DepthMode(r4.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), s3 = t4.useProgram("globeAtmosphere", null, n4.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), l3 = e.globeToMercatorTransition(n4.zoom), c2 = i3.properties.get("color").toArray01(), h3 = i3.properties.get("high-color").toArray01(), u3 = i3.properties.get("space-color").toArray01PremultipliedAlpha(), _2 = e.identity$1([]);
              e.rotateY$1(_2, _2, -e.degToRad(n4._center.lng)), e.rotateX$1(_2, _2, e.degToRad(n4._center.lat)), e.rotateZ$1(_2, _2, n4.angle), e.rotateX$1(_2, _2, -n4._pitch);
              const d2 = e.fromQuat(new Float32Array(16), _2), p3 = e.mapValue(i3.properties.get("star-intensity"), 0, 1, 0, 0.25), m3 = 5e-4, f2 = e.mapValue(i3.properties.get("horizon-blend"), 0, 1, m3, 0.25), g2 = e.globeUseCustomAntiAliasing(t4, o3, n4) && f2 === m3 ? n4.worldSize / (2 * Math.PI * 1.025) - 1 : n4.globeRadius, v3 = t4.frameCounter / 1e3 % 1, x3 = e.length(n4.globeCenterInViewSpace), y3 = Math.sqrt(Math.pow(x3, 2) - Math.pow(g2, 2)), b2 = Math.acos(y3 / x3), w2 = ((t5, i4, o4, r5, n5, a4, s4, l4, c3, h4, u4, _3, d3, p4) => ({ u_frustum_tl: t5, u_frustum_tr: i4, u_frustum_br: o4, u_frustum_bl: r5, u_horizon: n5, u_transition: a4, u_fadeout_range: s4, u_color: l4, u_high_color: c3, u_space_color: h4, u_star_intensity: u4, u_star_size: 5 * e.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: _3, u_horizon_angle: d3, u_rotation_matrix: p4 }))(n4.frustumCorners.TL, n4.frustumCorners.TR, n4.frustumCorners.BR, n4.frustumCorners.BL, n4.frustumCorners.horizon, l3, f2, c2, h3, u3, p3, v3, b2, d2);
              t4.prepareDrawProgram(o3, s3);
              const T3 = t4.atmosphereBuffer;
              T3 && s3.draw(o3, r4.TRIANGLES, a3, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w2, "skybox", T3.vertexBuffer, T3.indexBuffer, T3.segments);
            }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || this.transform.projection.name !== "globe") && this.transform.isHorizonVisible())
              for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                const e2 = this.style._layers[o2[this.currentLayer]], i3 = t3._getLayerSourceCache(e2);
                e2.isSky() && this.renderLayer(this, i3, e2, i3 ? a2[i3.id] : void 0);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t3._getLayerSourceCache(e2);
              if (e2.isSky()) {
                ++this.currentLayer;
                continue;
              }
              if (this.terrain && this.style.isLayerDraped(e2)) {
                if (e2.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                continue;
              }
              const r4 = i3 ? (e2.type === "symbol" ? s2 : a2)[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, i3 ? n3[i3.id] : void 0), this.renderLayer(this, i3, e2, r4), ++this.currentLayer;
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry) {
              let i3 = null;
              e.values(this.style._layers).forEach((e2) => {
                const o3 = t3._getLayerSourceCache(e2);
                o3 && !e2.isHidden(this.transform.zoom) && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
              }), i3 && this.options.showTileBoundaries && ko.debug(this, i3, i3.getVisibleCoordinates());
            }
            this.options.showPadding && function(e2) {
              const t4 = e2.transform.padding;
              Mo(e2, e2.transform.height - (t4.top || 0), 3, bo), Mo(e2, t4.bottom || 0, 3, wo), So(e2, t4.left || 0, 3, To), So(e2, e2.transform.width - (t4.right || 0), 3, Eo);
              const i3 = e2.transform.centerPoint;
              !function(e3, t5, i4, o3) {
                zo(e3, t5 - 1, i4 - 10, 2, 20, o3), zo(e3, t5 - 10, i4 - 1, 20, 2, o3);
              }(e2, i3.x, e2.transform.height - i3.y, Co);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
          }
        }
        renderLayer(e2, t3, i2, o2) {
          i2.isHidden(this.transform.zoom) || (i2.type === "background" || i2.type === "sky" || i2.type === "custom" || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), e2.transform.projection.unsupportedLayers && e2.transform.projection.unsupportedLayers.includes(i2.type) || ko[i2.type](e2, t3, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e2) {
          if (!this.options.gpuTiming)
            return;
          const t3 = this.context.extTimerQuery;
          let i2 = this.gpuTimers[e2.id];
          i2 || (i2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: t3.createQueryEXT() }), i2.calls++, t3.beginQueryEXT(t3.TIME_ELAPSED_EXT, i2.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const e2 = this.context.extTimerQuery, t3 = e2.createQueryEXT();
            this.deferredRenderGpuTimeQueries.push(t3), e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, t3);
          }
        }
        gpuTimingDeferredRenderEnd() {
          if (!this.options.gpuTimingDeferredRender)
            return;
          const e2 = this.context.extTimerQuery;
          e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          if (!this.options.gpuTiming)
            return;
          const e2 = this.context.extTimerQuery;
          e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e2 = this.gpuTimers;
          return this.gpuTimers = {}, e2;
        }
        collectDeferredRenderGpuQueries() {
          const e2 = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], e2;
        }
        queryGpuTimers(e2) {
          const t3 = {};
          for (const i2 in e2) {
            const o2 = e2[i2], r3 = this.context.extTimerQuery, n3 = r3.getQueryObjectEXT(o2.query, r3.QUERY_RESULT_EXT) / 1e6;
            r3.deleteQueryEXT(o2.query), t3[i2] = n3;
          }
          return t3;
        }
        queryGpuTimeDeferredRender(e2) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const t3 = this.context.extTimerQuery;
          let i2 = 0;
          for (const o2 of e2)
            i2 += t3.getQueryObjectEXT(o2, t3.QUERY_RESULT_EXT) / 1e6, t3.deleteQueryEXT(o2);
          return i2;
        }
        translatePosMatrix(t3, i2, o2, r3, n3) {
          if (!o2[0] && !o2[1])
            return t3;
          const a2 = n3 ? r3 === "map" ? this.transform.angle : 0 : r3 === "viewport" ? -this.transform.angle : 0;
          if (a2) {
            const e2 = Math.sin(a2), t4 = Math.cos(a2);
            o2 = [o2[0] * t4 - o2[1] * e2, o2[0] * e2 + o2[1] * t4];
          }
          const s2 = [n3 ? o2[0] : L2(i2, o2[0], this.transform.zoom), n3 ? o2[1] : L2(i2, o2[1], this.transform.zoom), 0], l3 = new Float32Array(16);
          return e.translate(l3, t3, s2), l3;
        }
        saveTileTexture(e2) {
          const t3 = this._tileTextures[e2.size[0]];
          t3 ? t3.push(e2) : this._tileTextures[e2.size[0]] = [e2];
        }
        getTileTexture(e2) {
          const t3 = this._tileTextures[e2];
          return t3 && t3.length > 0 ? t3.pop() : null;
        }
        isPatternMissing(e2) {
          if (!e2)
            return false;
          if (!e2.from || !e2.to)
            return true;
          const t3 = this.imageManager.getPattern(e2.from.toString()), i2 = this.imageManager.getPattern(e2.to.toString());
          return !t3 || !i2;
        }
        currentGlobalDefines() {
          const e2 = this.terrain && this.terrain.renderingToTexture, t3 = this.style && this.style.fog, i2 = [];
          return this.terrain && !this.terrain.renderingToTexture && i2.push("TERRAIN"), t3 && !e2 && t3.getOpacity(this.transform.pitch) !== 0 && i2.push("FOG"), e2 && i2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && i2.push("OVERDRAW_INSPECTOR"), i2;
        }
        useProgram(e2, t3, i2) {
          this.cache = this.cache || {};
          const o2 = i2 || [], r3 = this.currentGlobalDefines().concat(o2), n3 = Li2.cacheKey(_i[e2], e2, r3, t3);
          return this.cache[n3] || (this.cache[n3] = new Li2(this.context, e2, _i[e2], t3, lo[e2], r3)), this.cache[n3];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        prepareDrawProgram(t3, i2, o2) {
          if (this.terrain && this.terrain.renderingToTexture)
            return;
          const r3 = this.style.fog;
          if (r3) {
            const n3 = r3.getOpacity(this.transform.pitch), a2 = ((t4, i3, o3, r4, n4, a3, s2, l3, c2, h3, u3) => {
              const _2 = t4.transform, d2 = i3.properties.get("color").toArray01();
              d2[3] = r4;
              const p3 = t4.frameCounter / 1e3 % 1;
              return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : t4.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: d2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_temporal_offset: p3, u_frustum_tl: n4, u_frustum_tr: a3, u_frustum_br: s2, u_frustum_bl: l3, u_globe_pos: c2, u_globe_radius: h3, u_viewport: u3, u_globe_transition: e.globeToMercatorTransition(_2.zoom), u_is_globe: +(_2.projection.name === "globe") };
            })(this, r3, o2, n3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);
            i2.setFogUniformValues(t3, a2);
          }
        }
        setTileLoadedFlag(e2) {
          this.tileLoaded = e2;
        }
        saveCanvasCopy() {
          this.frameCopies.push(this.canvasCopy()), this.tileLoaded = false;
        }
        canvasCopy() {
          const e2 = this.context.gl, t3 = e2.createTexture();
          return e2.bindTexture(e2.TEXTURE_2D, t3), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t3;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return false;
          const e2 = this.style && this.style.fog;
          return !!e2 && e2.getOpacity(this.transform.pitch) !== 0;
        }
        getBackgroundTiles() {
          const t3 = this._backgroundTiles, i2 = this._backgroundTiles = {}, o2 = this.transform.coveringTiles({ tileSize: 512 });
          for (const r3 of o2)
            i2[r3.key] = t3[r3.key] || new e.Tile(r3, 512, this.transform.tileZoom, this);
          return i2;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
      }
      class Uo {
        constructor(e2 = 0, t3 = 0, i2 = 0, o2 = 0) {
          if (isNaN(e2) || e2 < 0 || isNaN(t3) || t3 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e2, this.bottom = t3, this.left = i2, this.right = o2;
        }
        interpolate(t3, i2, o2) {
          return i2.top != null && t3.top != null && (this.top = e.number(t3.top, i2.top, o2)), i2.bottom != null && t3.bottom != null && (this.bottom = e.number(t3.bottom, i2.bottom, o2)), i2.left != null && t3.left != null && (this.left = e.number(t3.left, i2.left, o2)), i2.right != null && t3.right != null && (this.right = e.number(t3.right, i2.right, o2)), this;
        }
        getCenter(t3, i2) {
          const o2 = e.clamp((this.left + t3 - this.right) / 2, 0, t3), r3 = e.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
          return new e.pointGeometry(o2, r3);
        }
        equals(e2) {
          return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
        }
        clone() {
          return new Uo(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function No(t3, i2) {
        const o2 = e.getColumn(t3, 3);
        e.fromQuat(t3, i2), e.setColumn(t3, 3, o2);
      }
      function Go(t3, i2) {
        const o2 = e.identity$1([]);
        return e.rotateZ$1(o2, o2, -i2), e.rotateX$1(o2, o2, -t3), o2;
      }
      function jo(t3, i2) {
        const o2 = [t3[0], t3[1], 0], r3 = [i2[0], i2[1], 0];
        if (e.length(o2) >= 1e-15) {
          const t4 = e.normalize([], o2);
          e.scale$2(r3, t4, e.dot(r3, t4)), i2[0] = r3[0], i2[1] = r3[1];
        }
        const n3 = e.cross([], i2, t3);
        if (e.len(n3) < 1e-15)
          return null;
        const a2 = Math.atan2(-n3[1], n3[0]);
        return Go(Math.atan2(Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]), -t3[2]), a2);
      }
      class Zo {
        constructor(e2, t3) {
          this.position = e2, this.orientation = t3;
        }
        get position() {
          return this._position;
        }
        set position(t3) {
          if (t3) {
            const i2 = t3 instanceof e.MercatorCoordinate ? t3 : new e.MercatorCoordinate(t3[0], t3[1], t3[2]);
            this._renderWorldCopies && (i2.x = e.wrap(i2.x, 0, 1)), this._position = i2;
          } else
            this._position = null;
        }
        lookAtPoint(t3, i2) {
          if (this.orientation = null, !this.position)
            return;
          const o2 = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t3)) : 0, r3 = this.position, n3 = e.MercatorCoordinate.fromLngLat(t3, o2), a2 = [n3.x - r3.x, n3.y - r3.y, n3.z - r3.z];
          i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = jo(a2, i2);
        }
        setPitchBearing(t3, i2) {
          this.orientation = Go(e.degToRad(t3), e.degToRad(-i2));
        }
      }
      class Vo {
        constructor(t3, i2) {
          this._transform = e.identity([]), this.orientation = i2, this.position = t3;
        }
        get mercatorPosition() {
          const t3 = this.position;
          return new e.MercatorCoordinate(t3[0], t3[1], t3[2]);
        }
        get position() {
          const t3 = e.getColumn(this._transform, 3);
          return [t3[0], t3[1], t3[2]];
        }
        set position(t3) {
          var i2;
          t3 && e.setColumn(this._transform, 3, [(i2 = t3)[0], i2[1], i2[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t3) {
          this._orientation = t3 || e.identity$1([]), t3 && No(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e2 = this.forward(), t3 = this.right();
          return { bearing: Math.atan2(-t3[1], t3[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
        }
        setPitchBearing(e2, t3) {
          this._orientation = Go(e2, t3), No(this._transform, this._orientation);
        }
        forward() {
          const t3 = e.getColumn(this._transform, 2);
          return [-t3[0], -t3[1], -t3[2]];
        }
        up() {
          const t3 = e.getColumn(this._transform, 1);
          return [-t3[0], -t3[1], -t3[2]];
        }
        right() {
          const t3 = e.getColumn(this._transform, 0);
          return [t3[0], t3[1], t3[2]];
        }
        getCameraToWorld(t3, i2) {
          const o2 = new Float64Array(16);
          return e.invert(o2, this.getWorldToCamera(t3, i2)), o2;
        }
        getWorldToCameraPosition(t3, i2, o2) {
          const r3 = this.position;
          e.scale$2(r3, r3, -t3);
          const n3 = new Float64Array(16);
          return e.fromScaling(n3, [o2, o2, o2]), e.translate(n3, n3, r3), n3[10] *= i2, n3;
        }
        getWorldToCamera(t3, i2) {
          const o2 = new Float64Array(16), r3 = new Float64Array(4), n3 = this.position;
          return e.conjugate(r3, this._orientation), e.scale$2(n3, n3, -t3), e.fromQuat(o2, r3), e.translate(o2, o2, n3), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
        }
        getCameraToClipPerspective(t3, i2, o2, r3) {
          const n3 = new Float64Array(16);
          return e.perspective(n3, t3, i2, o2, r3), n3;
        }
        getDistanceToElevation(t3) {
          const i2 = t3 === 0 ? 0 : e.mercatorZfromAltitude(t3, this.position[1]), o2 = this.forward();
          return (i2 - this.position[2]) / o2[2];
        }
        clone() {
          return new Vo([...this.position], [...this.orientation]);
        }
      }
      function Wo(t3, i2) {
        const o2 = qo(t3.projection, t3.zoom, t3.width, t3.height), r3 = function(t4, i3, o3, r4, n4) {
          const a2 = new e.LngLat(o3.lng - 180 * $o, o3.lat), s2 = new e.LngLat(o3.lng + 180 * $o, o3.lat), l3 = t4.project(a2.lng, a2.lat), c2 = t4.project(s2.lng, s2.lat), h3 = -Math.atan2(c2.y - l3.y, c2.x - l3.x), u3 = e.MercatorCoordinate.fromLngLat(o3);
          u3.y = e.clamp(u3.y, -0.999975, 0.999975);
          const _2 = u3.toLngLat(), d2 = t4.project(_2.lng, _2.lat), p3 = e.MercatorCoordinate.fromLngLat(_2);
          p3.x += $o;
          const m3 = p3.toLngLat(), f2 = t4.project(m3.lng, m3.lat), g2 = Yo(f2.x - d2.x, f2.y - d2.y, h3), v3 = e.MercatorCoordinate.fromLngLat(_2);
          v3.y += $o;
          const x3 = v3.toLngLat(), y3 = t4.project(x3.lng, x3.lat), b2 = Yo(y3.x - d2.x, y3.y - d2.y, h3), w2 = Math.abs(g2.x) / Math.abs(b2.y), T3 = e.identity([]);
          e.rotateZ(T3, T3, -h3 * (1 - (n4 ? 0 : r4)));
          const E3 = e.identity([]);
          return e.scale(E3, E3, [1, 1 - (1 - w2) * r4, 1]), E3[4] = -b2.x / b2.y * r4, e.rotateZ(E3, E3, h3), e.multiply(E3, T3, E3), E3;
        }(t3.projection, 0, t3.center, o2, i2), n3 = Xo(t3);
        return e.scale(r3, r3, [n3, n3, 1]), r3;
      }
      function Xo(t3) {
        const i2 = t3.projection, o2 = qo(t3.projection, t3.zoom, t3.width, t3.height), r3 = Ho(i2, t3.center), n3 = Ho(i2, e.LngLat.convert(i2.center));
        return Math.pow(2, r3 * o2 + (1 - o2) * n3);
      }
      function qo(t3, i2, o2, r3, n3 = 1 / 0) {
        const a2 = t3.range;
        if (!a2)
          return 0;
        const s2 = Math.min(n3, Math.max(o2, r3)), l3 = Math.log(s2 / 1024) / Math.LN2;
        return e.smoothstep(a2[0] + l3, a2[1] + l3, i2);
      }
      const $o = 1 / 4e4;
      function Ho(t3, i2) {
        const o2 = e.clamp(i2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), r3 = new e.LngLat(i2.lng - 180 * $o, o2), n3 = new e.LngLat(i2.lng + 180 * $o, o2), a2 = t3.project(r3.lng, o2), s2 = t3.project(n3.lng, o2), l3 = e.MercatorCoordinate.fromLngLat(r3), c2 = e.MercatorCoordinate.fromLngLat(n3), h3 = s2.x - a2.x, u3 = s2.y - a2.y, _2 = c2.x - l3.x, d2 = c2.y - l3.y, p3 = Math.sqrt((_2 * _2 + d2 * d2) / (h3 * h3 + u3 * u3));
        return Math.log(p3) / Math.LN2;
      }
      function Yo(e2, t3, i2) {
        const o2 = Math.cos(i2), r3 = Math.sin(i2);
        return { x: e2 * o2 - t3 * r3, y: e2 * r3 + t3 * o2 };
      }
      class Ko {
        constructor(t3, i2, o2, r3, n3, a2, s2) {
          this.tileSize = 512, this._renderWorldCopies = n3 === void 0 || n3, this._minZoom = t3 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 == null ? 0 : o2, this._maxPitch = r3 == null ? 60 : r3, this.setProjection(a2), this.setMaxBounds(s2), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Uo(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Vo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
        }
        clone() {
          const e2 = new Ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e2) {
          this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        updateElevation(e2) {
          const t3 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (this._seaLevelZoom == null || t3) && this._updateCameraOnTerrain(), (e2 || t3) && this._constrainCameraAltitude(), this._calcMatrices();
        }
        getProjection() {
          return e.pick(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(i2) {
          this.projectionOptions = i2 || { name: "mercator" };
          const o2 = this.projection ? this.getProjection() : void 0;
          this.projection = e.getProjection(this.projectionOptions);
          const r3 = !t2(o2, this.getProjection());
          return r3 && this._calcMatrices(), this.mercatorFromTransition = false, r3;
        }
        setMercatorFromTransition() {
          const t3 = this.projection.name;
          this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.getProjection({ name: "mercator" });
          const i2 = t3 !== this.projection.name;
          return i2 && this._calcMatrices(), i2;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e2) {
          this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e2) {
          this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e2) {
          this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e2) {
          this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && this.projection.supportsWorldCopies === true;
        }
        set renderWorldCopies(e2) {
          e2 === void 0 ? e2 = true : e2 === null && (e2 = false), this._renderWorldCopies = e2;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSize() {
          const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSize);
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e.pointGeometry(this.width, this.height);
        }
        get bearing() {
          return e.wrap(this.rotation, -180, 180);
        }
        set bearing(e2) {
          this.rotation = e2;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(t3) {
          const i2 = -t3 * Math.PI / 180;
          var o2;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(e2, t4, i3) {
            var o3 = t4[0], r3 = t4[1], n3 = t4[2], a2 = t4[3], s2 = Math.sin(i3), l3 = Math.cos(i3);
            e2[0] = o3 * l3 + n3 * s2, e2[1] = r3 * l3 + a2 * s2, e2[2] = o3 * -s2 + n3 * l3, e2[3] = r3 * -s2 + a2 * l3;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t3) {
          const i2 = e.clamp(t3, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(e2) {
          e2 = Math.max(0.01, Math.min(60, e2)), this._fov !== e2 && (this._unmodified = false, this._fov = e2 / 180 * Math.PI, this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e2) {
          this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e2) {
          const t3 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
          this._zoom !== t3 && (this._unmodified = false, this._setZoom(t3), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e2) {
          this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
        }
        _updateCameraOnTerrain() {
          if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const e2 = this._elevation;
          this._centerAltitude = e2.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e2.exaggeration(), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const t3 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
          let r3 = 0, n3 = 0;
          for (let a2 = 0; a2 < i2.length; a2++) {
            const s2 = new e.pointGeometry(i2[a2][0] * this.width, o2 + i2[a2][1] * (this.height - o2)), l3 = t3.pointCoordinate(s2);
            if (!l3)
              continue;
            const c2 = 1 / Math.hypot(l3[0] - this._camera.position[0], l3[1] - this._camera.position[1]);
            r3 += l3[3] * c2, n3 += c2;
          }
          return n3 === 0 ? NaN : r3 / n3;
        }
        get center() {
          return this._center;
        }
        set center(e2) {
          e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (this._seaLevelZoom == null || !this._elevation)
            return;
          const e2 = this._seaLevelZoom, t3 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t3, o2 = this._mercatorZfromZoom(e2), r3 = this._mercatorZfromZoom(this._maxZoom), n3 = Math.max(o2 - i2, r3);
          this._setZoom(this._zoomFromMercatorZ(n3));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e2) {
          this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t3) {
          const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t3.toAltitude()));
          let o2;
          o2 = t3.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t3.x, t3.y, t3.z];
          const r3 = e.length(e.sub([], this._camera.position, o2));
          return e.clamp(this._zoomFromMercatorZ(r3), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t3) {
          if (!this.height)
            return;
          if (!t3.position && !t3.orientation)
            return;
          this._updateCameraState();
          let i2 = false;
          if (t3.orientation && !e.exactEquals(t3.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t3.orientation)), t3.position) {
            const o2 = [t3.position.x, t3.position.y, t3.position.z];
            e.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
          }
          i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t3 = this._camera.position, i2 = new Zo();
          return i2.position = new e.MercatorCoordinate(t3[0], t3[1], t3[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
        }
        _setCameraOrientation(t3) {
          if (!e.length$1(t3))
            return false;
          e.normalize$1(t3, t3);
          const i2 = e.transformQuat([], [0, 0, -1], t3), o2 = e.transformQuat([], [0, -1, 0], t3);
          if (o2[2] < 0)
            return false;
          const r3 = jo(i2, o2);
          return !!r3 && (this._camera.orientation = r3, true);
        }
        _setCameraPosition(t3) {
          const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r3 = this.cameraToCenterDistance;
          t3[2] = e.clamp(t3[2], r3 / o2, r3 / i2), this._camera.position = t3;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e2) {
          return this._edgeInsets.equals(e2);
        }
        interpolatePadding(e2, t3, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(e2, t3, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e2) {
          const t3 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
          return Math.max(0, t3);
        }
        getVisibleUnwrappedCoordinates(t3) {
          const i2 = [new e.UnwrappedTileID(0, t3)];
          if (this.renderWorldCopies) {
            const o2 = this.pointCoordinate(new e.pointGeometry(0, 0)), r3 = this.pointCoordinate(new e.pointGeometry(this.width, 0)), n3 = this.pointCoordinate(new e.pointGeometry(this.width, this.height)), a2 = this.pointCoordinate(new e.pointGeometry(0, this.height)), s2 = Math.floor(Math.min(o2.x, r3.x, n3.x, a2.x)), l3 = Math.floor(Math.max(o2.x, r3.x, n3.x, a2.x)), c2 = 1;
            for (let o3 = s2 - c2; o3 <= l3 + c2; o3++)
              o3 !== 0 && i2.push(new e.UnwrappedTileID(o3, t3));
          }
          return i2;
        }
        coveringTiles(t3) {
          let i2 = this.coveringZoomLevel(t3);
          const o2 = i2, r3 = this.elevation && !t3.isTerrainDEM, n3 = this.projection.name === "mercator";
          if (t3.minzoom !== void 0 && i2 < t3.minzoom)
            return [];
          t3.maxzoom !== void 0 && i2 > t3.maxzoom && (i2 = t3.maxzoom);
          const a2 = this.locationCoordinate(this.center), s2 = this.center.lat, l3 = 1 << i2, c2 = [l3 * a2.x, l3 * a2.y, 0], h3 = this.projection.name === "globe", u3 = !h3, _2 = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, u3), d2 = h3 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p3 = l3 * e.mercatorZfromAltitude(1, this.center.lat), m3 = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat), f2 = [l3 * d2.x, l3 * d2.y, m3 * (u3 ? 1 : p3)], g2 = this.cameraToCenterDistance / t3.tileSize * (t3.roundZoom ? 1 : 0.502), v3 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i2 : 0, x3 = t3.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y3 = t3.isTerrainDEM ? -x3 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b2 = this.projection.isReprojectedInTileSpace ? Xo(this) : 1, w2 = (t4) => {
            const i3 = 1 / 4e4, o3 = new e.MercatorCoordinate(t4.x + i3, t4.y, t4.z), r4 = new e.MercatorCoordinate(t4.x, t4.y + i3, t4.z), n4 = t4.toLngLat(), a3 = o3.toLngLat(), s3 = r4.toLngLat(), l4 = this.locationCoordinate(n4), c3 = this.locationCoordinate(a3), h4 = this.locationCoordinate(s3), u4 = Math.hypot(c3.x - l4.x, c3.y - l4.y), _3 = Math.hypot(h4.x - l4.x, h4.y - l4.y);
            return Math.sqrt(u4 * _3) * b2 / i3;
          }, T3 = (t4) => {
            const i3 = x3, o3 = y3;
            return { aabb: e.tileAABB(this, l3, 0, 0, 0, t4, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t4, fullyVisible: false };
          }, E3 = [];
          let C3 = [];
          const I3 = i2, M3 = t3.reparseOverscaled ? o2 : i2, S3 = (e2) => e2 * e2, z3 = S3((m3 - this._centerAltitude) * p3), D3 = (e2) => {
            if (!this._elevation || !e2.tileID || !n3)
              return;
            const t4 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
            t4 ? (i3.min[2] = t4.min, i3.max[2] = t4.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = P3(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
          }, P3 = (t4) => {
            if (t4.zoom < v3)
              return true;
            if (t4.zoom === I3)
              return false;
            if (t4.shouldSplit != null)
              return t4.shouldSplit;
            const i3 = t4.aabb.distanceX(f2), n4 = t4.aabb.distanceY(f2);
            let a3 = z3, l4 = 1;
            if (h3) {
              a3 = S3(t4.aabb.distanceZ(f2));
              const i4 = Math.pow(2, t4.zoom), o3 = e.latFromMercatorY((t4.y + 1) / i4), r4 = e.latFromMercatorY(t4.y / i4), n5 = Math.min(Math.max(s2, o3), r4), c4 = e.circumferenceAtLatitude(n5) / e.circumferenceAtLatitude(s2);
              if (l4 = n5 === s2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c4 / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t4.zoom === I3 - 1 && c4 >= 0.9)
                return true;
            } else if (r3 && (a3 = S3(t4.aabb.distanceZ(f2) * p3)), this.projection.isReprojectedInTileSpace && o2 <= 5) {
              const i4 = Math.pow(2, t4.zoom), o3 = w2(new e.MercatorCoordinate((t4.x + 0.5) / i4, (t4.y + 0.5) / i4));
              l4 = o3 > 0.85 ? 1 : o3;
            }
            const c3 = i3 * i3 + n4 * n4 + a3;
            return c3 < S3((1 << I3 - t4.zoom) * g2 * l4 * ((e2, t5) => {
              if (t5 * S3(0.707) < e2)
                return 1;
              const i4 = Math.sqrt(t5 / e2);
              return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            })(Math.max(a3, z3), c3));
          };
          if (this.renderWorldCopies)
            for (let e2 = 1; e2 <= 3; e2++)
              E3.push(T3(-e2)), E3.push(T3(e2));
          for (E3.push(T3(0)); E3.length > 0; ) {
            const o3 = E3.pop(), a3 = o3.x, s3 = o3.y;
            let u4 = o3.fullyVisible;
            if (!u4) {
              const e2 = o3.aabb.intersects(_2);
              if (e2 === 0)
                continue;
              u4 = e2 === 2;
            }
            if (o3.zoom !== I3 && P3(o3))
              for (let t4 = 0; t4 < 4; t4++) {
                const i3 = (a3 << 1) + t4 % 2, c3 = (s3 << 1) + (t4 >> 1), _3 = { aabb: n3 ? o3.aabb.quadrant(t4) : e.tileAABB(this, l3, o3.zoom + 1, i3, c3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: c3, wrap: o3.wrap, fullyVisible: u4, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                r3 && !h3 && (_3.tileID = new e.OverscaledTileID(o3.zoom + 1 === I3 ? M3 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, c3), D3(_3)), E3.push(_3);
              }
            else {
              const r4 = o3.zoom === I3 ? M3 : o3.zoom;
              if (t3.minzoom && t3.minzoom > r4)
                continue;
              const n4 = c2[0] - (0.5 + a3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), l4 = c2[1] - 0.5 - s3, h4 = o3.tileID ? o3.tileID : new e.OverscaledTileID(r4, o3.wrap, o3.zoom, a3, s3);
              C3.push({ tileID: h4, distanceSq: n4 * n4 + l4 * l4 });
            }
          }
          if (this.fogCullDistSq) {
            const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
            C3 = C3.filter((r4) => {
              const n4 = [0, 0, 0, 1], a3 = [e.EXTENT, e.EXTENT, 0, 1], s3 = this.calculateFogTileMatrix(r4.tileID.toUnwrapped());
              e.transformMat4$1(n4, n4, s3), e.transformMat4$1(a3, a3, s3);
              const l4 = e.getAABBPointSquareDist(n4, a3);
              if (l4 === 0)
                return true;
              let c3 = false;
              const h4 = this._elevation;
              if (h4 && l4 > i3 && o3 !== 0) {
                const i4 = this.calculateProjMatrix(r4.tileID.toUnwrapped());
                let n5;
                t3.isTerrainDEM || (n5 = h4.getMinMaxForTile(r4.tileID)), n5 || (n5 = { min: y3, max: x3 });
                const a4 = e.furthestTileCorner(this.rotation), s4 = [a4[0] * e.EXTENT, a4[1] * e.EXTENT, n5.max];
                e.transformMat4(s4, s4, i4), c3 = (1 - s4[1]) * this.height * 0.5 < o3;
              }
              return l4 < i3 || c3;
            });
          }
          return C3.sort((e2, t4) => e2.distanceSq - t4.distanceSq).map((e2) => e2.tileID);
        }
        resize(e2, t3) {
          this.width = e2, this.height = t3, this.pixelsToGLUnits = [2 / e2, -2 / t3], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e2) {
          return Math.pow(2, e2);
        }
        scaleZoom(e2) {
          return Math.log(e2) / Math.LN2;
        }
        project(t3) {
          const i2 = e.clamp(t3.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), o2 = this.projection.project(t3.lng, i2);
          return new e.pointGeometry(o2.x * this.worldSize, o2.y * this.worldSize);
        }
        unproject(e2) {
          return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        setLocationAtPoint(t3, i2) {
          let o2, r3;
          const n3 = this.centerPoint;
          if (this.projection.name === "globe") {
            const e2 = this.worldSize;
            o2 = (i2.x - n3.x) / e2, r3 = (i2.y - n3.y) / e2;
          } else {
            const e2 = this.pointCoordinate(i2), t4 = this.pointCoordinate(n3);
            o2 = e2.x - t4.x, r3 = e2.y - t4.y;
          }
          const a2 = this.locationCoordinate(t3);
          this.setLocation(new e.MercatorCoordinate(a2.x - o2, a2.y - r3));
        }
        setLocation(e2) {
          this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(e2) {
          return this.projection.locationPoint(this, e2);
        }
        locationPoint3D(e2) {
          return this.projection.locationPoint(this, e2, true);
        }
        pointLocation(e2) {
          return this.coordinateLocation(this.pointCoordinate(e2));
        }
        pointLocation3D(e2) {
          return this.coordinateLocation(this.pointCoordinate3D(e2));
        }
        locationCoordinate(t3, i2) {
          const o2 = i2 ? e.mercatorZfromAltitude(i2, t3.lat) : void 0, r3 = this.projection.project(t3.lng, t3.lat);
          return new e.MercatorCoordinate(r3.x, r3.y, o2);
        }
        coordinateLocation(e2) {
          return this.projection.unproject(e2.x, e2.y);
        }
        pointRayIntersection(t3, i2) {
          const o2 = i2 != null ? i2 : this._centerAltitude, r3 = [t3.x, t3.y, 0, 1], n3 = [t3.x, t3.y, 1, 1];
          e.transformMat4$1(r3, r3, this.pixelMatrixInverse), e.transformMat4$1(n3, n3, this.pixelMatrixInverse);
          const a2 = n3[3];
          e.scale$1(r3, r3, 1 / r3[3]), e.scale$1(n3, n3, 1 / a2);
          const s2 = r3[2], l3 = n3[2];
          return { p0: r3, p1: n3, t: s2 === l3 ? 0 : (o2 - s2) / (l3 - s2) };
        }
        screenPointToMercatorRay(t3) {
          const i2 = [t3.x, t3.y, 0, 1], o2 = [t3.x, t3.y, 1, 1];
          return e.transformMat4$1(i2, i2, this.pixelMatrixInverse), e.transformMat4$1(o2, o2, this.pixelMatrixInverse), e.scale$1(i2, i2, 1 / i2[3]), e.scale$1(o2, o2, 1 / o2[3]), i2[2] = e.mercatorZfromAltitude(i2[2], this._center.lat) * this.worldSize, o2[2] = e.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, e.scale$1(i2, i2, 1 / this.worldSize), e.scale$1(o2, o2, 1 / this.worldSize), new e.Ray([i2[0], i2[1], i2[2]], e.normalize([], e.sub([], o2, i2)));
        }
        rayIntersectionCoordinate(t3) {
          const { p0: i2, p1: o2, t: r3 } = t3, n3 = e.mercatorZfromAltitude(i2[2], this._center.lat), a2 = e.mercatorZfromAltitude(o2[2], this._center.lat);
          return new e.MercatorCoordinate(e.number(i2[0], o2[0], r3) / this.worldSize, e.number(i2[1], o2[1], r3) / this.worldSize, e.number(n3, a2, r3));
        }
        pointCoordinate(e2, t3 = this._centerAltitude) {
          return this.projection.pointCoordinate(this, e2.x, e2.y, t3);
        }
        pointCoordinate3D(t3) {
          if (!this.elevation)
            return this.pointCoordinate(t3);
          let i2 = this.projection.pointCoordinate3D(this, t3.x, t3.y);
          if (i2)
            return new e.MercatorCoordinate(i2[0], i2[1], i2[2]);
          let o2 = 0, r3 = this.horizonLineFromTop();
          if (t3.y > r3)
            return this.pointCoordinate(t3);
          const n3 = 0.02 * r3, a2 = t3.clone();
          for (let t4 = 0; t4 < 10 && r3 - o2 > n3; t4++) {
            a2.y = e.number(o2, r3, 0.66);
            const t5 = this.projection.pointCoordinate3D(this, a2.x, a2.y);
            t5 ? (r3 = a2.y, i2 = t5) : o2 = a2.y;
          }
          return i2 ? new e.MercatorCoordinate(i2[0], i2[1], i2[2]) : this.pointCoordinate(t3);
        }
        isPointAboveHorizon(e2) {
          return this.projection.isPointAboveHorizon(this, e2);
        }
        _coordinatePoint(t3, i2) {
          const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t3, this._centerAltitude) : this._centerAltitude, r3 = [t3.x * this.worldSize, t3.y * this.worldSize, o2 + t3.toAltitude(), 1];
          return e.transformMat4$1(r3, r3, this.pixelMatrix), r3[3] > 0 ? new e.pointGeometry(r3[0] / r3[3], r3[1] / r3[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBounds(t3, i2) {
          const o2 = new e.pointGeometry(this._edgeInsets.left, this._edgeInsets.top), r3 = new e.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top), n3 = new e.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom), a2 = new e.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom);
          let s2 = this.pointCoordinate(o2, t3), l3 = this.pointCoordinate(r3, t3);
          const c2 = this.pointCoordinate(n3, i2), h3 = this.pointCoordinate(a2, i2), u3 = (e2, t4) => (t4.y - e2.y) / (t4.x - e2.x);
          return s2.y > 1 && l3.y >= 0 ? s2 = new e.MercatorCoordinate((1 - h3.y) / u3(h3, s2) + h3.x, 1) : s2.y < 0 && l3.y <= 1 && (s2 = new e.MercatorCoordinate(-h3.y / u3(h3, s2) + h3.x, 0)), l3.y > 1 && s2.y >= 0 ? l3 = new e.MercatorCoordinate((1 - c2.y) / u3(c2, l3) + c2.x, 1) : l3.y < 0 && s2.y <= 1 && (l3 = new e.MercatorCoordinate(-c2.y / u3(c2, l3) + c2.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(s2)).extend(this.coordinateLocation(l3)).extend(this.coordinateLocation(h3)).extend(this.coordinateLocation(c2));
        }
        _getBounds3D() {
          const e2 = this.elevation;
          if (!e2.visibleDemTiles.length)
            return this._getBounds(0, 0);
          const t3 = e2.visibleDemTiles.reduce((e3, t4) => {
            if (t4.dem) {
              const i2 = t4.dem.tree;
              e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
            }
            return e3;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBounds(t3.min * e2.exaggeration(), t3.max * e2.exaggeration());
        }
        getBounds() {
          return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0);
        }
        horizonLineFromTop(e2 = true) {
          const t3 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - t3 * (1 - this._horizonShift);
          return e2 ? Math.max(0, i2) : i2;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t3) {
          this.maxBounds = t3, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t3 && (this.minLat = t3.getSouth(), this.maxLat = t3.getNorth(), this.minLng = t3.getWest(), this.maxLng = t3.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(e2, t3) {
          return this.projection.createTileMatrix(this, t3, e2);
        }
        calculateDistanceTileData(t3) {
          const i2 = t3.key, o2 = this._distanceTileDataCache;
          if (o2[i2])
            return o2[i2];
          const r3 = t3.canonical, n3 = 1 / this.height, a2 = this.cameraWorldSize / this.zoomScale(r3.z), s2 = (r3.x + Math.pow(2, r3.z) * t3.wrap) * a2, l3 = r3.y * a2, c2 = this.point, h3 = this.angle, u3 = Math.sin(-h3), _2 = -Math.cos(-h3);
          return o2[i2] = { bearing: [u3, _2], center: [(c2.x - s2) * n3, (c2.y - l3) * n3], scale: a2 / e.EXTENT * n3 }, o2[i2];
        }
        calculateFogTileMatrix(t3) {
          const i2 = t3.key, o2 = this._fogTileMatrixCache;
          if (o2[i2])
            return o2[i2];
          const r3 = this.projection.createTileMatrix(this, this.cameraWorldSize, t3);
          return e.multiply(r3, this.worldToFogMatrix, r3), o2[i2] = new Float32Array(r3), o2[i2];
        }
        calculateProjMatrix(t3, i2 = false) {
          const o2 = t3.key, r3 = i2 ? this._alignedProjMatrixCache : this._projMatrixCache;
          if (r3[o2])
            return r3[o2];
          const n3 = this.calculatePosMatrix(t3, this.worldSize);
          return e.multiply(n3, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, n3), r3[o2] = new Float32Array(n3), r3[o2];
        }
        calculatePixelsToTileUnitsMatrix(t3) {
          const i2 = t3.tileID.key, o2 = this._pixelsToTileUnitsCache;
          if (o2[i2])
            return o2[i2];
          const r3 = function(t4, i3) {
            const { scale: o3 } = t4.tileTransform, r4 = o3 * e.EXTENT / (t4.tileSize * Math.pow(2, i3.zoom - t4.tileID.overscaledZ + t4.tileID.canonical.z));
            return n3 = new Float32Array(4), l3 = (a2 = i3.inverseAdjustmentMatrix)[1], c2 = a2[2], h3 = a2[3], _2 = (s2 = [r4, r4])[1], n3[0] = a2[0] * (u3 = s2[0]), n3[1] = l3 * u3, n3[2] = c2 * _2, n3[3] = h3 * _2, n3;
            var n3, a2, s2, l3, c2, h3, u3, _2;
          }(t3, this);
          return o2[i2] = r3, o2[i2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        recenterOnTerrain() {
          if (!this._elevation || this.projection.name === "globe")
            return;
          const t3 = this._elevation;
          this._updateCameraState();
          const i2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r3 = this._camera.forward(), n3 = e.mercatorZfromAltitude(1, this._center.lat);
          o2[2] /= n3, r3[2] /= n3, e.normalize(r3, r3);
          const a2 = t3.raycast(o2, r3, t3.exaggeration());
          if (a2) {
            const t4 = e.scaleAndAdd([], o2, r3, a2), i3 = new e.MercatorCoordinate(t4[0], t4[1], e.mercatorZfromAltitude(t4[2], e.latFromMercatorY(t4[1]))), s2 = (i3.z + e.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * n3])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(s2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCameraAltitude() {
          if (!this._elevation)
            return;
          const t3 = this._elevation;
          this._updateCameraState();
          const i2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r3 = t3.getAtPointOrZero(new e.MercatorCoordinate(...o2)), n3 = this._minimumHeightOverTerrain() * Math.cos(e.degToRad(this._maxPitch)), a2 = this._camera.position[2] - this.pixelsPerMeter / this.worldSize * r3;
          if (a2 < n3) {
            const t4 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [t4.x - o2[0], t4.y - o2[1], t4.z - o2[2]], r4 = e.length(i3);
            i3[2] -= (n3 - a2) / this._pixelsPerMercatorPixel;
            const s2 = e.length(i3);
            if (s2 === 0)
              return;
            e.scale$2(i3, i3, r4 / s2 * this._pixelsPerMercatorPixel), this._camera.position = [t4.x - i3[0], t4.y - i3[1], t4.z * this._pixelsPerMercatorPixel - i3[2]], this._camera.orientation = jo(i3, this._camera.up()), this._updateStateFromCamera();
          }
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const t3 = this.projection.name === "globe" || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t3) {
            const i3 = this.center;
            return i3.lat = e.clamp(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t3) && (i3.lng = e.clamp(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
          }
          const i2 = this._unmodified, { x: o2, y: r3 } = this.point;
          let n3 = 0, a2 = o2, s2 = r3;
          const l3 = this.width / 2, c2 = this.height / 2, h3 = this.worldMinY * this.scale, u3 = this.worldMaxY * this.scale;
          if (r3 - c2 < h3 && (s2 = h3 + c2), r3 + c2 > u3 && (s2 = u3 - c2), u3 - h3 < this.height && (n3 = Math.max(n3, this.height / (u3 - h3)), s2 = (u3 + h3) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const e2 = this.worldMinX * this.scale, t4 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t4) / 2;
            a2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, a2 - l3 < e2 && (a2 = e2 + l3), a2 + l3 > t4 && (a2 = t4 - l3), t4 - e2 < this.width && (n3 = Math.max(n3, this.width / (t4 - e2)), a2 = (t4 + e2) / 2);
          }
          a2 === o2 && s2 === r3 || (this.center = this.unproject(new e.pointGeometry(a2, s2))), n3 && (this.zoom += this.scaleZoom(n3)), this._constrainCameraAltitude(), this._unmodified = i2, this._constraining = false;
        }
        _minZoomForBounds() {
          let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t3 = this.centerOffset, i2 = this.pixelsPerMeter;
          this.projection.name === "globe" && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));
          const o2 = qo(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const r3 = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? i2 : 1), n3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          n3[8] = 2 * -t3.x / this.width, n3[9] = 2 * t3.y / this.height;
          let a2 = e.mul([], n3, r3);
          if (this.projection.isReprojectedInTileSpace) {
            const t4 = this.locationCoordinate(this.center), i3 = e.identity([]);
            e.translate(i3, i3, [t4.x * this.worldSize, t4.y * this.worldSize, 0]), e.multiply(i3, i3, Wo(this)), e.translate(i3, i3, [-t4.x * this.worldSize, -t4.y * this.worldSize, 0]), e.multiply(a2, a2, i3), this.inverseAdjustmentMatrix = function(e2) {
              const t5 = Wo(e2, true);
              return v2([], [t5[0], t5[1], t5[4], t5[5]]);
            }(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          this.mercatorMatrix = e.scale([], a2, [this.worldSize, this.worldSize, this.worldSize / i2, 1]), this.projMatrix = a2, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
          const s2 = e.invert([], n3);
          this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(s2, this.horizonLineFromTop(), this.height);
          const l3 = new Float32Array(16);
          e.identity(l3), e.scale(l3, l3, [1, -1, 1]), e.rotateX(l3, l3, this._pitch), e.rotateZ(l3, l3, this.angle);
          const c2 = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), h3 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          c2[8] = 2 * -t3.x / this.width, c2[9] = 2 * (t3.y + h3) / this.height, this.skyboxMatrix = e.multiply(l3, c2, l3);
          const u3 = this.point, _2 = u3.x, d2 = u3.y, p3 = this.width % 2 / 2, m3 = this.height % 2 / 2, f2 = Math.cos(this.angle), g2 = Math.sin(this.angle), x3 = _2 - Math.round(_2) + f2 * p3 + g2 * m3, y3 = d2 - Math.round(d2) + f2 * m3 + g2 * p3, b2 = new Float64Array(a2);
          if (e.translate(b2, b2, [x3 > 0.5 ? x3 - 1 : x3, y3 > 0.5 ? y3 - 1 : y3, 0]), this.alignedProjMatrix = b2, a2 = e.create(), e.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), e.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = e.create(), e.scale(a2, a2, [1, -1, 1]), e.translate(a2, a2, [-1, -1, 0]), e.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a2 = e.invert(new Float64Array(16), this.pixelMatrix), !a2)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = a2, this.projection.name === "globe" || this.mercatorFromTransition) {
            this.globeMatrix = e.calculateGlobeMatrix(this);
            const t4 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = e.transformMat4(t4, t4, r3), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = a2;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t3 = this.cameraWorldSize, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r3 = 1 / this.height / this._pixelsPerMercatorPixel, n3 = [t3, t3, i2];
          e.scale$2(n3, n3, r3), e.scale$2(o2, o2, -1), e.multiply$2(o2, o2, n3);
          const a2 = e.create();
          e.translate(a2, a2, o2), e.scale(a2, a2, n3), this.mercatorFogMatrix = a2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t3, i2, r3);
        }
        _computeCameraPosition(e2) {
          const t3 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r3 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t3 - e2 / this.worldSize * this._centerAltitude;
          return [o2.x / this.worldSize - i2[0] * r3, o2.y / this.worldSize - i2[1] * r3, e2 / this.worldSize * this._centerAltitude - i2[2] * r3];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(t3) {
          const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = t3[2];
          let r3 = 1;
          o2 > 0 && (r3 = Math.min((i2 - this._camera.position[2]) / o2, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t3, r3), this._updateStateFromCamera(), this.projection.wrap && (this.center = this.center.wrap());
        }
        _updateStateFromCamera() {
          const t3 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r3 } = this._camera.getPitchBearing(), n3 = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, a2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)), s2 = Math.max((t3[2] - n3) / Math.cos(o2), a2), l3 = this._zoomFromMercatorZ(s2);
          e.scaleAndAdd(t3, t3, i2, s2), this._pitch = e.clamp(o2, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r3, -Math.PI, Math.PI), this._setZoom(e.clamp(l3, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t3[0], t3[1], t3[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e2) {
          return Math.pow(2, e2) * this.tileSize;
        }
        _mercatorZfromZoom(e2) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
        }
        _minimumHeightOverTerrain() {
          const e2 = Math.min((this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom) + 2, this._maxZoom);
          return this._mercatorZfromZoom(e2);
        }
        _zoomFromMercatorZ(e2) {
          return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(t3, i2) {
          const o2 = Math.min(t3.x, i2.x), r3 = Math.max(t3.x, i2.x), n3 = Math.min(t3.y, i2.y), a2 = Math.max(t3.y, i2.y);
          if (n3 < this.horizonLineFromTop(false))
            return true;
          if (this.projection.name !== "mercator")
            return false;
          const s2 = [new e.pointGeometry(o2, n3), new e.pointGeometry(r3, a2), new e.pointGeometry(o2, a2), new e.pointGeometry(r3, n3)], l3 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
          for (const e2 of s2) {
            const t4 = this.pointRayIntersection(e2);
            if (t4.t < 0)
              return true;
            const i3 = this.rayIntersectionCoordinate(t4);
            if (i3.x < l3 || i3.y < 0 || i3.x > c2 || i3.y > 1)
              return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
        }
        zoomDeltaToMovement(t3, i2) {
          const o2 = e.length(e.sub([], this._camera.position, t3)), r3 = this._zoomFromMercatorZ(o2) + i2;
          return o2 - this._mercatorZfromZoom(r3);
        }
        getCameraPoint() {
          if (this.projection.name === "globe") {
            const t3 = function(t4, i2) {
              const o2 = [t4[0], t4[1], t4[2], 1];
              e.transformMat4$1(o2, o2, i2);
              const r3 = Math.max(o2[3], 1e-6);
              return [o2[0] / r3, o2[1] / r3, o2[2] / r3, r3];
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new e.pointGeometry(t3[0], t3[1]);
          }
          {
            const t3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e.pointGeometry(0, t3));
          }
        }
        getCameraToCenterDistance(e2) {
          const t3 = qo(e2, this.zoom, this.width, this.height, 1024), i2 = e2.pixelSpaceConversion(this.center.lat, this.worldSize, t3);
          return 0.5 / Math.tan(0.5 * this._fov) * this.height * i2;
        }
      }
      function Jo(e2, t3) {
        let i2 = false, o2 = null;
        const r3 = () => {
          o2 = null, i2 && (e2(), o2 = setTimeout(r3, t3), i2 = false);
        };
        return () => (i2 = true, o2 || r3(), o2);
      }
      class Qo {
        constructor(t3) {
          this._hashName = t3 && encodeURIComponent(t3), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Jo(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(t3) {
          return this._map = t3, e.window.addEventListener("hashchange", this._onHashChange, false), t3.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const t3 = this._map;
          if (!t3)
            return "";
          const i2 = er(t3);
          if (this._hashName) {
            const t4 = this._hashName;
            let o2 = false;
            const r3 = e.window.location.hash.slice(1).split("&").map((e2) => {
              const r4 = e2.split("=")[0];
              return r4 === t4 ? (o2 = true, `${r4}=${i2}`) : e2;
            }).filter((e2) => e2);
            return o2 || r3.push(`${t4}=${i2}`), `#${r3.join("&")}`;
          }
          return `#${i2}`;
        }
        _getCurrentHash() {
          const t3 = e.window.location.hash.replace("#", "");
          if (this._hashName) {
            let e2;
            return t3.split("&").map((e3) => e3.split("=")).forEach((t4) => {
              t4[0] === this._hashName && (e2 = t4);
            }), (e2 && e2[1] || "").split("/");
          }
          return t3.split("/");
        }
        _onHashChange() {
          const e2 = this._map;
          if (!e2)
            return false;
          const t3 = this._getCurrentHash();
          if (t3.length >= 3 && !t3.some((e3) => isNaN(e3))) {
            const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : e2.getBearing();
            return e2.jumpTo({ center: [+t3[2], +t3[1]], zoom: +t3[0], bearing: i2, pitch: +(t3[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          const t3 = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
          e.window.history.replaceState(e.window.history.state, null, t3);
        }
      }
      function er(e2, t3) {
        const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, r3 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n3 = Math.pow(10, r3), a2 = Math.round(i2.lng * n3) / n3, s2 = Math.round(i2.lat * n3) / n3, l3 = e2.getBearing(), c2 = e2.getPitch();
        let h3 = t3 ? `/${a2}/${s2}/${o2}` : `${o2}/${s2}/${a2}`;
        return (l3 || c2) && (h3 += "/" + Math.round(10 * l3) / 10), c2 && (h3 += `/${Math.round(c2)}`), h3;
      }
      const tr = { linearity: 0.3, easing: e.bezier(0, 0, 0.3, 1) }, ir = e.extend({ deceleration: 2500, maxSpeed: 1400 }, tr), or = e.extend({ deceleration: 20, maxSpeed: 1400 }, tr), rr = e.extend({ deceleration: 1e3, maxSpeed: 360 }, tr), nr = e.extend({ deceleration: 1e3, maxSpeed: 90 }, tr);
      class ar {
        constructor(e2) {
          this._map = e2, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t3) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t3 });
        }
        _drainInertiaBuffer() {
          const t3 = this._inertiaBuffer, i2 = e.exported.now();
          for (; t3.length > 0 && i2 - t3[0].time > 160; )
            t3.shift();
        }
        _onMoveEnd(t3) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e2 } of this._inertiaBuffer)
            i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
          const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r3 = {};
          if (i2.pan.mag()) {
            const n3 = lr(i2.pan.mag(), o2, e.extend({}, ir, t3 || {}));
            r3.offset = i2.pan.mult(n3.amount / i2.pan.mag()), r3.center = this._map.transform.center, sr(r3, n3);
          }
          if (i2.zoom) {
            const e2 = lr(i2.zoom, o2, or);
            r3.zoom = this._map.transform.zoom + e2.amount, sr(r3, e2);
          }
          if (i2.bearing) {
            const t4 = lr(i2.bearing, o2, rr);
            r3.bearing = this._map.transform.bearing + e.clamp(t4.amount, -179, 179), sr(r3, t4);
          }
          if (i2.pitch) {
            const e2 = lr(i2.pitch, o2, nr);
            r3.pitch = this._map.transform.pitch + e2.amount, sr(r3, e2);
          }
          if (r3.zoom || r3.bearing) {
            const e2 = i2.pinchAround === void 0 ? i2.around : i2.pinchAround;
            r3.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
          }
          return this.clear(), r3.noMoveStart = true, r3;
        }
      }
      function sr(e2, t3) {
        (!e2.duration || e2.duration < t3.duration) && (e2.duration = t3.duration, e2.easing = t3.easing);
      }
      function lr(t3, i2, o2) {
        const { maxSpeed: r3, linearity: n3, deceleration: a2 } = o2, s2 = e.clamp(t3 * n3 / (i2 / 1e3), -r3, r3), l3 = Math.abs(s2) / (a2 * n3);
        return { easing: o2.easing, duration: 1e3 * l3, amount: s2 * (l3 / 2) };
      }
      class cr extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t3, i2, o2, r3 = {}) {
          const n3 = p2(i2.getCanvasContainer(), o2), a2 = i2.unproject(n3);
          super(t3, e.extend({ point: n3, lngLat: a2, originalEvent: o2 }, r3)), this._defaultPrevented = false, this.target = i2;
        }
      }
      class hr extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t3, i2, o2) {
          const r3 = t3 === "touchend" ? o2.changedTouches : o2.touches, n3 = m2(i2.getCanvasContainer(), r3), a2 = n3.map((e2) => i2.unproject(e2)), s2 = n3.reduce((e2, t4, i3, o3) => e2.add(t4.div(o3.length)), new e.pointGeometry(0, 0));
          super(t3, { points: n3, point: s2, lngLats: a2, lngLat: i2.unproject(s2), originalEvent: o2 }), this._defaultPrevented = false;
        }
      }
      class ur extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, t3, i2) {
          super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }
      class _r {
        constructor(e2, t3) {
          this._map = e2, this._clickTolerance = t3.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(e2) {
          return this._firePreventable(new ur(e2.type, this._map, e2));
        }
        mousedown(e2, t3) {
          return this._mousedownPos = t3, this._firePreventable(new cr(e2.type, this._map, e2));
        }
        mouseup(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        preclick(t3) {
          const i2 = e.extend({}, t3);
          i2.type = "preclick", this._map.fire(new cr(i2.type, this._map, i2));
        }
        click(e2, t3) {
          this._mousedownPos && this._mousedownPos.dist(t3) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new cr(e2.type, this._map, e2)));
        }
        dblclick(e2) {
          return this._firePreventable(new cr(e2.type, this._map, e2));
        }
        mouseover(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        mouseout(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        touchstart(e2) {
          return this._firePreventable(new hr(e2.type, this._map, e2));
        }
        touchmove(e2) {
          this._map.fire(new hr(e2.type, this._map, e2));
        }
        touchend(e2) {
          this._map.fire(new hr(e2.type, this._map, e2));
        }
        touchcancel(e2) {
          this._map.fire(new hr(e2.type, this._map, e2));
        }
        _firePreventable(e2) {
          if (this._map.fire(e2), e2.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class dr {
        constructor(e2) {
          this._map = e2;
        }
        reset() {
          this._delayContextMenu = false, this._contextMenuEvent = void 0;
        }
        mousemove(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new cr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e2) {
          this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new cr(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class pr {
        constructor(e2, t3) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t3.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e2, t3) {
          this.isEnabled() && e2.shiftKey && e2.button === 0 && (h(), this._startPos = this._lastPos = t3, this._active = true);
        }
        mousemoveWindow(e2, t3) {
          if (!this._active)
            return;
          const i2 = t3;
          if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
            return;
          const o2 = this._startPos;
          this._lastPos = i2, this._box || (this._box = n2("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
          const r3 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), s2 = Math.min(o2.y, i2.y), l3 = Math.max(o2.y, i2.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${r3}px,${s2}px)`, this._box.style.width = a2 - r3 + "px", this._box.style.height = l3 - s2 + "px");
          });
        }
        mouseupWindow(t3, i2) {
          if (!this._active)
            return;
          if (t3.button !== 0)
            return;
          const o2 = this._startPos, r3 = i2;
          if (this.reset(), d(), o2.x !== r3.x || o2.y !== r3.y)
            return this._map.fire(new e.Event("boxzoomend", { originalEvent: t3 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, r3, this._map.getBearing(), { linear: false }) };
          this._fireEvent("boxzoomcancel", t3);
        }
        keydown(e2) {
          this._active && e2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e2));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u2(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t3, i2) {
          return this._map.fire(new e.Event(t3, { originalEvent: i2 }));
        }
      }
      function mr(e2, t3) {
        const i2 = {};
        for (let o2 = 0; o2 < e2.length; o2++)
          i2[e2[o2].identifier] = t3[o2];
        return i2;
      }
      class fr {
        constructor(e2) {
          this.reset(), this.numTouches = e2.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
        }
        touchstart(t3, i2, o2) {
          (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === 0 && (this.startTime = t3.timeStamp), o2.length === this.numTouches && (this.centroid = function(t4) {
            const i3 = new e.pointGeometry(0, 0);
            for (const e2 of t4)
              i3._add(e2);
            return i3.div(t4.length);
          }(i2), this.touches = mr(o2, i2)));
        }
        touchmove(e2, t3, i2) {
          if (this.aborted || !this.centroid)
            return;
          const o2 = mr(i2, t3);
          for (const e3 in this.touches) {
            const t4 = this.touches[e3], i3 = o2[e3];
            (!i3 || i3.dist(t4) > 30) && (this.aborted = true);
          }
        }
        touchend(e2, t3, i2) {
          if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), i2.length === 0) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3)
              return e3;
          }
        }
      }
      class gr {
        constructor(e2) {
          this.singleTap = new fr(e2), this.numTaps = e2.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(e2, t3, i2) {
          this.singleTap.touchstart(e2, t3, i2);
        }
        touchmove(e2, t3, i2) {
          this.singleTap.touchmove(e2, t3, i2);
        }
        touchend(e2, t3, i2) {
          const o2 = this.singleTap.touchend(e2, t3, i2);
          if (o2) {
            const t4 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
            if (t4 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
              return this.reset(), o2;
          }
        }
      }
      class vr {
        constructor() {
          this._zoomIn = new gr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new gr({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e2, t3, i2) {
          this._zoomIn.touchstart(e2, t3, i2), this._zoomOut.touchstart(e2, t3, i2);
        }
        touchmove(e2, t3, i2) {
          this._zoomIn.touchmove(e2, t3, i2), this._zoomOut.touchmove(e2, t3, i2);
        }
        touchend(e2, t3, i2) {
          const o2 = this._zoomIn.touchend(e2, t3, i2), r3 = this._zoomOut.touchend(e2, t3, i2);
          return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() + 1, around: t4.unproject(o2) }, { originalEvent: e2 }) }) : r3 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() - 1, around: t4.unproject(r3) }, { originalEvent: e2 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const xr = { 0: 1, 2: 2 };
      class yr {
        constructor(e2) {
          this.reset(), this._clickTolerance = e2.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(e2, t3) {
          return false;
        }
        _move(e2, t3) {
          return {};
        }
        mousedown(e2, t3) {
          if (this._lastPoint)
            return;
          const i2 = f(e2);
          this._correctButton(e2, i2) && (this._lastPoint = t3, this._eventButton = i2);
        }
        mousemoveWindow(e2, t3) {
          const i2 = this._lastPoint;
          if (i2) {
            if (e2.preventDefault(), this._eventButton != null && function(e3, t4) {
              const i3 = xr[t4];
              return e3.buttons === void 0 || (e3.buttons & i3) !== i3;
            }(e2, this._eventButton))
              this.reset();
            else if (this._moved || !(t3.dist(i2) < this._clickTolerance))
              return this._moved = true, this._lastPoint = t3, this._move(i2, t3);
          }
        }
        mouseupWindow(e2) {
          this._lastPoint && f(e2) === this._eventButton && (this._moved && d(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class br extends yr {
        mousedown(e2, t3) {
          super.mousedown(e2, t3), this._lastPoint && (this._active = true);
        }
        _correctButton(e2, t3) {
          return t3 === 0 && !e2.ctrlKey;
        }
        _move(e2, t3) {
          return { around: t3, panDelta: t3.sub(e2) };
        }
      }
      class wr extends yr {
        _correctButton(e2, t3) {
          return t3 === 0 && e2.ctrlKey || t3 === 2;
        }
        _move(e2, t3) {
          const i2 = 0.8 * (t3.x - e2.x);
          if (i2)
            return this._active = true, { bearingDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class Tr extends yr {
        _correctButton(e2, t3) {
          return t3 === 0 && e2.ctrlKey || t3 === 2;
        }
        _move(e2, t3) {
          const i2 = -0.5 * (t3.y - e2.y);
          if (i2)
            return this._active = true, { pitchDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class Er {
        constructor(t3, i2) {
          this._map = t3, this._el = t3.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
        }
        touchstart(e2, t3, i2) {
          return this._calculateTransform(e2, t3, i2);
        }
        touchmove(t3, i2, o2) {
          if (this._active && !(o2.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (o2.length === 1 && !e.isFullscreen())
                return void this._showTouchPanBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return t3.cancelable && t3.preventDefault(), this._calculateTransform(t3, i2, o2);
          }
        }
        touchend(e2, t3, i2) {
          this._calculateTransform(e2, t3, i2), this._active && i2.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t3, i2, o2) {
          o2.length > 0 && (this._active = true);
          const r3 = mr(o2, i2), n3 = new e.pointGeometry(0, 0), a2 = new e.pointGeometry(0, 0);
          let s2 = 0;
          for (const e2 in r3) {
            const t4 = r3[e2], i3 = this._touches[e2];
            i3 && (n3._add(t4), a2._add(t4.sub(i3)), s2++, r3[e2] = t4);
          }
          if (this._touches = r3, s2 < this._minTouches || !a2.mag())
            return;
          const l3 = a2.div(s2);
          return this._sum._add(l3), this._sum.mag() < this._clickTolerance ? void 0 : { around: n3.div(s2), panDelta: l3 };
        }
        enable() {
          this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = n2("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 500);
        }
      }
      class Cr {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, this._firstTwoTouches = void 0;
        }
        _start(e2) {
        }
        _move(e2, t3, i2) {
          return {};
        }
        touchstart(e2, t3, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t3[0], t3[1]]));
        }
        touchmove(e2, t3, i2) {
          const o2 = this._firstTwoTouches;
          if (!o2)
            return;
          e2.preventDefault();
          const [r3, n3] = o2, a2 = Ir(i2, t3, r3), s2 = Ir(i2, t3, n3);
          if (!a2 || !s2)
            return;
          const l3 = this._aroundCenter ? null : a2.add(s2).div(2);
          return this._move([a2, s2], l3, e2);
        }
        touchend(e2, t3, i2) {
          if (!this._firstTwoTouches)
            return;
          const [o2, r3] = this._firstTwoTouches, n3 = Ir(i2, t3, o2), a2 = Ir(i2, t3, r3);
          n3 && a2 || (this._active && d(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e2) {
          this._enabled = true, this._aroundCenter = !!e2 && e2.around === "center";
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Ir(e2, t3, i2) {
        for (let o2 = 0; o2 < e2.length; o2++)
          if (e2[o2].identifier === i2)
            return t3[o2];
      }
      function Mr(e2, t3) {
        return Math.log(e2 / t3) / Math.LN2;
      }
      class Sr extends Cr {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(e2) {
          this._startDistance = this._distance = e2[0].dist(e2[1]);
        }
        _move(e2, t3) {
          const i2 = this._distance;
          if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Mr(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: Mr(this._distance, i2), pinchAround: t3 };
        }
      }
      function zr(e2, t3) {
        return 180 * e2.angleWith(t3) / Math.PI;
      }
      class Dr extends Cr {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(e2) {
          this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
        }
        _move(e2, t3) {
          const i2 = this._vector;
          if (this._vector = e2[0].sub(e2[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = true, { bearingDelta: zr(this._vector, i2), pinchAround: t3 };
        }
        _isBelowThreshold(e2) {
          this._minDiameter = Math.min(this._minDiameter, e2.mag());
          const t3 = 25 / (Math.PI * this._minDiameter) * 360, i2 = zr(e2, this._startVector);
          return Math.abs(i2) < t3;
        }
      }
      function Pr(e2) {
        return Math.abs(e2.y) > Math.abs(e2.x);
      }
      class Ar extends Cr {
        constructor(e2) {
          super(), this._map = e2;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(e2) {
          this._lastPoints = e2, Pr(e2[0].sub(e2[1])) && (this._valid = false);
        }
        _move(e2, t3, i2) {
          const o2 = this._lastPoints;
          if (!o2)
            return;
          const r3 = e2[0].sub(o2[0]), n3 = e2[1].sub(o2[1]);
          return this._map._cooperativeGestures && i2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r3, n3, i2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = e2, this._active = true, { pitchDelta: (r3.y + n3.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(e2, t3, i2) {
          if (this._valid !== void 0)
            return this._valid;
          const o2 = e2.mag() >= 2, r3 = t3.mag() >= 2;
          if (!o2 && !r3)
            return;
          if (!o2 || !r3)
            return this._firstMove == null && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
          const n3 = e2.y > 0 == t3.y > 0;
          return Pr(e2) && Pr(t3) && n3;
        }
      }
      const Lr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Rr {
        constructor() {
          const e2 = Lr;
          this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e2) {
          if (e2.altKey || e2.ctrlKey || e2.metaKey)
            return;
          let t3 = 0, i2 = 0, o2 = 0, r3 = 0, n3 = 0;
          switch (e2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t3 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t3 = -1;
              break;
            case 37:
              e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r3 = -1);
              break;
            case 39:
              e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r3 = 1);
              break;
            case 38:
              e2.shiftKey ? o2 = 1 : (e2.preventDefault(), n3 = -1);
              break;
            case 40:
              e2.shiftKey ? o2 = -1 : (e2.preventDefault(), n3 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (a2) => {
            const s2 = a2.getZoom();
            a2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Or, zoom: t3 ? Math.round(s2) + t3 * (e2.shiftKey ? 2 : 1) : s2, bearing: a2.getBearing() + i2 * this._bearingStep, pitch: a2.getPitch() + o2 * this._pitchStep, offset: [-r3 * this._panStep, -n3 * this._panStep], center: a2.getCenter() }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function Or(e2) {
        return e2 * (2 - e2);
      }
      const Br = 4.000244140625;
      class kr {
        constructor(t3, i2) {
          this._map = t3, this._el = t3.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(e2) {
          this._defaultZoomRate = e2;
        }
        setWheelZoomRate(e2) {
          this._wheelZoomRate = e2;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && e2.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t3) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(t3.ctrlKey || t3.metaKey || this.isZooming() || e.isFullscreen()))
              return void this._showBlockerAlert();
            this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let i2 = t3.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t3.deltaY : t3.deltaY;
          const o2 = e.exported.now(), r3 = o2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o2, i2 !== 0 && i2 % Br == 0 ? this._type = "wheel" : i2 !== 0 && Math.abs(i2) < 4 ? this._type = "trackpad" : r3 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t3)) : this._type || (this._type = Math.abs(r3 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t3.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t3, this._delta -= i2, this._active || this._start(t3)), t3.preventDefault();
        }
        _onTimeout(e2) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
        }
        _start(e2) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t3 = p2(this._el, e2);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t3, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const t3 = this._map.transform, i2 = () => t3._terrainEnabled() && this._aroundCoord ? t3.computeZoomRelativeTo(this._aroundCoord) : t3.zoom;
          if (this._delta !== 0) {
            const e2 = this._type === "wheel" && Math.abs(this._delta) > Br ? this._wheelZoomRate : this._defaultZoomRate;
            let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
            this._delta < 0 && o3 !== 0 && (o3 = 1 / o3);
            const r4 = i2(), n4 = Math.pow(2, r4), a3 = typeof this._targetZoom == "number" ? t3.zoomScale(this._targetZoom) : n4;
            this._targetZoom = Math.min(t3.maxZoom, Math.max(t3.minZoom, t3.scaleZoom(a3 * o3))), this._type === "wheel" && (this._startZoom = r4, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const o2 = typeof this._targetZoom == "number" ? this._targetZoom : i2(), r3 = this._startZoom, n3 = this._easing;
          let a2, s2 = false;
          if (this._type === "wheel" && r3 && n3) {
            const t4 = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), i3 = n3(t4);
            a2 = e.number(r3, o2, i3), t4 < 1 ? this._frameId || (this._frameId = true) : s2 = true;
          } else
            a2 = o2, s2 = true;
          return this._active = true, s2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: true, needsRenderFrame: !s2, zoomDelta: a2 - i2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t3) {
          let i2 = e.ease;
          if (this._prevEase) {
            const t4 = this._prevEase, o2 = (e.exported.now() - t4.start) / t4.duration, r3 = t4.easing(o2 + 0.01) - t4.easing(o2), n3 = 0.27 / Math.sqrt(r3 * r3 + 1e-4) * 0.01, a2 = Math.sqrt(0.0729 - n3 * n3);
            i2 = e.bezier(n3, a2, 0.25, 1);
          }
          return this._prevEase = { start: e.exported.now(), duration: t3, easing: i2 }, i2;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = n2("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 200);
        }
      }
      class Fr {
        constructor(e2, t3) {
          this._clickZoom = e2, this._tapZoom = t3;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Ur {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e2, t3) {
          return e2.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t3) }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Nr {
        constructor() {
          this._tap = new gr({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(e2, t3, i2) {
          this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t3[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t3, i2));
        }
        touchmove(e2, t3, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const o2 = t3[0], r3 = o2.y - this._swipePoint.y;
              return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: r3 / 128 };
            }
          } else
            this._tap.touchmove(e2, t3, i2);
        }
        touchend(e2, t3, i2) {
          this._tapTime ? this._swipePoint && i2.length === 0 && this.reset() : this._tap.touchend(e2, t3, i2) && (this._tapTime = e2.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Gr {
        constructor(e2, t3, i2) {
          this._el = e2, this._mousePan = t3, this._touchPan = i2;
        }
        enable(e2) {
          this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class jr {
        constructor(e2, t3, i2) {
          this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t3, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Zr {
        constructor(e2, t3, i2, o2) {
          this._el = e2, this._touchZoom = t3, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e2) {
          this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const Vr = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
      class Wr extends e.Event {
      }
      class Xr {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t3, i2) {
          const o2 = e.sub([], i2, t3);
          this.radius = e.length(o2[2] < 0 ? e.div([], o2, this.constants) : [o2[0], o2[1], 0]);
        }
        projectRay(t3) {
          e.div(t3, t3, this.constants), e.normalize(t3, t3), e.mul$1(t3, t3, this.constants);
          const i2 = e.scale$2([], t3, this.radius);
          if (i2[2] > 0) {
            const t4 = e.scale$2([], [0, 0, 1], e.dot(i2, [0, 0, 1])), o2 = e.scale$2([], e.normalize([], [i2[0], i2[1], 0]), this.radius), r3 = e.add([], i2, e.scale$2([], e.sub([], e.add([], o2, t4), i2), 2));
            i2[0] = r3[0], i2[1] = r3[1];
          }
          return i2;
        }
      }
      function qr(e2) {
        return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
      }
      class $r {
        constructor(t3, i2) {
          this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ar(t3), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Xr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.bindAll(["handleEvent", "handleWindowEvent"], this);
          const o2 = this._el;
          this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [e.window.document, "mousemove", { capture: true }], [e.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [e.window, "blur", void 0]];
          for (const [t4, i3, o3] of this._listeners)
            t4.addEventListener(i3, t4 === e.window.document ? this.handleWindowEvent : this.handleEvent, o3);
        }
        destroy() {
          for (const [t3, i2, o2] of this._listeners)
            t3.removeEventListener(i2, t3 === e.window.document ? this.handleWindowEvent : this.handleEvent, o2);
        }
        _addDefaultHandlers(e2) {
          const t3 = this._map, i2 = t3.getCanvasContainer();
          this._add("mapEvent", new _r(t3, e2));
          const o2 = t3.boxZoom = new pr(t3, e2);
          this._add("boxZoom", o2);
          const r3 = new vr(), n3 = new Ur();
          t3.doubleClickZoom = new Fr(n3, r3), this._add("tapZoom", r3), this._add("clickZoom", n3);
          const a2 = new Nr();
          this._add("tapDragZoom", a2);
          const s2 = t3.touchPitch = new Ar(t3);
          this._add("touchPitch", s2);
          const l3 = new wr(e2), c2 = new Tr(e2);
          t3.dragRotate = new jr(e2, l3, c2), this._add("mouseRotate", l3, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
          const h3 = new br(e2), u3 = new Er(t3, e2);
          t3.dragPan = new Gr(i2, h3, u3), this._add("mousePan", h3), this._add("touchPan", u3, ["touchZoom", "touchRotate"]);
          const _2 = new Dr(), d2 = new Sr();
          t3.touchZoomRotate = new Zr(i2, d2, _2, a2), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new dr(t3));
          const p3 = t3.scrollZoom = new kr(t3, this);
          this._add("scrollZoom", p3, ["mousePan"]);
          const m3 = t3.keyboard = new Rr();
          this._add("keyboard", m3);
          for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            e2.interactive && e2[i3] && t3[i3].enable(e2[i3]);
        }
        _add(e2, t3, i2) {
          this._handlers.push({ handlerName: e2, handler: t3, allowed: i2 }), this._handlersById[e2] = t3;
        }
        stop(e2) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers)
              e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e2 } of this._handlers)
            if (e2.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Vr(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(e2, t3, i2) {
          for (const o2 in e2)
            if (o2 !== i2 && (!t3 || t3.indexOf(o2) < 0))
              return true;
          return false;
        }
        handleWindowEvent(e2) {
          this.handleEvent(e2, `${e2.type}Window`);
        }
        _getMapTouches(e2) {
          const t3 = [];
          for (const i2 of e2)
            this._el.contains(i2.target) && t3.push(i2);
          return t3;
        }
        handleEvent(e2, t3) {
          this._updatingCamera = true;
          const i2 = e2.type === "renderFrame", o2 = i2 ? void 0 : e2, r3 = { needsRenderFrame: false }, n3 = {}, a2 = {}, s2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l3 = s2 ? m2(this._el, s2) : i2 ? void 0 : p2(this._el, e2);
          for (const { handlerName: i3, handler: c3, allowed: h4 } of this._handlers) {
            if (!c3.isEnabled())
              continue;
            let u3;
            this._blockedByActive(a2, h4, i3) ? c3.reset() : c3[t3 || e2.type] && (u3 = c3[t3 || e2.type](e2, l3, s2), this.mergeHandlerResult(r3, n3, u3, i3, o2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || c3.isActive()) && (a2[i3] = c3);
          }
          const c2 = {};
          for (const e3 in this._previousActiveHandlers)
            a2[e3] || (c2[e3] = o2);
          this._previousActiveHandlers = a2, (Object.keys(c2).length || qr(r3)) && (this._changes.push([r3, n3, c2]), this._triggerRenderFrame()), (Object.keys(a2).length || qr(r3)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: h3 } = r3;
          h3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h3(this._map));
        }
        mergeHandlerResult(t3, i2, o2, r3, n3) {
          if (!o2)
            return;
          e.extend(t3, o2);
          const a2 = { handlerName: r3, originalEvent: o2.originalEvent || n3 };
          o2.zoomDelta !== void 0 && (i2.zoom = a2), o2.panDelta !== void 0 && (i2.drag = a2), o2.pitchDelta !== void 0 && (i2.pitch = a2), o2.bearingDelta !== void 0 && (i2.rotate = a2);
        }
        _applyChanges() {
          const t3 = {}, i2 = {}, o2 = {};
          for (const [r3, n3, a2] of this._changes)
            r3.panDelta && (t3.panDelta = (t3.panDelta || new e.pointGeometry(0, 0))._add(r3.panDelta)), r3.zoomDelta && (t3.zoomDelta = (t3.zoomDelta || 0) + r3.zoomDelta), r3.bearingDelta && (t3.bearingDelta = (t3.bearingDelta || 0) + r3.bearingDelta), r3.pitchDelta && (t3.pitchDelta = (t3.pitchDelta || 0) + r3.pitchDelta), r3.around !== void 0 && (t3.around = r3.around), r3.aroundCoord !== void 0 && (t3.aroundCoord = r3.aroundCoord), r3.pinchAround !== void 0 && (t3.pinchAround = r3.pinchAround), r3.noInertia && (t3.noInertia = r3.noInertia), e.extend(i2, n3), e.extend(o2, a2);
          this._updateMapTransform(t3, i2, o2), this._changes = [];
        }
        _updateMapTransform(t3, i2, o2) {
          const r3 = this._map, n3 = r3.transform, a2 = (e2) => [e2.x, e2.y, e2.z];
          if (((e2) => {
            const t4 = this._eventsInProgress.drag;
            return t4 && !this._handlersById[t4.handlerName].isActive();
          })() && !qr(t3)) {
            const e2 = n3.zoom;
            n3.cameraElevationReference = "sea", n3.recenterOnTerrain(), n3.cameraElevationReference = "ground", e2 !== n3.zoom && this._map._update(true);
          }
          if (!qr(t3))
            return void this._fireEvents(i2, o2, true);
          let { panDelta: s2, zoomDelta: l3, bearingDelta: c2, pitchDelta: h3, around: u3, aroundCoord: _2, pinchAround: d2 } = t3;
          d2 !== void 0 && (u3 = d2), ((e2) => i2.drag && !this._eventsInProgress.drag)() && u3 && (this._dragOrigin = a2(n3.pointCoordinate3D(u3)), this._trackingEllipsoid.setup(n3._camera.position, this._dragOrigin)), n3.cameraElevationReference = "sea", r3._stop(true), u3 = u3 || r3.transform.centerPoint, c2 && (n3.bearing += c2), h3 && (n3.pitch += h3), n3._updateCameraState();
          const p3 = [0, 0, 0];
          if (s2)
            if (n3.projection.name === "mercator") {
              const e2 = this._trackingEllipsoid.projectRay(n3.screenPointToMercatorRay(u3).dir), t4 = this._trackingEllipsoid.projectRay(n3.screenPointToMercatorRay(u3.sub(s2)).dir);
              p3[0] = t4[0] - e2[0], p3[1] = t4[1] - e2[1];
            } else {
              const t4 = n3.pointCoordinate(u3);
              if (n3.projection.name === "globe") {
                s2 = s2.rotate(-n3.angle);
                const i3 = n3._pixelsPerMercatorPixel / n3.worldSize;
                p3[0] = -s2.x * e.mercatorScale(e.latFromMercatorY(t4.y)) * i3, p3[1] = -s2.y * e.mercatorScale(n3.center.lat) * i3;
              } else {
                const e2 = n3.pointCoordinate(u3.sub(s2));
                t4 && e2 && (p3[0] = e2.x - t4.x, p3[1] = e2.y - t4.y);
              }
            }
          const m3 = n3.zoom, f2 = [0, 0, 0];
          if (l3) {
            const t4 = a2(_2 || n3.pointCoordinate3D(u3)), i3 = { dir: e.normalize([], e.sub([], t4, n3._camera.position)) };
            if (i3.dir[2] < 0) {
              const o3 = n3.zoomDeltaToMovement(t4, l3);
              e.scale$2(f2, i3.dir, o3);
            }
          }
          const g2 = e.add(p3, p3, f2);
          n3._translateCameraConstrained(g2), l3 && Math.abs(n3.zoom - m3) > 1e-4 && n3.recenterOnTerrain(), n3.cameraElevationReference = "ground", this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(i2, o2, true);
        }
        _fireEvents(t3, i2, o2) {
          const r3 = Vr(this._eventsInProgress), n3 = Vr(t3), a2 = {};
          for (const e2 in t3) {
            const { originalEvent: i3 } = t3[e2];
            this._eventsInProgress[e2] || (a2[`${e2}start`] = i3), this._eventsInProgress[e2] = t3[e2];
          }
          !r3 && n3 && this._fireEvent("movestart", n3.originalEvent);
          for (const e2 in a2)
            this._fireEvent(e2, a2[e2]);
          n3 && this._fireEvent("move", n3.originalEvent);
          for (const e2 in t3) {
            const { originalEvent: i3 } = t3[e2];
            this._fireEvent(e2, i3);
          }
          const s2 = {};
          let l3;
          for (const e2 in this._eventsInProgress) {
            const { handlerName: t4, originalEvent: o3 } = this._eventsInProgress[e2];
            this._handlersById[t4].isActive() || (delete this._eventsInProgress[e2], l3 = i2[t4] || o3, s2[`${e2}end`] = l3);
          }
          for (const e2 in s2)
            this._fireEvent(e2, s2[e2]);
          const c2 = Vr(this._eventsInProgress);
          if (o2 && (r3 || n3) && !c2) {
            this._updatingCamera = true;
            const t4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => e2 !== 0 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
            t4 ? (i3(t4.bearing || this._map.getBearing()) && (t4.bearing = 0), this._map.easeTo(t4, { originalEvent: l3 })) : (this._map.fire(new e.Event("moveend", { originalEvent: l3 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(t3, i2) {
          this._map.fire(new e.Event(t3, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
            this._frameId = void 0, this.handleEvent(new Wr("renderFrame", { timeStamp: e2 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      const Hr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class Yr extends e.Evented {
        constructor(t3, i2) {
          super(), this._moving = false, this._zooming = false, this.transform = t3, this._bearingSnap = i2.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e2, t3) {
          return this.jumpTo({ center: e2 }, t3);
        }
        panBy(t3, i2, o2) {
          return t3 = e.pointGeometry.convert(t3).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t3 }, i2), o2);
        }
        panTo(t3, i2, o2) {
          return this.easeTo(e.extend({ center: t3 }, i2), o2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e2, t3) {
          return this.jumpTo({ zoom: e2 }, t3), this;
        }
        zoomTo(t3, i2, o2) {
          return this.easeTo(e.extend({ zoom: t3 }, i2), o2);
        }
        zoomIn(e2, t3) {
          return this.zoomTo(this.getZoom() + 1, e2, t3), this;
        }
        zoomOut(e2, t3) {
          return this.zoomTo(this.getZoom() - 1, e2, t3), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e2, t3) {
          return this.jumpTo({ bearing: e2 }, t3), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e2, t3) {
          return this.jumpTo({ padding: e2 }, t3), this;
        }
        rotateTo(t3, i2, o2) {
          return this.easeTo(e.extend({ bearing: t3 }, i2), o2);
        }
        resetNorth(t3, i2) {
          return this.rotateTo(0, e.extend({ duration: 1e3 }, t3), i2), this;
        }
        resetNorthPitch(t3, i2) {
          return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t3), i2), this;
        }
        snapToNorth(e2, t3) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t3) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e2, t3) {
          return this.jumpTo({ pitch: e2 }, t3), this;
        }
        cameraForBounds(t3, i2) {
          this.transform.projection.name === "globe" && e.warnOnce('Globe projection does not support cameraForBounds API, this API may behave unexpectedly."'), t3 = e.LngLatBounds.convert(t3);
          const o2 = i2 && i2.bearing || 0;
          return this._cameraForBoxAndBearing(t3.getNorthWest(), t3.getSouthEast(), o2, i2);
        }
        _extendCameraOptions(t3) {
          const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (t3 = e.extend({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, t3)).padding == "number") {
            const e2 = t3.padding;
            t3.padding = { top: e2, bottom: e2, right: e2, left: e2 };
          }
          return t3.padding = e.extend(i2, t3.padding), t3;
        }
        _cameraForBoxAndBearing(t3, i2, o2, r3) {
          const n3 = this._extendCameraOptions(r3), a2 = this.transform, s2 = a2.padding, l3 = a2.project(e.LngLat.convert(t3)), c2 = a2.project(e.LngLat.convert(i2)), h3 = new e.pointGeometry(l3.x, c2.y), u3 = new e.pointGeometry(c2.x, l3.y), _2 = -e.degToRad(o2), d2 = l3.rotate(_2), p3 = c2.rotate(_2), m3 = h3.rotate(_2), f2 = u3.rotate(_2), g2 = new e.pointGeometry(Math.max(d2.x, p3.x, m3.x, f2.x), Math.max(d2.y, p3.y, m3.y, f2.y)), v3 = new e.pointGeometry(Math.min(d2.x, p3.x, m3.x, f2.x), Math.min(d2.y, p3.y, m3.y, f2.y)), x3 = g2.sub(v3), y3 = (a2.width - ((s2.left || 0) + (s2.right || 0) + n3.padding.left + n3.padding.right)) / x3.x, b2 = (a2.height - ((s2.top || 0) + (s2.bottom || 0) + n3.padding.top + n3.padding.bottom)) / x3.y;
          if (b2 < 0 || y3 < 0)
            return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const w2 = Math.min(a2.scaleZoom(a2.scale * Math.min(y3, b2)), n3.maxZoom), T3 = typeof n3.offset.x == "number" && typeof n3.offset.y == "number" ? new e.pointGeometry(n3.offset.x, n3.offset.y) : e.pointGeometry.convert(n3.offset), E3 = new e.pointGeometry((n3.padding.left - n3.padding.right) / 2, (n3.padding.top - n3.padding.bottom) / 2).rotate(o2 * Math.PI / 180), C3 = T3.add(E3).mult(a2.scale / a2.zoomScale(w2));
          return { center: a2.unproject(l3.add(c2).div(2).sub(C3)), zoom: w2, bearing: o2 };
        }
        _cameraForBox(t3, i2, o2, r3, n3) {
          const a2 = this._extendCameraOptions(n3);
          o2 = o2 || 0, r3 = r3 || 0, t3 = e.LngLat.convert(t3), i2 = e.LngLat.convert(i2);
          const s2 = this.transform.clone();
          s2.padding = a2.padding;
          const l3 = this.getFreeCameraOptions(), c2 = new e.LngLat(0.5 * (t3.lng + i2.lng), 0.5 * (t3.lat + i2.lat)), h3 = 0.5 * (o2 + r3);
          if (s2._camera.position[2] < e.mercatorZfromAltitude(h3, c2.lat))
            return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          l3.lookAtPoint(c2), s2.setFreeCameraOptions(l3);
          const u3 = e.MercatorCoordinate.fromLngLat(t3), _2 = e.MercatorCoordinate.fromLngLat(i2), d2 = s2.pointRayIntersection(s2.centerPoint, h3), p3 = [(m3 = s2.rayIntersectionCoordinate(d2)).x, m3.y, m3.z];
          var m3;
          const f2 = s2.screenPointToMercatorRay(s2.centerPoint), g2 = s2.projection.name !== "globe";
          let v3, x3 = 0;
          do {
            const t4 = Math.floor(s2.zoom), i3 = 1 << t4, n4 = Math.min(i3 * u3.x, i3 * _2.x), a3 = Math.min(i3 * u3.y, i3 * _2.y), l4 = Math.max(i3 * u3.x, i3 * _2.x), c3 = Math.max(i3 * u3.y, i3 * _2.y), h4 = new e.Aabb([n4, a3, o2], [l4, c3, r3]), d3 = e.Frustum.fromInvProjectionMatrix(s2.invProjMatrix, s2.worldSize, t4, g2);
            if (h4.intersects(d3) !== 2) {
              v3 && (s2._camera.position = e.scaleAndAdd([], s2._camera.position, f2.dir, -v3), s2._updateStateFromCamera());
              break;
            }
            const m4 = e.sub([], s2._camera.position, p3);
            v3 = 0.5 * e.length(m4), s2._camera.position = e.scaleAndAdd([], s2._camera.position, f2.dir, v3);
            try {
              s2._updateStateFromCamera();
            } catch (t5) {
              return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            }
          } while (++x3 < 10);
          return { center: s2.center, zoom: s2.zoom, bearing: s2.bearing, pitch: s2.pitch };
        }
        fitBounds(t3, i2, o2) {
          return this.transform.projection.name === "globe" && e.warnOnce("Globe projection does not support fitBounds API, this API may behave unexpectedly."), this._fitInternal(this.cameraForBounds(t3, i2), i2, o2);
        }
        _raycastElevationBox(t3, i2) {
          const o2 = this.transform.elevation;
          if (!o2)
            return;
          const r3 = new e.pointGeometry(t3.x, i2.y), n3 = new e.pointGeometry(i2.x, t3.y), a2 = o2.pointCoordinate(t3);
          if (!a2)
            return;
          const s2 = o2.pointCoordinate(i2);
          if (!s2)
            return;
          const l3 = o2.pointCoordinate(r3);
          if (!l3)
            return;
          const c2 = o2.pointCoordinate(n3);
          if (!c2)
            return;
          const h3 = new e.MercatorCoordinate(a2[0], a2[1]).toLngLat(), u3 = new e.MercatorCoordinate(s2[0], s2[1]).toLngLat(), _2 = new e.MercatorCoordinate(l3[0], l3[1]).toLngLat(), d2 = new e.MercatorCoordinate(c2[0], c2[1]).toLngLat(), p3 = Math.min(h3.lng, Math.min(u3.lng, Math.min(_2.lng, d2.lng))), m3 = Math.min(h3.lat, Math.min(u3.lat, Math.min(_2.lat, d2.lat))), f2 = Math.max(h3.lng, Math.max(u3.lng, Math.max(_2.lng, d2.lng))), g2 = Math.max(h3.lat, Math.max(u3.lat, Math.max(_2.lat, d2.lat))), v3 = Math.min(a2[3], Math.min(s2[3], Math.min(l3[3], c2[3]))), x3 = Math.max(a2[3], Math.max(s2[3], Math.max(l3[3], c2[3])));
          return { minLngLat: new e.LngLat(p3, m3), maxLngLat: new e.LngLat(f2, g2), minAltitude: v3, maxAltitude: x3 };
        }
        fitScreenCoordinates(t3, i2, o2, r3, n3) {
          let a2, s2, l3, c2;
          this.transform.projection.name === "globe" && e.warnOnce("Globe projection does not support fitScreenCoordinates API, this API may behave unexpectedly.");
          const h3 = e.pointGeometry.convert(t3), u3 = e.pointGeometry.convert(i2), _2 = this._raycastElevationBox(h3, u3);
          if (_2)
            a2 = _2.minLngLat, s2 = _2.maxLngLat, l3 = _2.minAltitude, c2 = _2.maxAltitude;
          else {
            if (this.transform.anyCornerOffEdge(h3, u3))
              return this;
            a2 = this.transform.pointLocation(h3), s2 = this.transform.pointLocation(u3);
          }
          return this._fitInternal(this.transform.pitch === 0 ? this._cameraForBoxAndBearing(this.transform.pointLocation(e.pointGeometry.convert(t3)), this.transform.pointLocation(e.pointGeometry.convert(i2)), o2, r3) : this._cameraForBox(a2, s2, l3, c2, r3), r3, n3);
        }
        _fitInternal(t3, i2, o2) {
          return t3 ? (delete (i2 = e.extend(t3, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
        }
        jumpTo(t3, i2) {
          this.stop();
          const o2 = t3.preloadOnly ? this.transform.clone() : this.transform;
          let r3 = false, n3 = false, a2 = false;
          return "zoom" in t3 && o2.zoom !== +t3.zoom && (r3 = true, o2.zoom = +t3.zoom), t3.center !== void 0 && (o2.center = e.LngLat.convert(t3.center)), "bearing" in t3 && o2.bearing !== +t3.bearing && (n3 = true, o2.bearing = +t3.bearing), "pitch" in t3 && o2.pitch !== +t3.pitch && (a2 = true, o2.pitch = +t3.pitch), t3.padding == null || o2.isPaddingEqual(t3.padding) || (o2.padding = t3.padding), t3.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), r3 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), n3 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), a2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || e.warnOnce(Hr), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t3, i2) {
          const o2 = this.transform;
          if (!o2.projection.supportsFreeCamera)
            return e.warnOnce(Hr), this;
          this.stop();
          const r3 = o2.zoom, n3 = o2.pitch, a2 = o2.bearing;
          o2.setFreeCameraOptions(t3);
          const s2 = r3 !== o2.zoom, l3 = n3 !== o2.pitch, c2 = a2 !== o2.bearing;
          return this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), s2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), c2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), l3 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)), this;
        }
        easeTo(t3, i2) {
          this._stop(false, t3.easeId), ((t3 = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t3)).animate === false || !t3.essential && e.exported.prefersReducedMotion) && (t3.duration = 0);
          const o2 = this.transform, r3 = this.getZoom(), n3 = this.getBearing(), a2 = this.getPitch(), s2 = this.getPadding(), l3 = "zoom" in t3 ? +t3.zoom : r3, c2 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, n3) : n3, h3 = "pitch" in t3 ? +t3.pitch : a2, u3 = "padding" in t3 ? t3.padding : o2.padding, _2 = e.pointGeometry.convert(t3.offset);
          let d2, p3, m3;
          if (o2.projection.name === "globe") {
            const i3 = e.MercatorCoordinate.fromLngLat(o2.center), r4 = _2.rotate(-o2.angle);
            i3.x += r4.x / o2.worldSize, i3.y += r4.y / o2.worldSize;
            const n4 = i3.toLngLat(), a3 = e.LngLat.convert(t3.center || n4);
            this._normalizeCenter(a3), d2 = o2.centerPoint.add(r4), p3 = new e.pointGeometry(i3.x, i3.y).mult(o2.worldSize), m3 = new e.pointGeometry(e.mercatorXfromLng(a3.lng), e.mercatorYfromLat(a3.lat)).mult(o2.worldSize).sub(p3);
          } else {
            d2 = o2.centerPoint.add(_2);
            const i3 = o2.pointLocation(d2), r4 = e.LngLat.convert(t3.center || i3);
            this._normalizeCenter(r4), p3 = o2.project(i3), m3 = o2.project(r4).sub(p3);
          }
          const f2 = o2.zoomScale(l3 - r3);
          let g2, v3;
          t3.around && (g2 = e.LngLat.convert(t3.around), v3 = o2.locationPoint(g2));
          const x3 = this._zooming || l3 !== r3, y3 = this._rotating || n3 !== c2, b2 = this._pitching || h3 !== a2, w2 = !o2.isPaddingEqual(u3), T3 = (o3) => (T4) => {
            if (x3 && (o3.zoom = e.number(r3, l3, T4)), y3 && (o3.bearing = e.number(n3, c2, T4)), b2 && (o3.pitch = e.number(a2, h3, T4)), w2 && (o3.interpolatePadding(s2, u3, T4), d2 = o3.centerPoint.add(_2)), g2)
              o3.setLocationAtPoint(g2, v3);
            else {
              const e2 = o3.zoomScale(o3.zoom - r3), t4 = l3 > r3 ? Math.min(2, f2) : Math.max(0.5, f2), i3 = Math.pow(t4, 1 - T4), n4 = o3.unproject(p3.add(m3.mult(T4 * i3)).mult(e2));
              o3.setLocationAtPoint(o3.renderWorldCopies ? n4.wrap() : n4, d2);
            }
            return t3.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t3.preloadOnly) {
            const e2 = this._emulate(T3, t3.duration, o2);
            return this._preloadTiles(e2), this;
          }
          const E3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = x3, this._rotating = y3, this._pitching = b2, this._padding = w2, this._easeId = t3.easeId, this._prepareEase(i2, t3.noMoveStart, E3), this._ease(T3(o2), (e2) => {
            o2.recenterOnTerrain(), this._afterEase(i2, e2);
          }, t3), this;
        }
        _prepareEase(t3, i2, o2 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", i2 || o2.moving || this.fire(new e.Event("movestart", t3)), this._zooming && !o2.zooming && this.fire(new e.Event("zoomstart", t3)), this._rotating && !o2.rotating && this.fire(new e.Event("rotatestart", t3)), this._pitching && !o2.pitching && this.fire(new e.Event("pitchstart", t3));
        }
        _fireMoveEvents(t3) {
          this.fire(new e.Event("move", t3)), this._zooming && this.fire(new e.Event("zoom", t3)), this._rotating && this.fire(new e.Event("rotate", t3)), this._pitching && this.fire(new e.Event("pitch", t3));
        }
        _afterEase(t3, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const o2 = this._zooming, r3 = this._rotating, n3 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.Event("zoomend", t3)), r3 && this.fire(new e.Event("rotateend", t3)), n3 && this.fire(new e.Event("pitchend", t3)), this.fire(new e.Event("moveend", t3));
        }
        flyTo(t3, i2) {
          if (!t3.essential && e.exported.prefersReducedMotion) {
            const o3 = e.pick(t3, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(o3, i2);
          }
          this.stop(), t3 = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t3);
          const o2 = this.transform, r3 = this.getZoom(), n3 = this.getBearing(), a2 = this.getPitch(), s2 = this.getPadding(), l3 = "zoom" in t3 ? e.clamp(+t3.zoom, o2.minZoom, o2.maxZoom) : r3, c2 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, n3) : n3, h3 = "pitch" in t3 ? +t3.pitch : a2, u3 = "padding" in t3 ? t3.padding : o2.padding, _2 = o2.zoomScale(l3 - r3), d2 = e.pointGeometry.convert(t3.offset);
          let p3 = o2.centerPoint.add(d2);
          const m3 = o2.pointLocation(p3), f2 = e.LngLat.convert(t3.center || m3);
          this._normalizeCenter(f2);
          const g2 = o2.project(m3), v3 = o2.project(f2).sub(g2);
          let x3 = t3.curve;
          const y3 = Math.max(o2.width, o2.height), b2 = y3 / _2, w2 = v3.mag();
          if ("minZoom" in t3) {
            const i3 = e.clamp(Math.min(t3.minZoom, r3, l3), o2.minZoom, o2.maxZoom), n4 = y3 / o2.zoomScale(i3 - r3);
            x3 = Math.sqrt(n4 / w2 * 2);
          }
          const T3 = x3 * x3;
          function E3(e2) {
            const t4 = (b2 * b2 - y3 * y3 + (e2 ? -1 : 1) * T3 * T3 * w2 * w2) / (2 * (e2 ? b2 : y3) * T3 * w2);
            return Math.log(Math.sqrt(t4 * t4 + 1) - t4);
          }
          function C3(e2) {
            return (Math.exp(e2) - Math.exp(-e2)) / 2;
          }
          function I3(e2) {
            return (Math.exp(e2) + Math.exp(-e2)) / 2;
          }
          const M3 = E3(0);
          let S3 = function(e2) {
            return I3(M3) / I3(M3 + x3 * e2);
          }, z3 = function(e2) {
            return y3 * ((I3(M3) * (C3(t4 = M3 + x3 * e2) / I3(t4)) - C3(M3)) / T3) / w2;
            var t4;
          }, D3 = (E3(1) - M3) / x3;
          if (Math.abs(w2) < 1e-6 || !isFinite(D3)) {
            if (Math.abs(y3 - b2) < 1e-6)
              return this.easeTo(t3, i2);
            const e2 = b2 < y3 ? -1 : 1;
            D3 = Math.abs(Math.log(b2 / y3)) / x3, z3 = function() {
              return 0;
            }, S3 = function(t4) {
              return Math.exp(e2 * x3 * t4);
            };
          }
          t3.duration = "duration" in t3 ? +t3.duration : 1e3 * D3 / ("screenSpeed" in t3 ? +t3.screenSpeed / x3 : +t3.speed), t3.maxDuration && t3.duration > t3.maxDuration && (t3.duration = 0);
          const P3 = n3 !== c2, A3 = h3 !== a2, L3 = !o2.isPaddingEqual(u3), R3 = (o3) => (_3) => {
            const m4 = _3 * D3, x4 = 1 / S3(m4);
            o3.zoom = _3 === 1 ? l3 : r3 + o3.scaleZoom(x4), P3 && (o3.bearing = e.number(n3, c2, _3)), A3 && (o3.pitch = e.number(a2, h3, _3)), L3 && (o3.interpolatePadding(s2, u3, _3), p3 = o3.centerPoint.add(d2));
            const y4 = _3 === 1 ? f2 : o3.unproject(g2.add(v3.mult(z3(m4))).mult(x4));
            return o3.setLocationAtPoint(o3.renderWorldCopies ? y4.wrap() : y4, p3), o3._updateCameraOnTerrain(), t3.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t3.preloadOnly) {
            const e2 = this._emulate(R3, t3.duration, o2);
            return this._preloadTiles(e2), this;
          }
          return this._zooming = true, this._rotating = P3, this._pitching = A3, this._padding = L3, this._prepareEase(i2, false), this._ease(R3(o2), () => this._afterEase(i2), t3), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e2, t3) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            this._onEaseEnd = void 0, e3.call(this, t3);
          }
          if (!e2) {
            const e3 = this.handlers;
            e3 && e3.stop(false);
          }
          return this;
        }
        _ease(t3, i2, o2) {
          o2.animate === false || o2.duration === 0 ? (t3(1), i2()) : (this._easeStart = e.exported.now(), this._easeOptions = o2, this._onEaseFrame = t3, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t3 = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
          i2 && i2(this._easeOptions.easing(t3)), t3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t3, i2) {
          t3 = e.wrap(t3, -180, 180);
          const o2 = Math.abs(t3 - i2);
          return Math.abs(t3 - 360 - i2) < o2 && (t3 -= 360), Math.abs(t3 + 360 - i2) < o2 && (t3 += 360), t3;
        }
        _normalizeCenter(e2) {
          const t3 = this.transform;
          if (!t3.renderWorldCopies || t3.maxBounds)
            return;
          const i2 = e2.lng - t3.center.lng;
          e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        _emulate(e2, t3, i2) {
          const o2 = Math.ceil(15 * t3 / 1e3), r3 = [], n3 = e2(i2.clone());
          for (let e3 = 0; e3 <= o2; e3++) {
            const t4 = n3(e3 / o2);
            r3.push(t4.clone());
          }
          return r3;
        }
      }
      class Kr {
        constructor(t3 = {}) {
          this.options = t3, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e2) {
          const t3 = this.options && this.options.compact;
          return this._map = e2, this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n2("button", "mapboxgl-ctrl-attrib-button", this._container), n2("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n2("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t3 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), t3 === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e2, t3) {
          const i2 = this._map._getUIString(`AttributionControl.${t3}`);
          e2.setAttribute("aria-label", i2), e2.removeAttribute("title"), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let t3 = this._editLink;
          t3 || (t3 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }];
          if (t3) {
            const o2 = i2.reduce((e2, t4, o3) => (t4.value && (e2 += `${t4.key}=${t4.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
            t3.href = `${e.config.FEEDBACK_URL}/${o2}#${er(this._map, true)}`, t3.rel = "noopener nofollow", this._setElementTitle(t3, "MapFeedback");
          }
        }
        _updateData(e2) {
          !e2 || e2.sourceDataType !== "metadata" && e2.sourceDataType !== "visibility" && e2.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e2 = [];
          if (this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t3 = this._map.style._sourceCaches;
          for (const i3 in t3) {
            const o2 = t3[i3];
            if (o2.used) {
              const t4 = o2.getSource();
              t4.attribution && e2.indexOf(t4.attribution) < 0 && e2.push(t4.attribution);
            }
          }
          e2.sort((e3, t4) => e3.length - t4.length), e2 = e2.filter((t4, i3) => {
            for (let o2 = i3 + 1; o2 < e2.length; o2++)
              if (e2[o2].indexOf(t4) >= 0)
                return false;
            return true;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
          const i2 = e2.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class Jr {
        constructor() {
          e.bindAll(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(e2) {
          this._map = e2, this._container = n2("div", "mapboxgl-ctrl");
          const t3 = n2("a", "mapboxgl-ctrl-logo");
          return t3.target = "_blank", t3.rel = "noopener nofollow", t3.href = "https://www.mapbox.com/", t3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t3), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e2) {
          e2 && e2.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return true;
          const e2 = this._map.style._sourceCaches;
          if (Object.entries(e2).length === 0)
            return true;
          for (const t3 in e2) {
            const i2 = e2[t3].getSource();
            if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
              return false;
          }
          return true;
        }
        _updateCompact() {
          const e2 = this._container.children;
          if (e2.length) {
            const t3 = e2[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t3.classList.add("mapboxgl-compact") : t3.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Qr {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e2) {
          const t3 = ++this._id;
          return this._queue.push({ callback: e2, id: t3, cancelled: false }), t3;
        }
        remove(e2) {
          const t3 = this._currentlyRunning, i2 = t3 ? this._queue.concat(t3) : this._queue;
          for (const t4 of i2)
            if (t4.id === e2)
              return void (t4.cancelled = true);
        }
        run(e2 = 0) {
          const t3 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of t3)
            if (!i2.cancelled && (i2.callback(e2), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      function en(t3, i2, o2) {
        if (t3 = new e.LngLat(t3.lng, t3.lat), i2) {
          const r3 = new e.LngLat(t3.lng - 360, t3.lat), n3 = new e.LngLat(t3.lng + 360, t3.lat), a2 = 360 * Math.ceil(Math.abs(t3.lng - o2.center.lng) / 360), s2 = o2.locationPoint(t3).distSqr(i2), l3 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
          o2.locationPoint(r3).distSqr(i2) < s2 && (l3 || Math.abs(r3.lng - o2.center.lng) < a2) ? t3 = r3 : o2.locationPoint(n3).distSqr(i2) < s2 && (l3 || Math.abs(n3.lng - o2.center.lng) < a2) && (t3 = n3);
        }
        for (; Math.abs(t3.lng - o2.center.lng) > 180; ) {
          const e2 = o2.locationPoint(t3);
          if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height)
            break;
          t3.lng > o2.center.lng ? t3.lng -= 360 : t3.lng += 360;
        }
        return t3;
      }
      const tn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class on extends e.Evented {
        constructor(t3, i2) {
          if (super(), (t3 instanceof e.window.HTMLElement || i2) && (t3 = e.extend({ element: t3 }, i2)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t3 && t3.anchor || "center", this._color = t3 && t3.color || "#3FB1CE", this._scale = t3 && t3.scale || 1, this._draggable = t3 && t3.draggable || false, this._clickTolerance = t3 && t3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t3 && t3.rotation || 0, this._rotationAlignment = t3 && t3.rotationAlignment || "auto", this._pitchAlignment = t3 && t3.pitchAlignment && t3.pitchAlignment || "auto", this._updateMoving = () => this._update(true), t3 && t3.element)
            this._element = t3.element, this._offset = e.pointGeometry.convert(t3 && t3.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = n2("div");
            const i3 = 41, o3 = 27, r3 = a("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i3}` }, this._element), s2 = a("radialGradient", { id: "shadowGradient" }, a("defs", {}, r3));
            a("stop", { offset: "10%", "stop-opacity": 0.4 }, s2), a("stop", { offset: "100%", "stop-opacity": 0.05 }, s2), a("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), a("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), a("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), a("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = e.pointGeometry.convert(t3 && t3.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
            e2.preventDefault();
          }), this._element.addEventListener("mousedown", (e2) => {
            e2.preventDefault();
          });
          const o2 = this._element.classList;
          for (const e2 in tn)
            o2.remove(`mapboxgl-marker-anchor-${e2}`);
          o2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
        }
        addTo(e2) {
          return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
        }
        remove() {
          const e2 = this._map;
          return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t3) {
          return this._lngLat = e.LngLat.convert(t3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
            if (!("offset" in e2.options)) {
              const t3 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
              e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t3], "bottom-left": [o2, -1 * (t3 - i2 + o2)], "bottom-right": [-o2, -1 * (t3 - i2 + o2)], left: [i2, -1 * (t3 - i2)], right: [-i2, -1 * (t3 - i2)] } : this._offset;
            }
            this._popup = e2, e2._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(e2) {
          const t3 = e2.code, i2 = e2.charCode || e2.keyCode;
          t3 !== "Space" && t3 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
        }
        _onMapClick(e2) {
          const t3 = e2.originalEvent.target, i2 = this._element;
          this._popup && (t3 === i2 || i2.contains(t3)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e2 = this._popup;
          return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const e2 = this._map;
          if (!e2)
            return false;
          const t3 = e2.unproject(this._pos), i2 = e2.getFreeCameraOptions();
          if (!i2.position)
            return false;
          const o2 = i2.position.toLngLat();
          return o2.distanceTo(t3) < 0.9 * o2.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t3 = this._map;
          if (!t3)
            return;
          const i2 = this._pos;
          if (!i2 || i2.x < 0 || i2.x > t3.transform.width || i2.y < 0 || i2.y > t3.transform.height)
            return void this._clearFadeTimer();
          const o2 = t3.unproject(i2);
          let r3;
          t3._showingGlobe() && e.isLngLatBehindGlobe(t3.transform, this._lngLat) ? r3 = 0 : (r3 = 1 - t3._queryFogOpacity(o2), t3.transform._terrainEnabled() && t3.getTerrain() && this._behindTerrain() && (r3 *= 0.2)), this._element.style.opacity = `${r3}`, this._element.style.pointerEvents = r3 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r3), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const e2 = this._pos;
          if (!e2 || !this._map)
            return;
          const t3 = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${tn[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t3.x}px,${t3.y}px)
        `;
        }
        _calculateXYTransform() {
          const t3 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
          if (!i2 || !t3 || o2 !== "map")
            return "";
          if (!i2._showingGlobe()) {
            const e2 = i2.getPitch();
            return e2 ? `rotateX(${e2}deg)` : "";
          }
          const r3 = e.radToDeg(e.globeTiltAtLngLat(i2.transform, this._lngLat)), n3 = t3.sub(e.globeCenterToScreenPoint(i2.transform)), a2 = Math.abs(n3.x) + Math.abs(n3.y);
          if (a2 === 0)
            return "";
          const s2 = r3 / a2;
          return `rotateX(${-n3.y * s2}deg) rotateY(${n3.x * s2}deg)`;
        }
        _calculateZTransform() {
          const t3 = this._pos, i2 = this._map;
          if (!i2 || !t3)
            return "";
          let o2 = 0;
          const r3 = this.getRotationAlignment();
          if (r3 === "map")
            if (i2._showingGlobe()) {
              const t4 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), r4 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t4);
              o2 = e.radToDeg(Math.atan2(r4.y, r4.x)) - 90;
            } else
              o2 = -i2.getBearing();
          else if (r3 === "horizon") {
            const r4 = e.smoothstep(4, 6, i2.getZoom()), n3 = e.globeCenterToScreenPoint(i2.transform);
            n3.y += r4 * i2.transform.height;
            const a2 = t3.sub(n3), s2 = e.radToDeg(Math.atan2(a2.y, a2.x));
            o2 = (s2 > 90 ? s2 - 270 : s2 + 90) * (1 - r4);
          }
          return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
        }
        _update(t3) {
          e.window.cancelAnimationFrame(this._updateFrameId);
          const i2 = this._map;
          i2 && (i2.transform.renderWorldCopies && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), this._pos = i2.project(this._lngLat), t3 === true ? this._updateFrameId = e.window.requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), i2._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i2._showingGlobe() || i2.getTerrain() || i2.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t3) {
          return this._offset = e.pointGeometry.convert(t3), this._update(), this;
        }
        _onMove(t3) {
          const i2 = this._map;
          if (i2) {
            if (!this._isDragging) {
              const e2 = this._clickTolerance || i2._clickTolerance;
              this._isDragging = t3.point.dist(this._pointerdownPos) >= e2;
            }
            this._isDragging && (this._pos = t3.point.sub(this._positionDelta), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag")));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
          const t3 = this._map;
          t3 && (t3.off("mousemove", this._onMove), t3.off("touchmove", this._onMove)), this._state === "active" && this.fire(new e.Event("dragend")), this._state = "inactive";
        }
        _addDragHandler(e2) {
          const t3 = this._map;
          t3 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(this._pos), this._pointerdownPos = e2.point, this._state = "pending", t3.on("mousemove", this._onMove), t3.on("touchmove", this._onMove), t3.once("mouseup", this._onUp), t3.once("touchend", this._onUp));
        }
        setDraggable(e2) {
          this._draggable = !!e2;
          const t3 = this._map;
          return t3 && (e2 ? (t3.on("mousedown", this._addDragHandler), t3.on("touchstart", this._addDragHandler)) : (t3.off("mousedown", this._addDragHandler), t3.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e2) {
          return this._rotation = e2 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e2) {
          return this._rotationAlignment = e2 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(e2) {
          return this._pitchAlignment = e2 || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment;
        }
      }
      class rn {
        constructor(e2) {
          this.jumpTo(e2);
        }
        getValue(t3) {
          if (t3 <= this._startTime)
            return this._start;
          if (t3 >= this._endTime)
            return this._end;
          const i2 = e.easeCubicInOut((t3 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - i2) + this._end * i2;
        }
        isEasing(e2) {
          return e2 >= this._startTime && e2 <= this._endTime;
        }
        jumpTo(e2) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
        }
        easeTo(e2, t3, i2) {
          this._start = this.getValue(t3), this._end = e2, this._startTime = t3, this._endTime = t3 + i2;
        }
      }
      const nn = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, an = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true };
      function sn(e2) {
        e2.parentNode && e2.parentNode.removeChild(e2);
      }
      const ln = { showCompass: true, showZoom: true, visualizePitch: false };
      class cn {
        constructor(t3, i2, o2 = false) {
          this._clickTolerance = 10, this.element = i2, this.mouseRotate = new wr({ clickTolerance: t3.dragRotate._mouseRotate._clickTolerance }), this.map = t3, o2 && (this.mousePitch = new Tr({ clickTolerance: t3.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
        }
        down(e2, t3) {
          this.mouseRotate.mousedown(e2, t3), this.mousePitch && this.mousePitch.mousedown(e2, t3), h();
        }
        move(e2, t3) {
          const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t3), r3 = o2 && o2.bearingDelta;
          if (r3 && i2.setBearing(i2.getBearing() + r3), this.mousePitch) {
            const o3 = this.mousePitch.mousemoveWindow(e2, t3), r4 = o3 && o3.pitchDelta;
            r4 && i2.setPitch(i2.getPitch() + r4);
          }
        }
        off() {
          const e2 = this.element;
          e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart, { passive: false }), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          u2(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t3) {
          this.down(e.extend({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), p2(this.element, t3)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(e2) {
          this.move(e2, p2(this.element, e2));
        }
        mouseup(e2) {
          this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
        }
        touchstart(e2) {
          e2.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = m2(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
        }
        touchmove(e2) {
          e2.targetTouches.length !== 1 ? this.reset() : (this._lastPos = m2(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
        }
        touchend(e2) {
          e2.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const hn = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, un = { maxWidth: 100, unit: "metric" };
      function _n(e2, t3, i2) {
        const o2 = dn(t3), r3 = o2 / t3, n3 = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }[i2];
        this._map._requestDomTask(() => {
          this._container.style.width = e2 * r3 + "px", this._container.innerHTML = `${o2}&nbsp;${n3}`;
        });
      }
      function dn(e2) {
        const t3 = Math.pow(10, `${Math.floor(e2)}`.length - 1);
        let i2 = e2 / t3;
        return i2 = i2 >= 10 ? 10 : i2 >= 5 ? 5 : i2 >= 3 ? 3 : i2 >= 2 ? 2 : i2 >= 1 ? 1 : function(e3) {
          const t4 = Math.pow(10, Math.ceil(-Math.log(e3) / Math.LN10));
          return Math.round(e3 * t4) / t4;
        }(i2), t3 * i2;
      }
      const pn = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, mn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function fn(t3 = new e.pointGeometry(0, 0), i2 = "bottom") {
        if (typeof t3 == "number") {
          const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t3, 2)));
          switch (i2) {
            case "top":
              return new e.pointGeometry(0, t3);
            case "top-left":
              return new e.pointGeometry(o2, o2);
            case "top-right":
              return new e.pointGeometry(-o2, o2);
            case "bottom":
              return new e.pointGeometry(0, -t3);
            case "bottom-left":
              return new e.pointGeometry(o2, -o2);
            case "bottom-right":
              return new e.pointGeometry(-o2, -o2);
            case "left":
              return new e.pointGeometry(t3, 0);
            case "right":
              return new e.pointGeometry(-t3, 0);
          }
          return new e.pointGeometry(0, 0);
        }
        return t3 instanceof e.pointGeometry || Array.isArray(t3) ? e.pointGeometry.convert(t3) : e.pointGeometry.convert(t3[i2] || [0, 0]);
      }
      const gn = { version: e.version, supported: i, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends Yr {
        constructor(t3) {
          if ((t3 = e.extend({}, an, t3)).minZoom != null && t3.maxZoom != null && t3.minZoom > t3.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (t3.minPitch != null && t3.maxPitch != null && t3.minPitch > t3.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (t3.minPitch != null && t3.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t3.maxPitch != null && t3.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t3.antialias && e.isSafariWithAntialiasingBug(e.window) && (t3.antialias = false, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ko(t3.minZoom, t3.maxZoom, t3.minPitch, t3.maxPitch, t3.renderWorldCopies), t3), this._interactive = t3.interactive, this._minTileCacheSize = t3.minTileCacheSize, this._maxTileCacheSize = t3.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t3.preserveDrawingBuffer, this._antialias = t3.antialias, this._trackResize = t3.trackResize, this._bearingSnap = t3.bearingSnap, this._refreshExpiredTiles = t3.refreshExpiredTiles, this._fadeDuration = t3.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t3.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t3.collectResourceTiming, this._optimizeForTerrain = t3.optimizeForTerrain, this._language = t3.language === "auto" ? e.window.navigator.language : t3.language, this._worldview = t3.worldview, this._renderTaskQueue = new Qr(), this._domRenderTaskQueue = new Qr(), this._controls = [], this._markers = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, nn, t3.locale), this._clickTolerance = t3.clickTolerance, this._cooperativeGestures = t3.cooperativeGestures, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new rn(0), this._useExplicitProjection = false, this._requestManager = new e.RequestManager(t3.transformRequest, t3.accessToken, t3.testMode), this._silenceAuthErrors = !!t3.testMode, typeof t3.container == "string") {
            if (this._container = e.window.document.getElementById(t3.container), !this._container)
              throw new Error(`Container '${t3.container}' not found.`);
          } else {
            if (!(t3.container instanceof e.window.HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t3.container;
          }
          if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t3.maxBounds && this.setMaxBounds(t3.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), e.window !== void 0 && (e.window.addEventListener("online", this._onWindowOnline, false), e.window.addEventListener("resize", this._onWindowResize, false), e.window.addEventListener("orientationchange", this._onWindowResize, false), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false)), this.handlers = new $r(this, t3), this._localFontFamily = t3.localFontFamily, this._localIdeographFontFamily = t3.localIdeographFontFamily, t3.style && this.setStyle(t3.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t3.projection && this.setProjection(t3.projection), this._hash = t3.hash && new Qo(typeof t3.hash == "string" && t3.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t3.center, zoom: t3.zoom, bearing: t3.bearing, pitch: t3.pitch }), t3.bounds && (this.resize(), this.fitBounds(t3.bounds, e.extend({}, t3.fitBoundsOptions, { duration: 0 })))), this.resize(), t3.attributionControl && this.addControl(new Kr({ customAttribution: t3.customAttribution })), this._logoControl = new Jr(), this.addControl(this._logoControl, t3.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (t4) => {
            this._update(t4.dataType === "style"), this.fire(new e.Event(`${t4.dataType}data`, t4));
          }), this.on("dataloading", (t4) => {
            this.fire(new e.Event(`${t4.dataType}dataloading`, t4));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t3, i2) {
          if (i2 === void 0 && (i2 = t3.getDefaultPosition ? t3.getDefaultPosition() : "top-right"), !t3 || !t3.onAdd)
            return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o2 = t3.onAdd(this);
          this._controls.push(t3);
          const r3 = this._controlPositions[i2];
          return i2.indexOf("bottom") !== -1 ? r3.insertBefore(o2, r3.firstChild) : r3.appendChild(o2), this;
        }
        removeControl(t3) {
          if (!t3 || !t3.onRemove)
            return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(t3);
          return i2 > -1 && this._controls.splice(i2, 1), t3.onRemove(this), this;
        }
        hasControl(e2) {
          return this._controls.indexOf(e2) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(t3) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const i2 = !this._moving;
          return i2 && this.fire(new e.Event("movestart", t3)).fire(new e.Event("move", t3)), this.fire(new e.Event("resize", t3)), i2 && this.fire(new e.Event("moveend", t3)), this;
        }
        getBounds() {
          return this.transform.projection.name === "globe" && e.warnOnce('Globe projection does not support getBounds API, this API may behave unexpectedly."'), this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(t3) {
          return this.transform.setMaxBounds(e.LngLatBounds.convert(t3)), this._update();
        }
        setMinZoom(t3) {
          if ((t3 = t3 == null ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom)
            return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 ? this.setZoom(t3) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t3) {
          if ((t3 = t3 == null ? 22 : t3) >= this.transform.minZoom)
            return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 ? this.setZoom(t3) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t3) {
          if ((t3 = t3 == null ? 0 : t3) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t3 >= 0 && t3 <= this.transform.maxPitch)
            return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 ? this.setPitch(t3) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t3) {
          if ((t3 = t3 == null ? 85 : t3) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t3 >= this.transform.minPitch)
            return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 ? this.setPitch(t3) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e2) {
          return this.transform.renderWorldCopies = e2, this._update();
        }
        getLanguage() {
          return this._language;
        }
        setLanguage(t3) {
          if (this._language = t3 === "auto" ? e.window.navigator.language : t3, this.style)
            for (const e2 in this.style._sourceCaches) {
              const t4 = this.style._sourceCaches[e2]._source;
              t4._setLanguage && t4._setLanguage(this._language);
            }
          for (const e2 of this._controls)
            e2._setLanguage && e2._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e2) {
          if (this._worldview = e2, this.style)
            for (const t3 in this.style._sourceCaches) {
              const i2 = this.style._sourceCaches[t3]._source;
              i2._setWorldview && i2._setWorldview(e2);
            }
          return this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return this.transform.projection.name === "globe";
        }
        setProjection(e2) {
          return this._lazyInitEmptyStyle(), e2 ? typeof e2 == "string" && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.stylesheet ? this.style.stylesheet.projection : null);
        }
        _updateProjectionTransition() {
          if (this.getProjection().name !== "globe")
            return;
          const t3 = this.transform, i2 = t3.projection.name;
          let o2;
          i2 === "globe" && t3.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t3.setMercatorFromTransition(), o2 = true) : i2 === "mercator" && t3.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t3.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e2, t3) {
          return this._updateProjection(e2 || t3 || { name: "mercator" });
        }
        _updateProjection(t3) {
          let i2;
          if (i2 = t3.name === "globe" && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t3), this.style.applyProjectionUpdate(), i2) {
            this.painter.clearBackgroundTiles();
            for (const e2 in this.style._sourceCaches)
              this.style._sourceCaches[e2].clearTiles();
            this._update(true);
          }
          return this;
        }
        project(t3) {
          return this.transform.locationPoint3D(e.LngLat.convert(t3));
        }
        unproject(t3) {
          return this.transform.pointLocation3D(e.pointGeometry.convert(t3));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || false;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || false;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || false;
        }
        _createDelegatedListener(e2, t3, i2) {
          if (e2 === "mouseenter" || e2 === "mouseover") {
            let o2 = false;
            const r3 = (r4) => {
              const n4 = t3.filter((e3) => this.getLayer(e3)), a2 = n4.length ? this.queryRenderedFeatures(r4.point, { layers: n4 }) : [];
              a2.length ? o2 || (o2 = true, i2.call(this, new cr(e2, this, r4.originalEvent, { features: a2 }))) : o2 = false;
            }, n3 = () => {
              o2 = false;
            };
            return { layers: new Set(t3), listener: i2, delegates: { mousemove: r3, mouseout: n3 } };
          }
          if (e2 === "mouseleave" || e2 === "mouseout") {
            let o2 = false;
            const r3 = (r4) => {
              const n4 = t3.filter((e3) => this.getLayer(e3));
              (n4.length ? this.queryRenderedFeatures(r4.point, { layers: n4 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new cr(e2, this, r4.originalEvent)));
            }, n3 = (t4) => {
              o2 && (o2 = false, i2.call(this, new cr(e2, this, t4.originalEvent)));
            };
            return { layers: new Set(t3), listener: i2, delegates: { mousemove: r3, mouseout: n3 } };
          }
          {
            const o2 = (e3) => {
              const o3 = t3.filter((e4) => this.getLayer(e4)), r3 = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
              r3.length && (e3.features = r3, i2.call(this, e3), delete e3.features);
            };
            return { layers: new Set(t3), listener: i2, delegates: { [e2]: o2 } };
          }
        }
        on(e2, t3, i2) {
          if (i2 === void 0)
            return super.on(e2, t3);
          Array.isArray(t3) || (t3 = [t3]);
          const o2 = this._createDelegatedListener(e2, t3, i2);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
          for (const e3 in o2.delegates)
            this.on(e3, o2.delegates[e3]);
          return this;
        }
        once(e2, t3, i2) {
          if (i2 === void 0)
            return super.once(e2, t3);
          Array.isArray(t3) || (t3 = [t3]);
          const o2 = this._createDelegatedListener(e2, t3, i2);
          for (const e3 in o2.delegates)
            this.once(e3, o2.delegates[e3]);
          return this;
        }
        off(e2, t3, i2) {
          if (i2 === void 0)
            return super.off(e2, t3);
          t3 = new Set(Array.isArray(t3) ? t3 : [t3]);
          const o2 = (e3, t4) => {
            if (e3.size !== t4.size)
              return false;
            for (const i3 of e3)
              if (!t4.has(i3))
                return false;
            return true;
          }, r3 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
          return r3 && ((e3) => {
            for (let r4 = 0; r4 < e3.length; r4++) {
              const n3 = e3[r4];
              if (n3.listener === i2 && o2(n3.layers, t3)) {
                for (const e4 in n3.delegates)
                  this.off(e4, n3.delegates[e4]);
                return e3.splice(r4, 1), this;
              }
            }
          })(r3), this;
        }
        queryRenderedFeatures(t3, i2) {
          return this.style ? (i2 !== void 0 || t3 === void 0 || t3 instanceof e.pointGeometry || Array.isArray(t3) || (i2 = t3, t3 = void 0), this.style.queryRenderedFeatures(t3 = t3 || [[0, 0], [this.transform.width, this.transform.height]], i2 = i2 || {}, this.transform)) : [];
        }
        querySourceFeatures(e2, t3) {
          return this.style.querySourceFeatures(e2, t3);
        }
        queryTerrainElevation(t3, i2) {
          const o2 = this.transform.elevation;
          return o2 ? (i2 = e.extend({}, { exaggerated: true }, i2), o2.getAtPoint(e.MercatorCoordinate.fromLngLat(t3), null, i2.exaggerated)) : null;
        }
        setStyle(t3, i2) {
          return (i2 = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff !== false && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && t3 ? (this._diffStyle(t3, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t3, i2));
        }
        _getUIString(e2) {
          const t3 = this._locale[e2];
          if (t3 == null)
            throw new Error(`Missing UI string '${e2}'`);
          return t3;
        }
        _updateStyle(e2, t3) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e2 && (this.style = new ei2(this, t3 || {}), this.style.setEventedParent(this, { style: this.style }), typeof e2 == "string" ? this.style.loadURL(e2) : this.style.loadJSON(e2)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new ei2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(t3, i2) {
          if (typeof t3 == "string") {
            const o2 = this._requestManager.normalizeStyleURL(t3), r3 = this._requestManager.transformRequest(o2, e.ResourceType.Style);
            e.getJSON(r3, (t4, o3) => {
              t4 ? this.fire(new e.ErrorEvent(t4)) : o3 && this._updateDiff(o3, i2);
            });
          } else
            typeof t3 == "object" && this._updateDiff(t3, i2);
        }
        _updateDiff(t3, i2) {
          try {
            this.style.setState(t3) && this._update(true);
          } catch (o2) {
            e.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t3, i2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), false);
        }
        addSource(e2, t3) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e2, t3), this._update(true);
        }
        isSourceLoaded(e2) {
          return !!this.style && this.style._isSourceCacheLoaded(e2);
        }
        areTilesLoaded() {
          const e2 = this.style && this.style._sourceCaches;
          for (const t3 in e2) {
            const i2 = e2[t3]._tiles;
            for (const e3 in i2) {
              const t4 = i2[e3];
              if (t4.state !== "loaded" && t4.state !== "errored")
                return false;
            }
          }
          return true;
        }
        addSourceType(e2, t3, i2) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t3, i2);
        }
        removeSource(e2) {
          return this.style.removeSource(e2), this._updateTerrain(), this._update(true);
        }
        getSource(e2) {
          return this.style.getSource(e2);
        }
        addImage(t3, i2, { pixelRatio: o2 = 1, sdf: r3 = false, stretchX: n3, stretchY: a2, content: s2 } = {}) {
          if (this._lazyInitEmptyStyle(), i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap) {
            const { width: l3, height: c2, data: h3 } = e.exported.getImageData(i2);
            this.style.addImage(t3, { data: new e.RGBAImage({ width: l3, height: c2 }, h3), pixelRatio: o2, stretchX: n3, stretchY: a2, content: s2, sdf: r3, version: 0 });
          } else if (i2.width === void 0 || i2.height === void 0)
            this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: l3, height: c2 } = i2, h3 = i2;
            this.style.addImage(t3, { data: new e.RGBAImage({ width: l3, height: c2 }, new Uint8Array(h3.data)), pixelRatio: o2, stretchX: n3, stretchY: a2, content: s2, sdf: r3, version: 0, userImage: h3 }), h3.onAdd && h3.onAdd(this, t3);
          }
        }
        updateImage(t3, i2) {
          const o2 = this.style.getImage(t3);
          if (!o2)
            return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r3 = i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? e.exported.getImageData(i2) : i2, { width: n3, height: a2 } = r3;
          n3 !== void 0 && a2 !== void 0 ? n3 === o2.data.width && a2 === o2.data.height ? (o2.data.replace(r3.data, !(i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap)), this.style.updateImage(t3, o2)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n3}, ${a2})
                must be that same as the previous version of the image
                (${o2.data.width}, ${o2.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
        }
        hasImage(t3) {
          return t3 ? !!this.style.getImage(t3) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), false);
        }
        removeImage(e2) {
          this.style.removeImage(e2);
        }
        loadImage(t3, i2) {
          e.getImage(this._requestManager.transformRequest(t3, e.ResourceType.Image), (t4, o2) => {
            i2(t4, o2 instanceof e.window.HTMLImageElement ? e.exported.getImageData(o2) : o2);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(e2, t3) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t3), this._update(true);
        }
        moveLayer(e2, t3) {
          return this.style.moveLayer(e2, t3), this._update(true);
        }
        removeLayer(e2) {
          return this.style.removeLayer(e2), this._update(true);
        }
        getLayer(e2) {
          return this.style.getLayer(e2);
        }
        setLayerZoomRange(e2, t3, i2) {
          return this.style.setLayerZoomRange(e2, t3, i2), this._update(true);
        }
        setFilter(e2, t3, i2 = {}) {
          return this.style.setFilter(e2, t3, i2), this._update(true);
        }
        getFilter(e2) {
          return this.style.getFilter(e2);
        }
        setPaintProperty(e2, t3, i2, o2 = {}) {
          return this.style.setPaintProperty(e2, t3, i2, o2), this._update(true);
        }
        getPaintProperty(e2, t3) {
          return this.style.getPaintProperty(e2, t3);
        }
        setLayoutProperty(e2, t3, i2, o2 = {}) {
          return this.style.setLayoutProperty(e2, t3, i2, o2), this._update(true);
        }
        getLayoutProperty(e2, t3) {
          return this.style.getLayoutProperty(e2, t3);
        }
        setLight(e2, t3 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e2, t3), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setTerrain(e2) {
          return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e2) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        _queryFogOpacity(t3) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t3), this.transform) : 0;
        }
        setFeatureState(e2, t3) {
          return this.style.setFeatureState(e2, t3), this._update();
        }
        removeFeatureState(e2, t3) {
          return this.style.removeFeatureState(e2, t3), this._update();
        }
        getFeatureState(e2) {
          return this.style.getFeatureState(e2);
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const t3 = this._container.getBoundingClientRect().width || 400, i2 = this._container.getBoundingClientRect().height || 300;
          let o2, r3, n3, a2 = this._container;
          for (; a2 && (!r3 || !n3); ) {
            const t4 = e.window.getComputedStyle(a2).transform;
            t4 && t4 !== "none" && (o2 = t4.match(/matrix.*\((.+)\)/)[1].split(", "), o2[0] && o2[0] !== "0" && o2[0] !== "1" && (r3 = o2[0]), o2[3] && o2[3] !== "0" && o2[3] !== "1" && (n3 = o2[3])), a2 = a2.parentElement;
          }
          this._containerWidth = r3 ? Math.abs(t3 / r3) : t3, this._containerHeight = n3 ? Math.abs(i2 / n3) : i2;
        }
        _detectMissingCSS() {
          e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e2 = this._container;
          e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = n2("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
          const t3 = this._canvasContainer = n2("div", "mapboxgl-canvas-container", e2);
          this._interactive && t3.classList.add("mapboxgl-interactive"), this._canvas = n2("canvas", "mapboxgl-canvas", t3), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i2 = this._controlContainer = n2("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
            o2[e3] = n2("div", `mapboxgl-ctrl-${e3}`, i2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t3, i2) {
          const o2 = e.exported.devicePixelRatio || 1;
          this._canvas.width = o2 * Math.ceil(t3), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${i2}px`;
        }
        _addMarker(e2) {
          this._markers.push(e2);
        }
        _removeMarker(e2) {
          const t3 = this._markers.indexOf(e2);
          t3 !== -1 && this._markers.splice(t3, 1);
        }
        _setupPainter() {
          const t3 = e.extend({}, i.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl", t3) || this._canvas.getContext("experimental-webgl", t3);
          o2 ? (e.storeAuthState(o2, true), this.painter = new Fo(o2, this.transform), this.on("data", (e2) => {
            e2.dataType === "source" && this.painter.setTileLoadedFlag(true);
          }), e.exported$1.testSupport(o2)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
        }
        _contextLost(t3) {
          t3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t3 }));
        }
        _contextRestored(t3) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t3 }));
        }
        _onMapScroll(e2) {
          if (e2.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e2) {
          return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e2) {
          return this._update(), this._renderTaskQueue.add(e2);
        }
        _cancelRenderFrame(e2) {
          this._renderTaskQueue.remove(e2);
        }
        _requestDomTask(e2) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
        }
        _render(t3) {
          let i2;
          const o2 = this.painter.context.extTimerQuery, r3 = e.exported.now();
          if (this.listens("gpu-timing-frame") && (i2 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i2)), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t3), this._domRenderTaskQueue.run(t3), this._removed)
            return;
          this._updateProjectionTransition();
          let n3 = false;
          const a2 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t4 = this.transform.zoom, i3 = this.transform.pitch, o3 = e.exported.now();
            this.style.zoomHistory.update(t4, o3);
            const r4 = new e.EvaluationParameters(t4, { now: o3, fadeDuration: a2, pitch: i3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), s3 = r4.crossFadingFactor();
            s3 === 1 && s3 === this._crossFadingFactor || (n3 = true, this._crossFadingFactor = s3), this.style.update(r4);
          }
          this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
          let s2 = false;
          if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), s2 = this._updateAverageElevation(r3), this.style._updateSources(this.transform), this._forceMarkerUpdate()) : s2 = this._updateAverageElevation(r3), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, a2, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: a2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e.Event("load"))), this.style && (this.style.hasTransitions() || n3) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i2) {
            const t4 = e.exported.now() - r3;
            o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
              const n4 = o2.getQueryObjectEXT(i2, o2.QUERY_RESULT_EXT) / 1e6;
              o2.deleteQueryEXT(i2), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t4, gpuTime: n4 })), e.window.performance.mark("frame-gpu", { startTime: r3, detail: { gpuTime: n4 } });
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const t4 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i3 = this.painter.queryGpuTimers(t4);
              this.fire(new e.Event("gpu-timing-layer", { layerTimes: i3 }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const t4 = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const i3 = this.painter.queryGpuTimeDeferredRender(t4);
              this.fire(new e.Event("gpu-timing-deferred-render", { gpuTime: i3 }));
            }, 50);
          }
          const l3 = this._sourcesDirty || this._styleDirty || this._placementDirty || s2;
          if (l3 || this._repaint)
            this.triggerRepaint();
          else {
            const t4 = !this.isMoving() && this.loaded();
            if (t4 && (s2 = this._updateAverageElevation(r3, true)), s2)
              this.triggerRepaint();
            else if (this._triggerFrame(false), t4 && (this.fire(new e.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const t5 = this._calculateSpeedIndex();
              this.fire(new e.Event("speedindexcompleted", { speedIndex: t5 })), this.speedIndexTiming = false;
            }
          }
          !this._loaded || this._fullyLoaded || l3 || (this._fullyLoaded = true, this._authenticate());
        }
        _forceMarkerUpdate() {
          for (const e2 of this._markers)
            e2._update();
        }
        _updateAverageElevation(e2, t3 = false) {
          const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing())
            return this.transform.averageElevation !== 0 && i2(0);
          if ((t3 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
            const t4 = this.transform.averageElevation;
            let o2 = this.transform.sampleAverageElevation(), r3 = false;
            this.transform.elevation && (r3 = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = e2;
            const n3 = Math.abs(t4 - o2);
            if (n3 > 1) {
              if (this._isInitialLoad || r3)
                return this._averageElevation.jumpTo(o2), i2(o2);
              this._averageElevation.easeTo(o2, e2, 300);
            } else if (n3 > 1e-4)
              return this._averageElevation.jumpTo(o2), i2(o2);
          }
          return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
        }
        _authenticate() {
          e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t3) => {
            if (t3 && (t3.message === e.AUTH_ERR_MSG || t3.status === 401)) {
              const t4 = this.painter.context.gl;
              e.storeAuthState(t4, false), this._logoControl instanceof Jr && this._logoControl._updateLogo(), t4 && t4.clear(t4.DEPTH_BUFFER_BIT | t4.COLOR_BUFFER_BIT | t4.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _updateTerrain() {
          this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming());
        }
        _calculateSpeedIndex() {
          const e2 = this.painter.canvasCopy(), t3 = this.painter.getCanvasCopiesAndTimestamps();
          t3.timeStamps.push(performance.now());
          const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
          function r3(e3) {
            i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
            const t4 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
            return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t4), t4;
          }
          return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r3(e2), t3.canvasCopies.map(r3), t3.timeStamps);
        }
        _canvasPixelComparison(e2, t3, i2) {
          let o2 = i2[1] - i2[0];
          const r3 = e2.length / 4;
          for (let n3 = 0; n3 < t3.length; n3++) {
            const a2 = t3[n3];
            let s2 = 0;
            for (let t4 = 0; t4 < a2.length; t4 += 4)
              a2[t4] === e2[t4] && a2[t4 + 1] === e2[t4 + 1] && a2[t4 + 2] === e2[t4 + 2] && a2[t4 + 3] === e2[t4 + 3] && (s2 += 1);
            o2 += (i2[n3 + 2] - i2[n3 + 1]) * (1 - s2 / r3);
          }
          return o2;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e2 of this._controls)
            e2.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), e.window !== void 0 && (e.window.removeEventListener("resize", this._onWindowResize, false), e.window.removeEventListener("orientationchange", this._onWindowResize, false), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.removeEventListener("online", this._onWindowOnline, false));
          const t3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t3 && t3.loseContext(), sn(this._canvasContainer), sn(this._controlContainer), sn(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), e.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e.Event("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(t3) {
          this._renderNextFrame = this._renderNextFrame || t3, this.style && !this._frame && (this._frame = e.exported.frame((e2) => {
            const t4 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t4 && this._render(e2);
          }));
        }
        _preloadTiles(t3) {
          const i2 = this.style ? Object.values(this.style._sourceCaches) : [];
          return e.asyncAll(i2, (e2, i3) => e2._preloadTiles(t3, i3), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e2) {
          this._trackResize && this.resize({ originalEvent: e2 })._update();
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e2) {
          this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e2) {
          this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e2) {
          this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e2) {
          this._showPadding !== e2 && (this._showPadding = e2, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e2) {
          this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e2) {
          this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e2) {
          this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e2) {
          this._vertices = e2, this._update();
        }
        _setCacheLimits(t3, i2) {
          e.setCacheLimits(t3, i2);
        }
        get version() {
          return e.version;
        }
      }, NavigationControl: class {
        constructor(t3) {
          this.options = e.extend({}, ln, t3), this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
            this._map && this._map.zoomIn({}, { originalEvent: e2 });
          }), n2("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
            this._map && this._map.zoomOut({}, { originalEvent: e2 });
          }), n2("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
            const t4 = this._map;
            t4 && (this.options.visualizePitch ? t4.resetNorthPitch({}, { originalEvent: e2 }) : t4.resetNorth({}, { originalEvent: e2 }));
          }), this._compassIcon = n2("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e2 = this._map;
          if (!e2)
            return;
          const t3 = e2.getZoom(), i2 = t3 === e2.getMaxZoom(), o2 = t3 === e2.getMinZoom();
          this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
        }
        _rotateCompassArrow() {
          const e2 = this._map;
          if (!e2)
            return;
          const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
          e2._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t3);
          });
        }
        onAdd(e2) {
          return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new cn(e2, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e2 = this._map;
          e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e2, t3) {
          const i2 = n2("button", e2, this._container);
          return i2.type = "button", i2.addEventListener("click", t3), i2;
        }
        _setButtonTitle(e2, t3) {
          if (!this._map)
            return;
          const i2 = this._map._getUIString(`NavigationControl.${t3}`);
          e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
        }
      }, GeolocateControl: class extends e.Evented {
        constructor(t3) {
          super(), this.options = e.extend({ geolocation: e.window.navigator.geolocation }, hn, t3), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Jo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e2) {
          return this._map = e2, this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
        }
        _checkGeolocationSupport(t3) {
          this._supportsGeolocation !== void 0 ? t3(this._supportsGeolocation) : e.window.navigator.permissions !== void 0 ? e.window.navigator.permissions.query({ name: "geolocation" }).then((e2) => {
            this._supportsGeolocation = e2.state !== "denied", t3(this._supportsGeolocation);
          }) : (this._supportsGeolocation = !!this.options.geolocation, t3(this._supportsGeolocation));
        }
        _isOutOfMapMaxBounds(e2) {
          const t3 = this._map.getMaxBounds(), i2 = e2.coords;
          return !!t3 && (i2.longitude < t3.getWest() || i2.longitude > t3.getEast() || i2.latitude < t3.getSouth() || i2.latitude > t3.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(t3) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t3))
              return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = t3, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t3), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t3)), this._finish();
          }
        }
        _updateCamera(t3) {
          const i2 = new e.LngLat(t3.coords.longitude, t3.coords.latitude), o2 = t3.coords.accuracy, r3 = this._map.getBearing(), n3 = e.extend({ bearing: r3 }, this.options.fitBoundsOptions);
          this._map.fitBounds(i2.toBounds(o2), n3, { geolocateSource: true });
        }
        _updateMarker(t3) {
          if (t3) {
            const i2 = new e.LngLat(t3.coords.longitude, t3.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const t3 = this._map.transform, i2 = e.mercatorZfromAltitude(1, t3._center.lat) * t3.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
          this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(t3) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (t3.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (t3.code === 3 && this._noTimeout)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t3)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(t3) {
          if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = n2("button", "mapboxgl-ctrl-geolocate", this._container), n2("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", t3 === false) {
            e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t4);
          } else {
            const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n2("div", "mapboxgl-user-location"), this._dotElement.appendChild(n2("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n2("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new on({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n2("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new on({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
            t4.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t4.originalEvent && t4.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
          });
        }
        _onDeviceOrientation(e2) {
          this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : e2.absolute === true && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return e.warnOnce("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let e2;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const t3 = () => {
            e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
          };
          e.window.DeviceMotionEvent !== void 0 && typeof e.window.DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((e2) => {
            e2 === "granted" && t3();
          }).catch(console.error) : t3();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: Kr, ScaleControl: class {
        constructor(t3) {
          this.options = e.extend({}, un, t3), function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "narrow", unit: "meter" }), true;
            } catch (e2) {
              return false;
            }
          }() || (this._setScale = _n.bind(this)), e.bindAll(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e2 = this.options.maxWidth || 100, t3 = this._map, i2 = t3._containerHeight / 2, o2 = t3._containerWidth / 2 - e2 / 2, r3 = t3.unproject([o2, i2]), n3 = t3.unproject([o2 + e2, i2]), a2 = r3.distanceTo(n3);
          if (this.options.unit === "imperial") {
            const t4 = 3.2808 * a2;
            t4 > 5280 ? this._setScale(e2, t4 / 5280, "mile") : this._setScale(e2, t4, "foot");
          } else
            this.options.unit === "nautical" ? this._setScale(e2, a2 / 1852, "nautical-mile") : a2 >= 1e3 ? this._setScale(e2, a2 / 1e3, "kilometer") : this._setScale(e2, a2, "meter");
        }
        _setScale(e2, t3, i2) {
          const o2 = dn(t3), r3 = o2 / t3;
          this._map._requestDomTask(() => {
            this._container.style.width = e2 * r3 + "px", this._container.innerHTML = i2 !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "narrow", unit: i2 }).format(o2) : `${o2}&nbsp;nm`;
          });
        }
        onAdd(e2) {
          return this._map = e2, this._language = e2.getLanguage(), this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e2) {
          this._language = e2, this._update();
        }
        setUnit(e2) {
          this.options.unit = e2, this._update();
        }
      }, FullscreenControl: class {
        constructor(t3) {
          this._fullscreen = false, t3 && t3.container && (t3.container instanceof e.window.HTMLElement ? this._container = t3.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(t3) {
          return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const t3 = this._fullscreenButton = n2("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          n2("span", "mapboxgl-ctrl-icon", t3).setAttribute("aria-hidden", "true"), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends e.Evented {
        constructor(t3) {
          super(), this.options = e.extend(Object.create(pn), t3), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t3 && t3.className ? t3.className.trim().split(/\s+/) : []);
        }
        addTo(t3) {
          return this._map && this.remove(), this._map = t3, this.options.closeOnClick && t3.on("preclick", this._onClose), this.options.closeOnMove && t3.on("move", this._onClose), t3.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (t3.on("mousemove", this._onMouseEvent), t3.on("mouseup", this._onMouseEvent), t3._canvasContainer.classList.add("mapboxgl-track-pointer")) : t3.on("move", this._update), this.fire(new e.Event("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const t3 = this._map;
          return t3 && (t3.off("move", this._update), t3.off("move", this._onClose), t3.off("preclick", this._onClose), t3.off("click", this._onClose), t3.off("remove", this.remove), t3.off("mousemove", this._onMouseEvent), t3.off("mouseup", this._onMouseEvent), t3.off("drag", this._onMouseEvent), this._map = void 0), this.fire(new e.Event("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t3) {
          this._lngLat = e.LngLat.convert(t3), this._pos = null, this._trackPointer = false, this._update();
          const i2 = this._map;
          return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = true, this._pos = null, this._update();
          const e2 = this._map;
          return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t3) {
          return this.setDOMContent(e.window.document.createTextNode(t3));
        }
        setHTML(t3) {
          const i2 = e.window.document.createDocumentFragment(), o2 = e.window.document.createElement("body");
          let r3;
          for (o2.innerHTML = t3; r3 = o2.firstChild, r3; )
            i2.appendChild(r3);
          return this.setDOMContent(i2);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e2) {
          return this.options.maxWidth = e2, this._update(), this;
        }
        setDOMContent(e2) {
          let t3 = this._content;
          if (t3)
            for (; t3.hasChildNodes(); )
              t3.firstChild && t3.removeChild(t3.firstChild);
          else
            t3 = this._content = n2("div", "mapboxgl-popup-content", this._container || void 0);
          if (t3.appendChild(e2), this.options.closeButton) {
            const e3 = this._closeButton = n2("button", "mapboxgl-popup-close-button", t3);
            e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e2) {
          return this._classList.add(e2), this._updateClassList(), this;
        }
        removeClassName(e2) {
          return this._classList.delete(e2), this._updateClassList(), this;
        }
        setOffset(e2) {
          return this.options.offset = e2, this._update(), this;
        }
        toggleClassName(e2) {
          let t3;
          return this._classList.delete(e2) ? t3 = false : (this._classList.add(e2), t3 = true), this._updateClassList(), t3;
        }
        _onMouseEvent(e2) {
          this._update(e2.point);
        }
        _getAnchor(e2) {
          if (this.options.anchor)
            return this.options.anchor;
          const t3 = this._map, i2 = this._container, o2 = this._pos;
          if (!t3 || !i2 || !o2)
            return "bottom";
          const r3 = i2.offsetWidth, n3 = i2.offsetHeight, a2 = o2.x < r3 / 2, s2 = o2.x > t3.transform.width - r3 / 2;
          if (o2.y + e2 < n3)
            return a2 ? "top-left" : s2 ? "top-right" : "top";
          if (o2.y > t3.transform.height - n3) {
            if (a2)
              return "bottom-left";
            if (s2)
              return "bottom-right";
          }
          return a2 ? "left" : s2 ? "right" : "bottom";
        }
        _updateClassList() {
          const e2 = this._container;
          if (!e2)
            return;
          const t3 = [...this._classList];
          t3.push("mapboxgl-popup"), this._anchor && t3.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t3.push("mapboxgl-popup-track-pointer"), e2.className = t3.join(" ");
        }
        _update(t3) {
          const i2 = this._map, o2 = this._content;
          if (!i2 || !this._lngLat && !this._trackPointer || !o2)
            return;
          let r3 = this._container;
          if (r3 || (r3 = this._container = n2("div", "mapboxgl-popup", i2.getContainer()), this._tip = n2("div", "mapboxgl-popup-tip", r3), r3.appendChild(o2)), this.options.maxWidth && r3.style.maxWidth !== this.options.maxWidth && (r3.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t3) {
            const e2 = this._pos = this._trackPointer && t3 ? t3 : i2.project(this._lngLat), o3 = fn(this.options.offset), r4 = this._anchor = this._getAnchor(o3.y), n3 = fn(this.options.offset, r4), a2 = e2.add(n3).round();
            i2._requestDomTask(() => {
              this._container && r4 && (this._container.style.transform = `${tn[r4]} translate(${a2.x}px,${a2.y}px)`);
            });
          }
          if (!this._marker && i2._showingGlobe()) {
            const t4 = e.isLngLatBehindGlobe(i2.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(t4);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e2 = this._container.querySelector(mn);
          e2 && e2.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e2) {
          this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
        }
      }, Marker: on, Style: ei2, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.pointGeometry, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: Zo, Evented: e.Evented, config: e.config, prewarm: function() {
        Ge2().acquire(Fe2);
      }, clearPrewarmedResources: function() {
        const e2 = Ne2;
        e2 && (e2.isPreloaded() && e2.numActive() === 1 ? (e2.release(Fe2), Ne2 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return e.config.ACCESS_TOKEN;
      }, set accessToken(t3) {
        e.config.ACCESS_TOKEN = t3;
      }, get baseApiUrl() {
        return e.config.API_URL;
      }, set baseApiUrl(t3) {
        e.config.API_URL = t3;
      }, get workerCount() {
        return Ue2.workerCount;
      }, set workerCount(e2) {
        Ue2.workerCount = e2;
      }, get maxParallelImageRequests() {
        return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(t3) {
        e.config.MAX_PARALLEL_IMAGE_REQUESTS = t3;
      }, clearStorage(t3) {
        e.clearTileCache(t3);
      }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow };
      return gn;
    });
    var mapboxgl$1 = mapboxgl2;
    return mapboxgl$1;
  });
})(mapboxGl$1);
var mapboxgl = mapboxGl$1.exports;
var mapboxGl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": mapboxgl
}, [mapboxGl$1.exports]));
var build = {};
const HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
const defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: (err) => typeof console !== "undefined" && console.warn(err),
  getWeek: (givenDate) => {
    const date2 = new Date(givenDate.getTime());
    date2.setHours(0, 0, 0, 0);
    date2.setDate(date2.getDate() + 3 - (date2.getDay() + 6) % 7);
    var week1 = new Date(date2.getFullYear(), 0, 4);
    return 1 + Math.round(((date2.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};
const english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: (nth) => {
    const s = nth % 100;
    if (s > 3 && s < 21)
      return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
const pad = (number2, length = 2) => `000${number2}`.slice(length * -1);
const int = (bool) => bool === true ? 1 : 0;
function debounce(fn, wait) {
  let t2;
  return function() {
    clearTimeout(t2);
    t2 = setTimeout(() => fn.apply(this, arguments), wait);
  };
}
const arrayify = (obj) => obj instanceof Array ? obj : [obj];
function toggleClass(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  const e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== void 0)
    e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  const wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (const key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      const path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}
const doNothing = () => void 0;
const monthToStr = (monthNumber, shorthand, locale2) => locale2.months[shorthand ? "shorthand" : "longhand"][monthNumber];
const revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale2) {
    dateObj.setMonth(locale2.months.longhand.indexOf(monthName));
  },
  G: (dateObj, hour) => {
    dateObj.setHours(parseFloat(hour));
  },
  H: (dateObj, hour) => {
    dateObj.setHours(parseFloat(hour));
  },
  J: (dateObj, day) => {
    dateObj.setDate(parseFloat(day));
  },
  K: (dateObj, amPM, locale2) => {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale2.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale2) {
    dateObj.setMonth(locale2.months.shorthand.indexOf(shortMonth));
  },
  S: (dateObj, seconds2) => {
    dateObj.setSeconds(parseFloat(seconds2));
  },
  U: (_, unixSeconds) => new Date(parseFloat(unixSeconds) * 1e3),
  W: function(dateObj, weekNum, locale2) {
    const weekNumber = parseInt(weekNum);
    const date2 = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date2.setDate(date2.getDate() - date2.getDay() + locale2.firstDayOfWeek);
    return date2;
  },
  Y: (dateObj, year) => {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: (_, ISODate) => new Date(ISODate),
  d: (dateObj, day) => {
    dateObj.setDate(parseFloat(day));
  },
  h: (dateObj, hour) => {
    dateObj.setHours(parseFloat(hour));
  },
  i: (dateObj, minutes2) => {
    dateObj.setMinutes(parseFloat(minutes2));
  },
  j: (dateObj, day) => {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: (dateObj, month) => {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: (dateObj, month) => {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: (dateObj, seconds2) => {
    dateObj.setSeconds(parseFloat(seconds2));
  },
  u: (_, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
  w: doNothing,
  y: (dateObj, year) => {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
const tokenRegex = {
  D: "(\\w+)",
  F: "(\\w+)",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "(\\w+)",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "(\\w+)",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
const formats = {
  Z: (date2) => date2.toISOString(),
  D: function(date2, locale2, options) {
    return locale2.weekdays.shorthand[formats.w(date2, locale2, options)];
  },
  F: function(date2, locale2, options) {
    return monthToStr(formats.n(date2, locale2, options) - 1, false, locale2);
  },
  G: function(date2, locale2, options) {
    return pad(formats.h(date2, locale2, options));
  },
  H: (date2) => pad(date2.getHours()),
  J: function(date2, locale2) {
    return locale2.ordinal !== void 0 ? date2.getDate() + locale2.ordinal(date2.getDate()) : date2.getDate();
  },
  K: (date2, locale2) => locale2.amPM[int(date2.getHours() > 11)],
  M: function(date2, locale2) {
    return monthToStr(date2.getMonth(), true, locale2);
  },
  S: (date2) => pad(date2.getSeconds()),
  U: (date2) => date2.getTime() / 1e3,
  W: function(date2, _, options) {
    return options.getWeek(date2);
  },
  Y: (date2) => pad(date2.getFullYear(), 4),
  d: (date2) => pad(date2.getDate()),
  h: (date2) => date2.getHours() % 12 ? date2.getHours() % 12 : 12,
  i: (date2) => pad(date2.getMinutes()),
  j: (date2) => date2.getDate(),
  l: function(date2, locale2) {
    return locale2.weekdays.longhand[date2.getDay()];
  },
  m: (date2) => pad(date2.getMonth() + 1),
  n: (date2) => date2.getMonth() + 1,
  s: (date2) => date2.getSeconds(),
  u: (date2) => date2.getTime(),
  w: (date2) => date2.getDay(),
  y: (date2) => String(date2.getFullYear()).substring(2)
};
const createDateFormatter = ({ config: config2 = defaults, l10n = english, isMobile = false }) => (dateObj, frmt, overrideLocale) => {
  const locale2 = overrideLocale || l10n;
  if (config2.formatDate !== void 0 && !isMobile) {
    return config2.formatDate(dateObj, frmt, locale2);
  }
  return frmt.split("").map((c, i, arr) => formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale2, config2) : c !== "\\" ? c : "").join("");
};
const createDateParser = ({ config: config2 = defaults, l10n = english }) => (date2, givenFormat, timeless, customLocale) => {
  if (date2 !== 0 && !date2)
    return void 0;
  const locale2 = customLocale || l10n;
  let parsedDate;
  const dateOrig = date2;
  if (date2 instanceof Date)
    parsedDate = new Date(date2.getTime());
  else if (typeof date2 !== "string" && date2.toFixed !== void 0)
    parsedDate = new Date(date2);
  else if (typeof date2 === "string") {
    const format2 = givenFormat || (config2 || defaults).dateFormat;
    const datestr = String(date2).trim();
    if (datestr === "today") {
      parsedDate = new Date();
      timeless = true;
    } else if (/Z$/.test(datestr) || /GMT$/.test(datestr))
      parsedDate = new Date(date2);
    else if (config2 && config2.parseDate)
      parsedDate = config2.parseDate(date2, format2);
    else {
      parsedDate = !config2 || !config2.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
      let matched, ops = [];
      for (let i = 0, matchIndex = 0, regexStr = ""; i < format2.length; i++) {
        const token2 = format2[i];
        const isBackSlash = token2 === "\\";
        const escaped = format2[i - 1] === "\\" || isBackSlash;
        if (tokenRegex[token2] && !escaped) {
          regexStr += tokenRegex[token2];
          const match = new RegExp(regexStr).exec(date2);
          if (match && (matched = true)) {
            ops[token2 !== "Y" ? "push" : "unshift"]({
              fn: revFormat[token2],
              val: match[++matchIndex]
            });
          }
        } else if (!isBackSlash)
          regexStr += ".";
        ops.forEach(({ fn, val }) => parsedDate = fn(parsedDate, val, locale2) || parsedDate);
      }
      parsedDate = matched ? parsedDate : void 0;
    }
  }
  if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
    config2.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));
    return void 0;
  }
  if (timeless === true)
    parsedDate.setHours(0, 0, 0, 0);
  return parsedDate;
};
function compareDates(date1, date2, timeless = true) {
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
const isBetween = (ts, ts1, ts2) => {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
const duration = {
  DAY: 864e5
};
function getDefaultHours(config2) {
  let hours2 = config2.defaultHour;
  let minutes2 = config2.defaultMinute;
  let seconds2 = config2.defaultSeconds;
  if (config2.minDate !== void 0) {
    const minHour = config2.minDate.getHours();
    const minMinutes = config2.minDate.getMinutes();
    const minSeconds = config2.minDate.getSeconds();
    if (hours2 < minHour) {
      hours2 = minHour;
    }
    if (hours2 === minHour && minutes2 < minMinutes) {
      minutes2 = minMinutes;
    }
    if (hours2 === minHour && minutes2 === minMinutes && seconds2 < minSeconds)
      seconds2 = config2.minDate.getSeconds();
  }
  if (config2.maxDate !== void 0) {
    const maxHr = config2.maxDate.getHours();
    const maxMinutes = config2.maxDate.getMinutes();
    hours2 = Math.min(hours2, maxHr);
    if (hours2 === maxHr)
      minutes2 = Math.min(maxMinutes, minutes2);
    if (hours2 === maxHr && minutes2 === maxMinutes)
      seconds2 = config2.maxDate.getSeconds();
  }
  return { hours: hours2, minutes: minutes2, seconds: seconds2 };
}
if (typeof Object.assign !== "function") {
  Object.assign = function(target, ...args) {
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    for (const source2 of args) {
      if (source2) {
        Object.keys(source2).forEach((key) => target[key] = source2[key]);
      }
    }
    return target;
  };
}
const DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  const self2 = {
    config: Object.assign(Object.assign({}, defaults), flatpickr.defaultConfig),
    l10n: english
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2._createElement = createElement;
  self2.destroy = destroy;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.open = open;
  self2.redraw = redraw;
  self2.set = set2;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth(month = self2.currentMonth, yr = self2.currentYear) {
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build2();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    const config2 = self2.config;
    if (config2.weekNumbers === false && config2.showMonths === 1) {
      return;
    } else if (config2.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          const daysWidth = (self2.days.offsetWidth + 1) * config2.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self2.selectedDates.length === 0) {
      const defaultDate = self2.config.minDate === void 0 || compareDates(new Date(), self2.config.minDate) >= 0 ? new Date() : new Date(self2.config.minDate.getTime());
      const defaults2 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e !== void 0 && e.type !== "blur") {
      timeWrapper(e);
    }
    const prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    let hours2 = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes2 = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds2 = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours2 = ampm2military(hours2, self2.amPM.textContent);
    }
    const limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    const limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (limitMaxHours) {
      const maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
      hours2 = Math.min(hours2, maxTime.getHours());
      if (hours2 === maxTime.getHours())
        minutes2 = Math.min(minutes2, maxTime.getMinutes());
      if (minutes2 === maxTime.getMinutes())
        seconds2 = Math.min(seconds2, maxTime.getSeconds());
    }
    if (limitMinHours) {
      const minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
      hours2 = Math.max(hours2, minTime.getHours());
      if (hours2 === minTime.getHours() && minutes2 < minTime.getMinutes())
        minutes2 = minTime.getMinutes();
      if (minutes2 === minTime.getMinutes())
        seconds2 = Math.max(seconds2, minTime.getSeconds());
    }
    setHours(hours2, minutes2, seconds2);
  }
  function setHoursFromDate(dateObj) {
    const date2 = dateObj || self2.latestSelectedDateObj;
    if (date2) {
      setHours(date2.getHours(), date2.getMinutes(), date2.getSeconds());
    }
  }
  function setHours(hours2, minutes2, seconds2) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours2 % 24, minutes2, seconds2 || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours2) % 12 + 12 * int(hours2 % 12 === 0) : hours2);
    self2.minuteElement.value = pad(minutes2);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours2 >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds2);
  }
  function onYearInput(event) {
    const eventTarget = getEventTarget(event);
    const year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event, handler, options) {
    if (event instanceof Array)
      return event.forEach((ev) => bind(element2, ev, handler, options));
    if (element2 instanceof Array)
      return element2.forEach((el) => bind(el, event, handler, options));
    element2.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: () => element2.removeEventListener(event, handler)
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach((evt) => {
        Array.prototype.forEach.call(self2.element.querySelectorAll(`[data-${evt}]`), (el) => bind(el, "click", self2[evt]));
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    const debouncedResize = debounce(onResize, 50);
    self2._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self2.daysContainer, "mouseover", (e) => {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e));
      });
    bind(window.document.body, "keydown", onKeyDown);
    if (!self2.config.inline && !self2.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind(self2._input, "focus", self2.open);
      bind(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind(self2.monthNav, "click", onMonthNavClick);
      bind(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      const selText = (e) => getEventTarget(e).select();
      bind(self2.timeContainer, ["increment"], updateTime);
      bind(self2.timeContainer, "blur", updateTime, { capture: true });
      bind(self2.timeContainer, "click", timeIncrement);
      bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind(self2.secondElement, "focus", () => self2.secondElement && self2.secondElement.select());
      if (self2.amPM !== void 0) {
        bind(self2.amPM, "click", (e) => {
          updateTime(e);
          triggerChange();
        });
      }
    }
    if (self2.config.allowInput) {
      bind(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    const jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    const oldYear = self2.currentYear;
    const oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e) {
    const eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    const target = e && getEventTarget(e);
    const input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    const event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build2() {
    const fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        const { weekWrapper, weekNumbers } = buildWeeks();
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    const customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        const wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date2, dayNumber, i) {
    const dateIsEnabled = isEnabled(date2, true), dayElement = createElement("span", "flatpickr-day " + className, date2.getDate().toString());
    dayElement.dateObj = date2;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self2.formatDate(date2, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date2, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date2)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date2, self2.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date2, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date2) && !isDateSelected(date2))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date2) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    const startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    const endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (let m2 = startMonth; m2 != endMonth; m2 += delta) {
      const month = self2.daysContainer.children[m2];
      const startIndex = delta > 0 ? 0 : month.children.length - 1;
      const endIndex = delta > 0 ? month.children.length : -1;
      for (let i = startIndex; i != endIndex; i += delta) {
        const c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    const givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    const endMonth = delta > 0 ? self2.config.showMonths : -1;
    const loopDelta = delta > 0 ? 1 : -1;
    for (let m2 = givenMonth - self2.currentMonth; m2 != endMonth; m2 += loopDelta) {
      const month = self2.daysContainer.children[m2];
      const startIndex = givenMonth - self2.currentMonth === m2 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      const numMonthDays = month.children.length;
      for (let i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        const c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset2) {
    const dayFocused = isInView(document.activeElement || document.body);
    const startElem = current !== void 0 ? current : dayFocused ? document.activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset2);
    }
  }
  function buildMonthDays(year, month) {
    const firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    const prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    const daysInMonth2 = self2.utils.getDaysInMonth(month, year), days2 = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    let dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days2.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
      days2.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (let dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days2.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
    }
    const dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days2);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    const frag = document.createDocumentFragment();
    for (let i = 0; i < self2.config.showMonths; i++) {
      const d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    const shouldBuildMonth = function(month) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (let i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      const month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    const container = createElement("div", "flatpickr-month");
    const monthNavFragment = window.document.createDocumentFragment();
    let monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind(self2.monthsDropdownContainer, "change", (e) => {
        const target = getEventTarget(e);
        const selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    const yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    const yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    const currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (let m2 = self2.config.showMonths; m2--; ) {
      const month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: () => self2.__hidePrevMonthArrow,
      set(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: () => self2.__hideNextMonthArrow,
      set(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    const defaults2 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    const separator = createElement("span", "flatpickr-time-separator", ":");
    const hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    const minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      const secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (let i = self2.config.showMonths; i--; ) {
      const container = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    const firstDayOfWeek = self2.l10n.firstDayOfWeek;
    let weekdays = [...self2.l10n.weekdays.shorthand];
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = [
        ...weekdays.splice(firstDayOfWeek, weekdays.length),
        ...weekdays.splice(0, firstDayOfWeek)
      ];
    }
    for (let i = self2.config.showMonths; i--; ) {
      self2.weekdayContainer.children[i].innerHTML = `
      <span class='flatpickr-weekday'>
        ${weekdays.join("</span><span class='flatpickr-weekday'>")}
      </span>
      `;
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    const weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    const weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value2, isOffset = true) {
    const delta = isOffset ? value2 : value2 - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent = true, toInitial = true) {
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      const { hours: hours2, minutes: minutes2, seconds: seconds2 } = getDefaultHours(self2.config);
      setHours(hours2, minutes2, seconds2);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (let i = self2._handlers.length; i--; ) {
      self2._handlers[i].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        const wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach((k) => {
      try {
        delete self2[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    if (self2.config.appendTo && self2.config.appendTo.contains(elem))
      return true;
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self2.isOpen && !self2.config.inline) {
      const eventTarget = getEventTarget(e);
      const isCalendarElement = isCalendarElem(eventTarget);
      const isInput = eventTarget === self2.input || eventTarget === self2.altInput || self2.element.contains(eventTarget) || e.path && e.path.indexOf && (~e.path.indexOf(self2.input) || ~e.path.indexOf(self2.altInput));
      const lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      const isIgnored = !self2.config.ignoredFocusElements.some((elem) => elem.contains(eventTarget));
      if (lostFocus && isIgnored) {
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1) {
          self2.clear(false);
          self2.redraw();
        }
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    const newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date2, timeless = true) {
    var _a;
    const dateToCheck = self2.parseDate(date2, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    const bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (let i = 0, d; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        const parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    const isInput = e.target === self2._input;
    if (isInput && (self2.selectedDates.length > 0 || self2._input.value.length > 0) && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self2.setDate(self2._input.value, true, e.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    const eventTarget = getEventTarget(e);
    const isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    const allowInput = self2.config.allowInput;
    const allowKeydown = self2.isOpen && (!allowInput || !isInput);
    const allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      const isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            if (self2.daysContainer !== void 0 && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
              const delta2 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey)
                focusOnDay(void 0, delta2);
              else {
                e.stopPropagation();
                changeMonth(delta2);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          const delta = e.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            const elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter((x2) => x2);
            const i = elems.indexOf(eventTarget);
            if (i !== -1) {
              const target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self2._input.focus();
          }
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem) {
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled")))
      return;
    const hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    let containsDisabled = false;
    let minRange = 0, maxRange = 0;
    for (let t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
      if (!isEnabled(new Date(t2), true)) {
        containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
        if (t2 < initialDate && (!minRange || t2 > minRange))
          minRange = t2;
        else if (t2 > initialDate && (!maxRange || t2 < maxRange))
          maxRange = t2;
      }
    }
    for (let m2 = 0; m2 < self2.config.showMonths; m2++) {
      const month = self2.daysContainer.children[m2];
      for (let i = 0, l2 = month.children.length; i < l2; i++) {
        const dayElem = month.children[i], date2 = dayElem.dateObj;
        const timestamp = date2.getTime();
        const outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach((c) => {
            dayElem.classList.remove(c);
          });
          continue;
        } else if (containsDisabled && !outOfRange)
          continue;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach((c) => {
          dayElem.classList.remove(c);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      }
    }
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open(e, positionElement = self2._positionElement) {
    if (self2.isMobile === true) {
      if (e) {
        e.preventDefault();
        const eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    const wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e === void 0 || !self2.timeContainer.contains(e.relatedTarget))) {
        setTimeout(() => self2.hourElement.select(), 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return (date2) => {
      const dateObj = self2.config[`_${type}Date`] = self2.parseDate(date2, self2.config.dateFormat);
      const inverseDateObj = self2.config[`_${type === "min" ? "max" : "min"}Date`];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter((d) => isEnabled(d));
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    const boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    const userConfig = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    const formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: () => self2.config._enable,
      set: (dates) => {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: () => self2.config._disable,
      set: (dates) => {
        self2.config._disable = parseDateRules(dates);
      }
    });
    const timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      const defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      const defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + ` h:i${userConfig.enableSeconds ? ":S" : ""} K`;
    }
    Object.defineProperty(self2.config, "minDate", {
      get: () => self2.config._minDate,
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: () => self2.config._maxDate,
      set: minMaxDateSetter("max")
    });
    const minMaxTimeSetter = (type) => (val) => {
      self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
    };
    Object.defineProperty(self2.config, "minTime", {
      get: () => self2.config._minTime,
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: () => self2.config._maxTime,
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (let i = 0; i < boolOpts.length; i++)
      self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
    HOOKS.filter((hook) => self2.config[hook] !== void 0).forEach((hook) => {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (let i = 0; i < self2.config.plugins.length; i++) {
      const pluginConf = self2.config.plugins[i](self2) || {};
      for (const key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error(`flatpickr: invalid locale ${self2.config.locale}`));
    self2.l10n = Object.assign(Object.assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.K = `(${self2.l10n.amPM[0]}|${self2.l10n.amPM[1]}|${self2.l10n.amPM[0].toLowerCase()}|${self2.l10n.amPM[1].toLowerCase()})`;
    const userConfig = Object.assign(Object.assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    const positionElement = customPositionElement || self2._positionElement;
    const calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, (acc, child) => acc + child.offsetHeight, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    const top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    let left = window.pageXOffset + inputBounds.left;
    let isCenter = false;
    let isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self2.calendarContainer, "arrowRight", isRight);
    const right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    const rightMost = left + calendarWidth > window.document.body.offsetWidth;
    const centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = `${top}px`;
    if (!rightMost) {
      self2.calendarContainer.style.left = `${left}px`;
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = `${right}px`;
    } else {
      const doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      const bodyWidth = window.document.body.offsetWidth;
      const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      const centerBefore = ".flatpickr-calendar.centerMost:before";
      const centerAfter = ".flatpickr-calendar.centerMost:after";
      const centerIndex = doc.cssRules.length;
      const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
      toggleClass(self2.calendarContainer, "rightMost", false);
      toggleClass(self2.calendarContainer, "centerMost", true);
      doc.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
      self2.calendarContainer.style.left = `${centerLeft}px`;
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    let editableSheet = null;
    for (let i = 0; i < document.styleSheets.length; i++) {
      const sheet = document.styleSheets[i];
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    const style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    const isSelectable = (day) => day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    const t2 = findParent(getEventTarget(e), isSelectable);
    if (t2 === void 0)
      return;
    const target = t2;
    const selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    const shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      const selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort((a, b) => a.getTime() - b.getTime());
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      const isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      const single = self2.config.mode === "single" && !self2.config.enableTime;
      const range2 = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range2) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  const CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    clickOpens: [
      () => {
        if (self2.config.clickOpens === true) {
          bind(self2._input, "focus", self2.open);
          bind(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set2(option, value2) {
    if (option !== null && typeof option === "object") {
      Object.assign(self2.config, option);
      for (const key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach((x2) => x2());
      }
    } else {
      self2.config[option] = value2;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach((x2) => x2());
      else if (HOOKS.indexOf(option) > -1)
        self2.config[option] = arrayify(value2);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format2) {
    let dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map((d) => self2.parseDate(d, format2));
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self2.parseDate(inputDate, format2)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format2)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map((date2) => self2.parseDate(date2, format2));
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map((date2) => self2.parseDate(date2, format2));
          break;
      }
    } else
      self2.config.errorHandler(new Error(`Invalid date supplied: ${JSON.stringify(inputDate)}`));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter((d) => d instanceof Date && isEnabled(d, false));
    if (self2.config.mode === "range")
      self2.selectedDates.sort((a, b) => a.getTime() - b.getTime());
  }
  function setDate(date2, triggerChange2 = false, format2 = self2.config.dateFormat) {
    if (date2 !== 0 && !date2 || date2 instanceof Array && date2.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date2, format2);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map((rule) => {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter((x2) => x2);
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || new Date();
    const preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    const inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind(self2.mobileInput, "change", (e) => {
      self2.setDate(getEventTarget(e).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0)
      return;
    const hooks2 = self2.config[event];
    if (hooks2 !== void 0 && hooks2.length > 0) {
      for (let i = 0; hooks2[i] && i < hooks2.length; i++)
        hooks2[i](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    const e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date2) {
    for (let i = 0; i < self2.selectedDates.length; i++) {
      if (compareDates(self2.selectedDates[i], date2) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date2) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date2, self2.selectedDates[0]) >= 0 && compareDates(date2, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach((yearElement, i) => {
      const d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(format2) {
    return self2.selectedDates.map((dObj) => self2.formatDate(dObj, format2)).filter((d, i, arr) => self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2 = true) {
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    const eventTarget = getEventTarget(e);
    const isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    const isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    const isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    const min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    let newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      const isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min2) {
        newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max2) {
        newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self2;
}
function _flatpickr(nodeList, config2) {
  const nodes = Array.prototype.slice.call(nodeList).filter((x2) => x2 instanceof HTMLElement);
  const instances2 = [];
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config2 || {});
      instances2.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances2.length === 1 ? instances2[0] : instances2;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
  HTMLElement.prototype.flatpickr = function(config2) {
    return _flatpickr([this], config2);
  };
}
var flatpickr = function(selector, config2) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config2);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config2);
  } else {
    return _flatpickr(selector, config2);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: Object.assign({}, english),
  default: Object.assign({}, english)
};
flatpickr.localize = (l10n) => {
  flatpickr.l10ns.default = Object.assign(Object.assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = (config2) => {
  flatpickr.defaultConfig = Object.assign(Object.assign({}, flatpickr.defaultConfig), config2);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
}
Date.prototype.fp_incr = function(days2) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days2 === "string" ? parseInt(days2, 10) : days2));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flatpickr
});
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(esm);
(function(exports) {
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _react = _interopRequireWildcard2(react.exports);
  var _propTypes = _interopRequireDefault2(propTypes.exports);
  var _flatpickr2 = _interopRequireDefault2(require$$2);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function _getRequireWildcardCache2() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard2(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
      return { "default": obj };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source2 = arguments[i];
        for (var key in source2) {
          if (Object.prototype.hasOwnProperty.call(source2, key)) {
            target[key] = source2[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectWithoutProperties2(source2, excluded) {
    if (source2 == null)
      return {};
    var target = _objectWithoutPropertiesLoose2(source2, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source2, key))
          continue;
        target[key] = source2[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose2(source2, excluded) {
    if (source2 == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source2);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source2[key];
    }
    return target;
  }
  function ownKeys2(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys2(Object(source2), true).forEach(function(key) {
          _defineProperty2(target, key, source2[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
      } else {
        ownKeys2(Object(source2)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
        });
      }
    }
    return target;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf2(subClass, superClass);
  }
  function _setPrototypeOf2(o, p2) {
    _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf2(o, p2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _defineProperty2(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  var hooks2 = ["onChange", "onOpen", "onClose", "onMonthChange", "onYearChange", "onReady", "onValueUpdate", "onDayCreate"];
  var hookPropType = _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].arrayOf(_propTypes["default"].func)]);
  var callbacks = ["onCreate", "onDestroy"];
  var callbackPropTypes = _propTypes["default"].func;
  var DateTimePicker = /* @__PURE__ */ function(_Component) {
    _inherits(DateTimePicker2, _Component);
    var _super = _createSuper(DateTimePicker2);
    function DateTimePicker2() {
      var _this;
      _classCallCheck(this, DateTimePicker2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty2(_assertThisInitialized(_this), "createFlatpickrInstance", function() {
        var options = _objectSpread2({
          onClose: function onClose() {
            _this.node.blur && _this.node.blur();
          }
        }, _this.props.options);
        hooks2.forEach(function(hook) {
          if (_this.props[hook]) {
            options[hook] = _this.props[hook];
          }
        });
        _this.flatpickr = (0, _flatpickr2["default"])(_this.node, options);
        if (_this.props.hasOwnProperty("value")) {
          _this.flatpickr.setDate(_this.props.value, false);
        }
        var onCreate = _this.props.onCreate;
        if (onCreate)
          onCreate(_this.flatpickr);
      });
      _defineProperty2(_assertThisInitialized(_this), "destroyFlatpickrInstance", function() {
        var onDestroy = _this.props.onDestroy;
        if (onDestroy)
          onDestroy(_this.flatpickr);
        _this.flatpickr.destroy();
        _this.flatpickr = null;
      });
      _defineProperty2(_assertThisInitialized(_this), "handleNodeChange", function(node) {
        _this.node = node;
        if (_this.flatpickr) {
          _this.destroyFlatpickrInstance();
          _this.createFlatpickrInstance();
        }
      });
      return _this;
    }
    _createClass(DateTimePicker2, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this2 = this;
        var options = this.props.options;
        var prevOptions = prevProps.options;
        hooks2.forEach(function(hook) {
          if (_this2.props.hasOwnProperty(hook)) {
            options[hook] = _this2.props[hook];
          }
          if (prevProps.hasOwnProperty(hook)) {
            prevOptions[hook] = prevProps[hook];
          }
        });
        var optionsKeys = Object.getOwnPropertyNames(options);
        for (var index = optionsKeys.length - 1; index >= 0; index--) {
          var key = optionsKeys[index];
          var value2 = options[key];
          if (value2 !== prevOptions[key]) {
            if (hooks2.indexOf(key) !== -1 && !Array.isArray(value2)) {
              value2 = [value2];
            }
            this.flatpickr.set(key, value2);
          }
        }
        if (this.props.hasOwnProperty("value") && this.props.value !== prevProps.value) {
          this.flatpickr.setDate(this.props.value, false);
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.createFlatpickrInstance();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.destroyFlatpickrInstance();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, options = _this$props.options, defaultValue = _this$props.defaultValue, value2 = _this$props.value, children = _this$props.children, render2 = _this$props.render, props = _objectWithoutProperties2(_this$props, ["options", "defaultValue", "value", "children", "render"]);
        hooks2.forEach(function(hook) {
          delete props[hook];
        });
        callbacks.forEach(function(callback2) {
          delete props[callback2];
        });
        if (render2)
          return render2(_objectSpread2(_objectSpread2({}, props), {}, {
            defaultValue,
            value: value2
          }), this.handleNodeChange);
        return options.wrap ? /* @__PURE__ */ _react["default"].createElement("div", _extends2({}, props, {
          ref: this.handleNodeChange
        }), children) : /* @__PURE__ */ _react["default"].createElement("input", _extends2({}, props, {
          defaultValue,
          ref: this.handleNodeChange
        }));
      }
    }]);
    return DateTimePicker2;
  }(_react.Component);
  _defineProperty2(DateTimePicker, "propTypes", {
    defaultValue: _propTypes["default"].string,
    options: _propTypes["default"].object,
    onChange: hookPropType,
    onOpen: hookPropType,
    onClose: hookPropType,
    onMonthChange: hookPropType,
    onYearChange: hookPropType,
    onReady: hookPropType,
    onValueUpdate: hookPropType,
    onDayCreate: hookPropType,
    onCreate: callbackPropTypes,
    onDestroy: callbackPropTypes,
    value: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object, _propTypes["default"].number]),
    children: _propTypes["default"].node,
    className: _propTypes["default"].string,
    render: _propTypes["default"].func
  });
  _defineProperty2(DateTimePicker, "defaultProps", {
    options: {}
  });
  var _default2 = DateTimePicker;
  exports["default"] = _default2;
})(build);
var Flatpickr = /* @__PURE__ */ getDefaultExportFromCjs(build);
export { Route as A, ReactDOM as B, Chart as C, Flatpickr as F, GeolocateControl$1 as G, HashRouter as H, Link as L, Map$1 as M, Navigate as N, PointElement as P, React as R, TimeScale as T, resolveConfig_1 as a, useLocation as b, NavLink as c, ReactCSSTransition as d, LineController as e, LineElement as f, plugin_filler as g, LinearScale as h, PolarAreaController as i, jsxDevRuntime as j, RadialLinearScale as k, plugin_legend as l, useForm as m, Controller as n, lib$2 as o, plugin_tooltip as p, useDropzone as q, react as r, lib as s, mapboxgl as t, useNavigate as u, useControl as v, Marker$1 as w, NavigationControl$1 as x, useParams as y, Routes as z };
